{
  "page_title": "Unity 本地化工具文档",
  "toc_title": "目录",
  "toc_search_placeholder": "搜索文档...",
  "nav_introduction": "1. 简介",
  "nav_quick_start": "2. 快速入门",
  "nav_components": "3. 核心组件",
  "nav_loc_tool_window": "4. “本地化工具”窗口",
  "nav_translation_editor": "5. 翻译编辑器",
  "nav_usage_examples": "6. 使用示例",
  "nav_important_notes": "7. 重要说明",
  "nav_extending": "8. 扩展功能",
  "nav_faq": "9. 常见问题与故障排除",
  "nav_key_features": "主要功能",
  "nav_installation": "2.1. 安装",
  "nav_initial_setup": "2.2. 初始设置",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. 上下文菜单",
  "nav_in_editor_preview": "4.1. 编辑器内预览",
  "nav_tab_settings": "4.2. “设置”选项卡",
  "nav_tab_content": "4.3. “内容”选项卡",
  "nav_tab_actions": "4.4. “操作”选项卡",
  "nav_tab_assets": "4.5. “资产”选项卡",
  "nav_tab_report": "4.6. “报告”选项卡",
  "nav_example_components": "6.1. 现成组件",
  "nav_example_attribute": "6.2. [LocalizableField] 属性",
  "nav_example_function": "6.3. _() 函数",
  "nav_example_plurals": "6.4. 复数和性别",
  "nav_custom_parser": "8.1. 创建解析器",
  "nav_faq_installation": "9.1. 安装与快速入门",
  "nav_faq_components": "9.2. 核心组件",
  "nav_faq_window": "9.3. “本地化工具”窗口",
  "nav_faq_window_actions": "9.3. “本地化工具”窗口 - “操作”选项卡",
  "nav_faq_window_assets": "9.3. “本地化工具”窗口 - “资产”选项卡",
  "nav_faq_window_report": "9.3. “本地化工具”窗口 - “报告”选项卡",
  "nav_faq_editor": "9.4. 翻译编辑器",
  "nav_faq_examples": "9.5. 使用示例和代码",
  "nav_faq_notes": "9.6. 重要细微差别和警告",
  "nav_faq_extending": "9.7. 扩展功能",
  "h1_introduction": "简介",
  "p_intro_1": "该工具是 Unity 中游戏和应用程序本地化的综合解决方案。它能自动收集文本和资产，通过强大的界面管理翻译，与机器翻译服务集成，并在游戏中动态更新本地化内容。",
  "h2_key_features": "主要功能",
  "li_feature_1": "<strong>高级解析：</strong> 自动扫描场景、预制件、UI 工具包 (UXML) 和 C# 脚本，包括标有 <code>[LocalizableField]</code> 属性的字段，以及嵌套类和列表。",
  "li_feature_2": "<strong>任何资产的本地化：</strong> 管理精灵图、音频、预制件、材质等。",
  "li_feature_3": "<strong>强大的翻译编辑器：</strong> 具有自动保存、完全撤销/重做支持和智能密钥分组的集中式界面。",
  "li_feature_4": "<strong>机器翻译：</strong> 与 DeepL、谷歌翻译和微软翻译器集成，为每项服务提供灵活的设置（批处理大小、重试次数）。",
  "li_feature_5": "<strong>灵活的导入/导出：</strong> 支持 CSV、XML、YAML、XLIFF，并可直接从 Google 表格导入。",
  "li_feature_6": "<strong>编辑器内实时预览：</strong> 无需运行游戏即可预览任何语言。",
  "li_feature_7": "<strong>复数和性别支持：</strong> 正确处理复数形式（具有斯拉夫语、阿拉伯语和其他语言的规则）和性别。",
  "li_feature_8": "<strong>完全 RTL 支持：</strong> 正确显示从右到左的语言。",
  "li_feature_9": "<strong>实时更新：</strong> 在游戏开始时从远程服务器加载最新的翻译。",
  "li_feature_10": "<strong>备份管理器：</strong> 用于创建和恢复备份的内置工具。",
  "h1_quick_start": "快速入门和设置",
  "h2_installation": "2.1. 安装",
  "li_install_1": "将资产复制到您的 Unity 项目文件夹中。",
  "li_install_2": "该工具将自动检查必要的依赖项。在出现的对话框中确认安装。",
  "li_install_3": "基本功能需要必要的依赖项（<code>Newtonsoft Json</code>、<code>Editor Coroutines</code>）。",
  "li_install_4": "可选依赖项（<code>Arabic Support</code>、<code>CsvHelper</code>、<code>YamlDotNet</code>）启用附加功能。",
  "li_install_5": "点击 <strong>安装所选</strong> 以安装推荐的软件包。",
  "li_install_6": "安装后，通过 <strong>工具 -> 本地化工具</strong> 菜单打开主工具窗口。",
  "h2_initial_setup": "2.2. 初始设置",
  "li_setup_1": "<strong>创建设置：</strong> 首次打开时，该工具将在 <code>Assets/Resources</code> 文件夹中创建一个 <code>LocalizationSettings.asset</code> 文件。",
  "li_setup_2": "<strong>配置语言：</strong> 在 <strong>设置</strong> 选项卡的 <strong>语言管理</strong> 下，确保您的主要语言（例如，英语为 <code>en</code>）被选为 <strong>源语言</strong>。启用您计划支持的所有语言。",
  "li_setup_3": "<strong>指定要解析的内容：</strong> 在 <strong>内容</strong> 选项卡中，将所有要分析的场景添加到 <strong>要解析的场景</strong> 列表中。如果您使用带有文本的预制件，请确保其文件夹已添加到 <strong>预制件文件夹</strong>。",
  "li_setup_4": "<strong>首次运行解析器：</strong> 转到 <strong>操作</strong> 选项卡，然后点击 <code>更新密钥</code> 按钮。该工具将扫描您的项目，创建翻译文件，并自动将必要的组件（<code>LocalizedText</code>、<code>LocalizedAsset</code> 等）添加到游戏对象。",
  "h1_components": "核心组件（自动分配）",
  "warning_box_components": "<strong>重要提示：</strong> 下面描述的所有组件都会在解析过程中自动添加到游戏对象中（当您点击 <code>更新密钥</code> 按钮时）。您无需手动添加它们。",
  "p_components_intro": "这些组件是您场景中对象与翻译数据库之间的“桥梁”。它们“监听”语言变化并自动替换正确的文本或资产。",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "用于显示翻译文本的主要组件。它放置在具有 <code>Text</code>、<code>TMP_Text</code> 和 <code>TextMesh</code> 的对象上。",
  "li_localizedtext_1": "<code>localizationKey</code>：用于查找翻译的密钥。自动生成。",
  "li_localizedtext_2": "<code>isStyleOnly</code>：如果为 <code>true</code>，该组件将仅应用样式（字体、RTL），但不会更改文本本身。对于其文本由另一个脚本（例如 <code>LanguageSelector</code>）管理的元素很有用。",
  "li_localizedtext_3": "<code>originalSourceText</code>：基础语言的原始文本。用作备用。",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "用于交换资产（<code>Sprite</code>、<code>AudioClip</code>、<code>Material</code> 等）。它会自动检测对象上的目标组件类型（<code>Image</code>、<code>AudioSource</code>）并替换其资源。",
  "p_localizedasset_2": "对于具有 <strong>Play on Awake</strong> 选项的组件（如 <code>AudioSource</code>、<code>VideoPlayer</code>），<code>LocalizedAsset</code> 会正确拦截自动播放，交换资产，然后开始播放以避免播放未本地化的内容。",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "用于本地化整个预制件的组件。它以非破坏性的方式工作：它不会修改原始预制件，而是创建本地化版本的实例作为子对象，禁用原始对象上的所有脚本（<code>MonoBehaviour</code>）、渲染器（<code>Renderer</code>）和碰撞器（<code>Collider</code>）。这可以防止双重逻辑执行和视觉伪影。为了正确的运行时操作，其执行顺序设置为 -100 (<code>[DefaultExecutionOrder(-100)]</code>) 以确保它在其他脚本之前运行。",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "添加到具有 <code>UIDocument</code> 的对象，并管理 UI 工具包文档 (UXML) 中所有文本元素的本地化。",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "添加到 <code>Dropdown</code> 和 <code>TMP_Dropdown</code> 以翻译它们的选项。",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "一个实用程序组件，允许您的脚本对语言更改做出反应。它会自动查找并调用标有 <code>[OnLanguageChange]</code> 属性的方法。",
  "h2_context_menu": "3.7. “为本地化分析”上下文菜单",
  "p_context_menu_1": "要快速将 <code>LocalizedAsset</code> 添加到对象，您可以在检查器中右键单击所需的组件（例如 <code>Image</code>、<code>AudioSource</code>）并选择 <strong>为本地化分析</strong>。该工具将自行添加和配置组件。（这是可选的，但可用于手动添加）。",
  "h1_loc_tool_window": "“本地化工具”窗口",
  "h2_in_editor_preview": "4.1. 编辑器内预览",
  "p_preview_1": "标题正下方是 <strong>预览语言</strong> 下拉列表。这个强大的功能允许您直接在 <strong>场景</strong> 窗口中查看任何语言的本地化效果，而无需运行游戏。",
  "li_preview_1": "<strong>工作原理：</strong> 从列表中选择一种语言，该工具将立即将相应的翻译、字体、RTL 设置和资产应用于活动场景中的所有可本地化对象。",
  "li_preview_2": "<strong>占位符：</strong> 如果在 <strong>设置</strong> 选项卡中选择了占位符样式（例如 <strong>重音</strong> 或 <strong>括号</strong>），则这些占位符将显示在预览模式中，而不是实际翻译。这对于测试布局和查找未本地化的元素非常理想。",
  "li_preview_3": "<strong>安全性：</strong> 在预览模式下所做的所有更改都是临时的。当您选择“<strong>恢复到原始</strong>”、关闭窗口、更改场景或在保存场景/预制件之前（感谢 <code>LocalizationPreviewProtector</code> 组件），该工具将自动将所有内容恢复到其原始状态。",
  "li_preview_4": "<strong>崩溃保护：</strong> 内置的 <code>PreviewCrashProtector</code> 系统将在预览处于活动状态时 Unity 编辑器崩溃的情况下自动恢复对象的原始状态。",
  "h2_tab_settings": "4.2. “设置”选项卡",
  "p_settings_1": "您的控制中心。在这里，您可以为整个本地化过程定义全局规则。",
  "li_settings_1": "<strong>密钥生成模式：</strong> 选择如何创建密钥。<ul><li><code>UseTextAsKey</code>：文本本身成为密钥。非常适合原型。缺点：如果更改源文本，密钥会更改，其所有翻译都将丢失。</li><li><code>AutoGenerateKeysOnly</code>：根据对象的层次结构和名称生成密钥。对于生产环境可靠。优点：更改文本时翻译不会中断。</li><li><code>UseTextAsKeyWithCustomPriority</code> 和 <code>AutoGenerateWithCustomKeys</code>：混合模式，允许您通过 <code>[LocalizableField(\"my_custom_key\")]</code> 属性在代码中设置自定义密钥。</li><li><strong>安全迁移：</strong> 您可以随时更改模式。该工具将自动将所有现有翻译迁移到新的密钥系统。</li></ul>",
  "li_settings_2": "<strong>语言管理：</strong> 配置语言列表。对于带有特殊字符的语言，分配适当的 <strong>字体资产</strong>。为从右到左的语言启用 <strong>RTL</strong> 选项。",
  "li_settings_3": "<strong>常规设置：</strong><ul><li><code>Parse Prefabs</code>：启用预制件解析。</li><li><code>Split files by language</code>：确定如何存储翻译（一个大文件或每种语言一个文件）。</li><li><code>Translations Path</code>：存储 <code>.json</code> 翻译文件的路径。重要提示：该文件夹必须位于 <code>Assets/StreamingAssets/</code> 内部。</li></ul>",
  "li_settings_4": "<strong>调试与测试：</strong><ul><li><code>Placeholder Style</code>：选择在预览模式下显示占位符的样式。</li></ul>",
  "li_settings_5": "<strong>实时更新：</strong> 用于从远程服务器加载翻译的设置。",
  "li_settings_6": "<strong>运行时 API 密钥：</strong> 用于安全存储可能在编译游戏中需要的 API 密钥的部分（以加密形式存储）。",
  "h2_tab_content": "4.3. “内容”选项卡",
  "p_content_1": "在这里，您可以告诉工具具体在哪里查找文本。",
  "li_content_1": "<strong>要解析的场景：</strong> 在此处拖放所有要分析的场景。",
  "li_content_2": "<strong>预制件文件夹：</strong> 指定带有预制件的文件夹。",
  "li_content_3": "<strong>动态文本：</strong> 在此处输入仅在代码中创建的字符串（例如，“游戏结束”）。",
  "li_content_4": "<strong>解析忽略：</strong> 指定要忽略的脚本、组件或对象。",
  "li_content_5": "<strong>固定：</strong> 此功能允许您将场景中的对象“固定”到忽略列表中。该工具将保存其在层次结构中的完整路径，而不是对对象的临时引用，从而使忽略在会话之间保持持久（但请注意，重命名对象或其父对象将破坏此链接）。",
  "h2_tab_actions": "4.4. “操作”选项卡",
  "p_actions_1": "主要工作选项卡。",
  "li_actions_1": "<strong>更新密钥：</strong> 运行解析器，更新您的翻译文件。",
  "li_actions_2": "<strong>打开翻译编辑器：</strong> 打开一个单独的、更方便的窗口来编辑所有翻译。",
  "li_actions_3": "<strong>数据管理：</strong> 用于与翻译人员交换数据（导出/导入到 CSV/XML/YAML/XLIFF，从 Google 表格导入）。",
  "li_actions_4": "<strong>自动翻译：</strong> 自动填充所有空的翻译字符串。新设置允许您分别为每个服务（DeepL、谷歌、微软）管理批处理大小（<strong>批处理大小</strong>）和重试策略（<strong>重试策略</strong>）。该工具会跟踪已翻译的字符数，并警告可能超出限制。",
  "li_actions_5": "<strong>危险区：</strong> 包含用于从项目中完全删除所有本地化组件的按钮。请谨慎使用！",
  "h2_tab_assets": "4.5. “资产”选项卡",
  "p_assets_1": "此选项卡完全专用于本地化非文本资源。",
  "li_assets_1": "<strong>创建文件夹结构（可选）：</strong> 在第 <strong>2. 资产文件夹生成</strong> 部分，点击 <strong>立即创建资产文件夹</strong>。",
  "li_assets_2": "<strong>配置类别和命名规则：</strong> 在第 <strong>3. 资产类别和扫描</strong> 部分，确保 <strong>命名规则</strong> (<code>{key}_{lang}</code>) 与您的文件匹配（例如，<code>button_ok_en.png</code>）。",
  "li_assets_3": "<strong>放置您的资产：</strong> 将本地化的资产放入文件夹中。",
  "li_assets_4": "<strong>扫描资产：</strong> 在第 <strong>4. 自动化</strong> 部分，点击 <strong>扫描资产和更新表</strong>。清理过程变得更安全：现在只删除旧的表文件（<code>.asset</code>），而不是整个文件夹。",
  "li_assets_5": "<strong>将资产链接到对象：</strong> 点击 <strong>分析项目和附加组件</strong>。",
  "h2_tab_report": "4.6. “报告”选项卡",
  "p_report_1": "每次解析后，此报告都会显示您的本地化状态的全貌。",
  "li_report_1": "<strong>类别：</strong> 所有密钥、已添加、已更新（文本已更改）、已删除、重复、已迁移、已跳过（未更改）。",
  "li_report_2": "<strong>高级查找：</strong> 点击任何条目旁边的 <strong>查找</strong> 按钮，即可立即在项目中找到相应的对象。搜索是异步工作的，不会阻塞编辑器，并且会搜索所有场景和预制件。如果一个密钥在多个地方使用，将出现一个包含所有来源的下拉列表。",
  "h1_translation_editor": "翻译表编辑器",
  "p_editor_1": "通过 <strong>工具 -> 本地化 -> 翻译表编辑器</strong> 打开。这是手动编辑翻译的主要工具。",
  "li_editor_1": "<strong>智能分组：</strong> 复数和性别的密钥（例如 <code>apple_count_one</code>、<code>apple_count_few</code>）会自动组合成可折叠的组。",
  "li_editor_2": "<strong>高级编辑：</strong> 点击一个单元格以打开 <strong>MultiLineEditWindow</strong> 弹出窗口。它显示源文本以供比较，允许您快速复制它，并实时检查占位符不匹配（例如 <code>{username}</code>），突出显示缺失或多余的占位符。",
  "li_editor_3": "<strong>通过注释进行占位符验证：</strong> 您可以通过在密钥的注释中添加特殊指令来明确指定翻译中应包含哪些占位符，例如：<code>@placeholders: {username}, {score}</code>。<strong>MultiLineEditWindow</strong> 将使用此列表作为主要的事实来源。",
  "li_editor_4": "<strong>导航和管理：</strong> 使用滚动条或按住鼠标中键在表格中导航。通过拖动分隔符更改列宽。使用 <code>Ctrl+S</code> 保存更改。",
  "li_editor_5": "<strong>完全撤销/重做：</strong> 通过 <code>Ctrl+Z</code> / <code>Ctrl+Y</code> 完全支持整个操作堆栈（文本更改、添加/删除密钥）。",
  "li_editor_6": "<strong>备份和自动保存：</strong> 使用 <strong>管理备份</strong> 按钮。该工具还会每隔几分钟自动保存您的会话。如果发生崩溃，系统将提示您恢复更改。",
  "h1_usage_examples": "使用示例",
  "h2_example_components": "6.1. 现成的组件和示例",
  "p_example_components_1": "该项目包含可直接使用的脚本，可作为很好的示例。",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>：</strong> 一个用于创建语言切换 UI 下拉列表的现成组件。它会自动查找所有可用语言并管理其切换。<br><strong>如何使用：</strong> 只需将 <code>LanguageSelector</code> 组件添加到您的场景中（例如，在一个空的 GameObject 上），然后在检查器中指定您的 <code>TMP_Dropdown</code>。",
  "li_example_components_2": "<strong>代码示例：</strong> 要学习高级技术，例如使用 <code>[LocalizableField]</code>、<code>_()</code> 函数、复数和性别，请研究 <code>StatPurchaseTest.cs</code> 和 <code>TestLocalization.cs</code> 文件。它们清楚地演示了该工具在代码中所有主要功能的实现。",
  "h2_example_attribute": "6.2. [LocalizableField] 属性",
  "p_example_attribute_1": "对于作为检查器中组件配置一部分的文本，这是首选方法。解析器现在可以处理字符串、字符串列表/数组，甚至嵌套的 <code>[System.Serializable]</code> 类中的字段。",
  "code_example_attribute": "using Ankonoanko.Localization; // [LocalizableField] 所需\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // 解析器将找到此字段并为其创建一个密钥\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"你未能完成任务。\";\n    \n    // 你可以设置一个自定义密钥\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"你准备好开始冒险了吗？\";\n    \n    // 适用于列表\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"找到宝藏\" };\n    \n    // 甚至适用于嵌套类！\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "6.3. _() 函数和 [OnLanguageChange] 属性",
  "p_example_function_1": "对于在游戏过程中更改的动态文本，请使用 <code>_()</code> 函数。更新 UI 的方法应标有 <code>[OnLanguageChange]</code> 属性，以便在更改语言时自动调用它。为此，将自动向对象添加一个 <code>LocalizedBehaviour</code> 组件。",
  "code_example_function": "// 要使用简短的 _() 调用，请添加这些行\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange] 所需\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // 初始更新\n    }\n    \n    // 当语言更改时，将自动调用此方法\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. 索引占位符（如 string.Format）\n        // 密钥：\"score_label\"，文件中的文本：\"分数：{0}\"\n        scoreText.text = _(\"score_label\", score); // 结果：\"分数：100\"\n        \n        // 2. 命名占位符（为可读性推荐）\n        // 密钥：\"welcome_message\"，文本：\"欢迎，{username}！\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // 对于复杂情况或高性能\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "6.4. 复数和性别",
  "p_example_plurals_1": "该工具现在对不同的语言组使用更准确的规则。",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // 密钥：\"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // 文本：\"{0} 个苹果\", \"{0} 个苹果\", \"{0} 个苹果\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // 自动选择正确的形式\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // 密钥：\"user_greeted_male\", \"user_greeted_female\"\n        // 文本：\"他到了。\", \"她到了。\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "重要说明和警告",
  "li_notes_1": "<strong>备份：</strong> 在进行全局操作（<code>Update Keys</code>、数据导入）之前，请始终通过 <strong>翻译表编辑器 -> 管理备份</strong> 创建备份。",
  "li_notes_2": "<strong>API 密钥安全：</strong> 用于在编辑器中工作的密钥存储在您机器的本地（在 <code>EditorPrefs</code> 中），不会进入存储库。对于游戏构建中需要的密钥，请使用 <strong>运行时 API 密钥</strong> 部分。",
  "li_notes_3": "<strong><code>StreamingAssets</code> 文件夹：</strong> 翻译文件必须位于 <code>Assets/StreamingAssets/</code> 的子文件夹中，才能包含在游戏构建中。",
  "li_notes_4": "<strong>“防呆”：</strong> 该工具会自动保护您免于意外地将预览模式下的临时数据保存到场景或预制件中。",
  "li_notes_5": "<strong>性能：</strong> <code>_()</code> 调用很快，但在每帧运行的循环中（例如，在 <code>Update</code> 中），请尝试将结果缓存到变量中。",
  "li_notes_6": "<strong>从解析中排除 <code>LanguageSelector</code>：</strong> 具有 <code>LanguageSelector</code> 组件及其 <code>TMP_Dropdown</code> 的对象必须添加到 <strong>内容</strong> 选项卡的 <strong>忽略特定对象</strong> 列表中。这是为了防止解析器为下拉选项创建额外的密钥，因为 <code>LanguageSelector</code> 脚本会在运行时动态填充它们。忽略可防止冲突并保持翻译文件整洁。",
  "li_notes_7": "<strong><code>LanguageSelector</code> 的字体：</strong> 要使 <code>TMP_Dropdown</code> 中选择的语言正确更新其字体，请手动将一个空的 <code>LocalizedText</code> 组件添加到 Dropdown 的子 <strong>标签</strong> 对象上，并选中 <code>isStyleOnly</code> 复选框。",
  "h1_extending": "扩展功能",
  "h2_custom_parser": "8.1. 创建自定义解析器",
  "p_custom_parser_1": "您可以通过创建自己的解析器类轻松扩展系统以支持自定义组件。",
  "li_custom_parser_1": "在项目的 <strong>编辑器</strong> 文件夹中创建一个新的 C# 脚本。",
  "li_custom_parser_2": "将下面的模板复制到其中。",
  "li_custom_parser_3": "修改逻辑以匹配您的组件。",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// 用于为自定义组件创建解析器的模板。\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. 检查对象是否具有我们需要的自定义组件。\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // 如果未找到组件，则退出\n        }\n        \n        // 2. 从自定义组件的字段中获取文本。\n        string titleText = component.Title;\n        \n        // 3. 检查文本是否对本地化有效。\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. 使用 TextParser 中的帮助程序生成密钥和来源。\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. 返回结果。\n            yield return (titleText, key, source);\n        }\n        \n        // 6. 对其他字段重复...\n        // （可以添加后缀以使密钥唯一）\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "常见问题与故障排除",
  "h2_faq_installation": "9.1. 安装与快速入门",
  "q_faq_installation_1": "如果我的项目中已经有来自另一个资产的 com.unity.nuget.newtonsoft-json 包，会发生什么？依赖项安装程序会尝试更新还是忽略它？",
  "a_faq_installation_1": "安装程序会检查 Newtonsoft.Json.JsonConvert 类型是否存在。如果该类型存在，它会认为依赖项已满足，并且不会尝试安装或更新该包。这样做是为了防止版本冲突。",
  "q_faq_installation_2": "我不小心点击了“暂时跳过”并勾选了“不再询问”可选依赖项（例如，对于 CSV 支持）。我该如何再次调出安装程序窗口来安装它们？",
  "a_faq_installation_2": "您可以随时通过“工具 -> 本地化 -> 检查依赖项”菜单手动触​​发依赖项检查。这将重置“不再询问”标志，并再次显示包含所有缺失的可选包的窗口。",
  "q_faq_installation_3": "该工具没有在 Assets/Resources 中创建 LocalizationSettings.asset。这可能是为什么，我可以通过 Assets -> Create 菜单手动创建它吗？",
  "a_faq_installation_3": "如果您没有 Assets/Resources 文件夹，则可能会发生这种情况。该工具会尝试创建它，但文件系统权限可能会阻止它。是的，您可以手动创建该资产：右键单击 Resources 文件夹，选择“创建 -> 本地化 -> 设置”。该工具会自动找到它。",
  "q_faq_installation_4": "我可以将 LocalizationSettings.asset 文件移动到另一个 Resources 文件夹，例如 Assets/MyGame/Resources 吗？该工具还能找到它吗？",
  "a_faq_installation_4": "可以。该工具使用 Resources.Load()，它会在您的项目中所有名为 Resources 的文件夹中按名称搜索资产。重要的是该文件保持其名称 LocalizationSettings.asset。",
  "q_faq_installation_5": "依赖项安装程序卡住或出现错误。我可以通过 Unity 包管理器手动安装依赖项（Newtonsoft Json、Editor Coroutines）吗？",
  "a_faq_installation_5": "可以。您可以打开“窗口 -> 包管理器”，点击“+”图标，然后选择“按名称添加包...”。输入包名称：com.unity.nuget.newtonsoft-json 和 com.unity.editorcoroutines。",
  "h2_faq_components": "9.2. 核心组件",
  "q_faq_components_1": "LocalizedPrefab 组件会禁用原始对象上的 MonoBehaviours。如果原始对象有一个在 Awake() 中创建其他对象或订阅事件的脚本，会发生什么？这段代码会被执行吗？",
  "a_faq_components_1": "不，不会。禁用 MonoBehaviour 会阻止调用 Unity 的所有“魔术”方法，包括 Awake()、OnEnable() 和 Start()。这是有意为之，以避免重复的逻辑执行。所有初始化都应该在预制件的本地化版本上的脚本中进行。",
  "q_faq_components_2": "如果原始预制件 (LocalizedPrefab) 有 Rigidbody 或其他物理组件，它会被禁用吗？如果本地化预制件没有它，这会影响物理效果吗？",
  "a_faq_components_2": "是的，原始对象的物理行为将被中和。LocalizedPrefab 组件会查找其 GameObject 上的所有 Rigidbody 和 Rigidbody2D 组件，并将其 isKinematic 属性设置为 true。这有效地将它们从动态物理计算中移除，防止了不希望的行为，如隐形对象下落或对碰撞做出反应。仍然建议预制件的本地化版本包含所有必要的物理组件以实现正确行为。",
  "q_faq_components_3": "LocalizedAsset 组件将目标组件名称存储为字符串 (_targetComponentTypeName)。如果我重命名一个自定义组件脚本或将其移动到另一个程序集（程序集定义），会发生什么？LocalizedAsset 会停止为它工作吗？",
  "a_faq_components_3": "是的，它会停止工作。该组件存储完整的类型名称，包括命名空间和程序集。重命名脚本或将其移动到另一个 .asmdef 将更改此名称，LocalizedAsset 将无法找到目标组件。您将需要通过“分析项目和附加组件”再次运行分析，以更新名称。",
  "q_faq_components_4": "如果同一个 GameObject 上有两个 Image 组件，LocalizedAsset 如何知道要本地化哪一个？它会同时处理两个还是只处理它找到的第一个？",
  "a_faq_components_4": "为特定的组件实例创建一个 LocalizedAsset。它在代码中保存对该组件的引用。如果您手动添加第二个 LocalizedAsset 并使用“为本地化分析”上下文菜单来定位第二个 Image，您将拥有两个 LocalizedAsset 组件，每个组件管理自己的 Image。自动分析器只会为它找到的第一个带有可本地化资产的 Image 创建一个组件。",
  "q_faq_components_5": "文档中指出 LocalizedPrefab 的执行顺序为 -100。如果我有一个执行顺序为 -110 的另一个脚本，它试图在其 Awake() 中查找由 LocalizedPrefab 创建的子对象，会发生什么？LocalizedPrefab 会及时实例化它的实例吗？",
  "a_faq_components_5": "是的，会的。LocalizedPrefab 在其 OnEnable() 方法中创建本地化预制件的实例。Unity 的执行顺序保证所有 Awake() 方法都在所有 OnEnable() 方法之前执行。因此，您的顺序为 -110 的脚本将执行其 Awake()，然后顺序为 -100 的 LocalizedPrefab 将执行其 Awake()，只有在那之后，它们的 OnEnable() 方法才会按顺序调用。您的脚本将找不到该对象，因为它尚未创建。",
  "q_faq_components_6": "LocalizedText 组件有一个 isStyleOnly 选项。如果我启用它，然后在代码中调用 myLocalizedText.SetFormattedText(\"new_key\")，文本会改变，还是只有样式（字体/RTL）会改变？",
  "a_faq_components_6": "键和文本都会改变。以编程方式调用 SetFormattedText 会覆盖该特定更新的 isStyleOnly 行为。isStyleOnly 选项旨在防止组件对全局语言更改做出反应，但它将始终对通过代码直接更改键做出反应。",
  "q_faq_components_7": "LocalizedBehaviour 会自动查找带有 [OnLanguageChange] 属性的方法。它会找到私有和受保护的方法，还是必须是公共的？",
  "a_faq_components_7": "它会找到带有任何访问修饰符（公共、私有、受保护、内部）的方法。Unity 中的反射允许发现所有实例方法，无论其访问级别如何。",
  "q_faq_components_8": "LocalizedAsset 组件会拦截 Play on Awake。如果同一对象上的另一个脚本在 LocalizedAsset 交换它之前尝试在 Awake() 或 Start() 中访问该资产（例如，audioSource.clip.length），会发生什么？是否可能出现 NullReferenceException 或使用旧资产？",
  "a_faq_components_8": "可能会使用旧的（未本地化的）资产。LocalizedAsset 在其 OnEnable() 中执行交换。所有脚本的 Awake() 方法都在 OnEnable() 之前执行。如果您的脚本在 Awake() 中访问 audioSource.clip，它将获取原始剪辑。如果它在 Start() 中访问它，结果将取决于脚本执行顺序。为保证访问本地化资产，请为您的脚本设置稍后的执行顺序，或在标有 [OnLanguageChange] 的方法中访问该资产。",
  "h2_faq_window": "9.3. “本地化工具”窗口",
  "h3_faq_window_preview": "编辑器内预览",
  "q_faq_window_preview_1": "我在预制件模式下打开了一个预制件，应用了编辑器内预览，然后按下了 Ctrl+S。临时预览数据会保存到预制件资产中吗？LocalizationPreviewProtector 如何处理这种情况？",
  "a_faq_window_preview_1": "不，它不会被保存。LocalizationPreviewProtector 会拦截资产保存事件 (OnWillSaveAssets)，并在 Unity 将更改写入磁盘之前自动调用 RevertEditorPreview()。因此，预制件将以其原始的、未本地化的状态保存。",
  "q_faq_window_preview_2": "如果我启用了编辑器内预览，而 Unity 编辑器崩溃了，并且 Temp/localization_preview_recovery.json 文件损坏了（例如，空的或无效的 JSON），下次启动时会发生什么？",
  "a_faq_window_preview_2": "PreviewCrashProtector 被包装在一个 try-catch 块中。如果 JSON 反序列化失败，控制台将记录一个关于无法恢复的错误，并且该过程将静默终止。您的场景将保持在崩溃时的“损坏”状态。在这种情况下，您需要在工具窗口中手动选择“恢复到原始状态”以强制回滚更改。",
  "q_faq_window_preview_3": "在 LocalizedPrefab 的编辑器内预览模式下，会创建一个临时实例。Awake() 和 Start() 方法会在此实例上执行吗？如果它们不是为在编辑模式下运行而设计的，这会导致错误吗？",
  "a_faq_window_preview_3": "是的，会的。编辑模式下的 PrefabUtility.InstantiatePrefab 会调用 Awake() 和 OnEnable()。如果这些方法包含不应在编辑器中运行的逻辑（例如，访问仅在播放模式下存在的单例），则可能会导致错误。建议使用 if (Application.isPlaying) 或 #if UNITY_EDITOR 来保护此类代码。",
  "h3_faq_window_settings": "“设置”选项卡",
  "q_faq_window_settings_1": "我可以在项目中途将密钥生成模式从 UseTextAsKey 更改为 AutoGenerateKeysOnly。我的现有翻译究竟会发生什么？它们会映射到新的密钥吗？",
  "a_faq_window_settings_1": "是的，会的。更改模式时，该工具会执行“安全迁移”：它会重新解析整个项目，根据新规则创建新密钥，但通过原始文本映射新旧密钥。然后，它会将您所有现有的翻译和注释从旧密钥转移到新密钥。您的翻译不会丢失。",
  "q_faq_window_settings_2": "如果我向支持的语言列表中添加一种没有复数规则的语言（例如，哈萨克语的“kz”），默认会使用哪条规则？",
  "a_faq_window_settings_2": "将使用 DefaultPluralRule，它适用于英语和大多数欧洲语言（“一个”和“其他”的形式）。",
  "q_faq_window_settings_3": "如果我将翻译路径指定为 Assets/MyTranslations 等常规文件夹，而不是 StreamingAssets，json 文件会包含在游戏构建中吗？",
  "a_faq_window_settings_3": "不，不会。只有位于 StreamingAssets 或 Resources 文件夹中的资产才能保证包含在构建中。如果指定不同的路径，本地化将在编辑器中工作，但在编译的游戏中将不起作用，因为翻译文件不会成为构建的一部分。",
  "q_faq_window_settings_4": "自动翻译 API 密钥存储在 EditorPrefs 中。如果我在两台不同的计算机上处理项目，我需要在每台计算机上单独输入密钥吗？",
  "a_faq_window_settings_4": "是的。EditorPrefs 是每台计算机的本地存储。您需要在计划使用自动翻译功能的每台计算机上输入 API 密钥。",
  "h3_faq_window_content": "“内容”选项卡",
  "q_faq_window_content_1": "如果我将未包含在构建设置中的场景添加到要解析的场景中，会发生什么？除了解析过程本身，这会影响其他任何事情吗？",
  "a_faq_window_content_1": "不，不会。要解析的场景列表专门用于让工具知道要打开和分析哪些场景以查找文本。它与最终将进入游戏构建的场景无关。",
  "q_faq_window_content_2": "我将一个对象添加到了忽略特定对象（临时列表）中。如果我从这个对象创建一个预制件，这个预制件的实例也会被忽略吗？",
  "a_faq_window_content_2": "不，不会。临时列表存储对场景中对象的直接引用。当您创建预制件时，它是一个新资产。它的实例是不同的对象，忽略规则将不适用于它们。要永久忽略预制件，必须将它们作为预制件资产添加到忽略列表中。",
  "q_faq_window_content_3": "如果我将 TMPro.TMP_Text 组件添加到解析忽略 -> 忽略组件类型中，但场景中有一个带有 LocalizedText 的对象已经引用了这个 TMP_Text，下次更新密钥时会发生什么？密钥会被删除吗？",
  "a_faq_window_content_3": "是的，会的。当您点击更新密钥时，解析器会重新扫描整个项目。它会看到 TMPro.TMP_Text 类型应该被忽略，并且不会为其生成密钥。在比较新旧密钥的过程中，它会确定旧密钥不再使用，并将其标记为“已删除”。",
  "q_faq_window_content_4": "文档中说，“固定”会保存对象的完整路径，如果重命名，它将中断。如果我从对象创建一个预制件，然后重命名原始对象，会发生什么？“固定”会继续对预制件实例起作用吗？",
  "a_faq_window_content_4": "不，不会。“固定”会在单击按钮时保存场景层次结构中的绝对路径（例如，Canvas/Panel/Button）。此路径与预制件逻辑无关。预制件实例将具有相同的路径，但如果您重命名场景中的父对象，“固定”将对原始对象和实例都停止工作。",
  "q_faq_window_content_5": "如果我对预制件实例中的子对象使用“固定”，会保存什么路径：相对于预制件根目录还是场景根目录？它会在其他场景中起作用吗？",
  "a_faq_window_content_5": "将保存从场景根目录开始的完整路径。例如，MyPrefab(Clone)/Content/Icon。这个“固定”的路径只在您创建它的场景中起作用。在其他场景中，很可能找不到这样的路径。",
  "h3_faq_window_actions": "“操作”选项卡",
  "h3_faq_window_assets": "“资产”选项卡",
  "h3_faq_window_report": "“报告”选项卡",
  "h2_faq_editor": "9.4. 翻译编辑器",
  "h2_faq_examples": "9.5. 使用示例和代码",
  "h2_faq_notes": "9.6. 重要细微差别和警告",
  "h2_faq_extending": "9.7. 扩展功能",
  "q_faq_window_actions_1": "如果在批量自动翻译期间互联网连接中断，会发生什么？该工具会根据重试策略重试失败的批次，还是整个过程会完全中断？",
  "a_faq_window_actions_1": "该工具将根据重试策略设置（尝试次数和延迟）尝试重新发送失败的确切批次。如果此批次的所有尝试都失败，当前语言的翻译过程将被中断，并且控制台将记录一个错误。队列中下一个语言的翻译将不会开始。",
  "q_faq_window_actions_2": "如果我导入一个 CSV 文件，其中包含项目中已经存在的密钥，但某些语言的值为空，这些空值会替换我现有的翻译还是被忽略？",
  "a_faq_window_actions_2": "空值将替换现有的翻译。导入过程将 CSV 文件视为“事实来源”。如果 ru 列中 welcome_message 密钥的值为空，则此密钥的当前俄语翻译将被覆盖。",
  "q_faq_window_actions_3": "“危险区”部分允许删除所有组件。它会从内容选项卡上的预制件文件夹中未指定的文件夹中的预制件中删除组件吗？",
  "a_faq_window_actions_3": "是的，会的。“危险区”中的函数会扫描项目中的所有预制件（AssetDatabase.FindAssets(\"t:Prefab\")），而不仅仅是解析列表中指定的那些，以确保尽可能彻底地清理。",
  "q_faq_window_actions_4": "从 Google 表格导入时，我应该如何格式化注释列，以使使用 @placeholders: 指令的占位符验证起作用？",
  "a_faq_window_actions_4": "在您的 Google 表格文档中，该列必须标题为“开发人员说明”。在该列的单元格中，您可以像往常一样编写注释。要指定占位符，只需在注释文本中添加一行，例如 @placeholders: {username}, {score}。该工具将在导入时自动识别此指令。",
  "q_faq_window_actions_5": "该工具可以从单个 Google 表格文档的多个工作表中导入数据，还是只能按 GID 处理一个工作表？",
  "a_faq_window_actions_5": "该工具一次只能处理一个工作表。导入 URL 包含一个 gid=... 参数，该参数唯一标识文档中的特定工作表。要从另一个工作表导入数据，您需要复制其 URL（使用不同的 gid）并再次执行导入。",
  "q_faq_window_assets_1": "如果我在同一个扫描文件夹中有两个具有相同密钥但类型不同的资产（例如，sound_effect_en.mp3 和 sound_effect_en.wav），会发生什么？哪一个会最终进入资产表？",
  "a_faq_window_assets_1": "资产扫描器会指定预期类型来加载它们（AssetDatabase.LoadAssetAtPath(path, expectedType)）。对于 AudioClip 类别，它只会搜索和加载 Unity 识别为 AudioClip 的文件。如果两个文件都是有效的音频剪辑，则最后处理的那个将包含在表中，实际上会覆盖前一个。建议避免此类重复。",
  "q_faq_window_assets_2": "如果我点击“扫描资产和分析项目”，并且场景中有一个 Image 对象，该对象已经存在一个本地化的精灵，但 Image 对象本身还没有 LocalizedAsset 组件，该工具会添加该组件并自动插入密钥吗？",
  "a_faq_window_assets_2": "是的，这正是它的工作方式。“分析项目”会找到 Image 组件，查看分配给它的精灵的名称（例如，icon_play_en），从中提取密钥（icon_play）和语言（en），然后向该 GameObject 添加一个 LocalizedAsset 组件，并将密钥 icon_play 写入其中。",
  "q_faq_window_assets_3": "如果不同的资产类别有不同的扫描文件夹，我可以使用相同的命名规则吗？这会导致冲突吗？",
  "a_faq_window_assets_3": "是的，可以。不会有冲突，因为会为每个类别创建一个单独的资产表（LocalizedAssetTable）。“精灵”类别的密钥与“音频剪辑”类别的密钥不重叠，即使它们的名称相同。",
  "q_faq_window_assets_4": "如果一个可本地化的资产（例如，button_ok_en.png）不在扫描文件夹的根目录，而是在一个子文件夹中，扫描器会找到它吗？",
  "a_faq_window_assets_4": "是的，会的。扫描器使用 SearchOption.AllDirectories 选项，这意味着它将递归检查您指定的扫描文件夹中的所有子文件夹。",
  "q_faq_window_report_1": "“查找”按钮会异步搜索对象。如果我开始搜索，然后立即点击“更新密钥”，会发生什么？搜索会被中断吗？",
  "a_faq_window_report_1": "是的，它会被中断。任何需要 UI 阻塞的新操作（如更新密钥）都会停止当前的搜索协程。将出现一个对话框，提示您停止当前搜索以开始新的搜索。",
  "q_faq_window_report_2": "如果一个密钥在多个地方使用（例如，在不同场景中的两个不同按钮上），这将在报告的“重复”类别下如何显示？",
  "a_faq_window_report_2": "“重复”类别将显示该密钥的所有来源。您将看到该密钥的一个条目，“来源”字段将列出所有路径（在场景 1 和场景 2 中）。在这种情况下，“查找”按钮将打开一个下拉列表，允许您选择要导航到哪个对象。",
  "q_faq_window_report_3": "如果我点击一个仅在代码中使用的密钥（通过 _() 函数）的“查找”，会发生什么？该工具能够找到并突出显示 C# 脚本吗？",
  "a_faq_window_report_3": "是的。搜索系统经过专门训练，可以识别像 script MyScript.cs 这样的来源。当您点击“查找”时，它将在项目中搜索 MyScript.cs 资产，并在项目窗口中突出显示（ping）它。",
  "q_faq_editor_1": "对于占位符验证，什么具有更高的优先级：注释中的 @placeholders: 指令还是在源语言文本中找到的占位符？例如，如果源文本中有 {name}，而注释中说 @placeholders: {username}。",
  "a_faq_editor_1": "注释中的 @placeholders: 指令具有优先权。它被认为是开发人员的明确指令和“事实来源”。在您的示例中，编辑器将要求翻译中包含 {username}，并将忽略源文本中的 {name}。",
  "q_faq_editor_2": "如果我在指令中输入错误（例如，@placeholder: 而不是 @placeholders:），它会被忽略还是工具会发出警告？",
  "a_faq_editor_2": "它将被简单地忽略。该工具会查找 @placeholders: 的精确匹配。如果指令拼写错误，它将被视为常规注释的一部分，并且验证将以旧方式工作 - 基于源文本中的占位符。",
  "q_faq_editor_3": "自动保存系统会在 Backups/AutoSaves 文件夹中创建文件。这些文件会在成功手动保存或关闭窗口后自动删除吗？",
  "a_faq_editor_3": "是的。成功手动保存或正常关闭窗口后（当您保存更改时），所有自动保存文件都会被删除，以避免在下次启动时提示恢复。它们仅在编辑器崩溃的情况下保留。",
  "q_faq_editor_4": "如果我在编辑器中更改列宽，这些设置会在 Unity 会话之间保存吗？",
  "a_faq_editor_4": "是的。每次关闭翻译编辑器窗口时，列宽都会保存到 EditorPrefs 中，并在下次打开时恢复。",
  "q_faq_editor_5": "文本编辑弹出窗口 (MultiLineEditWindow) 是否支持其自己的撤销/重做堆栈（通过 Ctrl+Z）以进行内部更改？",
  "a_faq_editor_5": "是的。MultiLineEditWindow 有自己的临时撤销/重做堆栈，在窗口打开时工作。这允许您在该窗口内撤销和重做文本更改。一旦您保存结果（通过关闭窗口），此更改将作为单个操作记录在主编辑器的全局撤销/重做堆栈中。",
  "q_faq_examples_1": "如果传递给 _() 函数的匿名类型中的属性名称与字符串中的占位符不匹配，会发生什么？例如，_(\"Hello, {username}\", new { user_name = \"Bob\" })。会出现错误，还是占位符 просто не будет заменен？",
  "a_faq_examples_1": "不会有错误。{username} 占位符 просто не будет заменен，您将得到字符串 \"Hello, {username}\" 作为结果。只有在名称完全匹配时才会进行替换。",
  "q_faq_examples_2": "[LocalizableField] 属性对私有字段起作用。它对静态字段起作用吗？",
  "a_faq_examples_2": "是的，会的。解析器使用反射来查找带有标志 BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static 的字段，因此它会找到并处理静态字段。",
  "q_faq_examples_3": "如果我将 [OnLanguageChange] 属性放在一个带参数的方法上（例如，void UpdateUI(string newLang)），会发生什么？会出现编译错误还是运行时警告？",
  "a_faq_examples_3": "不会有编译错误，但在运行时 Unity 控制台中会出现来自 LocalizedBehaviour 的警告。它会报告它找到了一个带有该属性的方法，但忽略了它，因为该方法有参数。这样的方法不会被调用。",
  "q_faq_examples_4": "我正在使用 _(\"apple_count\", count)。如果当前语言没有 apple_count_one 密钥（对于 count = 1），系统会选择哪种形式？它会使用 apple_count_other 作为后备吗？",
  "a_faq_examples_4": "是的。如果找不到特定的形式（_one、_few 等），系统将尝试使用带有 _other 后缀的密钥作为后备。如果也找不到，将使用基本密钥 apple_count 的翻译。",
  "q_faq_examples_5": "函数 _(\"key\", new { username = \"Alex\" }) 使用匿名类型。与传递一个预先创建的 Dictionary<string, object> 相比，在 Update() 方法中频繁调用它会不会给垃圾回收器 (GC) 带来过多的“负载”？",
  "a_faq_examples_5": "是的，会的。每次调用 new { ... } 都会在托管堆上分配内存，这会给垃圾回收器带来额外的工作。对于每帧更新的文本（在 Update 或 LateUpdate 中），在 Start() 中创建一次 Dictionary<string, object>，然后在 Update() 中只更新其值再传递给 _() 函数，会显著提高性能。",
  "q_faq_notes_1": "文档建议将 LanguageSelector 添加到忽略列表。如果我忘记这样做，具体会出什么问题？会为“Option A, Option B”创建额外的密钥吗？",
  "a_faq_notes_1": "是的。如果您不将 LanguageSelector 添加到忽略列表，解析器会将其 TMP_Dropdown 视为常规下拉列表。它会找到 Unity 创建的默认“Option A, Option B, Option C”，并为它们在您的翻译文件中添加密钥。这会用不必要的密钥弄乱您的文件，因为 LanguageSelector 无论如何都会在运行时删除这些选项并创建自己的选项。",
  "q_faq_notes_2": "如果我忘记在 LanguageSelector 使用的 TMP_Dropdown 内的标签上添加一个启用了 isStyleOnly 复选框的空 LocalizedText，字体会不改变吗？为什么这是必要的？",
  "a_faq_notes_2": "是的，字体不会改变。这是必要的，因为 LanguageSelector 直接更改 label.text 属性。如果没有此对象上的 LocalizedText，本地化系统不知道在语言更改时需要向此元素应用样式（字体、RTL）。一个带有 isStyleOnly 的空 LocalizedText 作为系统的“标记”，表示：“监视此对象并向其应用样式，但不要触摸其文本”。",
  "q_faq_notes_3": "不建议在 Update() 方法中调用 _()。但是如果我需要每帧更新文本（例如，一个计时器），该怎么办？缓存格式字符串的最有效方法是什么？",
  "a_faq_notes_3": "最有效的方法是在 Start() 或 [OnLanguageChange] 方法中缓存格式字符串，并在 Update() 中使用常规的 string.Format。示例：private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } 这避免了每帧在字典中查找密钥，这要快得多。",
  "q_faq_extending_1": "我的自定义解析器会在每次更新密钥后自动调用吗？我需要 कहीं इसे पंजीकृत करें，还是只要项目中有一个实现 ITextComponentParser 的类就足够了？",
  "a_faq_extending_1": "只要有这个类就足够了。当 TextParser 运行时，它使用反射来查找项目中所有实现 ITextComponentParser 接口的类，并自动为每个 GameObject 调用它们的 Parse() 方法。不需要手动注册。",
  "q_faq_extending_2": "如果我的自定义解析器中发生异常，会发生什么？它会中断整个解析过程，还是工具会安全地继续使用其他解析器？",
  "a_faq_extending_2": "自定义解析器中的异常会中断该过程。主解析循环不会将对自定义解析器的调用包装在 try-catch 块中。如果您的 Parse() 方法抛出未处理的异常，",
  "toggle_notes_title": "切换笔记",
  "mindmap_toggle_title": "显示思维导图",
  "on_this_page_title": "在本页",
  "my_notes_title": "我的笔记",
  "no_notes_message_new": "将鼠标悬停在文本上以添加笔记。",
  "notes_add_title": "为此块添加笔记",
  "notes_placeholder": "你的笔记...",
  "notes_close_title": "关闭",
  "notes_goto_title": "转到文本",
  "notes_edit_title": "编辑笔记",
  "notes_delete_title": "删除笔记",
  "notes_edit_text": "编辑",
  "copy_code_copy": "复制",
  "copy_code_copied": "已复制！",
  "copy_code_error": "错误",
  "error_loading_title": "加载错误",
  "error_loading_message": "请检查您的连接并刷新。",
  "lightbox_aria_close": "关闭图片查看器",
  "lightbox_image_alt": "放大视图",
  "mindmap_preset_full": "完整视图",
  "mindmap_preset_quick_start": "快速入门",
  "mindmap_preset_dev": "开发者工作流程",
  "mindmap_preset_translator": "翻译者工作流程",
  "mindmap_edge_configure": "1. 配置",
  "mindmap_edge_specify_content": "2. 指定内容",
  "mindmap_edge_parse_project": "3. 解析项目",
  "mindmap_edge_creates_components": "创建组件",
  "mindmap_edge_generates": "生成",
  "mindmap_edge_opens": "打开",
  "mindmap_edge_manages_assets": "管理资产",
  "mindmap_edge_defines_rules": "定义规则",
  "mindmap_edge_reports_on": "报告",
  "mindmap_edge_enables_reaction": "通过...启用反应",
  "mindmap_edge_processed_by": "由...处理",
  "mindmap_edge_edited_in": "在...编辑",
  "mindmap_edge_extends": "扩展",
  "mindmap_edge_warns_about": "警告",
  "mindmap_edge_relates_to": "与...相关",
  "mindmap_edge_recommends_for": "推荐用于",
  "mindmap_edge_see_faq": "查看常见问题"
}