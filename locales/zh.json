{
  "a_faq_addressables_1": "确保已安装 Addressables 包，已创建设置，并且您点击了“Scan Assets & Generate Tables”以在组中注册键。",
  "a_faq_addressables_2": "在资源文件夹中创建 <code>Translation Profile</code>，选择服务类型，输入 API 密钥，并在 <code>Settings</code> 窗口中分配此配置。",
  "a_faq_addressables_3": "在迁移窗口（“组件/导入”选项卡）中，有一个“启用存根”按钮，可激活紧急存根功能。这为 I2 Localization 或 Unity Localization 创建了伪占位符类，以便在移除这些插件后，您的项目可以立即编译。此功能通过切换 ANKO_ENABLE_MIGRATION_STUBS 定义符号来工作。这可以防止“找不到类型名称 'Localize'”错误，并为您提供时间来正确重构代码以使用新系统。“启用存根”允许您在删除旧的本地化插件后修复编译错误。在 v2.0 中，迁移系统已通过 <strong>迁移配置文件</strong> 进行了扩展，允许从其他插件进行更强大的转换规则。",
  "a_faq_audio_smart_update": "该工具使用带有 MD5 哈希的智能批处理，仅在源文本发生更改时才重新生成音频文件。它会计算您的文本内容的 MD5 哈希值，并将其与以前生成的音频文件进行比较。如果文本没有更改，它会跳过重新生成，从而节省您的 API 积分。这可以防止不必要的 API 调用并降低重新生成音频时的成本。该工具会哈希您的文本，并且仅在源文本发生更改时才重新生成音频文件，从而节省您的 API 积分。",
  "a_faq_components_1": "不，它不会。禁用 MonoBehaviour 会阻止所有 Unity 的“魔术”方法被调用，包括 Awake()、OnEnable() 和 Start()。这是有意的，以避免重复的逻辑执行。所有初始化都应该发生在本地化版本预制件上的脚本中。",
  "a_faq_components_2": "是的，原始对象的物理行为将被中和。LocalizedPrefab 组件会查找其 GameObject 上的所有 Rigidbody 和 Rigidbody2D 组件，并将其 isKinematic 属性设置为 true。这有效地将它们从动态物理计算中移除，防止不必要的行为，例如不可见的对象掉落或对碰撞做出反应。仍然建议本地化版本的预制件包含所有必要的物理组件以实现正确的行为。",
  "a_faq_components_3": "是的，会的。该组件存储完整的类型名称，包括命名空间和程序集。重命名脚本或将其移动到另一个 .asmdef 会更改此名称，导致 LocalizedAsset 无法找到目标组件。您需要通过 “Analyze Project & Attach Components” 再次运行分析以更新名称。",
  "a_faq_components_4": "LocalizedAsset 是为特定的组件实例创建的。它在代码中保存对该组件的引用。如果您手动添加第二个 LocalizedAsset 并使用“Analyze for Localization”上下文菜单来定位第二个 Image，您将拥有两个 LocalizedAsset 组件，每个组件管理其自己的 Image。自动分析器只会为它找到的第一个具有可本地化资源的 Image 创建一个组件。",
  "a_faq_components_5": "是的，它会。LocalizedPrefab 在其 OnEnable() 方法中创建本地化预制件的实例。Unity 的执行顺序保证所有 Awake() 方法在所有 OnEnable() 方法之前执行。因此，执行顺序为 -110 的脚本将执行其 Awake()，然后执行顺序为 -100 的 LocalizedPrefab 将执行其 Awake()，只有在那之后，它们的 OnEnable() 方法才会按顺序调用。您的脚本不会找到该对象，因为它尚未创建。",
  "a_faq_components_6": "键和文本都会更改。以编程方式调用 SetFormattedText 会覆盖 isStyleOnly 行为进行该特定更新。isStyleOnly 选项旨在防止组件对全局语言更改做出反应，但它将始终对通过代码进行的直接键更改做出反应。",
  "a_faq_components_7": "它将找到具有任何访问修饰符（public、private、protected、internal）的方法。Unity 中的反射允许发现所有实例方法，无论其访问级别如何。",
  "a_faq_components_8": "使用旧的（未本地化的）资源是可能的。LocalizedAsset 在其 OnEnable() 中执行交换。所有脚本的 Awake() 方法都在 OnEnable() 之前执行。如果您的脚本在 Awake() 中访问 audioSource.clip，它将获得原始剪辑。如果它在 Start() 中访问它，结果将取决于脚本执行顺序。要保证访问本地化资源，请为您的脚本设置较晚的执行顺序，或在带有 [OnLanguageChange] 属性的方法中访问资源。",
  "a_faq_custom_keys_attribute": "是的。在 <strong>Content Tab（内容标签页）</strong> 的 'Attributes to Scan'（要扫描的属性）下，您可以添加任何属性名称（例如，<code>[Header]</code>、<code>[TermsPopup]</code>）。解析器会将带有该属性的任何字符串字段视为可本地化的。",
  "a_faq_custom_provider_1": "确保您的类实现了 <code>IAssetProvider</code> 接口，不是抽象类，并且已使用 <code>[AssetProviderPlugin]</code> 属性进行标记。此外，检查控制台在启动期间是否有任何与反射相关的错误，因为该工具会扫描所有程序集以查找提供程序。",
  "a_faq_editor_1": "注释中的 @placeholders: 指令具有优先级。它被认为是开发人员的明确指令和“事实来源”。在您的示例中，编辑器将要求翻译中包含 {username}，并忽略源文本中的 {name}。",
  "a_faq_editor_2": "它只会被忽略。该工具会查找 @placeholders: 的精确匹配。如果指令拼写错误，它将被视为常规注释的一部分，并且验证将以旧方式工作 - 基于源文本中的占位符。",
  "a_faq_editor_3": "是的。在成功手动保存或正常关闭窗口（当您保存更改时）后，所有自动保存文件都将被删除，以避免在下次启动时提示恢复。它们仅在编辑器崩溃时保留。",
  "a_faq_editor_4": "是的。每次关闭翻译编辑器窗口时，列宽都会保存到 EditorPrefs 中，并在下次打开时恢复。",
  "a_faq_editor_5": "是的。MultiLineEditWindow 有其自己的临时撤销/重做堆栈，在窗口打开时有效。这允许您在该窗口内撤销和重做文本更改。一旦您保存结果（通过关闭窗口），此更改将作为单个操作记录在主编辑器的全局撤销/重做堆栈中。",
  "a_faq_examples_1": "不会出现错误。{username} 占位符根本不会被替换，您将得到字符串 \"Hello, {username}\" 作为结果。替换只会在名称完全匹配时发生。",
  "a_faq_examples_2": "是的，它会。解析器使用反射来查找带有标志 BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static 的字段，因此它会找到并处理静态字段。",
  "a_faq_examples_3": "不会出现编译错误，但运行时会在 Unity 控制台中出现来自 LocalizedBehaviour 的警告。它将报告它找到了带有该属性的方法，但因为它有参数而忽略了它。这样的方法将不会被调用。",
  "a_faq_examples_4": "是的。如果找不到特定的形式（_one、_few 等），系统将尝试使用带有 _other 后缀的键作为回退。如果也找不到，将使用基本键 apple_count 的翻译。",
  "a_faq_examples_5": "是的，它会。每次调用 new { ... } 都会在托管堆上分配内存，这会给垃圾收集器带来额外的工作。对于每帧更新的文本（在 Update 或 LateUpdate 中），在 Start() 中创建 Dictionary<string, object> 一次，并在 Update() 中仅更新其值，然后再将其传递给 _() 函数，性能会明显更高。",
  "a_faq_examples_6": "检查您的方法是否有参数。<code>[OnLanguageChange]</code> 属性仅适用于 <strong>没有参数</strong> 的方法（例如，<code>void UpdateUI()</code>）。如果您的方法需要参数，请将其包装在一个无参数的方法中。",
  "a_faq_extending_1": "只需有该类即可。当 TextParser 运行时，它使用反射来查找项目中所有实现 ITextComponentParser 接口的类，并自动为每个 GameObject 调用它们的 Parse() 方法。不需要手动注册。",
  "a_faq_extending_2": "您的自定义解析器中的异常将中断该过程。主解析循环不会将对自定义解析器的调用包装在 try-catch 块中。如果您的 Parse() 方法抛出未处理的异常，",
  "a_faq_installation_1": "安装程序会检查 Newtonsoft.Json.JsonConvert 类型的存在。如果该类型存在，则认为依赖项已满足，并且不会尝试安装或更新该包。这样做是为了防止版本冲突。",
  "a_faq_installation_2": "您可以随时通过 Tools -> Localization -> Check Dependencies 菜单手动触发依赖项检查。这将重置“Don't ask again”标志，并再次显示包含所有缺失的可选包的窗口。",
  "a_faq_installation_3": "如果您的项目没有 Assets/Resources 文件夹，可能会发生这种情况。该工具会尝试创建它，但文件系统权限可能会阻止它。是的，您可以手动创建该资源：在 Resources 文件夹中右键单击，选择 Create -> Localization -> Settings。工具会自动找到它。",
  "a_faq_installation_4": "是的。该工具使用 Resources.Load()，它会在您的项目中名为 Resources 的所有文件夹中按名称搜索资源。重要的是文件保持其名称 LocalizationSettings.asset。",
  "a_faq_installation_5": "是的。您可以打开 Window -> Package Manager，点击“+”图标，然后选择“Add package by name...”（按名称添加包）。输入包名称：com.unity.nuget.newtonsoft-json 和 com.unity.editorcoroutines。",
  "a_faq_notes_1": "是的。如果您不将 LanguageSelector 添加到忽略列表中，解析器会将其 TMP_Dropdown 视为常规下拉列表。它会找到 Unity 创建的默认“Option A, Option B, Option C”，并为它们向您的翻译文件添加键。这将用不必要的键来使您的文件混乱，因为 LanguageSelector 会在运行时删除这些选项并创建自己的选项。",
  "a_faq_notes_2": "是的，字体不会改变。这是必要的，因为 LanguageSelector 直接更改 label.text 属性。如果该对象上没有 LocalizedText，本地化系统就不知道该元素在语言更改时需要应用样式（字体、RTL）。带有 isStyleOnly 的空 LocalizedText 充当系统的“标记”，表示：“监视此对象并对其应用样式，但不要更改其文本”。",
  "a_faq_notes_3": "最有效的做法是在 Start() 或 [OnLanguageChange] 方法中缓存格式字符串，并在 Update() 中使用常规的 string.Format。示例：private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } 这样可以避免每帧都在字典中查找键，这明显更快。",
  "a_faq_runtime_api_key_distinction": "<strong>问：‘翻译服务密钥’和‘运行时 API 密钥’之间有什么区别？</strong><br>答：<strong>翻译服务密钥</strong>（OpenAI、DeepL）用于 <strong>Unity 编辑器</strong> 中生成翻译。它们存储在您计算机的注册表 (EditorPrefs) 中，并且不包含在构建中。<br><strong>运行时 API 密钥</strong> 由 <strong>游戏构建</strong> 用于获取实时更新。它包含在构建中（已加密）。",
  "a_faq_tts_voices": "在您的 <strong>Translation Profile（翻译配置）</strong>（Inspector）中，使用 'Voice Mappings'（声音映射）列表。您可以将正则表达式模式（例如 <code>^hero_.*</code>）映射到特定的 Voice ID。生成器将根据键名自动选择正确的语音。",
  "a_faq_window_actions_1": "该工具将根据重试策略设置（尝试次数和延迟）尝试重新发送失败的确切批次。如果此批次的所有尝试都失败，则当前语言的翻译过程将中断，并且控制台将记录错误。队列中后续语言的翻译将不会开始。",
  "a_faq_window_actions_2": "空值将替换现有翻译。导入过程将 CSV 文件视为“事实来源”。如果键 welcome_message 在 ru 列中的值为空，则该键当前的俄语翻译将被覆盖。",
  "a_faq_window_actions_3": "是的，它会。 “Danger Zone”中的功能会扫描项目中的所有预制件 (AssetDatabase.FindAssets(\"t:Prefab\"))，而不仅仅是解析列表中指定的预制件，以确保尽可能完整的清理。",
  "a_faq_window_actions_4": "在您的 Google Sheets 文档中，该列的标题必须是“Developer Notes”。在该列的单元格中，您可以像往常一样编写注释。要指定占位符，只需在注释文本中添加一行，例如 @placeholders: {username}, {score}。工具将在导入时自动识别此指令。",
  "a_faq_window_actions_5": "该工具一次只能处理一个工作表。导入 URL 包含一个 gid=... 参数，该参数唯一标识文档中的特定工作表。要从另一个工作表导入数据，您需要复制其 URL（使用不同的 gid）并再次执行导入。",
  "a_faq_window_assets_1": "资源扫描器通过指定预期类型加载它们 (AssetDatabase.LoadAssetAtPath(path, expectedType))。对于 AudioClip 类别，它只会搜索和加载 Unity 识别为 AudioClip 的文件。如果两个文件都是有效的音频片段，则最后处理的文件将包含在表中，从而有效地覆盖前一个文件。建议避免此类重复。",
  "a_faq_window_assets_2": "是的，它正是这样工作的。 “Analyze Project”找到 Image 组件，查看分配给它的精灵的名称（例如，icon_play_en），从中提取键 (icon_play) 和语言 (en)，然后将 LocalizedAsset 组件添加到该 GameObject 中并写入键 icon_play。",
  "a_faq_window_assets_3": "是的，您可以。不会有冲突，因为为每个类别创建了一个单独的资源表 (LocalizedAssetTable)。来自“Sprites”类别的键与来自“AudioClips”类别的键不会重叠，即使它们的命名相同。",
  "a_faq_window_assets_4": "是的，它会。扫描器使用 SearchOption.AllDirectories 选项，这意味着它将递归检查您指定的 Scan Folder 内的所有子文件夹。",
  "a_faq_window_content_1": "不，它不会。Scenes to Parse 列表仅用于让工具知道要打开和分析哪些场景以查找文本。它与最终游戏构建中将包含的场景没有任何关系。",
  "a_faq_window_content_2": "不，它不会。临时列表存储对场景中对象的直接引用。当您创建预制件时，它是一个新资源。它的实例是不同的对象，忽略规则将不适用于它们。要永久忽略预制件，必须将它们作为预制件资源添加到忽略列表中。",
  "a_faq_window_content_3": "是的，它会。当您点击 Update Keys 时，解析器会重新扫描整个项目。它会看到应该忽略 TMPro.TMP_Text 类型，并且不会为其生成键。在比较旧键和新键的过程中，它会确定旧键不再使用，并将其标记为“Removed”（已删除）。",
  "a_faq_window_content_4": "不，它不会。“Pin”在点击按钮时保存场景层级视图中的绝对路径（例如，Canvas/Panel/Button）。此路径与预制件逻辑无关。预制件实例将具有相同的路径，但如果您重命名场景中的父对象，“Pin”将对原始对象和实例都停止工作。",
  "a_faq_window_content_5": "将保存从场景根目录开始的完整路径。例如，MyPrefab(Clone)/Content/Icon。这个“固定”路径只会​​在您创建它的场景中起作用。在其他场景中，不太可能找到这样的路径。",
  "a_faq_window_preview_1": "不，它不会被保存。PreviewSafetyBridge 会拦截资源保存事件 (OnWillSaveAssets)，并在 Unity 将更改写入磁盘之前自动调用 RevertEditorPreview()。因此，Prefab 将以其原始的、未本地化的状态保存。",
  "a_faq_window_preview_2": "PreviewRecoveryService 处理崩溃恢复。如果 Unity 崩溃，服务会在下次启动时检测备份文件并尝试恢复场景状态。如果自动恢复失败，您可能需要手动在工具窗口中选择“恢复到原始状态”。",
  "a_faq_window_preview_3": "是的，它们会执行。PrefabUtility.InstantiatePrefab 在 Edit Mode 下调用 Awake() 和 OnEnable()。如果这些方法包含不应在编辑器中运行的逻辑（例如，访问仅在 Play Mode 中存在的单例），可能会导致错误。建议使用 if (Application.isPlaying) 或 #if UNITY_EDITOR 来保护此类代码。",
  "a_faq_window_report_1": "是的，它会被中断。任何需要 UI 阻塞的新操作（例如 Update Keys）都将停止当前的搜索协程。将出现一个对话框，提示您停止当前搜索以开始新的搜索。",
  "a_faq_window_report_2": "“Duplicates”类别将显示该键的所有来源。您将看到该键的一个条目，并且“Source”字段将列出所有路径（在场景 1 和场景 2 中）。在这种情况下，“Find”按钮将打开一个下拉列表，允许您选择导航到哪个对象。",
  "a_faq_window_report_3": "是的。搜索系统经过专门训练，可以识别 MyScript.cs 等脚本源。当您点击“Find”时，它将在项目中搜索 MyScript.cs 资源并在 Project 窗口中突出显示 (ping) 它。",
  "a_faq_window_settings_1": "是的，它们会。更改模式时，工具会执行“安全迁移”：它会重新解析整个项目，根据新规则创建新键，但会通过原始文本映射旧键和新键。然后，它会将所有现有翻译和注释从旧键转移到新键。您的翻译不会丢失。",
  "a_faq_window_settings_2": "将使用 DefaultPluralRule，它适用于英语和大多数欧洲语言（“one”和“other”形式）。",
  "a_faq_window_settings_3": "不，它们不会。只有位于 StreamingAssets 或 Resources 文件夹中的资源才保证包含在构建中。如果您指定不同的路径，本地化将在编辑器中工作，但在编译后的游戏中将不起作用，因为翻译文件不会成为构建的一部分。",
  "a_faq_window_settings_4": "是的。EditorPrefs 是每台计算机的本地存储。您需要为每台机器输入 <strong>翻译服务 API 密钥</strong>（用于编辑器，如 OpenAI/DeepL）。但是，<strong>运行时 API 密钥</strong>（用于构建）存储在项目设置中，并通过源代码管理共享（已加密）。",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "已复制！",
  "copy_code_copy": "复制",
  "copy_code_error": "错误",
  "error_loading_message": "请检查您的连接并刷新。",
  "error_loading_title": "加载错误",
  "h1_ai_audio": "AI 音频 / 文本转语音",
  "h1_ai_profiles": "AI 和翻译配置文件",
  "h1_api_snippets": "API 与代码片段",
  "h1_components": "核心组件（自动分配）",
  "h1_extending": "扩展功能",
  "h1_faq": "常见问题与故障排除",
  "h1_font_glyph_manager": "字体与字形管理器",
  "h1_important_notes": "重要注意事项和警告",
  "h1_introduction": "简介",
  "h1_loc_tool_window": "“本地化工具”窗口",
  "h1_migration_tool": "迁移工具",
  "h1_quick_start": "快速入门与设置",
  "h1_tms": "外部 TMS 集成 (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "翻译表编辑器",
  "h1_usage_examples": "用法示例",
  "h2_ai_assistant": "AI 助手命令",
  "h2_ai_audio_setup": "设置",
  "h2_ai_audio_usage": "用法",
  "h2_ai_context": "上下文 与 术语表",
  "h2_ai_profiles_overview": "翻译配置文件",
  "h2_async_api": "异步 API（Addressables）",
  "h2_backup_manager": "备份管理器",
  "h2_bridge_generation": "生成 C# 桥接（强类型访问）",
  "h2_custom_ai": "自定义 AI 与模型",
  "h2_custom_asset_provider": "创建自定义资源提供程序",
  "h2_custom_attributes": "自定义特性扫描",
  "h2_custom_parser": "创建自定义解析器",
  "h2_example_attribute": "[LocalizableField] 属性",
  "h2_example_components": "现成组件和示例",
  "h2_example_components_updated": "更新的 LanguageSelector.cs",
  "h2_example_function": "_() 函数 和 [OnLanguageChange] 属性",
  "h2_example_plurals": "复数 与 性别",
  "h2_faq_addressables": "Addressables 与迁移",
  "h2_faq_audio": "AI 音频 / 文本转语音",
  "h2_faq_components": "核心组件",
  "h2_faq_editor": "翻译编辑器",
  "h2_faq_examples": "使用示例 与 代码",
  "h2_faq_extending": "扩展功能",
  "h2_faq_installation": "安装 与 快速入门",
  "h2_faq_notes": "重要细节 与 警告",
  "h2_faq_window": "\"Localization Tool\" 窗口",
  "h2_font_glyph_manager_features": "功能",
  "h2_in_editor_preview": "编辑器内 & Prefab 预览",
  "h2_initial_setup": "初始设置",
  "h2_installation": "安装",
  "h2_key_features": "关键特性",
  "h2_live_updates_guide": "实时更新指南",
  "h2_localizedasset": "本地化资产",
  "h2_localizedasset_updated": "LocalizedAsset 异步加载",
  "h2_localizedbehaviour": "本地化行为",
  "h2_localizeddropdown": "本地化下拉菜单",
  "h2_localizedprefab": "本地化Prefab",
  "h2_localizedtext": "本地化文本",
  "h2_migration_custom": "创建自定义配置文件",
  "h2_migration_google_sheets": "Google 表格密钥",
  "h2_migration_import_formats": "导入格式（CSV 和 Google 表格）",
  "h2_migration_stubs": "安全迁移和紧急存根",
  "h2_migration_tool_features": "功能",
  "h2_migration_workflow": "迁移工作流程指南",
  "h2_preview_overlay": "场景视图叠加",
  "h2_safety_caps": "限制和安全配额",
  "h2_script_parsing_rules": "脚本解析规则（兼容性）",
  "h2_tab_actions": "\"Actions\" 选项卡",
  "h2_tab_assets": "\"Assets\" 选项卡",
  "h2_tab_content": "“内容”选项卡",
  "h2_tab_report": "\"Report\" 选项卡",
  "h2_tab_settings": "\"Settings\" 选项卡",
  "h2_tab_tutorials": "\"教程\" 选项卡",
  "h2_tms_setup": "设置与使用",
  "h2_tms_supported": "支持的服务",
  "h2_uitklocalization": "UITK本地化",
  "h2_visual_debugging_guide": "可视化调试",
  "h2_window_footer": "窗口底部（状态栏）",
  "h2_window_header": "窗口标题栏与工具栏",
  "h2_window_sidebar": "主菜单（侧边栏）",
  "h3_actions_autotranslate": "自动翻译",
  "h3_actions_danger": "危险区域",
  "h3_actions_data": "数据管理",
  "h3_actions_editor": "翻译编辑器",
  "h3_actions_parsing": "解析",
  "h3_actions_tms_integration": "外部服务（TMS）",
  "h3_assets_automation": "自动化",
  "h3_assets_categories": "资源类别",
  "h3_assets_folder_gen": "文件夹生成",
  "h3_assets_loading": "加载策略",
  "h3_assets_storage": "存储配置",
  "h3_attribute_cheat_sheet": "快速参考：注意事项",
  "h3_attribute_features": "支持的类型和特性",
  "h3_attribute_limitations": "限制",
  "h3_content_components_ignore": "要忽略的组件类型",
  "h3_content_dynamic_keys": "动态键前缀",
  "h3_content_dynamic_texts": "动态文本",
  "h3_content_objects_ignore": "要忽略的对象",
  "h3_content_prefabs": "Prefab 文件夹",
  "h3_content_regex": "已忽略的正则表达式模式",
  "h3_content_scenes": "要解析的场景",
  "h3_content_script_rules": "脚本解析规则",
  "h3_content_scripts_ignore": "要忽略的脚本",
  "h3_custom_provider_steps": "实现步骤",
  "h3_faq_window_actions": "“操作”标签页",
  "h3_faq_window_assets": "“资源”标签页",
  "h3_faq_window_content": "“内容”标签页",
  "h3_faq_window_preview": "编辑器内预览",
  "h3_faq_window_report": "“报告”标签页",
  "h3_faq_window_settings": "“设置”标签页",
  "h3_mode_auto": "仅自动生成键（标准）",
  "h3_mode_hybrid": "混合模式（自定义优先级）",
  "h3_mode_text": "使用文本作为键（简化）",
  "h3_report_all_keys": "所有键",
  "h3_settings_debugging": "调试",
  "h3_settings_general": "常规设置",
  "h3_settings_keygen": "键生成",
  "h3_settings_languages": "语言管理",
  "h3_settings_liveupdates": "实时更新",
  "h3_settings_pseudo": "伪本地化设置",
  "h3_settings_runtimeapi": "运行时 API",
  "h3_settings_tools": "通用与开发工具",
  "h3_tutorials_list": "教程列表",
  "lbl_not_supported": "不支持",
  "lbl_supported": "完全支持",
  "li_actions_1": "<strong>Parsing（解析）：</strong><ul><li><strong>Update Keys（更新键）：</strong>由“Content”标签页设置定义的完整项目扫描。</li><li><strong>Scan Selected Assets（扫描选定资源）：</strong>仅扫描 Project View 中当前选定的文件/文件夹。对于部分更新更安全，因为它会自动禁用“Remove Missing Keys”。</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor（打开翻译编辑器）：</strong>打开一个单独、更方便的窗口来编辑所有翻译。",
  "li_actions_3": "<strong>数据管理：</strong> 用于与翻译人员交换数据（导出/导入到 CSV/XML/YAML/XLIFF，从 Google 表格导入）。<strong>Google 表格：</strong> 支持“编辑”链接和“发布到网页”URL（检查 GID 参数）。",
  "li_actions_4": "<strong>Auto-Translation（自动翻译）：</strong>使用活动的 <strong>Translation Profile</strong> 自动填充所有空的翻译字符串。",
  "li_actions_5": "<strong>Danger Zone（危险区域）：</strong>包含用于从项目中完全删除所有本地化组件的按钮。请谨慎使用！",
  "li_ai_1": "<strong>创建配置：</strong>在 Project 视图中右键单击 -> Create -> Localization -> Translation Profile。",
  "li_ai_2": "<strong>服务：</strong>支持 DeepL、Google Translate、Microsoft Azure 和 <strong>Custom AI（自定义 AI）</strong>。",
  "li_ai_3": "<strong>设置：</strong>每个配置都存储其自己的 API 密钥、限制（批量大小、最大字符数）和模型设置。",
  "li_ai_4": "<strong>AIPresetsGenerator：</strong>使用内置的生成器快速创建流行服务（OpenAI、Gemini、Claude、Ollama）的配置。",
  "li_ai_audio_generate": "在 <strong>Translation Table Editor</strong> 中，选择行/单元格 -> 右键单击 -> <strong>Generate Audio（生成音频）</strong>。",
  "li_ai_audio_hash": "<strong>Smart Update & Hashing（智能更新与哈希）：</strong>该工具会计算您的文本内容的 MD5 哈希值，并且仅在源文本发生更改时才重新生成音频文件，从而节省您的 API 积分。它会检测自上次音频生成以来翻译是否已更改。编辑器会用“过时”图标（黄色）突出显示这些行，允许您仅更新已更改的行。此智能批处理功能可防止不必要的 API 调用并降低重新生成音频时的成本。该工具会哈希您的文本，并且仅在源文本发生更改时才重新生成音频文件，从而节省您的 API 积分。",
  "li_ai_audio_profile": "在 <strong>Settings</strong> 中，选择 <strong>Active Audio Profile（活动音频配置）</strong>（例如，OpenAI TTS 或 ElevenLabs）。",
  "li_ai_audio_save": "文件保存到配置中指定的文件夹。",
  "li_ai_audio_voice_mapping": "<strong>语音映射（多说话人）:</strong> 自动为不同角色分配不同的 AI 语音。使用 <strong>语音映射</strong> 列表将正则表达式模式（例如 <code>^hero_.*</code>）链接到特定的语音 ID。工具将在音频生成期间根据键名自动选择正确的语音。",
  "li_ai_provider_settings": "<strong>提供程序设置：</strong> 每个服务都允许配置 API 密钥、模型（例如，GPT-4o、Sonnet）和语音特定参数（稳定性、相似性）。",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> 用于异步加载 Addressables 资源。它返回一个 <code>Task&lt;T&gt;</code>。",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) 返回性别特定的翻译。",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> 根据语言特定规则返回正确的复数形式。",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> 用于更改语言的协程（<code>IEnumerator</code>）。始终使用 <code>StartCoroutine()</code>。",
  "li_assets_1": "<strong>创建文件夹结构（可选）：</strong>在 <strong>2. Asset Folder Generation</strong> 部分，点击 <strong>Create Asset Folders Now</strong>。",
  "li_assets_2": "<strong>配置类别和命名规则：</strong>在 <strong>3. Asset Categories & Scanning</strong> 部分，确保 <strong>Naming Rule（命名规则）</strong> (<code>{key}_{lang}</code>) 与您的文件匹配（例如，<code>button_ok_en.png</code>）。",
  "li_assets_3": "<strong>放置您的资源：</strong>将本地化资源放入文件夹中。",
  "li_assets_4": "<strong>扫描资源：</strong>在 <strong>4. Automation</strong> 部分，点击 <strong>Scan Assets & Update Tables</strong>。清理过程变得更安全：现在只删除旧的表文件 (<code>.asset</code>)，而不是整个文件夹。",
  "li_assets_5": "<strong>将资源链接到对象：</strong>点击 <strong>Analyze Project & Attach Components</strong>。",
  "li_assets_6": "<strong>Addressables 集成：</strong>如果启用了 <strong>Addressables</strong> 模式，资源将在扫描期间自动注册到 Addressables 组中，地址格式为 <code>{Category}/{Language}/{Key}</code>。",
  "li_assets_addressables_naming": "<strong>命名约定：</strong>扫描时，工具会自动将 Addressable 地址设置为 <code>{Category}/{Language}/{Key}</code> 格式。<strong>请勿手动重命名</strong> 这些地址，因为 LocalizationManager 在运行时依赖此特定格式来加载资源。",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> 如果启用，工具将在首次资源本地化时自动创建所有支持语言所需的目录结构。",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> 根据您的规则自动创建本地化资源的文件夹结构。",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> 定义所有本地化资源（精灵、音频等）的根目录。使用 <code>{lang}</code> 变量指定每种语言的文件夹结构。",
  "li_assistant_1": "<strong>Configurable（可配置）：</strong>在您的 Translation Profile 中定义命令（例如，“Fix Grammar”、“Make Formal”、“Shorten for UI”）。",
  "li_assistant_2": "<strong>Batch Processing（批量处理）：</strong>选择多个单元格以将命令一次应用于所有单元格。",
  "li_assistant_3": "<strong>自定义命令:</strong> 在 <strong>翻译配置文件</strong> 检视器中定义您自己的提示（<code>AIAssistantCommand</code> 列表）。每个命令都有一个 <strong>Label</strong>（出现在上下文菜单中）和一个 <strong>Prompt</strong>（发送给 AI 的指令，例如“以海盗风格改写”）。",
  "li_attr_feat_1": "<strong>集合：</strong> 支持 <code>List&lt;string&gt;</code> 和 <code>string[]</code>。键使用后缀 <code>_0</code>、<code>_1</code> 等生成。您甚至可以在列表字段本身上使用自定义键来为所有项目添加前缀。",
  "li_attr_feat_2": "<strong>访问修饰符：</strong> 适用于 <code>private</code>、<code>protected</code>、<code>internal</code> 和 <code>public</code> 字段。",
  "li_attr_feat_3": "<strong>自定义属性：</strong> 在<em>内容选项卡</em>设置中，您可以添加 <code>HeaderAttribute</code>、<code>TooltipAttribute</code> 或任何自定义属性名称。解析器随后会将带有这些属性（例如 <code>[Header(\"Text\")]</code>）的字段视为可本地化的字符串！",
  "li_attr_feat_4": "<strong>嵌套对象：</strong> 递归扫描标记有 <code>[System.Serializable]</code> 的类或结构体中的字段。这包括单个实例和嵌套对象列表。",
  "li_attr_feat_5": "<strong>格式化字符串：</strong> 支持插值字符串（<code>$\"Text {0}\"</code>）、逐字字符串（<code>@\"Text\"</code>）和字符串连接（<code>\"A\" + \"B\"</code>）。",
  "li_attr_limit_1": "<strong>支持属性：</strong> 解析器会扫描 <code>字段</code> 和 <code>属性</code>。需要一个 Getter。",
  "li_attr_limit_2": "<strong>字典：</strong> <code>Dictionary&lt;T, string&gt;</code> 不直接支持解析。",
  "li_attr_limit_3": "<strong>静态字段：</strong> 通过代码文件中的静态分析（正则表达式）支持，但通常建议使用实例字段以便在 GameObjects 上进行可靠检测。",
  "li_backup_desc": "跟踪更改并恢复翻译的先前版本。",
  "li_backup_rollback": "<strong>回滚：</strong> 立即将选定的键或整个表恢复到以前的状态。",
  "li_backup_snapshots": "<strong>快照：</strong> 在批量操作之前创建命名的恢复点。",
  "li_cheat_base_private": "<strong>基类私有字段：</strong> 支持（扫描器直接读取基类文件）",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> 数组",
  "li_cheat_concatenation": "<strong>字符串连接：</strong> <code>\"A\" + \"B\"</code>（支持）",
  "li_cheat_constructor_args": "<strong>复杂构造函数参数：</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>字典</strong>（Unity Inspector 自然不支持序列化）",
  "li_cheat_headers": "<code>[Header(\"...\")]</code> 等属性（完全支持）",
  "li_cheat_nested_lists": "<strong>嵌套对象列表</strong>（例如 <code>List&lt;ItemData&gt;</code>）",
  "li_cheat_non_literals": "<strong>变量和常量：</strong> <code>const string s = \"Value\";</code> 或 <code>static string</code>（支持，Roslyn 从同一文件解析值）",
  "li_cheat_private": "<code>private</code> / <code>protected</code> 字段（支持）",
  "li_cheat_properties": "<strong>属性：</strong> <code>{ get; set; }</code>（自动属性和完整属性均支持）",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong>（如果被引用则支持）",
  "li_cheat_serializable": "嵌套的 <code>[Serializable] class</code> （库存物品，对话节点）",
  "li_cheat_static": "<strong>静态字段：</strong> <code>public static string</code>（完全支持）",
  "li_cheat_structs": "<strong>结构体和记录：</strong> 支持（递归扫描）",
  "li_cheat_ternary": "<strong>逻辑/三元运算符：</strong> <code>cond ? \"A\" : \"B\"</code> （解析器无法确定值）",
  "li_cheat_unattached": "<strong>未附加脚本：</strong> 支持（扫描器读取项目中所有 .cs 文件）",
  "li_content_1": "<strong>Scenes to Parse（要解析的场景）：</strong>在此处拖放所有要分析的场景。",
  "li_content_2": "<strong>Prefab Folders（预制件文件夹）：</strong>指定包含预制件的文件夹。现在支持分页和搜索大型项目。",
  "li_content_3": "<strong>Dynamic Texts（动态文本）：</strong>在此处输入专门在代码中创建的字符串（例如，“Game Over”）。",
  "li_content_4": "<strong>要忽略的组件类型:</strong> 指定在扫描期间应跳过的 Unity 组件类型。",
  "li_content_5": "<strong>固定忽略:</strong> 此功能允许您将场景中的对象“固定”到忽略列表中，保持持久化。",
  "li_content_6": "<strong>要忽略的脚本:</strong> 添加特定的 C# 脚本或整个文件夹以将其排除在解析之外。",
  "li_content_7": "<strong>动态键前缀:</strong> 键前缀列表（例如 <code>Item_</code>），在清理期间不会被删除。",
  "li_content_dynamic_keys": "<strong>动态键前缀:</strong> 定义前缀（例如 <code>quest_item_</code>），应被识别为可能是动态的。这帮助工具区分静态 UI 标签和数据驱动的键。",
  "li_content_dynamic_texts": "<strong>动态文本规则:</strong> 配置通过代码动态更新的文本模式。这可防止扫描器为运行时更改的文本创建冗余键。",
  "li_content_regex_example": "<strong>自定义包装器示例：</strong>如果您使用 <code>MyGame.Loc(\"KEY\")</code> 这样的自定义函数，请添加一个脚本解析规则，其正则表达式为：<code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>。",
  "li_content_regex_presets": "<strong>忽略的正则表达式模式：</strong>点击 <strong>'添加常用模式'</strong> 以快速排除动态内容，例如 URLs、Emails 等。",
  "li_content_scanner": "<strong>Roslyn 代码扫描器：</strong>一个深度静态分析引擎，可理解 C# 语法树，实现强大的键检测。",
  "li_content_scanner_details_1": "<strong>智能调用检测：</strong> 自动查找 <code>LocalizationManager._(\"Text\")</code>、<code>_(\"Text\")</code> 和 <code>GetTranslation(\"Text\")</code> 调用。它对这些调用强制执行 <strong>文本即键</strong> 模式，以确保复数形式和性别等运行时功能正常工作。",
  "li_content_scanner_details_2": "<strong>常量解析：</strong> 扫描器足够智能，可以解析 `const` 或 `static readonly` 字符串变量。如果您使用 <code>_ (MyConst)</code>，它将找到 `MyConst` 的值（如果定义在同一类中）并将其用作源文本。",
  "li_content_scanner_details_3": "<strong>Attribute & Metadata:</strong> 它会扫描任何带有 `[LocalizableField]`、`[Header]` 或 `[Tooltip]`（如果已配置）的字段或属性。它递归处理 <strong>数组</strong>、<strong>列表</strong> 和甚至 <strong>嵌套可序列化类</strong>。",
  "li_content_scanner_details_4": "<strong>Modern C# Support:</strong> 完整支持 C# 9.0+ 语法，包括目标类型的 <code>new()</code> 表达式、隐式数组创建以及插值字符串（`$\"String {0}\"`）。",
  "li_content_script_rules_attributes": "<strong>要扫描的属性：</strong>定义自定义属性（例如 <code>[Header]</code> 或 <code>[Tooltip]</code>），解析器应将其识别为可本地化的字符串源。",
  "li_content_script_rules_bridge_name": "<strong>桥接类名称：</strong>允许您定义生成的静态类的名称。",
  "li_content_script_rules_bridges": "<strong>生成 C# 桥接：</strong>自动创建一个静态类（例如 <code>AnkoLoc</code>），提供对所有键的强类型访问，消除魔术字符串并启用 IDE 自动补全。",
  "li_context_1": "<strong>Developer Notes（开发人员注释）：</strong>翻译表中的注释作为上下文传递给 AI。",
  "li_context_2": "<strong>Object Path（对象路径）：</strong>如果不存在注释，则使用对象的层级路径（例如，<code>MainMenu/Canvas/StartButton</code>）作为回退上下文。",
  "li_context_3": "<strong>Glossary（词汇表）：</strong>您可以将 CSV 词汇表加载到配置中，以强制执行术语和名称的特定翻译。",
  "li_context_4": "<strong>Project Description:</strong> 描述游戏的设定和受众，以帮助 AI 理解整体背景。",
  "li_context_5": "<strong>Tone & Style:</strong> 定义期望的人设（例如“友好”“专业”“海盗”）以及格式规则。",
  "li_context_glossary": "<strong>Dictionary Manager:</strong> 直接与术语表交互以‘添加’、‘编辑’或‘删除’条目。支持区分大小写和‘不翻译’类型。",
  "li_context_optimization": "<strong>Token Optimization:</strong> 系统智能压缩上下文并复用缓存，以最小化令牌使用量和成本。",
  "li_custom_ai_1": "<strong>GenericAIService：</strong>一种灵活的实现，可以与 OpenAI 兼容的 API（包括通过 Ollama 的本地 LLM）进行通信。",
  "li_custom_ai_2": "<strong>模板与认证：</strong>完全自定义请求。 <ul><li><strong>认证：</strong>配置 <code>Auth Header Key</code>（例如 <code>Authorization</code>）和 <code>Format</code>（例如 <code>Bearer {0}</code>）。支持查询参数中的 API 密钥。</li><li><strong>正文模板：</strong>使用带有占位符的 JSON 模板，例如用于文本的 <code>{model}</code> 和 <code>{prompt}</code>，或用于音频的 <code>{input}</code> 和 <code>{voice}</code>。</li><li><strong>响应路径：</strong>定义结果的 JSON 路径（例如 <code>choices[0].message.content</code>）。</li></ul>",
  "li_custom_ai_3": "<strong>Built-in Safety Features（内置安全功能）：</strong>自动修复 AI 模型经常返回的损坏的格式标签（如 <ph0>），确保可靠且一致的翻译。",
  "li_custom_parser_1": "在您项目的 <strong>Editor</strong> 文件夹中创建一个新的 C# 脚本。",
  "li_custom_parser_2": "将下面的模板复制到其中。",
  "li_custom_parser_3": "修改逻辑以匹配您的组件。",
  "li_custom_provider_manual_reg": "<strong>Manual Registration:</strong> 对于高级场景（如 DI 注入或延迟初始化），您可以在初始化期间通过 <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> 手动注册提供者。",
  "li_custom_provider_step_1": "<strong>Implement the Interface:</strong> 创建一个实现 <code>IAssetProvider</code> 的新类。您需要使用系统的 API 定义如何 <code>Load&lt;T&gt;</code>（sync）和 <code>LoadAsync&lt;T&gt;</code>（async）加载资产。",
  "li_custom_provider_step_2": "<strong>Define Lifecycle:</strong> 实现 <code>Initialize</code>、<code>Dispose</code> 和 <code>UnloadAll</code>。这些方法会在切换语言或清理资源时由 <code>LocalizationManager</code> 调用。",
  "li_custom_provider_step_3": "<strong>Language Safety:</strong> 每当活动语言更改时，都会调用 <code>SetCurrentLanguage</code> 方法。使用它来更新内部路径或重新获取资产元数据。",
  "li_custom_provider_step_4": "<strong>Auto-Discovery (Recommended):</strong> 在类上添加 <code>[AssetProviderPlugin]</code> 特性。这样您的提供者会立即出现在 <strong>Settings Tab -&gt; Asset Loading Strategy</strong> 下拉菜单中。",
  "li_editor_1": "<strong>Smart Grouping（智能分组）：</strong>复数和性别键（例如，<code>apple_count_one</code>、<code>apple_count_few</code>）会自动组合成可折叠的组。",
  "li_editor_2": "<strong>Advanced Editing（高级编辑）：</strong>点击单元格以打开 <strong>MultiLineEditWindow</strong> 弹出窗口。它显示源文本进行比较并验证占位符。",
  "li_editor_3": "<strong>Advanced Selection:</strong> 支持灵活的选择模式：单元格、整行或特定列（语言）。使用 <code>Ctrl+Click</code> 和 <code>Shift+Click</code> 进行复杂选择。",
  "li_editor_4": "<strong>Mass Actions:</strong> 一次对数千个单元格执行操作。右键点击您的选择以：<ul><li><strong>Auto-Translate:</strong> 使用激活的 AI 配置文件填充缺失的翻译。</li><li><strong>Fill from Source:</strong> 快速重置翻译。</li><li><strong>Toggle Lock:</strong> 保护‘perfect’翻译免于意外覆盖。</li><li><strong>Generate Audio:</strong> 对选定短语批量处理 TTS。</li></ul>",
  "li_editor_5": "<strong>High-Performance Navigation:</strong> 编辑器使用虚拟化的 'MultiColumnListView' 实现平滑滚动，可处理 10k+ 键。支持键盘导航（方向键/Tab）以及强大的快捷键：<code>Ctrl+S</code>（保存），<code>Ctrl+Z/Y</code>（撤销/重做），<code>Ctrl+F</code>（搜索焦点）。",
  "li_editor_6": "<strong>Advanced Search Presets:</strong> 使用专用过滤器审计项目：<ul><li><strong>Status:</strong> 未翻译（Current/Any Lang），与源相同，已锁定。</li><li><strong>Content:</strong> 包含注释，包含/缺少占位符，存在长度问题（自动检测）。</li><li><strong>Structure:</strong> 复数形式，性别形式，或两者兼有。</li><li><strong>Audio:</strong> 缺少音频，已过时（Hash Mismatch）。</li></ul>",
  "li_editor_7": "<strong>Smart Audio Management:</strong> 跟踪 TTS 文件的‘新鲜度’。如果编辑翻译文本，会出现 <strong>黄色指示器（已过时）</strong>，表明音频文件哈希不再匹配文本。单击即可仅重新生成过期文件。",
  "li_editor_8": "<strong>Locking Mechanism:</strong> 说明：<ul><li><strong>Locked Cells/Rows:</strong> 阻止 <strong>Auto-Translate</strong>、<strong>CSV/Google Import</strong> 或 <strong>Fill from Source</strong> 进行任何修改。</li><li><strong>Use Case:</strong> 锁定已由母语者手动验证的‘Golden’翻译。</li><li><strong>Bulk Control:</strong> 在整个项目范围内锁定整种语言或特定功能（如角色名称）。</li></ul>",
  "li_editor_layout": "<strong>Dynamic Multi-Pane Layout:</strong> 使用 3 窗格系统将‘固定’列（如 Keys）固定在左侧，同时在中间滚动浏览 20 多种语言。通过标题右键菜单切换列可见性。",
  "li_editor_regex": "<strong>Regex Search:</strong> 主窗口和表格编辑器均支持 <strong>正则表达式</strong>。如果查询包含诸如 <code>* + ? ^ $ [ ] ( ) { } | .</code> 等符号，将自动视为正则表达式（例如 <code>^item_.*</code> 用于查找所有以 'item_' 开头的键）。",
  "li_editor_structure": "<strong>Tables & Groups:</strong> 数据以表格（Files）组织，在编辑器中显示为分组（Folders），以便更好地导航。",
  "li_editor_ui_test": "<strong>Built-in UI Testing:</strong> <ul><li><strong>Length Expansion Slider:</strong> 模拟文本扩展（0% - 100%），查看 UI 如何处理德语或俄语等更长语言，而无需离开编辑器。</li><li><strong>Rich Text Renderer:</strong> 切换标签（<code>&lt;b&gt;</code>、<code>&lt;color&gt;</code>）的渲染，以在不运行游戏的情况下验证样式。</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>：</strong>用于创建用于语言切换的 UI 下拉列表的现成组件。它自动查找所有可用语言并管理它们的切换。<br><strong>如何使用：</strong>只需将 <code>LanguageSelector</code> 组件添加到您的场景中（例如，在一个空的 GameObject 上），并在 Inspector 中指定您的 <code>TMP_Dropdown</code>。",
  "li_example_components_2": "<strong>Code Examples（代码示例）：</strong>要学习高级技术，例如使用 <code>[LocalizableField]</code>、<code>_()</code> 函数、复数和性别，请研究 <code>StatPurchaseTest.cs</code> 和 <code>TestLocalization.cs</code> 文件。它们清楚地演示了该工具所有主要功能的实现。",
  "li_example_components_new": "<strong>New (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>。返回 <code>IEnumerator</code>。必须使用 yield。",
  "li_example_components_old": "<strong>Old:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code>（synchronous void）- <strong>已弃用</strong>。使用协程版本。",
  "li_feature_1": "<strong>高级解析：</strong>自动扫描场景、预制件、UI Toolkit (UXML) 和 C# 脚本，包括用 <code>[LocalizableField]</code> 属性标记的字段，以及嵌套类和列表。",
  "li_feature_10": "<strong>备份管理器：</strong>内置的创建和恢复备份工具。",
  "li_feature_11": "<strong>AI 驱动：</strong>通过可定制的配置文件支持 OpenAI、Anthropic (Claude)、Google Gemini 和本地 LLM (Ollama)。",
  "li_feature_12": "<strong>文本转语音 (TTS)：</strong>使用 AI（OpenAI、ElevenLabs）为本地化字符串生成音频文件。",
  "li_feature_13": "<strong>迁移工具：</strong>用于从 I2 Localization 和 Unity Localization 插件自动转换的工具。",
  "li_feature_14": "<strong>字体与字形管理器：</strong>用于分析已用字符和查找字体中缺失字形的工具。",
  "li_feature_15": "<strong>可视化调试：</strong>层级视图中的图标和场景视图中的标签，用于快速调试。",
  "li_feature_2": "<strong>任意资源本地化：</strong>管理精灵（Sprites）、音频、预制件、材质等。",
  "li_feature_3": "<strong>Powerful Translation Editor:</strong> 一个集中式界面，具备自动保存、完整的 Undo/Redo 支持、智能键分组和多选操作。",
  "li_feature_4": "<strong>AI & Machine Translation:</strong> 支持 DeepL、Google、Microsoft，以及 <strong>自定义 AI（OpenAI、Gemini、Claude、Ollama）</strong>，具备上下文感知能力。",
  "li_feature_5": "<strong>灵活导入/导出：</strong>支持 CSV、XML、YAML、XLIFF，以及从 Google Sheets 直接导入。",
  "li_feature_6": "<strong>实时预览：</strong>在不运行游戏的情况下，在场景视图或 <strong>预制件模式</strong> 中预览任何语言。",
  "li_feature_7": "<strong>Plural & Gender Support:</strong> 完整的 CLDR 支持（v43）。包括以下规则：<strong>Asian</strong>（None），<strong>English/Germanic</strong>（One, Other），<strong>French</strong>（One 0-1），<strong>Slavic</strong>（One, Few, Many - RU, UK, PL），<strong>Arabic</strong>，<strong>Celtic</strong>，<strong>Baltic</strong>（LT, LV），以及更多。",
  "li_feature_8": "<strong>完整的 RTL 支持：</strong>正确显示从右到左的语言。",
  "li_feature_9": "<strong>实时更新：</strong>在游戏开始时从远程服务器加载最新的翻译。",
  "li_feature_tool_translation": "<strong>Fully Translated UI:</strong> 工具界面支持本地化。您可以通过 <strong>Main Window header</strong> 下拉菜单切换编辑器语言。",
  "li_font_global": "<strong>Global Report:</strong> 生成所有语言中缺失字形的报告。",
  "li_font_glyph_analyze": "分析所有翻译，并检查分配的字体 (TMP_FontAsset) 是否支持所有使用的字符。",
  "li_font_glyph_copy": "允许复制所有唯一的语言字符以生成字体图集。包含 <strong>过滤器以排除 ASCII、数字和标点符号</strong>，以优化纹理空间。",
  "li_font_glyph_missing": "显示缺失字形的列表。",
  "li_font_glyph_workflow": "<strong>TMP 工作流程：</strong>1. 运行扫描。2. 选择缺少字形的语言。3. 点击 <strong>'Copy Character Set'</strong>。4. 打开 Window -> TextMeshPro -> Font Asset Creator。5. 将剪贴板粘贴到 'Character Sequence (Custom Range)' 字段，以生成一个恰好包含您的游戏所需字符的图集。",
  "li_font_unicode": "<strong>Unicode Ranges:</strong> 查看翻译中使用的特定 Unicode 范围（例如 Basic Latin、Cyrillic），以优化字体资源。",
  "li_footer_status": "<strong>状态与进度：</strong>关于解析、导入或 AI 生成任务的实时反馈。",
  "li_header_lang_selector": "<strong>编辑器语言：</strong>切换工具的界面语言。工具 UI 完全可本地化。",
  "li_header_preview_btn": "<strong>预览开关：</strong>快速启用或禁用编辑器内预览。使用“还原”按钮恢复原始场景值。",
  "li_header_toolbar_buttons": "<strong>全局工具栏：</strong>直接访问文档、Discord、设置资产、依赖检查器和审查页面。",
  "li_install_1": "<strong>IMPORTANT (v2.0 Update):</strong> 如果从 v1.x 升级，您 <strong>必须删除</strong> 旧的 `Ankonoanko` 文件夹后再导入。Version 2.0 由于命名空间更改，需要全新安装。",
  "li_install_2": "该工具将自动检查必要的依赖项。在出现的对话框中确认安装。",
  "li_install_3": "基本功能需要必需的依赖项 (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>)。",
  "li_install_4": "可选依赖项 (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) 启用附加功能。",
  "li_install_5": "点击 <strong>安装选中项 (Install Selected)</strong> 来安装推荐的包。",
  "li_install_6": "安装后，通过 <strong>Tools -> Localization Tool</strong> 菜单打开主工具窗口。",
  "li_install_7": "如果您计划使用异步资源加载，请通过 Package Manager 安装 <strong>Addressables</strong> 包。",
  "li_live_updates_1": "<strong>Enable:</strong> 在 Settings 中，勾选‘Enable Live Updates’。",
  "li_live_updates_2": "<strong>Source:</strong> 提供返回 JSON 字典的 <code>Live Update URL</code>，或 <code>Google Sheet URL</code>。",
  "li_live_updates_3": "<strong>Cache:</strong> 翻译会在本地 <code>liveUpdateCachePath</code> 缓存，以确保游戏离线运行。",
  "li_live_updates_4": "<strong>Security:</strong> 如果服务器需要身份验证，请使用 <strong>Runtime API Key</strong>（加密）。",
  "li_localizedtext_1": "<code>localizationKey</code>: 用于查找翻译的键。可以自动生成或手动指定。",
  "li_localizedtext_2": "<code>isStyleOnly</code>: 如果 <code>true</code>，组件仅会应用样式（字体、RTL），而不会更改文本本身。对于通过脚本中的 `_()` 调用动态更新的文本元素至关重要。",
  "li_localizedtext_3": "<code>originalSourceText</code>: 基本语言的原始文本。用作回退。",
  "li_localizedtext_key_override": "<strong>手动键覆盖：</strong>您可以点击键旁边的“编辑”图标手动输入一个键。使用“X”恢复自动生成。这适用于 <code>LocalizedText</code>、<code>LocalizedDropdown</code>（针对每个选项单独），以及 <code>UITKLocalization</code>。",
  "li_localizedtext_search_key": "<strong>Search in Table:</strong> 点击放大镜图标即可立即打开翻译表并聚焦到该键。",
  "li_migration_csv_details_1": "<strong>Smart Filtering:</strong> 导入器会自动跳过看起来像资产路径的行（例如 <code>.png</code>、<code>.mp3</code>、<code>Assets/...</code>），以保持文本数据库整洁。",
  "li_migration_csv_details_2": "<strong>'Type' Column:</strong> 如果存在 ‘Type’ 列（I2 格式），仅导入标记为 ‘Text’ 或类型为空的行。要导入资产，请使用迁移配置文件将其映射到 <code>LocalizedAsset</code>。",
  "li_migration_csv_req_1": "<strong>Key Column:</strong> 必须命名为 <code>Key</code>（不区分大小写）或在迁移配置文件中定义。",
  "li_migration_csv_req_2": "<strong>Language Columns:</strong> 任何未标记为忽略的列都会被视为语言代码（例如 'en'、'ja'、'English'）。工具会尝试模糊匹配这些代码到项目中的语言。",
  "li_migration_csv_req_3": "<strong>注释：</strong>名为 <code>Desc</code>、<code>Description</code> 或 <code>Comment</code> 的列将作为开发者备注导入。此列表可在 <strong>迁移配置文件</strong> 中配置。",
  "li_migration_custom_1": "在 Project View 中右键 -> Create -> Anko Localization -> Migration Profile。",
  "li_migration_custom_2": "<strong>规则：</strong>定义转换规则（如果 [源组件] 带有 [上下文过滤器]，则转换为 [目标组件]）。规则支持 <strong>优先级</strong>（数字越大越先处理）、<strong>收集资产</strong>（自动提取并注册引用的资产，如 Sprites 或 Audio），以及 <strong>上下文过滤</strong> 以区分同一对象上的多个组件。",
  "li_migration_fallback_keys": "<strong>备用键字段：</strong> 指定在从旧组件提取键时要检查的其他字段名称。如果您的旧系统使用非标准属性名称作为键，这会很有用。",
  "li_migration_gs_1": "<strong>Access:</strong> 表格必须设为共享（‘Anyone with the link can view’）或发布到网络。",
  "li_migration_gs_2": "<strong>Sheet Tabs (GID):</strong> URL 必须包含 <code>gid=...</code> 参数。它告诉工具读取哪个标签页（例如 <code>gid=0</code> 通常是第一个标签页/工作表）。",
  "li_migration_ignored_headers": "<strong>忽略的 CSV 标题：</strong> 定义在导入时应跳过的列（例如，'Type'、'Description'）。这可以防止工具将元数据列视为语言数据。",
  "li_migration_legacy_components": "<strong>其他旧组件：</strong> 手动列出工具在迁移扫描期间应检测为“旧”的组件名称，即使没有定义直接转换规则。",
  "li_migration_profile_details": "<strong>高级配置文件设置：</strong><ul><li><code>CsvKeyHeader</code>：键列的标题名称。</li><li><code>CsvCommentHeaders</code>：要作为开发者备注/注释处理的标题列表。</li><li><code>IgnoredCsvHeaders</code>：要跳过的列（如“类型”或“状态”等元数据），以避免它们被视为语言。</li><li><code>AssetExtensions</code>：扫描期间识别为资产的文件类型。</li><li><code>FallbackKeyFields</code>：当主键字段为空时要检查的其他字段名称。</li></ul>",
  "li_migration_rule_fields": "<strong>规则配置：</strong><ul><li><code>优先级</code>：值越大越先处理。用此来在通用情况之前处理特定情况。</li><li><code>上下文过滤器</code>：仅当特定组件（例如 <code>Text</code>）存在于同一对象上时才应用规则。</li><li><code>收集资产</code>：如果启用，从旧版组件中提取当前资产（例如 Sprite）并将其注册到资产表中。</li><li><code>资产字段路径</code>：包含用于收集的资产引用的字段路径。</li><li><code>附加数据路径</code>：用于复杂组件（如下拉列表）以收集多个值/选项。</li></ul>",
  "li_migration_stubs_1": "<strong>Problem:</strong> 您删除了旧插件资产。Unity 检测到缺少脚本（例如缺少 <code>Localize</code> 组件）。编辑器进入编译错误模式。",
  "li_migration_stubs_2": "<strong>解决方案：</strong> 'Emergency Stubs' 功能生成轻量级、空的类，名称和命名空间与旧插件完全相同。这满足编译器的要求。",
  "li_migration_stubs_3": "<strong>工作流程：</strong>1. 点击 <strong>启用紧急存根</strong>（这会将 <code>ANKO_ENABLE_MIGRATION_STUBS</code> 添加到您的项目设置中）。2. 删除旧的插件文件夹。3. Unity 使用假类成功重新编译。4. 运行 <strong>组件转换器</strong> 将存根替换为官方组件。5. 重构完成后点击 <strong>禁用存根</strong>。",
  "li_migration_tool_converter": "<strong>步骤 2：组件转换器：</strong>扫描场景和预制件。自动用 <code>LocalizedText</code> / <code>LocalizedAsset</code> 替换旧组件（例如，<code>Localize</code>），并转移键。",
  "li_migration_tool_fields": "<strong>配置文件设置：</strong> 可配置的“Source Plugin”类型和“Asset Mapping”规则确保纹理和音频的正确转移。",
  "li_migration_tool_import": "<strong>步骤 1：数据导入：</strong>导入 CSV (I2) 或 XLIFF (Unity Loc) 文件以创建键数据库。",
  "li_migration_tool_profiles": "<strong>迁移配置文件：</strong> 创建自定义配置文件，以映射来自第三方插件（I2，Unity Loc）的资产和设置。",
  "li_migration_tool_safemode": "<strong>安全模式与紧急存根：</strong>组件被禁用而不是删除。包括关键的 <strong>紧急存根</strong> 功能（通过 <code>ANKO_ENABLE_MIGRATION_STUBS</code> 定义符号激活）：为 I2 Localization 或 Unity Localization 生成假的占位符类，以便在删除这些插件后您的项目可以立即编译。这可以防止“找不到类型名称 'Localize'”错误，并为您提供时间来正确重构代码以使用新系统。启用存根允许您在删除旧的本地化插件后修复编译错误。",
  "li_migration_tool_setup": "<strong>步骤 0：设置：</strong>配置组件名称（例如，I2 的 <code>Localize</code>）以及存储键的字段。提供预设。",
  "li_migration_workflow_1": "<strong>1. 备份：</strong> 将项目提交到源代码管理（Git）或在开始前进行文件备份。",
  "li_migration_workflow_2": "<strong>2. 启用 Stubs：</strong> 打开迁移工具 → “Safe Mode”选项卡。点击 <strong>启用紧急存根</strong> 为目标系统（I2/UnityLoc）创建轻量级的虚假类。",
  "li_migration_workflow_3": "<strong>3. 移除旧插件：</strong> 删除旧插件文件夹（例如 'Assets/Plugins/I2'）。Unity 将重新编译。由于 Stubs，您将 <strong>不会</strong> 遇到 “Type not found” 错误，保留所有在 Prefab 上的组件引用。",
  "li_migration_workflow_4": "<strong>4. 导入数据：</strong> 在 “Import Data” 选项卡中，加载您的源 CSV/XLIFF。验证预览并点击 <strong>导入</strong>。这将填充 AnKo 翻译表。",
  "li_migration_workflow_5": "<strong>5. 转换组件：</strong> 在 “Component Converter” 选项卡中，选择 “Entire Project” 并点击 <strong>扫描并转换</strong>。该工具将旧的存根替换为 ‘LocalizedText’/‘LocalizedAsset’ 组件，转移键值。",
  "li_migration_workflow_6": "<strong>6. 清理：</strong> 确认一切正常后，点击 <strong>禁用 Stubs</strong> 并让 Unity 再次重新编译。",
  "li_notes_1": "<strong>Backups（备份）：</strong>在进行重大更改之前，请始终通过 <strong>Translation Table Editor -> Manage Backups</strong> 创建备份。备份存储在 <strong>项目根目录（Assets 文件夹之外）</strong> 的 <code>LocalizationBackups</code> 文件夹中，以保持您的 Unity 项目清洁并减少导入时间。",
  "li_notes_2": "<strong>API Key Security（API 密钥安全性）：</strong>用于在编辑器中工作的密钥存储在您的本地计算机上（在 <code>EditorPrefs</code> 中），并且不会进入存储库。对于在游戏构建中需要的密钥，请使用 <strong>Runtime API Key</strong> 部分。",
  "li_notes_3": "<strong><code>StreamingAssets</code> Folder（文件夹）：</strong>翻译文件必须位于 <code>Assets/StreamingAssets/</code> 的子文件夹中，才能包含在游戏构建中。",
  "li_notes_4": "<strong>\"Fool-proofing\"（防呆）：</strong>该工具会自动保护您，防止意外将预览模式的临时数据保存到场景或预制件中。",
  "li_notes_5": "<strong>Performance（性能）：</strong><code>_()</code> 调用速度很快，但在每帧运行的循环中（例如，在 <code>Update</code> 中），请尝试将结果缓存到变量中。",
  "li_notes_6": "<strong>Excluding <code>LanguageSelector</code> from parsing（将 LanguageSelector 从解析中排除）：</strong>带有 <code>LanguageSelector</code> 组件及其 <code>TMP_Dropdown</code> 的对象必须添加到 <strong>Content</strong> 标签页的 <strong>Ignore Specific Objects</strong> 列表中。这是必要的，以防止解析器为下拉选项创建额外的键，因为 <code>LanguageSelector</code> 脚本会在运行时动态填充它们。忽略可以防止冲突并保持翻译文件干净。",
  "li_notes_7": "<strong>Fonts for <code>LanguageSelector</code>（LanguageSelector 的字体）：</strong>为了让 <code>TMP_Dropdown</code> 中选定的语言正确更新其字体，请手动向 Dropdown 的子 <strong>Label</strong> 对象添加一个空的 <code>LocalizedText</code> 组件，并勾选 <code>isStyleOnly</code> 框。",
  "li_notes_addressables_code": "<strong>Code & Addressables（代码与 Addressables）：</strong>如果您切换到 <strong>Addressables (Async)</strong> 模式，您的脚本中 <strong>必须</strong> 使用 <code>GetLocalizedAssetAsync<T>()</code>。调用同步的 <code>GetLocalizedAsset<T>()</code> 将返回 null 并记录警告，以防止主线程冻结。",
  "li_notes_addressables_sync_warning": "<strong>Sync vs Async（同步与异步）：</strong>如果您切换到 <strong>Addressables (Async)</strong> 模式，您 <strong>必须</strong> 更新您的代码以使用 <code>GetLocalizedAssetAsync<T>()</code>。调用同步方法将返回 null 并记录警告，以避免冻结主线程。",
  "li_preview_1": "<strong>工作原理：</strong>从列表中选择一种语言，工具将立即将相应的翻译、字体、RTL 设置和资源应用于活动场景或打开预制件中的所有可本地化对象。",
  "li_preview_2": "<strong>占位符：</strong>如果在 <strong>Settings</strong> 标签页中选择了占位符样式（例如，<strong>Accents</strong> 或 <strong>Brackets</strong>），这些占位符将以预览模式显示，而不是实际翻译。这非常适合测试布局和查找未本地化的元素。",
  "li_preview_3": "<strong>安全性：</strong>在预览模式下所做的所有更改都是临时的。当您选择“<strong>Revert to Original</strong>”、关闭窗口、更改场景或在保存场景/预制件之前（归功于 <code>LocalizationPreviewProtector</code> 组件）时，工具将自动将所有内容恢复到原始状态。",
  "li_preview_4": "<strong>崩溃保护：</strong>系统在预览之前会自动将场景状态备份到 <code>Library</code> 文件夹中。如果 Unity 在预览时崩溃或您强制退出，工具会在下次启动时检测恢复文件，并提供恢复原始场景状态的选项。",
  "li_preview_overlay_1": "<strong>访问：</strong> 该覆盖层会自动出现在 Scene View 中。您可以通过 Unity Overlay 菜单（Scene View 中的 <code>Space</code> 键）切换它。",
  "li_preview_overlay_2": "<strong>功能：</strong> 提供下拉菜单，可快速切换当前预览语言，无需打开主窗口。",
  "li_report_1": "<strong>Categories（类别）：</strong>所有键、已添加、已更新（文本已更改）、已删除、重复项、已迁移、已跳过（未更改）。",
  "li_report_2": "<strong>Advanced Find（高级查找）：</strong>点击任何条目旁边的 <strong>Find</strong> 按钮，即可立即在项目中找到相应的对象。搜索是异步进行的，不会阻塞编辑器，并且会搜索所有场景和预制件。",
  "li_report_all_keys": "<strong>所有键：</strong>项目中检测到的所有本地化键列表，附带搜索和过滤选项。",
  "li_report_btn_clear": "<strong>清除报告：</strong>从当前会话的内存中删除所有扫描结果。",
  "li_report_btn_copy_all": "<strong>复制所有键：</strong>将当前类别中的所有本地化键复制到系统剪贴板。",
  "li_report_btn_load_last": "<strong>加载上次扫描：</strong>无需重新扫描即可立即恢复最近一次项目分析的结果。",
  "li_report_btn_save": "<strong>保存报告：</strong>将当前扫描结果导出到文本或 CSV 文件，用于外部文档或审计。",
  "li_report_source_filter": "<strong>源过滤器：</strong>根据来源缩小结果范围（例如，只显示在脚本、场景或 Prefab 中找到的键）。",
  "li_safety_global_limit": "<strong>全局月度限制：</strong> <code>monthlyCharLimit</code>（默认：500,000 字符）充当所有请求的断路器。您可以通过 <code>enableApiLimitWarning</code> 切换警告。",
  "li_safety_profile_limit": "<strong>配置文件限制：</strong> 每个 Translation Profile 都可以设置其自己的 “Max Chars Per Request” 和 “Batch Size”。",
  "li_settings_1": "<strong>键生成模式：</strong>定义为文本创建唯一标识符的策略：<ul><li><code>AutoGenerateKeysOnly</code> <strong>（默认 - 推荐）</strong>：根据场景/Prefab 名称和对象层级结构生成键（例如 <code>scene_Menu_BtnPlay_682412</code>）。最适合大型项目，因为它保证唯一性且不受文本更改的影响。</li><li><code>UseTextAsKey</code>：使用源文本本身作为键（例如 “Start Game” → <code>Start Game</code>）。理想用于键应易于阅读的快速原型设计。</li><li><code>AutoGenerateWithCustomKeys</code> <strong>（混合）</strong>：最灵活的模式。它首先检查组件是否已有手动分配的键或 <code>[LocalizableField(key=\"...\")]</code>。如果不存在键，则生成一个分层键。 <em>使用此模式可在自动化新内容的同时保留现有工作。</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>（混合）</strong>：与上述类似，但如果未找到手动键，则回退到文本本身。尊重现有组件和数据。</li><li><code>Manual</code>：扫描器从不创建新键。它只更新已经具有本地化组件和键的对象。非常适合严格的手动控制。</li></ul>",
  "li_settings_10": "<strong>Dev Tools（开发工具）：</strong>在 Settings 标签页的底部，您可以找到实用按钮，例如 <strong>Clear Saved Language Pref</strong>（重置保存在 PlayerPrefs 中的语言，以便游戏再次以默认语言启动）。",
  "li_settings_11": "<strong>Technical Dropdown Options（技术下拉选项）：</strong>解析器在扫描 Dropdowns 时将 <strong>忽略</strong> 的字符串值列表（默认值：'Option A'、'Option B'、'Option C'）。这使您的翻译表保持干净，免受 Unity 默认 UI 占位符文本的影响。",
  "li_settings_2": "<strong>Language Management（语言管理）：</strong><ul><li><strong>Source Language（源语言）：</strong>您的 Unity 场景/预制件中使用的语言（开发语言）。</li><li><strong>Default Language（默认语言）：</strong>如果用户的系统语言不受支持，则在首次游戏启动时选择的语言。</li><li><strong>List（列表）：</strong>管理支持的语言，分配特定的 <strong>Font Assets（字体资源）</strong>，并启用 <strong>RTL</strong> 支持。</li></ul>",
  "li_settings_3": "<strong>通用设置：</strong>项目范围行为的配置：<ul><li><code>翻译保存路径</code>：用于存储 <code>.json</code> 翻译文件的根目录。为了在游戏中访问，此目录必须位于 <code>Assets/Resources</code> 或 <code>Assets/StreamingAssets</code> 内。</li><li><code>安全模式</code>：一个保护层，如果检测到项目不一致或缺少依赖项，则会阻止操作（例如自动翻译）。</li><li><code>移除缺失键</code>：如果启用，扫描器将在项目更新期间自动删除数据库中不再存在于任何场景或 Prefab 中的条目。</li><li><code>解析非活动对象</code>：确定工具是否应扫描和本地化禁用或隐藏的 GameObjects。</li><li><code>解析所有 Prefabs</code>：扫描项目中的每个 Prefab。如果禁用，则只处理 <strong>内容</strong> 选项卡中指定的文件夹中的 Prefabs。</li><li><code>按路径填充注释</code>：使用对象的场景/Prefab 层级路径自动填充翻译表中的“注释”字段。</li><li><code>按语言拆分文件</code>：将翻译数据库分成多个文件（例如 <code>en.json</code>、<code>ja.json</code>）。强烈建议大型项目使用此功能，以减少运行时内存开销。</li><li><code>允许空源/键</code>：允许工具注册和跟踪对象，即使其源文本为空。对于完全通过代码设置的动态文本很有用。</li><li><code>附加到正则表达式忽略的文本</code>：强制工具向其文本与排除正则表达式（如数字）匹配的对象添加本地化组件，从而允许手动覆盖。</li><li><code>查找设置资产</code>：一个实用按钮，可立即在您的项目窗口中定位并选择 <code>LocalizationSettings.asset</code> 文件。</li></ul>",
  "li_settings_4": "<strong>调试与测试：</strong><ul><li><code>占位符样式</code>：选择在预览模式中显示占位符的样式。</li><li><code>伪本地化</code>：选择 <strong>'自定义伪造'</strong> 以显示高级布局测试设置（扩展因子、重音和分隔符）。</li></ul>",
  "li_settings_5": "<strong>Live Updates（实时更新）：</strong>从远程服务器加载翻译的设置。",
  "li_settings_6": "<strong>运行时 API 密钥：</strong> 安全存储用于 <strong>Live Updates</strong>（在游戏中获取新翻译）的 API 密钥。这与编辑器中使用的 Translation Service 密钥不同。该密钥在构建中被 <strong>混淆</strong>（加密），以防止通过字符串搜索轻易提取，但请记住：没有客户端密钥是 100% 安全的。",
  "li_settings_7": "<strong>资产加载策略：</strong> 可在 <code>Resources (Legacy)</code>、<code>Addressables (Async)</code> 和 <code>Custom</code> 之间选择。警告：更改此模式需要重新扫描项目。强烈建议在移动端和 WebGL 上使用 Addressables 模式以降低内存使用。",
  "li_settings_8": "<strong>自动翻译：</strong>使用 <strong>翻译配置文件</strong> 系统进行 AI 驱动的本地化。配置包括：<ul><li><code>文本与音频配置文件</code>：选择或创建 ScriptableObject 配置文件以配置不同的服务（例如 OpenAI、DeepL、Google）。</li><li><code>预设文件夹</code>：存储您的翻译预设和配置文件的目录。</li><li><code>目标语言</code>：所有项目语言的列表，显示所选配置文件的实时状态、进度条和字符计数。</li><li><code>开始自动翻译</code>：使用指定的配置文件开始所有选定语言的翻译过程。</li></ul>",
  "li_settings_9": "<strong>调试增强：</strong><ul><li><code>显示层级图标</code>：在层级中显示状态图标（绿色勾号 / 黄色警告）。<strong>性能优化：</strong>使用缓存以确保即使在大型场景中也零延迟。</li><li><code>显示场景视图标签</code>：直接在场景视图中进行可视化调试。标签是交互式的：右键单击任何场景标签即可立即将本地化键复制到剪贴板。</li></ul>",
  "li_settings_asset_folder_rule": "<strong>文件夹结构规则：</strong>定义生成本地化资产时子文件夹的结构方式（例如 <code>{lang}/{category}</code>）。",
  "li_settings_bridge_name": "<strong>桥接类名称：</strong>允许您自定义生成的静态类的名称（默认为 <code>AnkoLoc</code>）。",
  "li_settings_general_safe_mode": "<strong>安全模式：</strong>确保如果关键操作可能导致项目状态不一致，则不会继续进行。",
  "li_settings_lang_culture_fallback": "<strong>使用文化回退：</strong>如果特定区域方言（例如 <code>en-AU</code>）缺失，工具将尝试使用基础语言（<code>en</code>），然后回退到 <strong>默认语言</strong>。",
  "li_settings_lang_follow_system": "<strong>跟随系统语言：</strong>在首次启动时自动将游戏语言切换为与玩家的操作系统语言匹配。",
  "li_settings_live_updates_security": "<strong>安全性：</strong> 运行时 API 密钥在构建中使用 AES 加密，以防止随意提取。始终使用 HTTPS。",
  "li_settings_pseudo_accents": "<strong>使用重音符号：</strong>将标准字符替换为带重音的版本（例如 <code>å</code>, <code>é</code>）。使用此功能可确保您的字体支持所有必需的字形。",
  "li_settings_pseudo_brackets": "<strong>添加括号：</strong>将文本包裹在 <code>[ ]</code> 中，以验证本地化字符串的开始和结束，有助于识别文本截断或连接问题。",
  "li_settings_pseudo_expand_length": "<strong>扩展长度：</strong>通过附加尾随字符来模拟德语或俄语等语言中常见的文本扩展。",
  "li_settings_pseudo_expansion_factor": "<strong>扩展因子：</strong>文本长度模拟的乘数（例如，2.0 将使文本长度加倍）。",
  "li_settings_pseudo_prefix": "<strong>自定义前缀：</strong>在每个本地化文本的开头添加一个特定字符串（例如 <code>PSEUDO-</code>）。",
  "li_settings_pseudo_suffix": "<strong>自定义后缀：</strong>在每个本地化文本的末尾添加一个特定字符串。",
  "li_settings_return_source": "<strong>缺失时返回源文本：</strong>如果启用，当当前语言找不到翻译时，系统将返回源语言的文本（或键本身）。",
  "li_settings_tms_timeout": "<strong>TMS 超时：</strong>指定对外部 TMS 服务进行网络请求的最大等待时间（以秒为单位）。",
  "li_settings_tool_check_deps": "<strong>检查依赖项：</strong>重新扫描项目以查找所需的包（例如 Newtonsoft）和可选集成。",
  "li_settings_tool_cleanup": "<strong>完整项目清理：</strong>一个破坏性工具，从项目中移除所有 Anko Localization 组件和数据（请谨慎使用！）。",
  "li_settings_tool_clear_prefs": "<strong>清除语言偏好设置：</strong>重置 PlayerPrefs 中保存的语言，强制游戏在下次启动时使用默认或系统语言。",
  "li_settings_tool_font_manager": "<strong>字体管理器：</strong>打开字体与字形管理器，分析缺失字符并生成优化的字体资产。",
  "li_settings_tool_migration": "<strong>迁移工具：</strong>协助从 I2 Localization 或 Unity Localization 移动数据和组件。",
  "li_settings_tool_test_center": "<strong>本地化测试中心：</strong>一个诊断工具，用于验证项目健康状况、检查损坏的引用并确保本地化完整性。",
  "li_setup_1": "<strong>创建设置：</strong>首次打开时，工具将在 <code>Assets/Resources</code> 文件夹中创建 <code>LocalizationSettings.asset</code> 文件。",
  "li_setup_2": "<strong>配置语言和模式：</strong> 在<strong>设置</strong>选项卡中，确保您的<strong>源语言</strong>正确。此外，验证<strong>键生成模式</strong>（默认为<code>AutoGenerateKeysOnly</code>，推荐用于大多数项目）。",
  "li_setup_3": "<strong>指定要解析的内容：</strong>在 <strong>Content</strong> 标签页中，将所有用于分析的场景添加到 <strong>Scenes to Parse</strong> 列表中。如果您使用带有文本的预制件，请确保它们的文件夹已添加到 <strong>Prefab Folders</strong>。",
  "li_setup_4": "<strong>首次运行解析器：</strong>转到 <strong>Actions</strong> 标签页，点击 <code>Update Keys</code> 按钮。工具将扫描您的项目，创建翻译文件，并自动将必要的组件 (<code>LocalizedText</code>, <code>LocalizedAsset</code> 等) 添加到游戏对象。",
  "li_setup_5": "<strong>设置与构建（关键）：</strong>工具会自动将 <code>LocalizationSettings.asset</code> 添加到 <code>Project Settings -> Player -> Preloaded Assets</code>。<br>⚠️ <strong>安全检查：</strong>如果设置文件在 Preloaded Assets 中缺失且不在 Resources 文件夹中，工具将 <strong>阻止构建</strong> 并抛出 <code>BuildFailedException</code>，以防止游戏启动时崩溃。",
  "li_sidebar_presets": "<strong>搜索预设：</strong>用于查找未翻译字符串或缺少占位符的键等常见任务的预定义过滤器。",
  "li_sidebar_search": "<strong>全局搜索：</strong>在项目中的所有表中搜索特定的键或文本。",
  "li_tms_crowdin": "<strong>Crowdin:</strong> 需要项目ID和API密钥。支持上传源XLIFF并下载翻译作为ZIP存档。<em>高级：</em> <code>File Name</code> (Crowdin中的目标路径)。",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> 需要API密钥。针对小型项目提供简单快速的集成。<em>高级：</em> <code>Import/Export Params</code> (允许添加额外的Loco API标志，例如 <code>&tag=v1</code> 或 <code>&status=translated</code>)。",
  "li_tms_phrase": "<strong>Phrase:</strong> 企业级本地化管理。<em>高级：</em> <code>Update Translations/Descriptions</code> 标志，用于控制Phrase在上传时是否覆盖现有数据。",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> 支持组织/项目slug和API令牌认证。<em>高级：</em> <code>Resource Slug</code> (如果资源不存在，则自动创建)。",
  "li_tutorials_1": "<strong>互动学习：</strong> 指南会突出显示特定的 UI 元素并等待您的操作。",
  "li_tutorials_2": "<strong>可用课程：</strong>",
  "li_tutorials_editor": "<strong>翻译编辑器：</strong> 类似于电子表格的编辑器的进阶功能。",
  "li_tutorials_list": "<strong>教程列表:</strong> 访问工具主要功能的交互式指南。",
  "li_tutorials_migration": "<strong>迁移：</strong> 如何从其他本地化系统（I2, Unity Localization）迁移。",
  "li_tutorials_quickstart": "<strong>快速入门：</strong> 文本和资源的初步设置。",
  "li_tutorials_size": "<strong>教程大小:</strong> 调整交互式指南的UI缩放和详细程度（从紧凑到超大）。位于教程选项卡的标题中。",
  "li_vis_debug_1": "<strong>层级图标：</strong> 立即发现问题（Missing Key，Missing Component）。已优化至零性能影响。",
  "li_vis_debug_2": "<strong>Scene View 标签：</strong> 在每个本地化对象上显示键。 <strong>右键单击</strong> 标签可进行 “Copy Key” 或 “Select Object”。",
  "li_vis_debug_3": "<strong>覆盖层：</strong> 使用场景视图覆盖层（空格键）可即时切换预览语言。",
  "lightbox_aria_close": "关闭图像查看器",
  "lightbox_image_alt": "放大视图",
  "mindmap_edge_configure": "1. 配置",
  "mindmap_edge_creates_components": "创建组件",
  "mindmap_edge_defines_rules": "定义规则",
  "mindmap_edge_edited_in": "在...中编辑",
  "mindmap_edge_enables_reaction": "通过...启用反应",
  "mindmap_edge_extends": "扩展",
  "mindmap_edge_generates": "生成",
  "mindmap_edge_manages_assets": "管理资源",
  "mindmap_edge_opens": "打开",
  "mindmap_edge_parse_project": "3. 解析项目",
  "mindmap_edge_processed_by": "由...处理",
  "mindmap_edge_recommends_for": "推荐用于",
  "mindmap_edge_relates_to": "与...相关",
  "mindmap_edge_reports_on": "报告",
  "mindmap_edge_see_faq": "查看常见问题",
  "mindmap_edge_specify_content": "2. 指定内容",
  "mindmap_edge_warns_about": "警告关于",
  "mindmap_node_ai_ecosystem": "AI 生态系统",
  "mindmap_node_async_code": "异步 / Addressables",
  "mindmap_node_dev_tools": "工具与实用工具",
  "mindmap_node_tms_integration": "TMS 集成",
  "mindmap_preset_ai": "AI 与自动化",
  "mindmap_preset_dev": "开发人员工作流程",
  "mindmap_preset_full": "完整视图",
  "mindmap_preset_quick_start": "快速入门",
  "mindmap_preset_tools": "工具与集成",
  "mindmap_preset_translator": "翻译人员工作流程",
  "mindmap_toggle_title": "显示思维导图",
  "my_notes_title": "我的注释",
  "no_notes_message_new": "将鼠标悬停在文本上以添加注释。",
  "notes_add_title": "为此块添加注释",
  "notes_close_title": "关闭",
  "notes_delete_title": "删除注释",
  "notes_edit_text": "编辑",
  "notes_edit_title": "编辑注释",
  "notes_goto_title": "转到文本",
  "notes_placeholder": "您的注释...",
  "on_this_page_title": "本页内容",
  "p_actions_1": "主要工作标签页。",
  "p_ai_assistant": "在翻译表编辑器中，您现在可以通过上下文菜单（右键单击 -> AI: ...）对选定的单元格运行自定义 AI 命令。",
  "p_ai_audio_economy": "<strong>节省成本：</strong>该工具会计算您的文本的 MD5 哈希值，并且仅在源文本发生更改时才重新生成音频文件，从而节省您的 API 积分。如果您更改了翻译，系统仅将该特定音频文件标记为“过时”。使用“Generate Missing/Outdated”仅重新生成已更改的内容，从而节省 API 积分。该工具会哈希您的文本，并且仅在源文本发生更改时才重新生成音频文件，通过智能批处理节省您的 API 积分。",
  "p_ai_context": "为了提高翻译质量，AI 现在会收到额外的上下文：",
  "p_ai_intro": "该工具使用 <strong>Translation Profile</strong> 系统（ScriptableObject）。这将翻译服务设置保存在各个配置文件资产中，便于您轻松切换配置。",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code> 提供了一个强大的API，用于运行时本地化管理。以下是您将在脚本中使用的主要方法。",
  "p_assets_1": "此标签页完全致力于本地化非文本资源。",
  "p_async_api": "使用 Addressables 时，资源不会立即加载。您必须使用异步 API 以防止帧率下降。",
  "p_bridge_description": "该工具包含一个用于键访问的静态类生成器，允许您使用强类型引用而不是“魔法字符串”。这有助于防止拼写错误并启用 IDE 自动补全。",
  "p_bridge_usage_title": "使用示例：",
  "p_components_intro": "这些组件是场景中的对象与翻译数据库之间的“桥梁”。它们“监听”语言变化，并自动替换正确的文本或资源。",
  "p_content_1": "在这里，您告诉工具具体在哪里查找文本。界面已完全重新设计，以提供更好的可用性。",
  "p_custom_ai": "<strong>Custom AI（自定义 AI）</strong> 服务类型允许您通过 REST API 连接任何 LLM。",
  "p_custom_asset_provider_1": "开发自定义提供程序可让您将自己的资产管理系统（例如自定义云加载器、特定内部打包系统或基于数据库的资产仓库）直接集成到本地化工作流中。",
  "p_custom_asset_provider_intro": "Asset Provider系统抽象了资产（Sprites、Audio、Prefab等）在运行时加载的方式。它使用一个<strong>插件注册表</strong>，自动发现任何标记有<code>[AssetProviderPlugin]</code>属性的<code>IAssetProvider</code>类的实现。这使得自定义加载系统（如云加载器或内部捆绑）能够无缝集成，而无需修改核心工具包。",
  "p_custom_attributes_description": "除了函数调用，您还可以使用自定义特性将脚本中的任何字符串字段标记为可本地化。默认情况下，该工具识别 <code>[LocalizableField]</code>，但您可以将任何特性名称（如 <code>[Header]</code> 或 <code>[Tooltip]</code>）添加到<strong>要扫描的特性</strong>列表中。",
  "p_custom_parser_1": "您可以通过创建自己的解析器类轻松扩展系统以支持自定义组件。",
  "p_editor_1": "通过 <strong>Tools -> Localization -> Translation Table Editor</strong> 打开。这是手动编辑翻译的主要工具。",
  "p_example_attribute_1": "本地化脚本变量的最强大方式。它支持 <strong>private、protected 和 public</strong> 字段。解析器递归处理 <strong>Arrays、Lists</strong> 和 <strong>Nested Serializable Classes</strong>。如果在 Settings 中进行配置，它甚至可以为其他属性（如 <code>[Header]</code> 或 <code>[Tooltip]</code>）生成键。",
  "p_example_components_1": "项目包含可用作优秀示例的现成脚本。",
  "p_example_components_updated": "代码已更改。语言加载（尤其是在使用 Addressables 时）现在是异步的。",
  "p_example_function_1": "使用 <code>_()</code> 函数处理在游戏过程中动态更改的文本。更新 UI 的方法应使用 <code>[OnLanguageChange]</code> 属性标记，以便在语言更改时自动调用它。为此，将自动向对象添加 <code>LocalizedBehaviour</code> 组件。",
  "p_example_plurals_1": "该工具现在为不同的语言组使用更准确的规则。",
  "p_font_glyph_manager_access": "通过 <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong> 访问。",
  "p_intro_1": "本工具是一个全面的解决方案，用于在 Unity 中本地化游戏和应用程序。它自动化了文本和资源收集过程，通过强大的界面管理翻译，集成机器翻译服务（包括自定义 AI），并动态更新游戏中的本地化内容。",
  "p_live_updates_guide": "Live Updates 系统允许您的游戏在运行时从远程服务器或 Google Sheet 获取新翻译，无需重新构建。",
  "p_localizedasset_1": "用于根据语言交换资源。自动检测组件类型。支持： <ul><li><strong>2D：</strong> 精灵 (<code>Image</code>, <code>SpriteRenderer</code>)，纹理 (<code>RawImage</code>)。</li><li><strong>音频/视频：</strong> <code>AudioSource</code>, <code>VideoPlayer</code>。</li><li><strong>3D/动画：</strong> <code>MeshFilter</code> (网格), <code>Renderer</code> (材质), <code>Animator</code> (控制器), <code>PlayableDirector</code> (时间轴)。</li></ul>",
  "p_localizedasset_2": "对于带有 <strong>Play on Awake</strong> 选项的组件（如 <code>AudioSource</code>, <code>VideoPlayer</code>），<code>LocalizedAsset</code> 会正确拦截自动播放，交换资源，然后开始播放，以避免播放未本地化的内容。",
  "p_localizedasset_updated": "该组件现在支持异步加载。请注意，如果资源是从云/磁盘 (Addressables) 加载的，更改语言时可能会有轻微延迟。",
  "p_localizedbehaviour_1": "一个实用组件，允许您的脚本对语言变化做出反应。它会自动查找并调用用 <code>[OnLanguageChange]</code> 属性标记的方法。",
  "p_localizeddropdown_1": "添加到 <code>Dropdown</code> 和 <code>TMP_Dropdown</code> 以翻译其选项。",
  "p_localizedprefab_1": "用于本地化整个预制件的组件。它以非破坏性方式工作：它不会修改原始预制件，而是创建本地化版本的实例作为子对象，并禁用原始对象上的所有脚本 (<code>MonoBehaviour</code>)、渲染器 (<code>Renderer</code>) 和碰撞器 (<code>Collider</code>)。这可以防止双重逻辑执行和视觉伪影。为了正确的运行时操作，其执行顺序设置为 -100 (<code>[DefaultExecutionOrder(-100)]</code>)，以确保它在其他脚本之前运行。",
  "p_localizedtext_1": "用于显示翻译文本的主要组件。它被放置在带有 <code>Text</code>、<code>TMP_Text</code> 和 <code>TextMesh</code> 的对象上。",
  "p_migration_custom": "您可以创建自己的迁移配置文件，以支持自定义系统或特定的项目设置。每个配置文件都包含一个<strong>规则</strong>列表，用于定义组件及其字段应如何转换。规则按其<strong>优先级</strong>的顺序进行检查。",
  "p_migration_custom_advanced": "迁移配置文件提供了高级设置，用于微调导入和检测过程：",
  "p_migration_google_sheet": "您可以直接从 Google Sheet URL 导入，无需下载文件。",
  "p_migration_import_csv": "该工具支持标准 CSV 文件（逗号分隔）。首行必须为标题行。",
  "p_migration_stubs": "迁移时的常见问题是删除旧插件（例如 I2）会导致构建中断，阻止 Unity 编译迁移工具本身。",
  "p_migration_tool_access": "通过 <strong>Tools -> Anko Localization Tool -> Migration Tool</strong> 访问。",
  "p_migration_tool_desc": "用于从其他本地化系统（I2 Localization、Unity Localization）过渡的工具。",
  "p_preview_1": "在标题正下方是 <strong>Preview Language</strong> 下拉列表。这个强大的功能允许您在不运行游戏的情况下，直接在 <strong>Scene</strong> 窗口或 <strong>Prefab Mode</strong> 中查看本地化在任何语言中的外观。",
  "p_preview_overlay": "为了更快的迭代，您可以使用专用的 <strong>Localization Preview Overlay</strong> 直接在 Scene View 中切换语言。",
  "p_report_1": "每次解析后，此报告都会显示您的本地化状态的全貌。",
  "p_safety_caps": "为防止意外产生高费用或大量流量检查：",
  "p_script_parsing_rules_description": "该工具可以配置为识别自定义函数甚至竞争对手系统（如 I2 Localization）中使用的本地化键，而无需修改您现有的代码。这是通过定义扫描器用于从脚本中提取键的正则表达式模式来实现的。",
  "p_script_parsing_rules_usage": "在<strong>内容</strong>选项卡下的<strong>脚本解析规则</strong>中，您可以添加与您的特定函数调用匹配的规则。例如，要支持 <code>I2.Loc.Get(\"key\")</code>，您可以添加一个带有模式的规则，该模式捕获括号内的字符串。",
  "p_settings_1": "您的控制中心。在这里，您定义整个本地化过程的全局规则。",
  "p_tms_intro": "该工具现在支持与流行的翻译管理系统同步。您可以直接在 Unity 中推送源键并拉取翻译。",
  "p_tms_setup": "1. 前往 <strong>Actions -> External Services</strong>。<br>2. 选择您的服务提供商。<br>3. 输入 API 密钥和项目 ID。<br>4. 在 设置 窗口中使用 <strong>Push</strong>（上传密钥）和 <strong>Pull</strong>（下载翻译）按钮。",
  "p_tutorials_1": "教程选项卡提供了交互式分步指南，可帮助您直接在 Unity Editor 中掌握该工具的功能。",
  "p_uitklocalization_1": "添加到具有<code>UIDocument</code>的对象。支持任何元素的<strong>标签、按钮、HelpBox、Foldout、进度条（标题）、文本字段（标签和占位符）、下拉字段（标签和选项）、单选按钮、单选按钮组、切换按钮组（Unity 2023+）和工具提示</strong>的本地化。如果在UI Builder中设置了ID，则标识符在重命名后保持稳定。",
  "p_window_footer": "显示当前状态、后台操作进度和工具版本。",
  "p_window_header": "顶部栏提供对预览控件和实用工具的全局访问，这些工具无论选择哪个选项卡都将持续存在。",
  "p_window_sidebar": "侧边栏处理不同功能选项卡之间的导航和全局搜索工具。",
  "page_title": "Unity 本地化工具文档",
  "q_faq_addressables_1": "我启用了 Addressables 模式，但资源未加载。我应该检查什么？",
  "q_faq_addressables_2": "如何添加对 DeepL/Google 的支持？",
  "q_faq_addressables_3": "迁移器在删除 I2/UnityLoc 后显示编译错误。如何修复？",
  "q_faq_audio_smart_update": "该工具如何在重新生成音频文件时节省 API 积分？",
  "q_faq_components_1": "LocalizedPrefab 组件会禁用原始对象上的 MonoBehaviours。如果原始对象有脚本在 Awake() 中创建其他对象或订阅事件，该怎么办？",
  "q_faq_components_2": "如果原始预制件 (LocalizedPrefab) 具有 Rigidbody 或其他物理组件，它会被禁用吗？如果本地化预制件没有它，这会影响物理吗？",
  "q_faq_components_3": "LocalizedAsset 组件将目标组件名称存储为字符串 (_targetComponentTypeName)。如果我重命名自定义组件脚本或将其移动到另一个程序集（Assembly Definition），LocalizedAsset 会停止工作吗？",
  "q_faq_components_4": "如果同一个 GameObject 上有两个 Image 组件，LocalizedAsset 如何知道要本地化哪一个？它会同时作用于两者还是只作用于它找到的第一个？",
  "q_faq_components_5": "文档指出 LocalizedPrefab 的执行顺序为 -100。如果我有一个执行顺序为 -110 的脚本，它尝试在其 Awake() 中查找由 LocalizedPrefab 创建的子对象，LocalizedPrefab 会及时实例化其实例吗？",
  "q_faq_components_6": "LocalizedText 组件有一个 isStyleOnly 选项。如果我启用它，然后在代码中调用 myLocalizedText.SetFormattedText(\"new_key\")，文本会更改，还是只有样式（字体/RTL）会更改？",
  "q_faq_components_7": "LocalizedBehaviour 自动查找带有 [OnLanguageChange] 属性的方法。它会找到私有和受保护的方法，还是它们必须是公共的？",
  "q_faq_components_8": "LocalizedAsset 组件会拦截 Play on Awake。如果同一对象上的另一个脚本尝试在 LocalizedAsset 交换资源之前在其 Awake() 或 Start() 中访问资源（例如，audioSource.clip.length），会发生什么？是否可能出现 NullReferenceException 或使用旧资源？",
  "q_faq_custom_keys_attribute": "我可以使用自己的属性代替 [LocalizableField] 来作为键吗？",
  "q_faq_custom_provider_1": "为什么我的自定义提供程序未出现在 Settings 下拉列表中？",
  "q_faq_editor_1": "对于占位符验证，注释中的 @placeholders: 指令与源语言文本中找到的占位符，哪个具有更高的优先级？例如，如果源文本有 {name} 而注释说 @placeholders: {username}。",
  "q_faq_editor_2": "如果我在指令中打错了字（例如，@placeholder: 而不是 @placeholders:），它会被忽略还是工具会发出警告？",
  "q_faq_editor_3": "自动保存系统在 Backups/AutoSaves 文件夹中创建文件。在成功手动保存或关闭窗口后，这些文件会自动删除吗？",
  "q_faq_editor_4": "如果我更改编辑器中的列宽，这些设置会在 Unity 会话之间保存吗？",
  "q_faq_editor_5": "文本编辑弹出窗口 (MultiLineEditWindow) 是否支持其自己的撤销/重做堆栈（通过 Ctrl+Z）以进行其中所做的更改？",
  "q_faq_examples_1": "如果传递给 _() 函数的匿名类型中的属性名称与字符串中的占位符不匹配，会发生什么？例如，_(\"Hello, {username}\", new { user_name = \"Bob\" })。会出现错误，还是占位符根本不会被替换？",
  "q_faq_examples_2": "[LocalizableField] 属性适用于私有字段。它适用于静态字段吗？",
  "q_faq_examples_3": "如果我将 [OnLanguageChange] 属性放在带有参数的方法上（例如，void UpdateUI(string newLang)），会发生什么？会出现编译错误还是运行时警告？",
  "q_faq_examples_4": "我正在使用 _(\"apple_count\", count)。如果当前语言没有键 apple_count_one（对于 count = 1），系统将选择哪种形式？它会使用 apple_count_other 作为回退吗？",
  "q_faq_examples_5": "函数 _(\"key\", new { username = \"Alex\" }) 使用匿名类型。与传递预先创建的 Dictionary<string, object> 相比，这会在 Update() 方法中频繁调用时给垃圾收集器 (GC) 带来过多的“负载”吗？",
  "q_faq_examples_6": "我用 [OnLanguageChange] 标记的方法没有被调用。为什么？",
  "q_faq_extending_1": "我的自定义解析器会在每次 Update Keys 后自动调用吗？我需要注册它吗，还是只需要在项目中使用实现 ITextComponentParser 的类就足够了？",
  "q_faq_extending_2": "如果我的自定义解析器中发生异常，它会中断整个解析过程，还是工具会安全地继续使用其他解析器？",
  "q_faq_installation_1": "如果我的项目已经有来自另一个资源的 com.unity.nuget.newtonsoft-json 包，会发生什么？依赖项安装程序会尝试更新还是忽略它？",
  "q_faq_installation_2": "我不小心点击了“Skip for Now”（暂时跳过）并勾选了“Don't ask again”（不再询问）可选依赖项（例如，用于 CSV 支持）。如何再次调出安装程序窗口来安装它们？",
  "q_faq_installation_3": "该工具没有在 Assets/Resources 中创建 LocalizationSettings.asset。为什么会发生这种情况，我可以通过 Assets -> Create 菜单手动创建它吗？",
  "q_faq_installation_4": "我可以将 LocalizationSettings.asset 文件移动到另一个 Resources 文件夹，例如 Assets/MyGame/Resources 吗？工具还能找到它吗？",
  "q_faq_installation_5": "依赖项安装程序冻结或出现错误。我可以通过 Unity Package Manager 手动安装依赖项（Newtonsoft Json、Editor Coroutines）吗？",
  "q_faq_notes_1": "文档建议将 LanguageSelector 添加到忽略列表中。如果我忘记这样做，具体会出什么问题？会为“Option A, Option B”创建额外的键吗？",
  "q_faq_notes_2": "如果我忘记在 LanguageSelector 使用的 TMP_Dropdown 内部的 Label 上添加一个启用了 isStyleOnly 复选框的空 LocalizedText，字体会不改变吗？为什么这是必要的？",
  "q_faq_notes_3": "不建议在 Update() 方法中调用 _()。但是如果我需要每帧更新文本（例如，计时器）呢？最有效的做法是什么，只缓存格式字符串？",
  "q_faq_tts_voices": "如何将特定的声音分配给角色？",
  "q_faq_window_actions_1": "如果在批量自动翻译过程中互联网连接丢失，会发生什么？工具会根据重试策略重试失败的批次，还是整个过程会完全中断？",
  "q_faq_window_actions_2": "如果我导入一个 CSV 文件，其中包含项目中已存在的键，但某些语言的值为空，这些空值会替换我现有的翻译还是被忽略？",
  "q_faq_window_actions_3": "“Danger Zone”部分允许删除所有组件。它会从 Content 标签页上的 Prefab Folders 中未指定的文件夹中的预制件中删除组件吗？",
  "q_faq_window_actions_4": "从 Google Sheets 导入时，我应该如何格式化注释列，以便使用 @placeholders: 指令进行占位符验证？",
  "q_faq_window_actions_5": "该工具可以从单个 Google Sheets 文档的多个工作表导入数据吗，还是只适用于每个 GID 一个工作表？",
  "q_faq_window_assets_1": "如果我在同一个扫描文件夹中有两个具有相同键但类型不同的资源（例如，sound_effect_en.mp3 和 sound_effect_en.wav），哪个会最终出现在资源表中？",
  "q_faq_window_assets_2": "如果我点击 Scan Assets & Analyze Project，并且场景中有一个 Image 对象，该对象已经存在一个本地化的精灵，但 Image 对象本身还没有 LocalizedAsset 组件，工具会添加组件并自动插入键吗？",
  "q_faq_window_assets_3": "如果不同的资源类别有不同的 Scan Folders，我可以使用相同的 Naming Rule 吗？这会导致冲突吗？",
  "q_faq_window_assets_4": "如果一个可本地化资源（例如，button_ok_en.png）不在 Scan Folder 的根目录中，而是在一个子文件夹中，扫描器会找到它吗？",
  "q_faq_window_content_1": "如果我向 Scenes to Parse 添加一个未包含在 Build Settings 中的场景，除了解析过程本身之外，这会影响其他任何事情吗？",
  "q_faq_window_content_2": "我将一个对象添加到 Ignore Specific Objects（临时列表）中。如果我用这个对象制作一个预制件，这个预制件的实例也会被忽略吗？",
  "q_faq_window_content_3": "如果我将 TMPro.TMP_Text 组件添加到 Parsing Ignores -> Ignore Component Types 中，但场景中有一个 LocalizedText 已经引用了这个 TMP_Text 的对象，下次 Update Keys 时会发生什么？键会被删除吗？",
  "q_faq_window_content_4": "文档说“Pin”（固定）会保存对象的完整路径，并且如果它被重命名就会中断。如果我从对象创建一个预制件，然后重命名原始对象， “Pin”还会对预制件实例起作用吗？",
  "q_faq_window_content_5": "如果我对预制件实例内的子对象使用“Pin”，会保存哪个路径：相对于预制件根目录还是场景根目录？它会在其他场景中工作吗？",
  "q_faq_window_preview_1": "我在 Prefab Mode 中打开了一个预制件，应用了 In-Editor Preview，然后按下了 Ctrl+S。临时预览数据会保存到预制件资源中吗？LocalizationPreviewProtector 如何处理这种情况？",
  "q_faq_window_preview_2": "如果我启用 In-Editor Preview 并且 Unity 编辑器崩溃，并且 Temp/localization_preview_recovery.json 文件损坏（例如，为空或无效 JSON），下次启动时会发生什么？",
  "q_faq_window_preview_3": "在 LocalizedPrefab 的 In-Editor Preview 模式下，会创建一个临时实例。此实例上的 Awake() 和 Start() 方法会执行吗？如果它们不是设计为在 Edit Mode 下运行，这会导致错误吗？",
  "q_faq_window_report_1": "“Find”（查找）按钮是异步搜索对象的。如果我开始搜索，然后立即点击 Update Keys，搜索会被中断吗？",
  "q_faq_window_report_2": "如果一个键在多个地方使用（例如，在不同场景的两个不同按钮上），这将在报告的“Duplicates”（重复项）类别下如何显示？",
  "q_faq_window_report_3": "如果我点击“Find”查找仅在代码中使用的键（通过 _() 函数），会发生什么？工具能否找到并突出显示 C# 脚本？",
  "q_faq_window_settings_1": "我可以在项目中期将 Key Generation Mode 从 UseTextAsKey 更改为 AutoGenerateKeysOnly 吗？我的现有翻译会发生什么？它们会被映射到新键吗？",
  "q_faq_window_settings_2": "如果我向 Supported Languages 列表添加一种没有复数规则的代码（例如，哈萨克语的“kz”），默认将使用哪个规则？",
  "q_faq_window_settings_3": "如果我将 Translations Path 指定不在 StreamingAssets 中，而是在一个常规文件夹中，例如 Assets/MyTranslations，json 文件会包含在游戏构建中吗？",
  "q_faq_window_settings_4": "自动翻译 API 密钥存储在 EditorPrefs 中。如果我在两台不同的计算机上处理项目，我需要在每台计算机上单独输入密钥吗？",
  "tip_best_practice": "<strong>专业提示：</strong> 如果需要本地化属性，请创建一个带有 <code>[LocalizableField]</code> 的支持字段，并单独暴露该属性。",
  "toc_search_placeholder": "搜索文档...",
  "toc_title": "目录",
  "toggle_notes_title": "切换注释",
  "warning_box_components": "<strong>重要提示：</strong>下面描述的所有组件都会在解析过程中（当您点击 <code>Update Keys</code> 按钮时）自动添加到游戏对象。您无需手动添加它们。",
  "warning_tms_overwrite": "<strong>Warning:</strong> 从 TMS 拉取将覆盖匹配键的本地翻译。确保您的 TMS 是唯一的真实来源。"
}