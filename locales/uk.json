{
  "a_faq_addressables_1": "Переконайтеся, що пакет Addressables встановлено, налаштування створено, і ви натиснули «Scan Assets & Generate Tables», щоб зареєструвати ключі у групах.",
  "a_faq_addressables_2": "Створіть <code>Translation Profile</code> у папці активів, оберіть тип сервісу, введіть API-ключ та призначте цей профіль у вікні <code>Settings</code>.",
  "a_faq_addressables_3": "У вікні міграції (вкладки Components / Import) є кнопка «Enable Stubs», яка активує функцію Emergency Stubs. Вона створює фіктивні класи-заглушки для I2 Localization або Unity Localization, щоб ваш проєкт міг скомпілюватися одразу після видалення цих плагінів. Функція працює шляхом перемикання символу визначення ANKO_ENABLE_MIGRATION_STUBS. Це запобігає помилкам «The type name 'Localize' could not be found» і дає вам час для належного рефакторингу коду для використання нової системи. Enable Stubs дозволяє виправляти помилки компіляції після видалення старого плагіна локалізації. У версії 2.0 система міграції була розширена за допомогою <strong>профілів міграції</strong> (Migration Profiles), що дозволяє використовувати більш надійні правила переходу від інших плагінів.",
  "a_faq_audio_smart_update": "Інструмент використовує розумне пакетування з хешуванням MD5 для регенерації аудіофайлів лише тоді, коли вихідний текст змінився. Він обчислює хеш MD5 вашого текстового вмісту та порівнює його з раніше згенерованими аудіофайлами. Якщо текст не змінився, він пропускає регенерацію, заощаджуючи ваші API-кредити. Це запобігає зайвим викликам API та знижує витрати при регенерації аудіо. Інструмент хешує ваш текст та регенерує аудіофайли лише в тому випадку, якщо вихідний текст змінився, заощаджуючи ваші API-кредити.",
  "a_faq_components_1": "Ні, не буде. Вимкнення MonoBehaviour запобігає виклику всіх «магічних» методів Unity, включно з Awake(), OnEnable() та Start(). Це зроблено навмисно, щоб уникнути дублювання виконання логіки. Уся ініціалізація повинна відбуватися у скриптах на локалізованих версіях префаба.",
  "a_faq_components_2": "Так, фізична поведінка оригінального об'єкта буде нейтралізована. Компонент LocalizedPrefab знаходить усі компоненти Rigidbody та Rigidbody2D на своєму GameObject та встановлює їхню властивість isKinematic на true. Це фактично виводить їх із динамічних фізичних розрахунків, запобігаючи небажаній поведінці, як-от падіння невидимого об'єкта або його реакція на зіткнення. Як і раніше, рекомендується, щоб локалізована версія префаба містила всі необхідні фізичні компоненти для коректної поведінки.",
  "a_faq_components_3": "Так, це станеться. Компонент зберігає повну назву типу, включаючи простір імен та збірку. Перейменування скрипту або переміщення його в інший .asmdef змінить цю назву, і LocalizedAsset не зможе знайти цільовий компонент. Вам потрібно запустити ще один аналіз через Analyze Project & Attach Components, щоб оновити назву.",
  "a_faq_components_4": "LocalizedAsset створюється для конкретного екземпляра компонента. Він зберігає посилання на цей компонент у коді. Якщо ви вручну додасте другий LocalizedAsset і використаєте контекстне меню «Analyze for Localization», щоб націлити його на другий Image, у вас буде два компоненти LocalizedAsset, кожен з яких керуватиме своїм Image. Автоматичний аналізатор створить компонент лише для першого Image з локалізованим активом, який він знайде.",
  "a_faq_components_5": "Так, встигне. LocalizedPrefab створює екземпляр локалізованого префаба у своєму методі OnEnable(). Порядок виконання Unity гарантує, що всі методи Awake() виконуються перед усіма методами OnEnable(). Таким чином, ваш скрипт з порядком -110 виконає свій Awake(), потім LocalizedPrefab з порядком -100 виконає свій Awake(), і лише після цього будуть викликані їхні методи OnEnable() по черзі. Ваш скрипт не знайде об'єкт, оскільки він ще не буде створений.",
  "a_faq_components_6": "Зміниться і ключ, і текст. Програмний виклик SetFormattedText перевизначає поведінку isStyleOnly для цього конкретного оновлення. Опція isStyleOnly призначена для того, щоб компонент не реагував на глобальну зміну мови, але на пряму зміну ключа через код він завжди реагуватиме.",
  "a_faq_components_7": "Він знайде методи з будь-яким модифікатором доступу (public, private, protected, internal). Рефлексія в Unity дозволяє виявляти всі методи екземпляра незалежно від їхнього рівня доступу.",
  "a_faq_components_8": "Можливе використання старого (нелокалізованого) активу. LocalizedAsset виконує заміну у своєму OnEnable(). Методи Awake() усіх скриптів виконуються перед OnEnable(). Якщо ваш скрипт звертається до audioSource.clip у Awake(), він отримає оригінальний кліп. Якщо він звертається до нього у Start(), результат залежатиме від порядку виконання скриптів. Щоб гарантувати доступ до локалізованого активу, або встановіть пізніший порядок виконання для вашого скрипта, або звертайтеся до активу в методі, позначеному [OnLanguageChange].",
  "a_faq_custom_keys_attribute": "Так. На вкладці <strong>Content Tab</strong> у розділі 'Attributes to Scan' ви можете додати будь-яке ім'я атрибута (наприклад, <code>[Header]</code>, <code>[TermsPopup]</code>). Парсер вважатиме будь-яке строкове поле з цим атрибутом локалізованим.",
  "a_faq_custom_provider_1": "Переконайтеся, що ваш клас реалізує <code>IAssetProvider</code>, НЕ є абстрактним і позначений атрибутом <code>[AssetProviderPlugin]</code>. Також перевірте консоль на наявність будь-яких помилок, пов'язаних з рефлексією під час запуску, оскільки інструмент сканує всі збірки на наявність провайдерів.",
  "a_faq_editor_1": "Директива @placeholders: у коментарі має пріоритет. Вона вважається явною інструкцією від розробника та «джерелом істини». У вашому прикладі редактор вимагатиме {username} у перекладі та ігноруватиме {name} з вихідного тексту.",
  "a_faq_editor_2": "Вона буде просто проігнорована. Інструмент шукає точну відповідність @placeholders:. Якщо директива написана з помилкою, вона буде розглядатися як частина звичайного коментаря, а валідація працюватиме по-старому – на основі заповнювачів з вихідного тексту.",
  "a_faq_editor_3": "Так. Після успішного ручного збереження або нормального закриття вікна (коли ви зберігаєте зміни) усі файли автозбереження видаляються, щоб уникнути запиту на відновлення при наступному запуску. Вони залишаються лише у випадку збою редактора.",
  "a_faq_editor_4": "Так. Ширина стовпців зберігається у EditorPrefs кожного разу, коли ви закриваєте вікно редактора перекладів, і буде відновлена при наступному його відкритті.",
  "a_faq_editor_5": "Так. MultiLineEditWindow має свій власний тимчасовий стек Undo/Redo, який працює, поки вікно відкрите. Це дозволяє скасовувати та повторювати зміни тексту в межах цього вікна. Після того, як ви збережете результат (закривши вікно), ця зміна записується як єдина дія у глобальний стек Undo/Redo основного редактора.",
  "a_faq_examples_1": "Помилки не буде. Заповнювач {username} просто не буде замінений, і ви отримаєте рядок \"Hello, {username}\" у результаті. Заміна відбувається лише при точному збігу імен.",
  "a_faq_examples_2": "Так, буде. Парсер використовує рефлексію для пошуку полів з прапорцями BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, тому він знайде та обробить статичні поля.",
  "a_faq_examples_3": "Помилки компіляції не буде, але в консолі Unity з'явиться попередження від LocalizedBehaviour. Воно повідомить, що знайшло метод з атрибутом, але проігнорувало його, оскільки метод має параметри. Такий метод не буде викликаний.",
  "a_faq_examples_4": "Так. Якщо конкретна форма (_one, _few тощо) не знайдена, система спробує використати ключ із суфіксом _other як резервний варіант. Якщо й він не знайдений, буде використано переклад для базового ключа apple_count.",
  "a_faq_examples_5": "Так, створить. Кожен виклик new { ... } виділяє пам'ять у керованій купі, що створює додаткову роботу для збирача сміття. Для тексту, який оновлюється щокадру (в Update або LateUpdate), значно продуктивніше створити Dictionary<string, object> один раз у Start(), а в Update() лише оновлювати його значення перед передачею функції _().",
  "a_faq_examples_6": "Перевірте, чи має ваш метод параметри. Атрибут <code>[OnLanguageChange]</code> працює лише на методах <strong>без параметрів</strong> (наприклад, <code>void UpdateUI()</code>). Якщо ваш метод вимагає аргументів, обгорніть його у метод без параметрів.",
  "a_faq_extending_1": "Достатньо просто мати клас. Коли запускається TextParser, він використовує рефлексію, щоб знайти всі класи у проєкті, які реалізують інтерфейс ITextComponentParser, і автоматично викликає їхній метод Parse() для кожного GameObject. Жодної ручної реєстрації не потрібно.",
  "a_faq_extending_2": "Виняток у вашому власному парсері перерве процес. Основний цикл парсингу не обгортає виклики до власних парсерів у блок try-catch. Якщо ваш метод Parse() викидає необроблений виняток,",
  "a_faq_installation_1": "Інсталятор перевіряє існування типу Newtonsoft.Json.JsonConvert. Якщо тип існує, він вважає залежність задоволеною і не намагатиметься встановити або оновити пакет. Це робиться для запобігання конфліктам версій.",
  "a_faq_installation_2": "Ви можете вручну запустити перевірку залежностей у будь-який час через меню Tools -> Localization -> Check Dependencies. Це скине прапорець «Don't ask again» та знову покаже вікно з усіма відсутніми необов'язковими пакетами.",
  "a_faq_installation_3": "Це може статися, якщо у вас немає папки Assets/Resources. Інструмент спробує її створити, але права доступу до файлової системи можуть цьому запобігти. Так, ви можете створити актив вручну: правий клік у папці Resources, оберіть Create -> Localization -> Settings. Інструмент знайде його автоматично.",
  "a_faq_installation_4": "Так. Інструмент використовує Resources.Load(), який шукає актив за іменем у всіх папках з назвою Resources у вашому проєкті. Важливо, щоб файл зберіг свою назву LocalizationSettings.asset.",
  "a_faq_installation_5": "Так. Ви можете відкрити Window -> Package Manager, натиснути іконку «+» та вибрати «Add package by name...». Введіть назви пакетів: com.unity.nuget.newtonsoft-json та com.unity.editorcoroutines.",
  "a_faq_notes_1": "Так. Якщо ви не додасте LanguageSelector до списку ігнорування, парсер розглядатиме його TMP_Dropdown як звичайний випадаючий список. Він знайде стандартні «Option A, Option B, Option C», які створює Unity, і додасть ключі для них до ваших файлів перекладів. Це засмітить ваші файли зайвими ключами, оскільки LanguageSelector все одно видалить ці опції під час рантайму та створить свої.",
  "a_faq_notes_2": "Так, шрифт не зміниться. Це необхідно, оскільки LanguageSelector безпосередньо змінює властивість label.text. Без LocalizedText на цьому об'єкті система локалізації не знає, що до цього елемента потрібно застосовувати стилі (шрифт, RTL) при зміні мови. Порожній LocalizedText з isStyleOnly слугує «маркером» для системи, кажучи: «Слідкуй за цим об'єктом та застосовуй до нього стилі, але не чіпай його текст».",
  "a_faq_notes_3": "Найбільш продуктивний підхід — це кешувати рядок формату в Start() або в методі [OnLanguageChange] та використовувати звичайний string.Format у Update(). Приклад: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Це дозволяє уникнути пошуку ключа у словнику щокадру, що значно швидше.",
  "a_faq_runtime_api_key_distinction": "<strong>Питання: Яка різниця між 'Translation Service Keys' та 'Runtime API Key'?</strong><br>Відповідь: <strong>Ключі сервісів перекладу</strong> (Translation Service Keys) (OpenAI, DeepL) використовуються в <strong>редакторі Unity</strong> для генерації перекладів. Вони зберігаються в реєстрі вашого комп'ютера (EditorPrefs) і НЕ включаються в білд.<br><strong>Ключ API для виконання</strong> (Runtime API Key) використовується <strong>ігровим білдом</strong> для отримання Live Updates. Він включається в білд (зашифрований).",
  "a_faq_tts_voices": "У вашому <strong>Translation Profile</strong> (Інспектор) використовуйте список 'Voice Mappings' (Мапування Голосів). Ви можете мапувати шаблон Regex (наприклад, <code>^hero_.*</code>) до певного Voice ID. Генератор автоматично обере правильний голос на основі імені ключа.",
  "a_faq_window_actions_1": "Інструмент спробує повторно надіслати саме той пакет, який не вдався, відповідно до налаштувань Retry Policy (кількість спроб та затримка). Якщо всі спроби для цього пакета не вдаряться, процес перекладу для поточної мови буде перервано, і до консолі буде записана помилка. Переклад для наступних мов у черзі не розпочнеться.",
  "a_faq_window_actions_2": "Порожні значення замінять існуючі переклади. Процес імпорту вважає CSV-файл «джерелом істини». Якщо значення для ключа welcome_message у стовпці ru порожнє, поточний російський переклад для цього ключа буде перезаписано.",
  "a_faq_window_actions_3": "Так, видалить. Функції в «Danger Zone» сканують усі префаби у проєкті (AssetDatabase.FindAssets(\"t:Prefab\")), а не лише ті, що вказані у списку парсингу, щоб забезпечити максимально повне очищення.",
  "a_faq_window_actions_4": "У вашому документі Google Sheets стовпець повинен мати назву «Developer Notes». У комірках цього стовпця ви можете писати коментарі як зазвичай. Щоб вказати заповнювачі, просто додайте рядок, як-от @placeholders: {username}, {score}, у тексті коментаря. Інструмент автоматично розпізнає цю директиву при імпорті.",
  "a_faq_window_actions_5": "Інструмент працює лише з одним аркушем одночасно. URL-адреса імпорту включає параметр gid=..., який унікально ідентифікує конкретний аркуш у документі. Щоб імпортувати дані з іншого аркуша, вам потрібно скопіювати його URL (з іншим gid) та виконати імпорт знову.",
  "a_faq_window_assets_1": "Сканер активів завантажує їх, вказуючи очікуваний тип (AssetDatabase.LoadAssetAtPath(path, expectedType)). Для категорії AudioClip він шукатиме та завантажуватиме лише файли, які Unity розпізнає як AudioClips. Якщо обидва файли є дійсними аудіо-кліпами, до таблиці буде включено той, що буде оброблений останнім, фактично перезаписавши попередній. Рекомендовано уникати таких дублікатів.",
  "a_faq_window_assets_2": "Так, саме так це працює. «Analyze Project» знаходить компонент Image, дивиться на ім'я призначеного йому спрайта (наприклад, icon_play_en), витягує з нього ключ (icon_play) та мову (en), а потім додає компонент LocalizedAsset до цього GameObject і записує в нього ключ icon_play.",
  "a_faq_window_assets_3": "Так, можете. Конфліктів не буде, оскільки для кожної категорії створюється окрема таблиця активів (LocalizedAssetTable). Ключі з категорії «Sprites» не перетинаються з ключами з категорії «AudioClips», навіть якщо вони названі однаково.",
  "a_faq_window_assets_4": "Так, знайде. Сканер використовує опцію SearchOption.AllDirectories, що означає, що він рекурсивно перевірятиме всі підпапки у межах вказаної вами Scan Folder.",
  "a_faq_window_content_1": "Ні, не вплине. Список Scenes to Parse використовується виключно для того, щоб інструмент знав, які сцени відкривати та аналізувати на наявність тексту. Він жодним чином не пов'язаний зі сценами, які потраплять до фінальної збірки вашої гри.",
  "a_faq_window_content_2": "Ні, не буде. Тимчасовий список зберігає пряме посилання на об'єкт у сцені. Коли ви створюєте префаб, це новий актив. Його екземпляри є іншими об'єктами, і правило ігнорування на них не поширюватиметься. Щоб назавжди ігнорувати префаби, їх потрібно додати до списку ігнорування як актив префаба.",
  "a_faq_window_content_3": "Так, буде. Коли ви натискаєте Update Keys, парсер повторно сканує весь проєкт. Він побачить, що тип TMPro.TMP_Text має бути проігнорований, і не згенерує для нього ключ. У процесі порівняння старих і нових ключів він визначить, що старий ключ більше не використовується, і позначить його як «Removed» (Видалений).",
  "a_faq_window_content_4": "Ні, не продовжить. «Pin» зберігає абсолютний шлях в ієрархії сцени в момент натискання кнопки (наприклад, Canvas/Panel/Button). Цей шлях не пов'язаний з логікою префабів. Екземпляри префаба матимуть той самий шлях, але якщо ви перейменуєте батьківський об'єкт у сцені, «Pin» перестане працювати як для оригіналу, так і для екземплярів.",
  "a_faq_window_content_5": "Буде збережено повний шлях від кореня сцени. Наприклад, MyPrefab(Clone)/Content/Icon. Цей «закріплений» шлях працюватиме лише у сцені, де ви його створили. В інших сценах такий шлях навряд чи буде знайдено.",
  "a_faq_window_preview_1": "Ні, його не буде збережено. PreviewSafetyBridge перехоплює подію збереження ресурсу (OnWillSaveAssets) і автоматично викликає RevertEditorPreview() до того, як Unity запише зміни на диск. Таким чином, prefab буде збережено у своєму початковому, нелокалізованому стані.",
  "a_faq_window_preview_2": "PreviewRecoveryService обробляє відновлення після збоїв. Якщо Unity виходить з ладу, служба виявляє файл резервної копії під час наступного запуску та намагається відновити стан сцени. Якщо автоматичне відновлення не вдається, можливо, вам доведеться вручну вибрати «Revert to Original» у вікні інструментів.",
  "a_faq_window_preview_3": "Так, будуть. PrefabUtility.InstantiatePrefab у Edit Mode викликає Awake() та OnEnable(). Якщо ці методи містять логіку, яка не повинна запускатися в редакторі (наприклад, звернення до синглтонів, які існують лише в Play Mode), це може спричинити помилки. Рекомендовано використовувати if (Application.isPlaying) або #if UNITY_EDITOR, щоб захистити такий код.",
  "a_faq_window_report_1": "Так, буде перервано. Будь-яка нова дія, що вимагає блокування UI (як-от Update Keys), зупинить поточну корутину пошуку. З'явиться діалогове вікно, яке запропонує вам зупинити поточний пошук, щоб розпочати новий.",
  "a_faq_window_report_2": "Категорія «Duplicates» покаже всі джерела для цього ключа. Ви побачите один запис для ключа, а поле «Source» (Джерело) міститиме список усіх шляхів (у сцені 1 та сцені 2). Кнопка «Find» у цьому випадку відкриє випадаючий список, дозволяючи вам вибрати, до якого об'єкта перейти.",
  "a_faq_window_report_3": "Так. Система пошуку спеціально навчена розпізнавати джерела, як-от скрипт MyScript.cs. Коли ви натиснете «Find», він шукатиме актив MyScript.cs у проєкті та підсвітить (ping) його у вікні Project.",
  "a_faq_window_settings_1": "Так, будуть. При зміні режиму інструмент виконує «безпечну міграцію»: він повторно парсить увесь проєкт, створює нові ключі відповідно до нових правил, але зіставляє старі та нові ключі через оригінальний текст. Потім він переносить усі ваші існуючі переклади та коментарі зі старих ключів на нові. Ваші переклади не будуть втрачені.",
  "a_faq_window_settings_2": "Використовуватиметься DefaultPluralRule, яке підходить для англійської та більшості європейських мов (форми для «one» та «other»).",
  "a_faq_window_settings_3": "Ні, не будуть. Лише активи, розташовані у папці StreamingAssets або Resources, гарантовано включаються до збірки. Якщо ви вкажете інший шлях, локалізація працюватиме в редакторі, але не працюватиме у скомпільованій грі, оскільки файли перекладів не будуть частиною збірки.",
  "a_faq_window_settings_4": "Так. EditorPrefs — це локальне сховище для кожного комп’ютера. Вам потрібно буде ввести <strong>ключ API сервісу перекладу</strong> (Translation Service API Key) (для використання в редакторі, наприклад OpenAI/DeepL) на кожній машині. Однак <strong>ключ API під час виконання</strong> (Runtime API Key) (використовується в збірках) зберігається в налаштуваннях проєкту та поширюється через систему контролю версій (зашифрований).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "Скопійовано!",
  "copy_code_copy": "Копіювати",
  "copy_code_error": "Помилка",
  "error_loading_message": "Будь ласка, перевірте ваше з'єднання та оновіть сторінку.",
  "error_loading_title": "Помилка Завантаження",
  "h1_ai_audio": "ШІ Аудіо / Текст-у-Мовлення",
  "h1_ai_profiles": "Профілі ШІ та перекладу",
  "h1_api_snippets": "API та фрагменти коду",
  "h1_components": "Основні Компоненти (призначаються автоматично)",
  "h1_extending": "Розширення Функціоналу",
  "h1_faq": "Поширені Запитання та Вирішення Проблем",
  "h1_font_glyph_manager": "Менеджер Шрифтів та Гліфів",
  "h1_important_notes": "Важливі Примітки та Застереження",
  "h1_introduction": "Вступ",
  "h1_loc_tool_window": "Вікно «Localization Tool»",
  "h1_migration_tool": "Інструмент Міграції",
  "h1_quick_start": "Швидкий Старт та Налаштування",
  "h1_tms": "Інтеграція зовнішніх TMS (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Редактор Таблиці Перекладів",
  "h1_usage_examples": "Приклади Використання",
  "h2_ai_assistant": "Команди AI Assistant",
  "h2_ai_audio_setup": "Налаштування",
  "h2_ai_audio_usage": "Використання",
  "h2_ai_context": "Контекст та глосарій",
  "h2_ai_profiles_overview": "Профілі перекладу",
  "h2_async_api": "Асинхронний API (Addressables)",
  "h2_backup_manager": "Менеджер резервного копіювання",
  "h2_bridge_generation": "Генерувати C# мости (строго типізований доступ)",
  "h2_custom_ai": "Користувацькі AI та моделі",
  "h2_custom_asset_provider": "Створення користувацького постачальника ресурсів",
  "h2_custom_attributes": "Сканування користувацьких атрибутів",
  "h2_custom_parser": "Створення користувацького парсера",
  "h2_example_attribute": "[LocalizableField] атрибут",
  "h2_example_components": "Готові компоненти та приклади",
  "h2_example_components_updated": "Оновлений LanguageSelector.cs",
  "h2_example_function": "_() функція та [OnLanguageChange] атрибут",
  "h2_example_plurals": "Множини та рід",
  "h2_faq_addressables": "Addressables та Міграція",
  "h2_faq_audio": "ШІ Аудіо / Текст-у-Мовлення",
  "h2_faq_components": "Основні компоненти",
  "h2_faq_editor": "Редактор перекладів",
  "h2_faq_examples": "Приклади використання та код",
  "h2_faq_extending": "Розширення функціональності",
  "h2_faq_installation": "Встановлення та швидкий старт",
  "h2_faq_notes": "Важливі нюанси та попередження",
  "h2_faq_window": "\"Localization Tool\" вікно",
  "h2_font_glyph_manager_features": "Особливості",
  "h2_in_editor_preview": "Попередній перегляд у редакторі & Prefab",
  "h2_initial_setup": "Початкова настройка",
  "h2_installation": "Встановлення",
  "h2_key_features": "Ключові Особливості",
  "h2_live_updates_guide": "Посібник із живих оновлень",
  "h2_localizedasset": "LocalizedAsset",
  "h2_localizedasset_updated": "Асинхронне Завантаження LocalizedAsset",
  "h2_localizedbehaviour": "LocalizedBehaviour",
  "h2_localizeddropdown": "LocalizedDropdown",
  "h2_localizedprefab": "LocalizedPrefab",
  "h2_localizedtext": "LocalizedText",
  "h2_migration_custom": "Створення користувацьких профілів",
  "h2_migration_google_sheets": "Ключ Google Таблиць",
  "h2_migration_import_formats": "Формати імпорту (CSV та Google Таблиці)",
  "h2_migration_stubs": "Безпечна міграція та аварійні заглушки",
  "h2_migration_tool_features": "Особливості",
  "h2_migration_workflow": "Посібник із робочого процесу міграції",
  "h2_preview_overlay": "Настроювання вікна сцени",
  "h2_safety_caps": "Ліміти та квоти безпеки",
  "h2_script_parsing_rules": "Правила аналізу сценаріїв (сумісність)",
  "h2_tab_actions": "\"Actions\" вкладка",
  "h2_tab_assets": "\"Assets\" вкладка",
  "h2_tab_content": "Вкладка «Вміст»",
  "h2_tab_report": "\"Report\" вкладка",
  "h2_tab_settings": "\"Settings\" вкладка",
  "h2_tab_tutorials": "Вкладка \"Tutorials\"",
  "h2_tms_setup": "Налаштування та використання",
  "h2_tms_supported": "Підтримувані сервіси",
  "h2_uitklocalization": "UITKLocalization",
  "h2_visual_debugging_guide": "Візуальне налагодження",
  "h2_window_footer": "Нижній колонтитул (рядок стану)",
  "h2_window_header": "Заголовок вікна та панель інструментів",
  "h2_window_sidebar": "Головне меню (бічна панель)",
  "h3_actions_autotranslate": "Автопереклад",
  "h3_actions_danger": "Зона ризику",
  "h3_actions_data": "Керування даними",
  "h3_actions_editor": "Редактор перекладів",
  "h3_actions_parsing": "Парсинг",
  "h3_actions_tms_integration": "Зовнішні сервіси (TMS)",
  "h3_assets_automation": "Автоматизація",
  "h3_assets_categories": "Категорії ресурсів",
  "h3_assets_folder_gen": "Створення папок",
  "h3_assets_loading": "Стратегія завантаження",
  "h3_assets_storage": "Конфігурація сховища",
  "h3_attribute_cheat_sheet": "Короткий довідник: Що робити, а чого не робити",
  "h3_attribute_features": "Підтримувані типи та функції",
  "h3_attribute_limitations": "Обмеження",
  "h3_content_components_ignore": "Типи компонентів, які слід ігнорувати",
  "h3_content_dynamic_keys": "Динамічні префікси ключів",
  "h3_content_dynamic_texts": "Динамічні тексти",
  "h3_content_objects_ignore": "Об’єкти, які слід ігнорувати",
  "h3_content_prefabs": "Папки Prefab",
  "h3_content_regex": "Ігноровані шаблони Regex",
  "h3_content_scenes": "Сцени для парсингу",
  "h3_content_script_rules": "Правила парсингу скриптів",
  "h3_content_scripts_ignore": "Скрипти, які слід ігнорувати",
  "h3_custom_provider_steps": "Етапи реалізації",
  "h3_faq_window_actions": "Вкладка «Actions» (Дії)",
  "h3_faq_window_assets": "Вкладка «Assets» (Активи)",
  "h3_faq_window_content": "Вкладка «Content» (Вміст)",
  "h3_faq_window_preview": "Попередній Перегляд у Редакторі",
  "h3_faq_window_report": "Вкладка «Report» (Звіт)",
  "h3_faq_window_settings": "Вкладка «Settings» (Налаштування)",
  "h3_mode_auto": "AutoGenerateKeysOnly (Стандартно)",
  "h3_mode_hybrid": "Гібридні режими (користувацький пріоритет)",
  "h3_mode_text": "UseTextAsKey (Спрощено)",
  "h3_report_all_keys": "Всі ключі",
  "h3_settings_debugging": "Налагодження",
  "h3_settings_general": "Загальні налаштування",
  "h3_settings_keygen": "Генерація ключів",
  "h3_settings_languages": "Керування мовами",
  "h3_settings_liveupdates": "Оновлення в реальному часі",
  "h3_settings_pseudo": "Налаштування псевдо-локалізації",
  "h3_settings_runtimeapi": "Runtime API",
  "h3_settings_tools": "Загальні та інструменти розробника",
  "h3_tutorials_list": "Список посібників",
  "lbl_not_supported": "НЕ Підтримується",
  "lbl_supported": "Повністю підтримується",
  "li_actions_1": "<strong>Парсинг:</strong><ul><li><strong>Update Keys:</strong> Повне сканування проєкту, визначене налаштуваннями вкладки 'Content'.</li><li><strong>Scan Selected Assets:</strong> Сканує ЛИШЕ файли/папки, вибрані на даний момент у Project View. Більш безпечно для часткових оновлень, оскільки автоматично вимикає 'Remove Missing Keys'.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Відкриває окреме, зручніше вікно для редагування всіх перекладів.",
  "li_actions_3": "<strong>Керування даними:</strong> Використовуйте для обміну даними з перекладачами (експорт/імпорт у CSV/XML/YAML/XLIFF, імпорт з Google Sheets). <strong>Google Sheets:</strong> Підтримує як посилання 'Edit', так і URL-адреси 'Publish to Web' (перевірте параметр GID).",
  "li_actions_4": "<strong>Auto-Translation:</strong> Автоматично заповнює всі порожні рядки перекладу, використовуючи активний <strong>Translation Profile</strong>.",
  "li_actions_5": "<strong>Danger Zone:</strong> Містить кнопки для повного видалення всіх компонентів локалізації з проєкту. Використовуйте з обережністю!",
  "li_ai_1": "<strong>Створення Профілю:</strong> Правий клік у Project view -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Сервіси:</strong> Підтримує DeepL, Google Translate, Microsoft Azure та <strong>Custom AI</strong>.",
  "li_ai_3": "<strong>Налаштування:</strong> Кожен профіль зберігає свій власний API Key, ліміти (розмір пакета, макс. символів) та налаштування моделі.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Використовуйте вбудований генератор для швидкого створення профілів для популярних сервісів (OpenAI, Gemini, Claude, Ollama).",
  "li_ai_audio_generate": "У <strong>Translation Table Editor</strong> (Редактор Таблиці Перекладів) оберіть рядки/комірки -> Правий клік -> <strong>Generate Audio</strong> (Згенерувати Аудіо).",
  "li_ai_audio_hash": "<strong>Розумне Оновлення та Хешування:</strong> Інструмент обчислює хеш MD5 вашого текстового вмісту та регенерує аудіофайли лише в тому випадку, якщо вихідний текст змінився, заощаджуючи ваші API-кредити. Він виявляє, чи змінився переклад з моменту останньої генерації аудіо. Редактор підсвічує ці рядки іконкою «Outdated» (застарілий) (жовта), дозволяючи вам оновити ЛИШЕ змінені рядки. Ця функція розумного пакетування запобігає зайвим викликам API та знижує витрати при регенерації аудіо. Інструмент хешує ваш текст та регенерує аудіофайли лише в тому випадку, якщо вихідний текст змінився, заощаджуючи ваші API-кредити.",
  "li_ai_audio_profile": "У <strong>Settings</strong> (Налаштування) оберіть <strong>Active Audio Profile</strong> (Активний Аудіо Профіль) (наприклад, OpenAI TTS або ElevenLabs).",
  "li_ai_audio_save": "Файли зберігаються у папці, вказаній у профілі.",
  "li_ai_audio_voice_mapping": "<strong>Призначення голосу (мультиспікер):</strong> Призначати різні AI‑голоси різним персонажам автоматично. Використовуйте список <strong>Voice Mappings</strong>, щоб зв’язати шаблони Regex (наприклад <code>^hero_.*</code>) з конкретними Voice ID. Інструмент автоматично вибере правильний голос на основі назви ключа під час генерації аудіо.",
  "li_ai_provider_settings": "<strong>Налаштування провайдера:</strong> Кожен сервіс дозволяє налаштовувати ключі API (API Keys), моделі (наприклад, GPT-4o, Sonnet) та параметри, специфічні для голосу (Stability, Similarity).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Використовуйте це для асинхронного завантаження Addressables ресурсів. Повертає <code>Task&lt;T&gt;</code>.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) повертає переклад, специфічний для статі.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> повертає правильну форму множини згідно з правилами мови.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> Корутіна (<code>IEnumerator</code>) для зміни мови. Завжди використовуйте <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Створення структури папок (необов'язково):</strong> У розділі <strong>2. Asset Folder Generation</strong> натисніть <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Налаштування категорій та правил найменування:</strong> У розділі <strong>3. Asset Categories & Scanning</strong> переконайтеся, що <strong>Naming Rule</strong> (Правило Найменування) (<code>{key}_{lang}</code>) відповідає вашим файлам (наприклад, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Розміщення ваших активів:</strong> Помістіть локалізовані активи в папки.",
  "li_assets_4": "<strong>Сканування активів:</strong> У розділі <strong>4. Automation</strong> натисніть <strong>Scan Assets & Update Tables</strong>. Процес очищення став безпечнішим: тепер видаляються лише старі файли таблиць (<code>.asset</code>), а не вся папка.",
  "li_assets_5": "<strong>Прив'язка активів до об'єктів:</strong> Натисніть <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Інтеграція з Addressables:</strong> Якщо увімкнено режим <strong>Addressables</strong>, активи будуть автоматично зареєстровані у групах Addressables з адресами у формі <code>{Category}/{Language}/{Key}</code> під час сканування.",
  "li_assets_addressables_naming": "<strong>Угода про Найменування:</strong> Під час сканування інструмент автоматично встановлює Addressable Addresses у формат <code>{Category}/{Language}/{Key}</code>. <strong>Не перейменовуйте</strong> ці адреси вручну, оскільки LocalizationManager покладається на цей конкретний формат для завантаження активів у рантаймі.",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> Якщо увімкнено, інструмент автоматично створить необхідну структуру каталогів для всіх підтримуваних мов під час першої локалізації ресурсів.",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> Автоматично створює структуру папок для локалізованих ресурсів згідно з вашими правилами.",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> Визначте кореневий каталог для всіх локалізованих ресурсів (Sprites, Audio тощо). Використовуйте змінну <code>{lang}</code>, щоб вказати структуру папок для кожної мови.",
  "li_assistant_1": "<strong>Налаштовувані:</strong> Визначте команди у вашому Translation Profile (наприклад, «Fix Grammar», «Make Formal», «Shorten for UI»).",
  "li_assistant_2": "<strong>Пакетна Обробка:</strong> Виберіть кілька комірок, щоб застосувати команду до всіх них одночасно.",
  "li_assistant_3": "<strong>Custom Commands:</strong> Визначте власні підказки у інспекторі <strong>Translation Profile</strong> (Список <code>AIAssistantCommand</code>). Кожна команда має <strong>Label</strong> (відображається в контекстному меню) та <strong>Prompt</strong> (інструкції, що надсилаються AI, наприклад, 'Переписати у стилі пірата').",
  "li_attr_feat_1": "<strong>Колекції:</strong> Підтримує `List&lt;string&gt;` та `string[]`. Ключі генеруються з суфіксами `_0`, `_1` тощо. Ви навіть можете використовувати власний ключ для самого поля списку, щоб додати префікс до всіх елементів.",
  "li_attr_feat_2": "<strong>Модифікатори доступу:</strong> Працює з `private`, `protected`, `internal` та `public` полями.",
  "li_attr_feat_3": "<strong>Користувацькі атрибути:</strong> У налаштуваннях вкладки <em>Content Tab</em> ви можете додати `HeaderAttribute`, `TooltipAttribute` або будь-яку назву користувацького атрибута. Парсер тоді розглядатиме поля з цими атрибутами (напр., `[Header(\"Text\")]`) як локалізовані рядки!",
  "li_attr_feat_4": "<strong>Вкладені об'єкти:</strong> Рекурсивно сканує поля всередині класів або структур, позначених `[System.Serializable]`. Це включає окремі екземпляри та списки вкладених об'єктів.",
  "li_attr_feat_5": "<strong>Форматовані рядки:</strong> Підтримує інтерпольовані рядки (<code>$\"Text {0}\"</code>), дослівні рядки (<code>@\"Text\"</code>) та конкатенацію (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Властивості підтримуються:</strong> Парсер сканує як <code>Fields</code>, так і <code>Properties</code>. Потрібен Getter.",
  "li_attr_limit_2": "<strong>Словники:</strong> `Dictionary&lt;T, string&gt;` не підтримується безпосередньо для аналізу.",
  "li_attr_limit_3": "<strong>Статичні поля:</strong> Підтримується за допомогою статичного аналізу (regex) у файлах коду, але загалом рекомендується використовувати поля екземплярів для надійного виявлення на GameObjects.",
  "li_backup_desc": "Відстежуйте зміни та відновлюйте попередні версії ваших перекладів.",
  "li_backup_rollback": "<strong>Відкат:</strong> Миттєво поверніть вибрані ключі або всю таблицю до попереднього стану.",
  "li_backup_snapshots": "<strong>Знімки:</strong> Створює іменовані точки відновлення перед масовими операціями.",
  "li_cheat_base_private": "<strong>Приватні поля базового класу:</strong> Підтримуються (сканер читає файли базового класу безпосередньо)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> Масиви",
  "li_cheat_concatenation": "<strong>Конкатенація рядків:</strong> <code>\"A\" + \"B\"</code> (Підтримується)",
  "li_cheat_constructor_args": "<strong>Складні аргументи конструктора:</strong> `new Item(\"Name\" + index)`",
  "li_cheat_dictionaries": "<strong>Словники</strong> (За замовчуванням не серіалізуються інспектором Unity)",
  "li_cheat_headers": "Атрибути, такі як <code>[Header(\"...\")]</code> (Повністю підтримуються)",
  "li_cheat_nested_lists": "<strong>Списки вкладених об'єктів</strong> (напр. <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Змінні та константи:</strong> <code>const string s = \"Значення\";</code> або <code>static string</code> (Підтримується, Roslyn розпізнає значення з того самого файлу)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> поля (Підтримується)",
  "li_cheat_properties": "<strong>Властивості:</strong> <code>{ get; set; }</code> (Автоматичні властивості та повні властивості підтримуються)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Підтримуються, якщо є посилання)",
  "li_cheat_serializable": "Вкладені <code>[Serializable] class</code> (Предмети інвентарю, Вузли діалогів)",
  "li_cheat_static": "<strong>Статичні поля:</strong> <code>public static string</code> (Повністю підтримуються)",
  "li_cheat_structs": "<strong>Структури та записи:</strong> Підтримуються (рекурсивне сканування)",
  "li_cheat_ternary": "<strong>Логіка/Тернарний оператор:</strong> `cond ? \"A\" : \"B\"` (Парсер не може визначити значення)",
  "li_cheat_unattached": "<strong>Невід'єднані скрипти:</strong> Підтримуються (сканер читає всі файли .cs у проєкті)",
  "li_content_1": "<strong>Scenes to Parse:</strong> Перетягніть сюди всі сцени для аналізу.",
  "li_content_2": "<strong>Prefab Folders:</strong> Вкажіть папки з префабами. Тепер підтримує пагінацію та пошук для великих проєктів.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Введіть сюди рядки, які створюються виключно в коді (наприклад, \"Game Over\").",
  "li_content_4": "<strong>Component Types to Ignore:</strong> Вкажіть типи Unity Component, які слід пропускати під час сканування.",
  "li_content_5": "<strong>Pin to Ignore:</strong> Ця функція дозволяє \"закріпити\" об’єкт зі сцени у список ігнорування постійно.",
  "li_content_6": "<strong>Scripts to Ignore:</strong> Додайте конкретні C# скрипти АБО цілі папки, щоб виключити їх з парсингу.",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> Список префіксів для ключів (наприклад <code>Item_</code>), які не будуть видалені під час очищення.",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> Визначте префікси (наприклад <code>quest_item_</code>), які слід розглядати як потенційно динамічні. Це допомагає інструменту розрізняти статичні мітки UI та ключі, що генеруються даними.",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> Налаштуйте шаблони для тексту, який оновлюється динамічно через код. Це запобігає створенню сканером зайвих ключів для тексту, що змінюється під час виконання.",
  "li_content_regex_example": "<strong>Приклад власної обгортки:</strong> Якщо ви використовуєте власну функцію, таку як <code>MyGame.Loc(\"KEY\")</code>, додайте правило аналізу сценарію з регулярним виразом: <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Ігноровані шаблони регулярних виразів:</strong> Натисніть <strong>'Додати загальний шаблон'</strong>, щоб швидко виключити динамічний вміст, такий як URL-адреси, електронні листи тощо.",
  "li_content_scanner": "<strong>Сканер коду Roslyn:</strong> Двигун глибокого статичного аналізу, який розуміє дерева синтаксису C# для надійного виявлення ключів.",
  "li_content_scanner_details_1": "<strong>Розумне виявлення викликів:</strong> автоматично знаходить виклики <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> та <code>GetTranslation(\"Text\")</code>. Він застосовує режим <strong>Text-As-Key</strong> для цих викликів, щоб забезпечити правильну роботу функцій під час виконання, таких як Pluralization та Gender.",
  "li_content_scanner_details_2": "<strong>Розпізнавання констант:</strong> Сканер є достатньо інтелектуальним, щоб розпізнавати `const` або `static readonly` рядкові змінні. Якщо ви використовуєте <code>_ (MyConst)</code>, він знайде значення `MyConst` (якщо визначено в тому ж класі) і використає його як вихідний текст.",
  "li_content_scanner_details_3": "<strong>Атрибут і метадані:</strong> Він сканує будь-яке поле або властивість з `[LocalizableField]`, `[Header]` або `[Tooltip]` (якщо налаштовано). Він обробляє <strong>Масиви</strong>, <strong>Списки</strong> та навіть <strong>Вкладені серіалізовані класи</strong> рекурсивно.",
  "li_content_scanner_details_4": "<strong>Підтримка сучасного C#:</strong> Повна підтримка синтаксису C# 9.0+, включаючи target-typed <code>new()</code> вирази, неявне створення масивів та інтерпольовані рядки (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Атрибути для сканування:</strong> Визначте власні атрибути (наприклад, <code>[Header]</code> або <code>[Tooltip]</code>), які аналізатор має розпізнавати як джерела локалізованих рядків.",
  "li_content_script_rules_bridge_name": "<strong>Ім'я класу-мосту:</strong> Дозволяє визначити ім'я згенерованого статичного класу.",
  "li_content_script_rules_bridges": "<strong>Генерувати C# мости:</strong> Автоматично створює статичний клас (наприклад, <code>AnkoLoc</code>), що забезпечує строго типізований доступ до всіх ключів, усуваючи 'магічні рядки' та вмикаючи автозаповнення в IDE.",
  "li_context_1": "<strong>Примітки Розробника:</strong> Коментарі з таблиці перекладів передаються ШІ як контекст.",
  "li_context_2": "<strong>Шлях до Об'єкта:</strong> Якщо коментар відсутній, як резервний контекст використовується шлях ієрархії об'єкта (наприклад, <code>MainMenu/Canvas/StartButton</code>).",
  "li_context_3": "<strong>Глосарій:</strong> Ви можете завантажити CSV-глосарій у профіль, щоб забезпечити виконання конкретних перекладів для термінів та імен.",
  "li_context_4": "<strong>Опис проєкту:</strong> Опишіть місце дії та цільову аудиторію вашої гри, щоб допомогти ШІ зрозуміти загальний контекст.",
  "li_context_5": "<strong>Тон і стиль:</strong> Визначте бажану персону (наприклад, 'Дружній', 'Професійний', 'Пірат') та правила форматування.",
  "li_context_glossary": "<strong>Менеджер словника:</strong> Взаємодійте безпосередньо з глосарієм, щоб 'Додати', 'Редагувати' або 'Видалити' терміни. Підтримує чутливість до регістру та типи 'Не перекладати'.",
  "li_context_optimization": "<strong>Оптимізація токенів:</strong> Система інтелектуально ущільнює контекст і повторно використовує кеш для мінімізації використання токенів та витрат.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Гнучка реалізація, що може взаємодіяти з API, сумісними з OpenAI (включно з локальними LLM через Ollama).",
  "li_custom_ai_2": "<strong>Шаблони та авторизація:</strong> Повністю налаштуйте запит. <ul><li><strong>Авторизація:</strong> Налаштуйте <code>Auth Header Key</code> (наприклад, <code>Authorization</code>) та <code>Format</code> (наприклад, <code>Bearer {0}</code>). Підтримує ключ API у параметрах запиту.</li><li><strong>Шаблон тіла запиту:</strong> Використовуйте JSON-шаблон із заповнювачами, такими як <code>{model}</code> та <code>{prompt}</code> для тексту, або <code>{input}</code> та <code>{voice}</code> для аудіо.</li><li><strong>Шлях до відповіді:</strong> Визначте шлях JSON до результату (наприклад, <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Вбудовані Функції Безпеки:</strong> Автоматично виправляйте зламані теги форматування (як-от <ph0>), які часто повертаються моделями ШІ, забезпечуючи надійні та послідовні переклади.",
  "li_custom_parser_1": "Створіть новий C# скрипт у папці <strong>Editor</strong> вашого проєкту.",
  "li_custom_parser_2": "Скопіюйте у нього шаблон нижче.",
  "li_custom_parser_3": "Змініть логіку відповідно до вашого компонента.",
  "li_custom_provider_manual_reg": "<strong>Ручна реєстрація:</strong> Для складних сценаріїв (таких як DI injection або lazy init) ви можете вручну зареєструвати свій провайдер через <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> під час ініціалізації.",
  "li_custom_provider_step_1": "<strong>Реалізуйте інтерфейс:</strong> Створіть новий клас, який реалізує <code>IAssetProvider</code>. Вам потрібно буде визначити, як завантажувати <code>Load&lt;T&gt;</code> (синхронно) та <code>LoadAsync&lt;T&gt;</code> (асинхронно) асети, використовуючи API вашої системи.",
  "li_custom_provider_step_2": "<strong>Визначте життєвий цикл:</strong> Реалізуйте <code>Initialize</code>, <code>Dispose</code> та <code>UnloadAll</code>. Ці методи викликаються <code>LocalizationManager</code> під час перемикання мов або очищення ресурсів.",
  "li_custom_provider_step_3": "<strong>Мовна безпека:</strong> Метод <code>SetCurrentLanguage</code> викликається щоразу, коли змінюється активна мова. Використовуйте це для оновлення внутрішніх шляхів або повторного отримання метаданих асетів.",
  "li_custom_provider_step_4": "<strong>Автоматичне виявлення (рекомендовано):</strong> Прикрасьте ваш клас атрибутом <code>[AssetProviderPlugin]</code>. Це робить ваш провайдер миттєво видимим у випадаючому списку <strong>Вкладка Налаштувань -> Стратегія завантаження асетів</strong>.",
  "li_editor_1": "<strong>Розумне Групування:</strong> Ключі для множини та гендеру (наприклад, <code>apple_count_one</code>, <code>apple_count_few</code>) автоматично об'єднуються у згортані групи.",
  "li_editor_2": "<strong>Розширене Редагування:</strong> Клацніть на комірці, щоб відкрити спливаюче вікно <strong>MultiLineEditWindow</strong>. Воно показує вихідний текст для порівняння та перевіряє заповнювачі.",
  "li_editor_3": "<strong>Розширений вибір:</strong> Підтримує гнучкі режими вибору: окремі комірки, цілі рядки або певні стовпці (мови). Використовуйте <code>Ctrl+Click</code> та <code>Shift+Click</code> для складних виділень.",
  "li_editor_4": "<strong>Масові дії:</strong> Виконуйте операції над тисячами комірок одночасно. Клацніть правою кнопкою миші на виділення, щоб: <ul><li><strong>Автопереклад:</strong> Заповнити відсутні переклади за допомогою активного AI профілю.</li><li><strong>Заповнити з джерела:</strong> Швидко скинути переклади.</li><li><strong>Перемкнути блокування:</strong> Захистити 'ідеальні' переклади від випадкових перезаписів.</li><li><strong>Генерувати аудіо:</strong> Групова обробка TTS для вибраних фраз.</li></ul>",
  "li_editor_5": "<strong>Високопродуктивна навігація:</strong> Редактор використовує віртуалізований 'MultiColumnListView' для плавного прокручування з 10k+ ключами. Підтримує навігацію клавіатурою (Стрілки/Tab) та надійні комбінації клавіш: <code>Ctrl+S</code> (Зберегти), <code>Ctrl+Z/Y</code> (Скасувати/Повторити), <code>Ctrl+F</code> (Фокус пошуку).",
  "li_editor_6": "<strong>Розширені налаштування пошуку:</strong> Перевіряйте свій проєкт за допомогою спеціалізованих фільтрів: <ul><li><strong>Статус:</strong> Неперекладено (Поточна/Будь-яка мова), Ідентично джерелу, Заблоковано.</li><li><strong>Вміст:</strong> Має коментарі, Має/Відсутні плейсхолдери, Має проблеми з довжиною (Автоматично виявлено).</li><li><strong>Структура:</strong> Множина, Гендер, або Обидва.</li><li><strong>Аудіо:</strong> Відсутнє аудіо, Застаріле (Невідповідність хешу).</li></ul>",
  "li_editor_7": "<strong>Інтелектуальне керування аудіо:</strong> Відстежує 'свіжість' ваших TTS файлів. Якщо ви редагуєте текст перекладу, з'являється <strong>Жовтий індикатор (Застаріле)</strong>, що вказує на те, що хеш аудіофайлу більше не відповідає тексту. Один клік регенерує лише застарілі файли.",
  "li_editor_8": "<strong>Механізм блокування:</strong> Пояснення: <ul><li><strong>Заблоковані комірки/рядки:</strong> Запобігає будь-яким змінам за допомогою <strong>Автоперекладу</strong>, <strong>Імпорту CSV/Google</strong> або <strong>Заповнення з джерела</strong>.</li><li><strong>Варіант використання:</strong> Заблокувати 'еталонні' переклади, які були вручну перевірені носіями мови.</li><li><strong>Масовий контроль:</strong> Блокувати цілі мови або певні функції (наприклад, імена персонажів) в рамках всього проєкту.</li></ul>",
  "li_editor_layout": "<strong>Динамічний багатопанельний макет:</strong> Використовуйте 3-панельну систему, щоб закріпити 'фіксовані' стовпці (наприклад, ключі) зліва, прокручуючи понад 20 мов по центру. Перемикайте видимість стовпців через контекстне меню заголовка.",
  "li_editor_regex": "<strong>Пошук за Regex:</strong> Головне вікно та редактор таблиць підтримують <strong>Регулярні вирази</strong>. Якщо ваш запит містить символи, такі як <code>* + ? ^ $ [ ] ( ) { } | .</code>, він автоматично розглядається як Regex (наприклад, <code>^item_.*</code> для пошуку всіх ключів, що починаються з 'item_').",
  "li_editor_structure": "<strong>Таблиці та групи:</strong> Дані організовані в Таблиці (Файли), відображаються як Групи (Папки) у редакторі для кращої навігації.",
  "li_editor_ui_test": "<strong>Вбудоване тестування інтерфейсу користувача:</strong> <ul><li><strong>Повзунок розширення довжини:</strong> Симулюйте розширення тексту (0% - 100%), щоб побачити, як ваш інтерфейс користувача обробляє довші мови, такі як німецька або російська, не виходячи з редактора.</li><li><strong>Рендерер форматованого тексту:</strong> Перемикайте рендеринг тегів (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) для перевірки стилів без запуску гри.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Готовий компонент для створення UI-випадаючого списку для перемикання мови. Він автоматично знаходить усі доступні мови та керує їхнім перемиканням.<br><strong>Як використовувати:</strong> Просто додайте компонент <code>LanguageSelector</code> до вашої сцени (наприклад, на порожній GameObject) та вкажіть ваш <code>TMP_Dropdown</code> в інспекторі.",
  "li_example_components_2": "<strong>Приклади Коду:</strong> Щоб вивчити розширені техніки, такі як робота з <code>[LocalizableField]</code>, функцією <code>_()</code>, множиною та гендером, вивчіть файли <code>StatPurchaseTest.cs</code> та <code>TestLocalization.cs</code>. Вони наочно демонструють реалізацію всіх основних функцій інструменту в коді.",
  "li_example_components_new": "<strong>Нове (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Повертає <code>IEnumerator</code>. Має бути yield-нуто.",
  "li_example_components_old": "<strong>Старе:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (синхронний void) - <strong>Застаріле</strong>. Використовуйте Coroutine версію.",
  "li_feature_1": "<strong>Розширений Парсинг:</strong> Автоматичне сканування сцен, префабів, UI Toolkit (UXML) та C#-скриптів, включно з полями, позначеними атрибутом <code>[LocalizableField]</code>, а також вкладеними класами та списками.",
  "li_feature_10": "<strong>Менеджер Резервних Копій:</strong> Вбудований інструмент для створення та відновлення резервних копій.",
  "li_feature_11": "<strong>На Основі ШІ:</strong> Підтримка OpenAI, Anthropic (Claude), Google Gemini та локальних LLM (Ollama) через профілі, що налаштовуються.",
  "li_feature_12": "<strong>Текст-у-Мовлення (TTS):</strong> Генерація аудіофайлів для локалізованих рядків за допомогою ШІ (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Інструменти Міграції:</strong> Інструменти для автоматичного переходу з плагінів I2 Localization та Unity Localization.",
  "li_feature_14": "<strong>Менеджер Шрифтів та Гліфів:</strong> Інструмент для аналізу використаних символів та пошуку відсутніх гліфів у шрифтах.",
  "li_feature_15": "<strong>Візуальне Налагодження:</strong> Іконки в ієрархії та мітки у Scene View для швидкого налагодження.",
  "li_feature_2": "<strong>Локалізація Будь-якого Активу:</strong> Керування спрайтами, аудіо, префабами, матеріалами тощо.",
  "li_feature_3": "<strong>Потужний редактор перекладів:</strong> Централізований інтерфейс з автозбереженням, повною підтримкою Undo/Redo, розумним групуванням ключів та діями для множинного вибору.",
  "li_feature_4": "<strong>ШІ та машинний переклад:</strong> Система профілів, що підтримує DeepL, Google, Microsoft та <strong>Користувацький ШІ (OpenAI, Gemini, Claude, Ollama)</strong> з контекстною обізнаністю.",
  "li_feature_5": "<strong>Гнучкий Імпорт/Експорт:</strong> Підтримка CSV, XML, YAML, XLIFF та прямий імпорт із Google Sheets.",
  "li_feature_6": "<strong>Живий Попередній Перегляд:</strong> Переглядайте будь-яку мову у Scene View або <strong>Prefab Mode</strong> без запуску гри.",
  "li_feature_7": "<strong>Підтримка множини та роду:</strong> Повна підтримка CLDR (v43). Включає правила для <strong>Азіатських</strong> (Жодного), <strong>Англійських/Германських</strong> (Один, Інше), <strong>Французьких</strong> (Один 0-1), <strong>Слов'янських</strong> (Один, Декілька, Багато - RU, UK, PL), <strong>Арабських</strong>, <strong>Кельтських</strong>, <strong>Балтійських</strong> (LT, LV) та інших.",
  "li_feature_8": "<strong>Повна Підтримка RTL:</strong> Коректне відображення мов, що пишуться справа наліво.",
  "li_feature_9": "<strong>Живі Оновлення:</strong> Завантаження актуальних перекладів з віддаленого сервера під час запуску гри.",
  "li_feature_tool_translation": "<strong>Повністю перекладений інтерфейс користувача:</strong> Інтерфейс інструменту локалізований. Ви можете змінити мову редактора за допомогою випадаючого списку в <strong>заголовку Головного вікна</strong>.",
  "li_font_global": "<strong>Глобальний звіт:</strong> Генерує звіт про всі відсутні гліфи для всіх мов.",
  "li_font_glyph_analyze": "Аналізує всі переклади та перевіряє, чи підтримує призначений шрифт (TMP_FontAsset) усі використовувані символи.",
  "li_font_glyph_copy": "Дозволяє копіювати всі унікальні символи мови для генерації атласу шрифтів. Включає <strong>фільтри для виключення ASCII, чисел та розділових знаків</strong> для оптимізації простору текстури.",
  "li_font_glyph_missing": "Показує список відсутніх гліфів.",
  "li_font_glyph_workflow": "<strong>Робочий Процес для TMP:</strong> 1. Запустіть Scan. 2. Оберіть мову з відсутніми гліфами. 3. Натисніть <strong>'Copy Character Set'</strong>. 4. Відкрийте Window -> TextMeshPro -> Font Asset Creator. 5. Вставте вміст буфера обміну у поле 'Character Sequence (Custom Range)', щоб згенерувати атлас, що містить саме ті символи, які потрібні вашій грі.",
  "li_font_unicode": "<strong>Діапазони Unicode:</strong> Переглядайте конкретні діапазони Unicode, що використовуються у ваших перекладах (наприклад, Basic Latin, Cyrillic), для оптимізації асетів шрифтів.",
  "li_footer_status": "<strong>Стан та прогрес:</strong> Відгук у реальному часі про завдання аналізу, імпорту або генерації ШІ.",
  "li_header_lang_selector": "<strong>Мова редактора:</strong> Змініть мову інтерфейсу інструменту. Інтерфейс інструменту повністю локалізований.",
  "li_header_preview_btn": "<strong>Перемикач попереднього перегляду:</strong> Швидко вмикайте або вимикайте попередній перегляд в редакторі. Використовуйте кнопку 'Повернути', щоб відновити вихідні значення сцени.",
  "li_header_toolbar_buttons": "<strong>Глобальна панель інструментів:</strong> Прямий доступ до Документації, Discord, Asset налаштувань, Перевірки залежностей та Сторінки огляду.",
  "li_install_1": "<strong>ВАЖЛИВО (Оновлення v2.0):</strong> При оновленні з v1.x, ви <strong>ПОВИННІ видалити</strong> стару папку `Ankonoanko` перед імпортом. Версія 2.0 вимагає чистої установки через зміни просторів імен.",
  "li_install_2": "Інструмент автоматично перевірить наявність необхідних залежностей. Підтвердьте встановлення у діалоговому вікні, що з’явиться.",
  "li_install_3": "Обов'язкові залежності (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) необхідні для базового функціоналу.",
  "li_install_4": "Необов'язкові залежності (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) вмикають додаткові функції.",
  "li_install_5": "Натисніть <strong>Install Selected</strong>, щоб встановити рекомендовані пакети.",
  "li_install_6": "Після встановлення відкрийте головне вікно інструменту через меню <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Якщо ви плануєте використовувати асинхронне завантаження активів, встановіть пакет <strong>Addressables</strong> через Package Manager.",
  "li_live_updates_1": "<strong>Увімкнути:</strong> у Налаштуваннях, встановіть прапорець 'Увімкнути живі оновлення'.",
  "li_live_updates_2": "<strong>Джерело:</strong> Надайте <code>Live Update URL</code>, що повертає JSON словник, або <code>Google Sheet URL</code>.",
  "li_live_updates_3": "<strong>Кеш:</strong> Переклади кешуються локально за адресою <code>liveUpdateCachePath</code>, щоб забезпечити роботу гри в автономному режимі.",
  "li_live_updates_4": "<strong>Безпека:</strong> Використовуйте <strong>Runtime API Key</strong> (зашифрований), якщо ваш сервер вимагає автентифікації.",
  "li_localizedtext_1": "<code>localizationKey</code>: Ключ, який використовується для пошуку перекладу. Може бути згенерований автоматично або призначений вручну.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Якщо <code>true</code>, компонент застосовуватиме лише стилі (шрифт, RTL), але не змінюватиме сам текст. Важливо для динамічних текстових елементів (наприклад, текст, оновлений за допомогою викликів `_()` у скриптах).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Оригінальний текст базовою мовою. Використовується як резервний варіант.",
  "li_localizedtext_key_override": "<strong>Ручне перевизначення ключа:</strong> Ви можете натиснути іконку 'Редагувати' поруч із ключем, щоб ввести ключ вручну. Використовуйте 'X', щоб повернутися до автоматичної генерації. Це працює для <code>LocalizedText</code>, <code>LocalizedDropdown</code> (для кожної опції окремо) та <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>Пошук у таблиці:</strong> Натисніть піктограму лупи, щоб миттєво відкрити Таблицю перекладів і сфокусуватися на цьому конкретному ключі.",
  "li_migration_csv_details_1": "<strong>Інтелектуальна фільтрація:</strong> Імпортер автоматично пропускає рядки, що виглядають як шляхи до асетів (наприклад, <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>), щоб зберегти вашу текстову базу даних чистою.",
  "li_migration_csv_details_2": "<strong>Стовпець 'Тип':</strong> Якщо стовпець 'Type' існує (формат I2), імпортуються лише рядки, позначені як 'Text' або з порожнім типом. Щоб імпортувати асети, використовуйте Профілі міграції для їх відображення на <code>LocalizedAsset</code>.",
  "li_migration_csv_req_1": "<strong>Стовпець ключа:</strong> Повинен бути названий <code>Key</code> (без урахування регістру) або визначений у вашому Профілі міграції.",
  "li_migration_csv_req_2": "<strong>Стовпці мови:</strong> Будь-який стовпець, не позначений як ігнорований, розглядається як код мови (наприклад, 'en', 'ja', 'English'). Інструмент намагається нечітко зіставити їх з мовами вашого проєкту.",
  "li_migration_csv_req_3": "<strong>Коментарі:</strong> Стовпці з назвами <code>Desc</code>, <code>Description</code> або <code>Comment</code> імпортуються як нотатки розробника. Цей список налаштовується в <strong>Профілі міграції</strong>.",
  "li_migration_custom_1": "Клацніть правою кнопкою миші в Project View -> Створити -> Anko Localization -> Migration Profile.",
  "li_migration_custom_2": "<strong>Правила:</strong> Визначте правила перетворення (якщо [Вихідний компонент] із [Контекстним фільтром], то перетворити на [Цільовий компонент]). Правила підтримують <strong>Пріоритет</strong> (вищі числа обробляються першими), <strong>Збір активів</strong> (автоматично видобуває та реєструє посилальні активи, такі як спрайти або аудіо) та <strong>Контекстну фільтрацію</strong> для розрізнення кількох компонентів на одному об'єкті.",
  "li_migration_fallback_keys": "<strong>Поля резервних ключів:</strong> Вкажіть додаткові назви полів для перевірки при вилученні ключів зі застарілих компонентів. Корисно, якщо ваша стара система використовує нестандартні назви властивостей для ключів.",
  "li_migration_gs_1": "<strong>Доступ:</strong> Аркуш має бути спільним ('Будь-хто, хто має посилання, може переглядати') або опублікованим у Інтернеті.",
  "li_migration_gs_2": "<strong>Вкладки аркуша (GID):</strong> URL-адреса повинна включати параметр <code>gid=...</code>. Це повідомляє інструменту, яку саме вкладку читати (наприклад, <code>gid=0</code> зазвичай є першою вкладкою/аркушем).",
  "li_migration_ignored_headers": "<strong>Ігноровані заголовки CSV:</strong> Визначте стовпці, які слід пропускати під час імпорту (наприклад, 'Type', 'Description'). Це запобігає обробці інструментом стовпців метаданих як мовних даних.",
  "li_migration_legacy_components": "<strong>Додаткові застарілі компоненти:</strong> Вручну перелічіть назви компонентів, які інструмент має розпізнавати як 'застарілі' під час сканування міграції, навіть якщо не визначено прямого правила перетворення.",
  "li_migration_profile_details": "<strong>Розширені налаштування профілю:</strong><ul><li><code>CsvKeyHeader</code>: Ім'я заголовка для стовпця ключа.</li><li><code>CsvCommentHeaders</code>: Список заголовків, які розглядаються як нотатки/коментарі розробника.</li><li><code>IgnoredCsvHeaders</code>: Стовпці, які потрібно пропустити (метадані, такі як 'Type' або 'Status'), щоб уникнути їхнього трактування як мов.</li><li><code>AssetExtensions</code>: Типи файлів, що розпізнаються як активи під час сканування.</li><li><code>FallbackKeyFields</code>: Додаткові імена полів для перевірки, якщо первинне поле ключа порожнє.</li></ul>",
  "li_migration_rule_fields": "<strong>Конфігурація правила:</strong><ul><li><code>Priority</code>: Вищі значення обробляються першими. Використовуйте це для обробки конкретних випадків перед загальними.</li><li><code>Context Filter</code>: Застосовувати правило лише якщо певний компонент (наприклад, <code>Text</code>) присутній на тому ж об'єкті.</li><li><code>Harvest Assets</code>: Якщо ввімкнено, видобуває поточний актив (наприклад, спрайт) з успадкованого компонента та реєструє його в таблиці активів.</li><li><code>Asset Field Path</code>: Шлях до поля, що містить посилання на актив для збору.</li><li><code>Additional Data Path</code>: Використовується для складних компонентів, таких як Dropdowns, для збору кількох значень/опцій.</li></ul>",
  "li_migration_stubs_1": "<strong>Проблема:</strong> Ви видаляєте старі асети плагіна. Unity виявляє відсутні скрипти (наприклад, відсутній компонент <code>Localize</code>). Редактор переходить у режим помилок компіляції.",
  "li_migration_stubs_2": "<strong>Рішення:</strong> Функція «Екстрені заглушки» генерує легкі, порожні класи з тими ж іменами та просторами імен, що й старий плагін. Це задовольняє компілятор.",
  "li_migration_stubs_3": "<strong>Робочий процес:</strong> 1. Натисніть <strong>Увімкнути екстрені заглушки</strong> (це додає <code>ANKO_ENABLE_MIGRATION_STUBS</code> до ваших налаштувань проекту). 2. Видаліть папку старого плагіна. 3. Unity успішно перекомпілюється, використовуючи фальшиві класи. 4. Запустіть <strong>Конвертер компонентів</strong>, щоб замінити заглушки офіційними компонентами. 5. Натисніть <strong>Вимкнути заглушки</strong> після завершення рефакторингу.",
  "li_migration_tool_converter": "<strong>Крок 2: Конвертер Компонентів:</strong> Скануйте сцени та префаби. Автоматично замінює старі компоненти (наприклад, <code>Localize</code>) на <code>LocalizedText</code> / <code>LocalizedAsset</code>, передаючи ключі.",
  "li_migration_tool_fields": "<strong>Налаштування профілю:</strong> Конфігурований тип 'Source Plugin' та правила 'Asset Mapping' забезпечують правильну передачу текстур та аудіо.",
  "li_migration_tool_import": "<strong>Крок 1: Імпорт Даних:</strong> Імпортуйте CSV (I2) або XLIFF (Unity Loc) файли, щоб створити базу даних ключів.",
  "li_migration_tool_profiles": "<strong>Профілі міграції:</strong> Створюйте власні профілі для зіставлення ресурсів і налаштувань зі сторонніх плагінів (I2, Unity Loc).",
  "li_migration_tool_safemode": "<strong>Безпечний режим та екстрені заглушки:</strong> Компоненти вимикаються, а не видаляються. Включає критично важливу функцію <strong>Екстрені заглушки</strong> (активується через символ визначення <code>ANKO_ENABLE_MIGRATION_STUBS</code>): генерує фальшиві класи-заповнювачі для I2 Localization або Unity Localization, щоб ваш проект міг скомпілюватися одразу після видалення цих плагінів. Це запобігає помилкам \"The type name 'Localize' could not be found\" і дає вам час належним чином рефакторити ваш код для використання нової системи. Увімкнення заглушок дозволяє виправити помилки компіляції після видалення старого плагіна локалізації.",
  "li_migration_tool_setup": "<strong>Крок 0: Налаштування:</strong> Налаштуйте імена компонентів (наприклад, <code>Localize</code> для I2) та поля, де зберігається ключ. Доступні пресети.",
  "li_migration_workflow_1": "<strong>1. Резервне копіювання:</strong> Зафіксуйте свій проект у системі контролю версій (Git) або зробіть резервну копію файлу перед початком.",
  "li_migration_workflow_2": "<strong>2. Увімкнути заглушки:</strong> Відкрийте Інструмент міграції -> вкладку 'Safe Mode'. Натисніть <strong>Enable Emergency Stubs</strong> для вашої цільової системи (I2/UnityLoc). Це створює легкі фіктивні класи у вашому проекті.",
  "li_migration_workflow_3": "<strong>3. Видалити старий плагін:</strong> Видаліть папку старого плагіна (наприклад, 'Assets/Plugins/I2'). Unity перекомпілює. Завдяки заглушкам, ви <strong>НЕ</strong> отримаєте помилок 'Type not found', зберігаючи всі посилання на компоненти на префабах.",
  "li_migration_workflow_4": "<strong>4. Імпорт даних:</strong> На вкладці 'Import Data' завантажте свій вихідний CSV/XLIFF. Перевірте попередній перегляд і натисніть <strong>Import</strong>. Це заповнить таблиці перекладів AnKo.",
  "li_migration_workflow_5": "<strong>5. Перетворити компоненти:</strong> На вкладці 'Component Converter' виберіть 'Entire Project' і натисніть <strong>Scan & Convert</strong>. Інструмент замінює старі заглушки на компоненти 'LocalizedText'/'LocalizedAsset', переносячи ключі.",
  "li_migration_workflow_6": "<strong>6. Очищення:</strong> Щойно все запрацює, натисніть <strong>Disable Stubs</strong> і дозвольте Unity перекомпілювати знову.",
  "li_notes_1": "<strong>Резервні Копії:</strong> Завжди створюйте резервну копію через <strong>Translation Table Editor -> Manage Backups</strong> перед великими змінами. Резервні копії зберігаються у папці <code>LocalizationBackups</code> <strong>у корені проєкту (за межами папки Assets)</strong>, щоб ваш Unity-проєкт був чистим та зменшився час імпорту.",
  "li_notes_2": "<strong>Безпека API Key:</strong> Ключ для роботи в редакторі зберігається локально на вашій машині (у <code>EditorPrefs</code>) і не потрапляє в репозиторій. Для ключів, необхідних у збірці гри, використовуйте розділ <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Папка <code>StreamingAssets</code>:</strong> Файли перекладів повинні знаходитись у підпапці <code>Assets/StreamingAssets/</code>, щоб бути включеними до збірки гри.",
  "li_notes_4": "<strong>«Захист від Дурня»:</strong> Інструмент автоматично захищає вас від випадкового збереження тимчасових даних з режиму попереднього перегляду у сцену чи префаб.",
  "li_notes_5": "<strong>Продуктивність:</strong> Виклик <code>_()</code> є швидким, але у циклах, що виконуються щокадру (наприклад, у <code>Update</code>), намагайтеся кешувати результат у змінну.",
  "li_notes_6": "<strong>Виключення <code>LanguageSelector</code> з парсингу:</strong> Об'єкт з компонентом <code>LanguageSelector</code> та його <code>TMP_Dropdown</code> повинні бути додані до списку <strong>Ignore Specific Objects</strong> на вкладці <strong>Content</strong>. Це необхідно, щоб запобігти створенню парсером зайвих ключів для опцій випадаючого списку, оскільки скрипт <code>LanguageSelector</code> заповнює їх динамічно у рантаймі. Ігнорування запобігає конфліктам і зберігає файли перекладів чистими.",
  "li_notes_7": "<strong>Шрифти для <code>LanguageSelector</code>:</strong> Щоб обрана мова у <code>TMP_Dropdown</code> коректно оновлювала свій шрифт, вручну додайте порожній компонент <code>LocalizedText</code> до дочірнього об'єкта <strong>Label</strong> випадаючого списку та встановіть прапорець <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Код та Addressables:</strong> Якщо ви переходите в режим <strong>Addressables (Async)</strong>, ви ПОВИННІ використовувати <code>GetLocalizedAssetAsync<T>()</code> у ваших скриптах. Виклик синхронного <code>GetLocalizedAsset<T>()</code> поверне null і запише попередження, щоб запобігти зависанню головного потоку.",
  "li_notes_addressables_sync_warning": "<strong>Синхронний проти Асинхронного:</strong> Якщо ви переходите в режим <strong>Addressables (Async)</strong>, ви ПОВИННІ оновити свій код, щоб використовувати <code>GetLocalizedAssetAsync<T>()</code>. Виклик синхронного методу поверне null і запише попередження, щоб уникнути зависання головного потоку.",
  "li_preview_1": "<strong>Як це працює:</strong> Виберіть мову зі списку, і інструмент миттєво застосує відповідні переклади, шрифти, налаштування RTL та активи до всіх локалізованих об'єктів в активній сцені або відкритому префабі.",
  "li_preview_2": "<strong>Заповнювачі (Placeholders):</strong> Якщо на вкладці <strong>Settings</strong> обрано стиль заповнювача (наприклад, <strong>Accents</strong> або <strong>Brackets</strong>), замість фактичних перекладів у режимі попереднього перегляду відображатимуться ці заповнювачі. Це ідеально підходить для тестування макета та пошуку нелокалізованих елементів.",
  "li_preview_3": "<strong>Безпека:</strong> Усі зміни, зроблені в режимі попереднього перегляду, є тимчасовими. Інструмент автоматично поверне все у початковий стан, коли ви виберете «<strong>Revert to Original</strong>» (Повернути до Оригіналу), закриєте вікно, зміните сцени або перед збереженням сцени/префаба (завдяки компоненту <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Захист від Збоїв:</strong> Система автоматично створює резервну копію стану сцени в папку <code>Library</code> перед попереднім переглядом. Якщо Unity злетить або ви примусово закриєте його під час попереднього перегляду, інструмент виявить файл відновлення при наступному запуску і запропонує відновити початковий стан сцени.",
  "li_preview_overlay_1": "<strong>Доступ:</strong> Накладка автоматично з'являється у вікні Scene View. Ви можете перемикати її за допомогою меню Unity Overlay (клавіша <code>Space</code> у Scene View).",
  "li_preview_overlay_2": "<strong>Функціональність:</strong> Надає випадаючий список для швидкого перемикання поточної мови попереднього перегляду без відкриття головного вікна.",
  "li_report_1": "<strong>Категорії:</strong> Усі Ключі, Додані, Оновлені (текст змінено), Видалені, Дублікати, Мігровані, Пропущені (без змін).",
  "li_report_2": "<strong>Розширений Пошук:</strong> Натисніть кнопку <strong>Find</strong> (Знайти) поруч із будь-яким записом, щоб миттєво знайти відповідний об'єкт у проєкті. Пошук працює асинхронно, не блокуючи редактор, і шукає по всіх сценах та префабах.",
  "li_report_all_keys": "<strong>Усі ключі:</strong> Список усіх ключів локалізації, виявлених у проекті, з можливостями пошуку та фільтрації.",
  "li_report_btn_clear": "<strong>Очистити звіт:</strong> Видаляє всі результати сканування з пам'яті поточної сесії.",
  "li_report_btn_copy_all": "<strong>Копіювати всі ключі:</strong> Копіює всі ключі локалізації в поточній категорії до буфера обміну системи.",
  "li_report_btn_load_last": "<strong>Завантажити останнє сканування:</strong> Миттєво відновлює результати останнього аналізу проекту без повторного сканування.",
  "li_report_btn_save": "<strong>Зберегти звіт:</strong> Експортує поточні результати сканування у текстовий або CSV-файл для зовнішньої документації чи аудиту.",
  "li_report_source_filter": "<strong>Фільтр джерела:</strong> Звузьте результати за їх походженням (наприклад, показувати лише ключі, знайдені у сценаріях, сценах або Prefabs).",
  "li_safety_global_limit": "<strong>Глобальний місячний ліміт:</strong> <code>monthlyCharLimit</code> (за замовчуванням: 500 000 символів) діє як автоматичний вимикач для всіх запитів. Ви можете перемикати попередження за допомогою <code>enableApiLimitWarning</code>.",
  "li_safety_profile_limit": "<strong>Ліміти профілю:</strong> Кожен Профіль перекладу дозволяє встановити власні 'Max Chars Per Request' (Макс. символів на запит) та 'Batch Size' (Розмір пакета).",
  "li_settings_1": "<strong>Режим генерації ключів:</strong> Визначає стратегію створення унікальних ідентифікаторів для вашого тексту:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(За замовчуванням - Рекомендовано)</strong>: Генерує ключі на основі назви сцени/Prefab та ієрархії об'єктів (наприклад, <code>scene_Menu_BtnPlay_682412</code>). Найкраще підходить для великих проектів, оскільки гарантує унікальність та несприйнятливість до змін тексту.</li><li><code>UseTextAsKey</code>: Використовує сам вихідний текст як ключ (наприклад, \"Start Game\" → <code>Start Game</code>). Ідеально підходить для швидкого прототипування, де ключі мають бути легко читабельними.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Гібридний)</strong>: Найгнучкіший режим. Спершу перевіряє, чи має компонент вже призначений вручну ключ або <code>[LocalizableField(key=\"...\")]</code>. Якщо ключ відсутній, він генерує ієрархічний. <em>Використовуйте це, щоб зберегти існуючу роботу, автоматизуючи новий вміст.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Гібридний)</strong>: Як і вище, але повертається до самого тексту, якщо не знайдено ручного ключа. Поважає існуючі компоненти та дані.</li><li><code>Manual</code>: Сканер ніколи не створює нових ключів. Він оновлює лише об'єкти, які вже мають компонент локалізації з ключем. Ідеально підходить для суворого ручного контролю.</li></ul>",
  "li_settings_10": "<strong>Інструменти Розробника:</strong> Внизу вкладки Settings ви можете знайти службові кнопки, як-от <strong>Clear Saved Language Pref</strong> (скидає збережену мову у PlayerPrefs, щоб гра знову стартувала з Default language).",
  "li_settings_11": "<strong>Технічні Опції Dropdown:</strong> Список рядкових значень (за замовчуванням: 'Option A', 'Option B', 'Option C'), які парсер <strong>ігноруватиме</strong> при скануванні Dropdown'ів. Це запобігає засміченню вашої таблиці перекладів стандартним UI-текстом-заповнювачем від Unity.",
  "li_settings_2": "<strong>Керування Мовами:</strong><ul><li><strong>Source Language:</strong> Мова, що використовується у ваших сценах/префабах Unity (мова розробки).</li><li><strong>Default Language:</strong> Мова, обрана при першому запуску гри, якщо системна мова користувача не підтримується.</li><li><strong>Список:</strong> Керуйте підтримуваними мовами, призначайте певні <strong>Font Assets</strong> (Шрифтові Активи) та вмикайте підтримку <strong>RTL</strong>.</li></ul>",
  "li_settings_3": "<strong>Загальні налаштування:</strong> Конфігурація для поведінки в масштабах проекту:<ul><li><code>Translations Save Path</code>: Кореневий каталог для зберігання файлів перекладу <code>.json</code>. Для доступу в грі він має бути всередині <code>Assets/Resources</code> або <code>Assets/StreamingAssets</code>.</li><li><code>Safe Mode</code>: Захисний шар, який блокує операції (наприклад, автоматичний переклад), якщо виявлено невідповідності в проекті або відсутні залежності.</li><li><code>Remove Missing Keys</code>: Якщо ввімкнено, сканер автоматично видалить записи з бази даних, які більше не присутні в жодній сцені або Prefab під час оновлення проекту.</li><li><code>Parse Inactive Objects</code>: Визначає, чи повинен інструмент сканувати та локалізувати вимкнені або приховані GameObjects.</li><li><code>Parse All Prefabs</code>: Сканує кожен Prefab у проекті. Якщо вимкнено, обробляються лише Prefabs у папках, зазначених на вкладці <strong>Content</strong>.</li><li><code>Fill Comments By Paths</code>: Автоматично заповнює поле 'Comment' у таблиці перекладу шляхом ієрархії сцени/Prefab об'єкта.</li><li><code>Split Files by Language</code>: Розділяє базу даних перекладів на кілька файлів (наприклад, <code>en.json</code>, <code>ja.json</code>). Настійно рекомендується для великих проектів для зменшення накладних витрат пам'яті під час виконання.</li><li><code>Allow Empty Source/Keys</code>: Дозволяє інструменту реєструвати та відстежувати об'єкти, навіть якщо їх вихідний текст порожній. Корисно для динамічного тексту, який встановлюється виключно за допомогою коду.</li><li><code>Attach to Regex-Ignored Text</code>: Змушує інструмент додавати компоненти локалізації до об'єктів, текст яких відповідає регулярному виразу виключення (наприклад, числа), дозволяючи ручне перевизначення.</li><li><code>Find Settings Asset</code>: Кнопка-утиліта, яка миттєво 'пінгує' та вибирає файл <code>LocalizationSettings.asset</code> у вікні вашого проекту.</li></ul>",
  "li_settings_4": "<strong>Відлагодження та тестування:</strong><ul><li><code>Placeholder Style</code>: Виберіть стиль відображення заповнювачів у режимі попереднього перегляду.</li><li><code>Pseudo-Localization</code>: Виберіть <strong>'Користувацьке псевдо'</strong>, щоб відкрити розширені налаштування тестування макета (Expansion Factor, Accents та Delimiters).</li></ul>",
  "li_settings_5": "<strong>Живі Оновлення:</strong> Налаштування для завантаження перекладів з віддаленого сервера.",
  "li_settings_6": "<strong>Ключ API під час виконання:</strong> Надійно зберігає ваш ключ API для <strong>Live Updates</strong> (отримання нових перекладів у грі). Це відрізняється від ключів Служби перекладів, які використовуються в Editor. Ключ <strong>обфускований</strong> (зашифрований) у збірці, щоб запобігти легкому видобуванню за допомогою пошуку рядків, але пам'ятайте: жоден клієнтський секрет не є на 100% безпечним.",
  "li_settings_7": "<strong>Стратегія завантаження ресурсів:</strong> Вибір між <code>Resources (Legacy)</code>, <code>Addressables (Async)</code> та <code>Custom</code>. Увага: Зміна цього режиму вимагає повторного сканування проекту. Режим Addressables настійно рекомендується для мобільних пристроїв та WebGL для зменшення використання пам'яті.",
  "li_settings_8": "<strong>Автоматичний переклад:</strong> Використовує систему <strong>Профілів перекладу</strong> для локалізації за допомогою ШІ. Конфігурація включає:<ul><li><code>Text & Audio Profiles</code>: Виберіть або створіть профілі ScriptableObject для налаштування різних служб (наприклад, OpenAI, DeepL, Google).</li><li><code>Presets Folder</code>: Каталог, де зберігаються ваші пресети та профілі перекладу.</li><li><code>Target Languages</code>: Список усіх мов проекту зі статусом у реальному часі, індикаторами прогресу та кількістю символів для вибраного профілю.</li><li><code>Start Auto Translation</code>: Розпочинає процес для всіх вибраних мов за допомогою вказаних профілів.</li></ul>",
  "li_settings_9": "<strong>Покращення відлагодження:</strong><ul><li><code>Show Hierarchy Icons</code>: Відображає іконки статусу (зелена галочка / жовте попередження) в ієрархії. <strong>Оптимізовано для продуктивності:</strong> Використовує кешування для забезпечення відсутності затримок навіть у великих сценах.</li><li><code>Show Scene View Labels</code>: Візуальне відлагодження безпосередньо в Scene View. Мітки інтерактивні: Клацніть правою кнопкою миші на будь-якій мітці сцени, щоб миттєво скопіювати ключ локалізації до буфера обміну.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Правило структури папок:</strong> Визначає, як структуруються підпапки при генерації локалізованих активів (наприклад, <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Ім'я класу-мосту:</strong> Дозволяє налаштувати ім'я згенерованого статичного класу (за замовчуванням <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Безпечний режим:</strong> Забезпечує, що критичні операції не будуть виконуватися, якщо вони можуть спричинити неузгоджені стани проекту.",
  "li_settings_icons_legend": "<strong>Легенда Іконок Ієрархії:</strong><br>🟢 (Зелена Галочка): Локалізовано та встановлено Ключ.<br>🔴 (Червона Помилка): Локалізований компонент присутній, але <strong>Ключ відсутній</strong>.<br>🟡 (Жовте Попередження): Знайдено компонент Text/Image, але <strong>не приєднано Компонент Локалізації</strong>.<br>🐛 (Жук): Об'єкт <strong>Ігнорується</strong> налаштуваннями.",
  "li_settings_lang_culture_fallback": "<strong>Використовувати резервну культуру:</strong> Якщо відсутній певний регіональний діалект (наприклад, <code>en-AU</code>), інструмент спробує використати базову мову (<code>en</code>), перш ніж повернутися до <strong>Мови за замовчуванням</strong>.",
  "li_settings_lang_follow_system": "<strong>Слідувати системній мові:</strong> Автоматично перемикає мову гри відповідно до мови ОС гравця при першому запуску.",
  "li_settings_live_updates_security": "<strong>Безпека:</strong> ключі API під час виконання зашифровані (AES) у збірці, щоб запобігти випадковому видобуванню. Завжди використовуйте HTTPS.",
  "li_settings_pseudo_accents": "<strong>Використовувати акценти:</strong> Замінює стандартні символи версіями з акцентами (наприклад, <code>å</code>, <code>é</code>). Використовуйте це, щоб переконатися, що ваші шрифти підтримують усі необхідні гліфи.",
  "li_settings_pseudo_brackets": "<strong>Додати дужки:</strong> Огортає текст у <code>[ ]</code>, щоб перевірити початок і кінець локалізованих рядків, допомагаючи виявити проблеми з обрізанням або конкатенацією тексту.",
  "li_settings_pseudo_expand_length": "<strong>Розширити довжину:</strong> Імітує розширення тексту, поширене в таких мовах, як німецька або російська, додаючи кінцеві символи.",
  "li_settings_pseudo_expansion_factor": "<strong>Коефіцієнт розширення:</strong> Множник для симуляції довжини тексту (наприклад, 2.0 зробить текст у два рази довшим).",
  "li_settings_pseudo_prefix": "<strong>Власний префікс:</strong> Додає певний рядок (наприклад, <code>PSEUDO-</code>) на початок кожного локалізованого тексту.",
  "li_settings_pseudo_suffix": "<strong>Власний суфікс:</strong> Додає певний рядок у кінець кожного локалізованого тексту.",
  "li_settings_return_source": "<strong>Повернути джерело, якщо відсутнє:</strong> Якщо ввімкнено, система поверне текст вихідною мовою (або сам ключ), якщо переклад для поточної мови не знайдено.",
  "li_settings_tms_timeout": "<strong>Таймаут TMS:</strong> Визначає максимальний час очікування (у секундах) для мережевих запитів до зовнішніх служб TMS.",
  "li_settings_tool_check_deps": "<strong>Перевірити залежності:</strong> Повторно сканує проект на наявність необхідних пакетів (наприклад, Newtonsoft) та додаткових інтеграцій.",
  "li_settings_tool_cleanup": "<strong>Повне очищення проекту:</strong> Руйнівний інструмент, який видаляє всі компоненти та дані Anko Localization з проекту (використовуйте з обережністю!).",
  "li_settings_tool_clear_prefs": "<strong>Очистити налаштування мови:</strong> Скидає збережену мову в PlayerPrefs, змушуючи гру використовувати мову за замовчуванням або системну мову при наступному запуску.",
  "li_settings_tool_font_manager": "<strong>Менеджер шрифтів:</strong> Відкриває Менеджер шрифтів та гліфів для аналізу відсутніх символів та генерації оптимізованих активів шрифтів.",
  "li_settings_tool_migration": "<strong>Інструмент міграції:</strong> Сприяє переміщенню даних та компонентів з I2 Localization або Unity Localization.",
  "li_settings_tool_test_center": "<strong>Центр тестування локалізації:</strong> Діагностичний інструмент для перевірки стану проекту, пошуку непрацюючих посилань та забезпечення цілісності локалізації.",
  "li_setup_1": "<strong>Створення Налаштувань:</strong> При першому відкритті інструмент створить файл <code>LocalizationSettings.asset</code> у папці <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Налаштуйте мови та режим:</strong> На вкладці <strong>Налаштування</strong> переконайтеся, що ваша <strong>Вихідна мова</strong> вірна. Також перевірте <strong>Режим генерації ключів</strong> (за замовчуванням встановлено <code>AutoGenerateKeysOnly</code>, що рекомендовано для більшості проектів).",
  "li_setup_3": "<strong>Визначення Вмісту для Парсингу:</strong> На вкладці <strong>Content</strong> додайте всі сцени для аналізу до списку <strong>Scenes to Parse</strong> (Сцени для Парсингу). Якщо ви використовуєте префаби з текстом, переконайтеся, що їхні папки додано до <strong>Prefab Folders</strong> (Папки Префабів).",
  "li_setup_4": "<strong>Перший Запуск Парсера:</strong> Перейдіть на вкладку <strong>Actions</strong> та натисніть кнопку <code>Update Keys</code> (Оновити Ключі). Інструмент просканує ваш проєкт, створить файли перекладів та автоматично додасть необхідні компоненти (<code>LocalizedText</code>, <code>LocalizedAsset</code> тощо) до ігрових об'єктів.",
  "li_setup_5": "<strong>Налаштування та Збірки (КРИТИЧНО):</strong> Інструмент автоматично додає <code>LocalizationSettings.asset</code> до <code>Project Settings -> Player -> Preloaded Assets</code>. <br>⚠️ <strong>Перевірка Безпеки:</strong> Якщо налаштування відсутні у Preloaded Assets і не знаходяться у папці Resources, інструмент <strong>заблокує збірку</strong> з <code>BuildFailedException</code>, щоб запобігти збою гри на старті.",
  "li_sidebar_presets": "<strong>Пресети пошуку:</strong> Заздалегідь визначені фільтри для поширених завдань, таких як пошук неперекладених рядків або ключів із відсутніми заповнювачами.",
  "li_sidebar_search": "<strong>Глобальний пошук:</strong> Пошук певних ключів або тексту в усіх таблицях вашого проекту.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Потребує Project ID та API Key. Підтримує завантаження вихідного XLIFF та завантаження перекладів як ZIP-архів. <em>Додатково:</em> <code>File Name</code> (цільовий шлях у Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Потребує API Key. Проста та швидка інтеграція для менших проєктів. <em>Додатково:</em> <code>Import/Export Params</code> (дозволяє додавати додаткові прапорці Loco API, такі як <code>&tag=v1</code> або <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Корпоративний рівень управління локалізацією. <em>Додатково:</em> Прапорці <code>Update Translations/Descriptions</code> для керування тим, чи Phrase перезаписує існуючі дані під час завантаження.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Підтримує slugs організації/проєкту та автентифікацію за допомогою API Token. <em>Додатково:</em> <code>Resource Slug</code> (автоматично створює ресурс, якщо він не існує).",
  "li_tutorials_1": "<strong>Інтерактивне навчання:</strong> Посібники виділяють певні елементи інтерфейсу користувача та чекають ваших дій.",
  "li_tutorials_2": "<strong>Доступні уроки:</strong>",
  "li_tutorials_editor": "<strong>Редактор перекладу:</strong> Розширені можливості редактора, схожого на електронну таблицю.",
  "li_tutorials_list": "<strong>Список посібників:</strong> Отримуйте доступ до інтерактивних посібників з основних функцій інструменту.",
  "li_tutorials_migration": "<strong>Міграція:</strong> Як перейти з інших систем локалізації (I2, Unity Localization).",
  "li_tutorials_quickstart": "<strong>Швидкий старт:</strong> Базове налаштування для тексту та ассетів.",
  "li_tutorials_size": "<strong>Розмір посібника:</strong> Налаштовує масштаб інтерфейсу та деталізацію інтерактивних посібників (від компактного до дуже великого). Розташовано в заголовку вкладки «Посібники».",
  "li_vis_debug_1": "<strong>Іконки ієрархії:</strong> Миттєво виявляйте проблеми (Відсутній ключ, Відсутній компонент). Оптимізовано для нульового впливу на продуктивність.",
  "li_vis_debug_2": "<strong>Мітки у Scene View:</strong> Відображає ключ над кожним локалізованим об'єктом. <strong>Натисніть правою кнопкою миші</strong> на мітку, щоб 'Copy Key' (Скопіювати ключ) або 'Select Object' (Вибрати об'єкт).",
  "li_vis_debug_3": "<strong>Накладки:</strong> Використовуйте накладку у Scene View (пробіл) для миттєвого перемикання мов попереднього перегляду.",
  "lightbox_aria_close": "Закрити переглядач зображень",
  "lightbox_image_alt": "Збільшений вигляд",
  "mindmap_edge_configure": "1. Налаштувати",
  "mindmap_edge_creates_components": "Створює Компоненти",
  "mindmap_edge_defines_rules": "Визначає правила для",
  "mindmap_edge_edited_in": "Редагується у",
  "mindmap_edge_enables_reaction": "Вмикає реакцію через",
  "mindmap_edge_extends": "Розширює",
  "mindmap_edge_generates": "Генерує",
  "mindmap_edge_manages_assets": "Керує активами для",
  "mindmap_edge_opens": "Відкриває",
  "mindmap_edge_parse_project": "3. Парсити Проєкт",
  "mindmap_edge_processed_by": "Обробляється",
  "mindmap_edge_recommends_for": "Рекомендує для",
  "mindmap_edge_relates_to": "Стосується",
  "mindmap_edge_reports_on": "Звітує щодо",
  "mindmap_edge_see_faq": "Див. FAQ",
  "mindmap_edge_specify_content": "2. Вказати Вміст",
  "mindmap_edge_warns_about": "Попереджає про",
  "mindmap_node_ai_ecosystem": "Екосистема ШІ",
  "mindmap_node_async_code": "Асинхронність / Addressables",
  "mindmap_node_dev_tools": "Інструменти та утиліти",
  "mindmap_node_tms_integration": "Інтеграція TMS",
  "mindmap_preset_ai": "ШІ та автоматизація",
  "mindmap_preset_dev": "Робочий Процес Розробника",
  "mindmap_preset_full": "Повний Перегляд",
  "mindmap_preset_quick_start": "Швидкий Старт",
  "mindmap_preset_tools": "Інструменти та інтеграції",
  "mindmap_preset_translator": "Робочий Процес Перекладача",
  "mindmap_toggle_title": "Показати Mind Map",
  "my_notes_title": "Мої Примітки",
  "no_notes_message_new": "Наведіть курсор на текст, щоб додати примітку.",
  "notes_add_title": "Додати примітку до цього блоку",
  "notes_close_title": "Закрити",
  "notes_delete_title": "Видалити примітку",
  "notes_edit_text": "Редагувати",
  "notes_edit_title": "Редагувати примітку",
  "notes_goto_title": "Перейти до тексту",
  "notes_placeholder": "Ваша примітка...",
  "on_this_page_title": "На Цій Сторінці",
  "p_actions_1": "Основна робоча вкладка.",
  "p_ai_assistant": "У Редакторі Таблиці Перекладів ви тепер можете запускати власні команди ШІ на вибраних комірках через контекстне меню (Правий клік -> AI: ...).",
  "p_ai_audio_economy": "<strong>Економія Коштів:</strong> Інструмент обчислює хеш MD5 вашого тексту та регенерує аудіофайли лише в тому випадку, якщо вихідний текст змінився, заощаджуючи ваші API-кредити. Якщо ви змінюєте переклад, система позначає лише цей конкретний аудіофайл як 'Outdated'. Використовуйте 'Generate Missing/Outdated' для регенерації лише того, що змінилося, заощаджуючи API-кредити. Інструмент хешує ваш текст та регенерує аудіофайли лише в тому випадку, якщо вихідний текст змінився, заощаджуючи ваші API-кредити через розумне пакетування.",
  "p_ai_context": "Для покращення якості перекладу ШІ тепер отримує додатковий контекст:",
  "p_ai_intro": "Інструмент використовує систему <strong>Профілів перекладу</strong> (ScriptableObject). Це зберігає налаштування служб перекладу в окремих ресурсних профілях, дозволяючи легко перемикати конфігурації.",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code> надає надійний API для управління локалізацією під час виконання. Нижче наведено ключові методи, які ви будете використовувати у своїх скриптах.",
  "p_assets_1": "Ця вкладка повністю присвячена локалізації нетекстових ресурсів.",
  "p_async_api": "При використанні Addressables ресурси не завантажуються миттєво. Потрібно використовувати асинхронний API, щоб запобігти падінню кадрів.",
  "p_bridge_description": "Інструмент включає генератор статичних класів для доступу до ключів, що дозволяє використовувати строго типізовані посилання замість \"магічних\" рядків. Це допомагає запобігти одруківкам і вмикає автозавершення в IDE.",
  "p_bridge_usage_title": "Приклад використання:",
  "p_components_intro": "Ці компоненти є «містком» між вашими об'єктами на сцені та базою даних перекладів. Вони «слухають» зміни мови та автоматично підставляють коректний текст або актив.",
  "p_content_1": "Тут ви вказуєте інструменту, де саме шукати текст. Інтерфейс був повністю перероблений для кращої зручності використання.",
  "p_custom_ai": "Тип сервісу <strong>Custom AI</strong> дозволяє підключати будь-яку LLM через REST API.",
  "p_custom_asset_provider_1": "Розробка власного постачальника дозволяє інтегрувати вашу власну систему керування активами (наприклад, власний хмарний завантажувач, конкретну внутрішню систему комплектування або репозиторій активів на основі бази даних) безпосередньо в робочий процес локалізації.",
  "p_custom_asset_provider_intro": "Система Asset Provider абстрагує спосіб завантаження ресурсів (Sprites, Audio, Prefabs тощо) під час виконання. Вона використовує <strong>Plugin Registry</strong>, який автоматично виявляє будь-яку реалізацію класу <code>IAssetProvider</code>, позначену атрибутом <code>[AssetProviderPlugin]</code>. Це дозволяє безшовно інтегрувати власні системи завантаження (як-от хмарні завантажувачі або внутрішнє об'єднання в пакети) без зміни основного інструментарію.",
  "p_custom_attributes_description": "На додаток до викликів функцій, ви можете позначити будь-яке рядкове поле у ваших сценаріях як локалізоване за допомогою користувацьких атрибутів. За замовчуванням інструмент розпізнає <code>[LocalizableField]</code>, але ви можете додати будь-яку назву атрибута (наприклад, <code>[Header]</code> або <code>[Tooltip]</code>) до списку <strong>Атрибутів для сканування</strong>.",
  "p_custom_parser_1": "Ви можете легко розширити систему для підтримки власних компонентів, створивши свій власний клас парсера.",
  "p_editor_1": "Відкривається через <strong>Tools -> Localization -> Translation Table Editor</strong>. Це основний інструмент для ручного редагування перекладів.",
  "p_example_attribute_1": "Найпотужніший спосіб локалізувати змінні скриптів. Працює з <strong>private, protected, and public</strong> полями. Парсер рекурсивно обробляє <strong>Arrays, Lists</strong>, та <strong>Nested Serializable Classes</strong>. Він навіть може генерувати ключі для інших атрибутів (наприклад <code>[Header]</code> або <code>[Tooltip]</code>), якщо це налаштовано в Settings.",
  "p_example_components_1": "Проєкт містить готові до використання скрипти, що слугують чудовими прикладами.",
  "p_example_components_updated": "Код змінився. Завантаження мови (особливо при використанні Addressables) тепер асинхронне.",
  "p_example_function_1": "Використовуйте функцію <code>_()</code> для динамічного тексту, який змінюється під час ігрового процесу. Метод, що оновлює UI, повинен бути позначений атрибутом <code>[OnLanguageChange]</code>, щоб він викликався автоматично при зміні мови. Для цього до об'єкта буде автоматично додано компонент <code>LocalizedBehaviour</code>.",
  "p_example_plurals_1": "Інструмент тепер використовує точніші правила для різних мовних груп.",
  "p_font_glyph_manager_access": "Доступ через <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "Цей інструмент є комплексним рішенням для локалізації ігор та додатків у Unity. Він автоматизує процес збору тексту й активів, керування перекладами через потужний інтерфейс, інтеграцію із сервісами машинного перекладу (включно з Власним ШІ) та динамічне оновлення локалізованого контенту в грі.",
  "p_live_updates_guide": "Система Live Updates дозволяє вашій грі отримувати нові переклади з віддаленого сервера або Google Sheet під час виконання, без необхідності створення нового білду.",
  "p_localizedasset_1": "Використовується для заміни активів залежно від мови. Автоматично визначає тип компонента. Підтримує: <ul><li><strong>2D:</strong> Спрайти (<code>Image</code>, <code>SpriteRenderer</code>), Текстури (<code>RawImage</code>).</li><li><strong>Аудіо/Відео:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Анімація:</strong> <code>MeshFilter</code> (Меші), <code>Renderer</code> (Матеріали), <code>Animator</code> (Контролер), <code>PlayableDirector</code> (Таймлайн).</li></ul>",
  "p_localizedasset_2": "Для компонентів з опцією <strong>Play on Awake</strong> (як-от <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> коректно перехоплює автозапуск, замінює актив, а потім ініціює відтворення, щоб уникнути програвання нелокалізованого контенту.",
  "p_localizedasset_updated": "Компонент тепер підтримує асинхронне завантаження. Зверніть увагу, що може бути невелика затримка при зміні мови, якщо активи завантажуються з хмари/диска (Addressables).",
  "p_localizedbehaviour_1": "Допоміжний компонент, що дозволяє вашим скриптам реагувати на зміну мови. Він автоматично знаходить та викликає методи, позначені атрибутом <code>[OnLanguageChange]</code>.",
  "p_localizeddropdown_1": "Додається до <code>Dropdown</code> та <code>TMP_Dropdown</code> для перекладу їхніх опцій.",
  "p_localizedprefab_1": "Компонент для локалізації цілих префабів. Працює неруйнівно: не модифікує оригінальний префаб, а створює екземпляр локалізованої версії як дочірній об'єкт, вимикаючи всі скрипти (<code>MonoBehaviour</code>), рендерери (<code>Renderer</code>) та колайдери (<code>Collider</code>) на оригінальному об'єкті. Це запобігає подвійному виконанню логіки та візуальним артефактам. Для коректної роботи в рантаймі його порядок виконання встановлено на -100 (<code>[DefaultExecutionOrder(-100)]</code>), щоб забезпечити його запуск перед іншими скриптами.",
  "p_localizedtext_1": "Основний компонент для відображення перекладеного тексту. Розміщується на об'єктах з <code>Text</code>, <code>TMP_Text</code> та <code>TextMesh</code>.",
  "p_migration_custom": "Ви можете створювати власні профілі міграції для підтримки користувацьких систем або конкретних налаштувань проєкту. Кожен профіль містить список <strong>Правил</strong>, які визначають, як компоненти та їхні поля мають бути перетворені. Правила перевіряються в порядку їхнього <strong>Пріоритету</strong>.",
  "p_migration_custom_advanced": "Профілі міграції пропонують розширені налаштування для тонкого налаштування процесу імпорту та виявлення:",
  "p_migration_google_sheet": "Ви можете імпортувати безпосередньо з URL Google Sheet без завантаження файлів.",
  "p_migration_import_csv": "Інструмент підтримує стандартні файли CSV (розділені комами). Перший рядок має бути заголовком.",
  "p_migration_stubs": "Поширеною проблемою під час міграції є те, що видалення старого плагіна (наприклад, I2) ламає білд, не дозволяючи Unity скомпілювати сам Інструмент Міграції.",
  "p_migration_tool_access": "Доступ через <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Інструмент для переходу з інших систем локалізації (I2 Localization, Unity Localization).",
  "p_preview_1": "Прямо під заголовком знаходиться випадаючий список <strong>Preview Language</strong> (Мова Попереднього Перегляду). Ця потужна функція дозволяє вам побачити, як виглядатиме локалізація будь-якою мовою безпосередньо у вікні <strong>Scene</strong> або <strong>Prefab Mode</strong>, не запускаючи гру.",
  "p_preview_overlay": "Для ще швидшої ітерації ви можете перемикати мови безпосередньо з Scene View за допомогою спеціального <strong>Localization Preview Overlay</strong>.",
  "p_report_1": "Після кожного парсингу цей звіт показує повну картину стану вашої локалізації.",
  "p_safety_caps": "Щоб запобігти випадковим високим витратам або великим перевіркам трафіку:",
  "p_script_parsing_rules_description": "Інструмент може бути налаштований на розпізнавання ключів локалізації, що використовуються в користувацьких функціях або навіть у конкуруючих системах (наприклад, I2 Localization), без зміни вашого існуючого коду. Це досягається шляхом визначення шаблонів регулярних виразів, які сканер використовує для вилучення ключів з ваших сценаріїв.",
  "p_script_parsing_rules_usage": "На вкладці <strong>Вміст</strong>, у розділі <strong>Правила аналізу сценаріїв</strong>, ви можете додати правила, які відповідають вашим конкретним викликам функцій. Наприклад, щоб підтримати <code>I2.Loc.Get(\"key\")</code>, ви можете додати правило з шаблоном, який захоплює рядок всередині дужок.",
  "p_settings_1": "Ваш центр керування. Тут ви визначаєте глобальні правила для всього процесу локалізації.",
  "p_tms_intro": "Тепер інструмент підтримує синхронізацію з популярними системами управління перекладами. Ви можете надсилати вихідні ключі та отримувати переклади безпосередньо в Unity.",
  "p_tms_setup": "1. Перейдіть до <strong>Settings -> TMS Integration</strong>.<br>2. Виберіть вашого постачальника послуг.<br>3. Введіть API Keys та Project IDs.<br>4. Використовуйте кнопки <strong>Push</strong> (Upload Keys) та <strong>Pull</strong> (Download Translations) у вікні Settings.",
  "p_tutorials_1": "Вкладка «Посібники» надає інтерактивні покрокові посібники, які допоможуть вам освоїти функції інструменту безпосередньо в редакторі Unity.",
  "p_uitklocalization_1": "Додається до об'єктів із <code>UIDocument</code>. Підтримує локалізацію <strong>Міток, Кнопок, HelpBox, Foldout, ProgressBar (заголовок), TextField (мітка та заповнювач), DropdownField (мітка та варіанти), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+) та Підказок</strong> на будь-якому елементі. Ідентифікатори є стабільними при перейменуванні, якщо ідентифікатори встановлені в UI Builder.",
  "p_window_footer": "Відображає поточний статус, хід фонових операцій та версію інструменту.",
  "p_window_header": "Верхня панель надає глобальний доступ до елементів керування попереднім переглядом та утиліт, які зберігаються незалежно від обраної вкладки.",
  "p_window_sidebar": "Бічна панель забезпечує навігацію між різними функціональними вкладками та глобальними інструментами пошуку.",
  "page_title": "Документація Інструмента Локалізації Unity",
  "q_faq_addressables_1": "Я ввімкнув режим Addressables, але активи не завантажуються. Що мені слід перевірити?",
  "q_faq_addressables_2": "Як додати підтримку DeepL/Google?",
  "q_faq_addressables_3": "Мігратор показує помилки компіляції після видалення I2/UnityLoc. Як це виправити?",
  "q_faq_audio_smart_update": "Як інструмент заощаджує API-кредити при регенерації аудіофайлів?",
  "q_faq_components_1": "Компонент LocalizedPrefab вимикає MonoBehaviours на оригінальному об'єкті. Що робити, якщо оригінальний об'єкт має скрипт, який створює інші об'єкти або підписується на події в Awake()?",
  "q_faq_components_2": "Якщо оригінальний префаб (LocalizedPrefab) має Rigidbody або інший фізичний компонент, чи буде він вимкнений? Чи вплине це на фізику, якщо локалізований префаб його не має?",
  "q_faq_components_3": "Компонент LocalizedAsset зберігає ім'я цільового компонента як рядок (_targetComponentTypeName). Що станеться, якщо я перейменую скрипт власного компонента або переміщу його до іншої збірки (Assembly Definition)? Чи перестане LocalizedAsset для нього працювати?",
  "q_faq_components_4": "Якщо на одному GameObject є два компоненти Image, як LocalizedAsset дізнається, який з них локалізувати? Чи працюватиме він з обома, чи лише з першим, який знайде?",
  "q_faq_components_5": "У документації зазначено, що LocalizedPrefab має порядок виконання -100. Що, якщо у мене є інший скрипт з порядком виконання -110, який намагається знайти дочірній об'єкт, створений LocalizedPrefab, у своєму Awake()? Чи встигне LocalizedPrefab інстанціювати свій екземпляр?",
  "q_faq_components_6": "Компонент LocalizedText має опцію isStyleOnly. Якщо я її увімкну, а потім викличу myLocalizedText.SetFormattedText(\"new_key\") у коді, чи зміниться текст, чи лише стиль (шрифт/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour автоматично знаходить методи з атрибутом [OnLanguageChange]. Чи знайде він приватні та захищені методи, чи вони повинні бути публічними?",
  "q_faq_components_8": "Компонент LocalizedAsset перехоплює Play on Awake. Що станеться, якщо інший скрипт на тому ж об'єкті спробує отримати доступ до активу (наприклад, audioSource.clip.length) у Awake() або Start() до того, як LocalizedAsset його замінив? Чи можлива NullReferenceException або використання старого активу?",
  "q_faq_custom_keys_attribute": "Чи можу я використовувати свій власний атрибут для ключів замість [LocalizableField]?",
  "q_faq_custom_provider_1": "Чому мій користувацький постачальник не відображається у випадаючому списку Налаштувань?",
  "q_faq_editor_1": "Що має вищий пріоритет для валідації заповнювачів: директива @placeholders: у коментарі чи заповнювачі, знайдені у вихідному тексті мови? Наприклад, якщо у вихідному тексті є {name}, а коментар говорить @placeholders: {username}.",
  "q_faq_editor_2": "Якщо я зроблю опечатку в директиві (наприклад, @placeholder: замість @placeholders:), чи буде вона проігнорована, чи інструмент видасть попередження?",
  "q_faq_editor_3": "Система автозбереження створює файли у папці Backups/AutoSaves. Чи будуть ці файли автоматично видалені після успішного ручного збереження або закриття вікна?",
  "q_faq_editor_4": "Якщо я змінюю ширину стовпців у редакторі, чи будуть ці налаштування збережені між сесіями Unity?",
  "q_faq_editor_5": "Чи підтримує спливаюче вікно редагування тексту (MultiLineEditWindow) власний стек Undo/Redo (через Ctrl+Z) для змін, внесених у ньому?",
  "q_faq_examples_1": "Що станеться, якщо імена властивостей в анонімному типі, переданому функції _(), не збігаються із заповнювачами у рядку? Наприклад, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Чи буде помилка, чи заповнювач просто не буде замінений?",
  "q_faq_examples_2": "Атрибут [LocalizableField] працює для приватних полів. Чи працюватиме він для статичних полів?",
  "q_faq_examples_3": "Якщо я поставлю атрибут [OnLanguageChange] на метод з параметрами (наприклад, void UpdateUI(string newLang)), що станеться? Чи буде помилка компіляції чи попередження в рантаймі?",
  "q_faq_examples_4": "Я використовую _(\"apple_count\", count). Якщо для поточної мови (для count = 1) немає ключа apple_count_one, яку форму обере система? Чи використовуватиме вона apple_count_other як резервний варіант?",
  "q_faq_examples_5": "Функція _(\"key\", new { username = \"Alex\" }) використовує анонімний тип. Чи не створить це надмірне «навантаження» на збирач сміття (GC) при частих викликах у методі Update() порівняно з передачею попередньо створеного Dictionary<string, object>?",
  "q_faq_examples_6": "Мій метод, позначений [OnLanguageChange], не викликається. Чому?",
  "q_faq_extending_1": "Чи буде мій власний парсер викликатися автоматично після кожного Update Keys? Чи потрібно його десь реєструвати, чи достатньо просто мати клас, який реалізує ITextComponentParser у проєкті?",
  "q_faq_extending_2": "Що, якщо у моєму власному парсері виникне виняток? Чи перерве це весь процес парсингу, чи інструмент безпечно продовжить роботу з іншими парсерами?",
  "q_faq_installation_1": "Що станеться, якщо у моєму проєкті вже є пакет com.unity.nuget.newtonsoft-json від іншого активу? Чи спробує інсталятор залежностей його оновити чи проігнорує?",
  "q_faq_installation_2": "Я випадково натиснув «Skip for Now» та обрав «Don't ask again» для необов'язкових залежностей (наприклад, для підтримки CSV). Як знову викликати вікно інсталятора, щоб їх встановити?",
  "q_faq_installation_3": "Інструмент не створив LocalizationSettings.asset у Assets/Resources. Чому це могло статися, і чи можу я створити його вручну через меню Assets -> Create?",
  "q_faq_installation_4": "Чи можна перемістити файл LocalizationSettings.asset до іншої папки Resources, наприклад, Assets/MyGame/Resources? Чи знайде його інструмент?",
  "q_faq_installation_5": "Інсталятор залежностей завис або видав помилку. Чи можу я встановити залежності (Newtonsoft Json, Editor Coroutines) вручну через Unity Package Manager?",
  "q_faq_notes_1": "У документації рекомендується додати LanguageSelector до списку ігнорування. Що саме зламається, якщо я забуду це зробити? Чи будуть створені зайві ключі для «Option A, Option B»?",
  "q_faq_notes_2": "Якщо я забуду додати порожній LocalizedText з прапорцем isStyleOnly на Label всередині TMP_Dropdown, який використовується LanguageSelector, чи не зміниться шрифт? Чому це необхідно?",
  "q_faq_notes_3": "Викликати _() у методі Update() не рекомендовано. Але що, якщо мені потрібно оновлювати текст щокадру (наприклад, таймер)? Який найбільш продуктивний спосіб зробити це, кешуючи лише рядок формату?",
  "q_faq_tts_voices": "Як призначити певні голоси персонажам?",
  "q_faq_window_actions_1": "Що станеться, якщо під час пакетного автоперекладу буде втрачено інтернет-з'єднання? Чи спробує інструмент повторно надіслати невдалий пакет відповідно до Retry Policy, чи процес буде повністю перервано?",
  "q_faq_window_actions_2": "Якщо я імпортую CSV-файл, який містить ключі, що вже існують у проєкті, але з порожніми значеннями для деяких мов, чи замінять ці порожні значення мої існуючі переклади, чи будуть проігноровані?",
  "q_faq_window_actions_3": "Розділ «Danger Zone» дозволяє видалити всі компоненти. Чи видалить він компоненти з префабів, які знаходяться в папках, не вказаних у Prefab Folders на вкладці Content?",
  "q_faq_window_actions_4": "При імпорті з Google Sheets, як слід форматувати стовпець коментарів, щоб працювала валідація заповнювачів за допомогою директиви @placeholders:?",
  "q_faq_window_actions_5": "Чи може інструмент імпортувати дані з кількох аркушів одного документа Google Sheets, чи він працює лише з одним аркушем за GID?",
  "q_faq_window_assets_1": "Що, якщо у мене є два активи з однаковим ключем, але різними типами в одній папці сканування (наприклад, sound_effect_en.mp3 та sound_effect_en.wav)? Який із них потрапить до таблиці активів?",
  "q_faq_window_assets_2": "Якщо я натисну Scan Assets & Analyze Project, і на сцені є об'єкт Image, для якого вже існує локалізований спрайт, але сам об'єкт Image ще не має компонента LocalizedAsset, чи додасть інструмент компонент і автоматично вставить ключ?",
  "q_faq_window_assets_3": "Чи можу я використовувати те саме Naming Rule для різних категорій активів, якщо вони мають різні Scan Folders? Чи спричинить це конфлікти?",
  "q_faq_window_assets_4": "Якщо локалізований актив (наприклад, button_ok_en.png) знаходиться не у корені Scan Folder, а у підпапці, чи знайде його сканер?",
  "q_faq_window_content_1": "Що, якщо я додам до Scenes to Parse сцену, яка не включена до Build Settings? Чи вплине це на щось, крім самого процесу парсингу?",
  "q_faq_window_content_2": "Я додав об'єкт до Ignore Specific Objects (тимчасового списку). Якщо я зроблю префаб із цього об'єкта, чи буде екземпляр цього префаба також ігноруватися?",
  "q_faq_window_content_3": "Якщо я додам компонент TMPro.TMP_Text до Parsing Ignores -> Ignore Component Types, але на сцені є об'єкт з LocalizedText, який вже посилається на цей TMP_Text, що станеться при наступному Update Keys? Чи буде ключ видалено?",
  "q_faq_window_content_4": "У документації сказано, що «Pin» зберігає повний шлях до об'єкта і зламається, якщо його перейменувати. Що, якщо я зроблю префаб з об'єкта, а потім перейменую оригінальний об'єкт — чи продовжить «Pin» працювати для екземплярів префаба?",
  "q_faq_window_content_5": "Якщо я використаю «Pin» для дочірнього об'єкта всередині екземпляра префаба, який шлях буде збережено: відносно кореня префаба чи кореня сцени? Чи працюватиме це в інших сценах?",
  "q_faq_window_preview_1": "Я відкрив префаб у Prefab Mode, застосував In-Editor Preview і натиснув Ctrl+S. Чи буде тимчасові дані попереднього перегляду збережено в актив префаба? Як LocalizationPreviewProtector обробляє цей випадок?",
  "q_faq_window_preview_2": "Якщо я ввімкну In-Editor Preview, і редактор Unity злетить, а файл Temp/localization_preview_recovery.json буде пошкоджено (наприклад, порожній або недійсний JSON), що станеться при наступному запуску?",
  "q_faq_window_preview_3": "У режимі In-Editor Preview для LocalizedPrefab створюється тимчасовий екземпляр. Чи будуть на цьому екземплярі виконані методи Awake() та Start()? Чи може це спричинити помилки, якщо вони не розраховані на запуск у Edit Mode?",
  "q_faq_window_report_1": "Кнопка «Find» шукає об'єкт асинхронно. Що, якщо я розпочну пошук, а потім одразу натисну Update Keys? Чи буде пошук перервано?",
  "q_faq_window_report_2": "Якщо ключ використовується у кількох місцях (наприклад, на двох різних кнопках у різних сценах), як це буде відображено у звіті в категорії «Duplicates» (Дублікати)?",
  "q_faq_window_report_3": "Якщо я натисну «Find» для ключа, який використовується лише в коді (через функцію _()), що станеться? Чи зможе інструмент знайти та підсвітити C#-скрипт?",
  "q_faq_window_settings_1": "Я можу змінити Key Generation Mode з UseTextAsKey на AutoGenerateKeysOnly посеред проєкту. Що саме станеться з моїми існуючими перекладами? Чи будуть вони відображені на нові ключі?",
  "q_faq_window_settings_2": "Якщо я додам до списку Supported Languages мову з кодом, для якої немає правил множини (наприклад, «kz» для казахської), яке правило використовуватиметься за замовчуванням?",
  "q_faq_window_settings_3": "Що, якщо я вкажу Translations Path не в StreamingAssets, а у звичайній папці, як-от Assets/MyTranslations? Чи будуть json-файли включені до збірки гри?",
  "q_faq_window_settings_4": "API-ключ автоперекладу зберігається в EditorPrefs. Якщо я працюю над проєктом на двох різних комп'ютерах, чи потрібно мені вводити ключ на кожній машині окремо?",
  "tip_best_practice": "<strong>Професійна порада:</strong> Якщо вам потрібно локалізувати властивість, створіть резервне поле з `[LocalizableField]` і відкрийте властивість окремо.",
  "toc_search_placeholder": "Пошук документації...",
  "toc_title": "Зміст",
  "toggle_notes_title": "Перемкнути Примітки",
  "warning_box_components": "<strong>Важливе Зауваження:</strong> Усі описані нижче компоненти додаються до ігрових об'єктів автоматично під час парсингу (коли ви натискаєте кнопку <code>Update Keys</code>). Вам не потрібно додавати їх вручну.",
  "warning_tms_overwrite": "<strong>Warning:</strong> Завантаження з TMS перезапише локальні переклади для відповідних ключів. Переконайтеся, що ваш TMS є єдиним джерелом правди."
}