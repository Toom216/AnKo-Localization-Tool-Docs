{
    "page_title": "Документація інструменту локалізації для Unity",
    "toc_title": "Зміст",
    "toc_search_placeholder": "Пошук по документації...",
    "nav_introduction": "1. Вступ",
    "nav_quick_start": "2. Швидкий старт",
    "nav_components": "3. Основні компоненти",
    "nav_loc_tool_window": "4. Вікно \"Localization Tool\"",
    "nav_translation_editor": "5. Редактор перекладів",
    "nav_usage_examples": "6. Приклади використання",
    "nav_important_notes": "7. Важливі примітки",
    "nav_extending": "8. Розширення функціоналу",
    "nav_faq": "9. ЧаПи та вирішення проблем",
    "nav_key_features": "Ключові особливості",
    "nav_installation": "2.1. Встановлення",
    "nav_initial_setup": "2.2. Початкове налаштування",
    "nav_localizedtext": "3.1. LocalizedText",
    "nav_localizedasset": "3.2. LocalizedAsset",
    "nav_localizedprefab": "3.3. LocalizedPrefab",
    "nav_uitklocalization": "3.4. UITKLocalization",
    "nav_localizeddropdown": "3.5. LocalizedDropdown",
    "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
    "nav_context_menu": "3.7. Контекстне меню",
    "nav_in_editor_preview": "4.1. Попередній перегляд у редакторі",
    "nav_tab_settings": "4.2. Вкладка \"Налаштування\"",
    "nav_tab_content": "4.3. Вкладка \"Вміст\"",
    "nav_tab_actions": "4.4. Вкладка \"Дії\"",
    "nav_tab_assets": "4.5. Вкладка \"Асети\"",
    "nav_tab_report": "4.6. Вкладка \"Звіт\"",
    "nav_example_components": "6.1. Готові компоненти",
    "nav_example_attribute": "6.2. Атрибут [LocalizableField]",
    "nav_example_function": "6.3. Функція _()",
    "nav_example_plurals": "6.4. Множина та рід",
    "nav_custom_parser": "8.1. Створення парсера",
    "nav_faq_installation": "9.1. Встановлення та швидкий старт",
    "nav_faq_components": "9.2. Основні компоненти",
    "nav_faq_window": "9.3. Вікно \"Localization Tool\"",
    "nav_faq_window_actions": "9.3. Вікно \"Localization Tool\" - Вкладка \"Дії\"",
    "nav_faq_window_assets": "9.3. Вікно \"Localization Tool\" - Вкладка \"Асети\"",
    "nav_faq_window_report": "9.3. Вікно \"Localization Tool\" - Вкладка \"Звіт\"",
    "nav_faq_editor": "9.4. Редактор перекладів",
    "nav_faq_examples": "9.5. Приклади використання та код",
    "nav_faq_notes": "9.6. Важливі нюанси та попередження",
    "nav_faq_extending": "9.7. Розширення функціоналу",
    "h1_introduction": "Вступ",
    "p_intro_1": "Цей інструмент є комплексним рішенням для локалізації ігор та додатків у Unity. Він автоматизує процес збору тексту та асетів, керування перекладами через потужний інтерфейс, інтеграцію з сервісами машинного перекладу та динамічне оновлення локалізованого контенту в грі.",
    "h2_key_features": "Ключові особливості",
    "li_feature_1": "<strong>Розширений парсинг:</strong> Автоматичне сканування сцен, префабів, UI Toolkit (UXML) та C# скриптів, включаючи поля, позначені атрибутом <code>[LocalizableField]</code>, а також вкладені класи та списки.",
    "li_feature_2": "<strong>Локалізація будь-яких асетів:</strong> Керуйте спрайтами, аудіо, префабами, матеріалами тощо.",
    "li_feature_3": "<strong>Потужний редактор перекладів:</strong> Централізований інтерфейс з автозбереженням, повною підтримкою Undo/Redo та розумним групуванням ключів.",
    "li_feature_4": "<strong>Машинний переклад:</strong> Інтеграція з DeepL, Google Translate та Microsoft Translator з гнучкими налаштуваннями (розмір пакета, кількість повторних спроб) для кожного сервісу.",
    "li_feature_5": "<strong>Гнучкий імпорт/експорт:</strong> Підтримка CSV, XML, YAML, XLIFF та прямого імпорту з Google Таблиць.",
    "li_feature_6": "<strong>Попередній перегляд у редакторі:</strong> Переглядайте будь-яку мову, не запускаючи гру.",
    "li_feature_7": "<strong>Підтримка множини та роду:</strong> Коректна обробка форм множини (з правилами для слов'янських, арабських та інших мов) та роду.",
    "li_feature_8": "<strong>Повна підтримка RTL:</strong> Коректне відображення мов, що пишуться справа наліво.",
    "li_feature_9": "<strong>Оновлення в реальному часі:</strong> Завантажуйте актуальні переклади з віддаленого сервера при старті гри.",
    "li_feature_10": "<strong>Менеджер резервних копій:</strong> Вбудований інструмент для створення та відновлення резервних копій.",
    "h1_quick_start": "Швидкий старт та налаштування",
    "h2_installation": "2.1. Встановлення",
    "li_install_1": "Скопіюйте асет у папку вашого проєкту Unity.",
    "li_install_2": "Інструмент автоматично перевірить наявність необхідних залежностей. Підтвердіть встановлення у діалоговому вікні, що з'явиться.",
    "li_install_3": "Необхідні залежності (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) потрібні для базової функціональності.",
    "li_install_4": "Опціональні залежності (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) вмикають додаткові можливості.",
    "li_install_5": "Натисніть <strong>Install Selected</strong>, щоб встановити рекомендовані пакети.",
    "li_install_6": "Після встановлення відкрийте головне вікно інструменту через меню <strong>Tools -> Localization Tool</strong>.",
    "h2_initial_setup": "2.2. Початкове налаштування",
    "li_setup_1": "<strong>Створення налаштувань:</strong> При першому відкритті інструмент створить файл <code>LocalizationSettings.asset</code> у папці <code>Assets/Resources</code>.",
    "li_setup_2": "<strong>Налаштування мов:</strong> У вкладці <strong>Settings</strong> у розділі <strong>Language Management</strong> переконайтеся, що ваша основна мова (напр., <code>en</code> для англійської) обрана як <strong>Source Language</strong>. Увімкніть усі мови, які ви плануєте підтримувати.",
    "li_setup_3": "<strong>Вкажіть вміст для парсингу:</strong> У вкладці <strong>Content</strong> додайте всі сцени для аналізу до списку <strong>Scenes to Parse</strong>. Якщо ви використовуєте префаби з текстом, переконайтеся, що папки з ними додані до <strong>Prefab Folders</strong>.",
    "li_setup_4": "<strong>Перший запуск парсера:</strong> Перейдіть на вкладку <strong>Actions</strong> і натисніть кнопку <code>Update Keys</code>. Інструмент просканує ваш проєкт, створить файли перекладів і автоматично додасть необхідні компоненти (<code>LocalizedText</code>, <code>LocalizedAsset</code> тощо) до ігрових об'єктів.",
    "h1_components": "Основні компоненти (призначаються автоматично)",
    "warning_box_components": "<strong>Важлива примітка:</strong> Усі компоненти, описані нижче, додаються до ігрових об'єктів автоматично під час парсингу (коли ви натискаєте кнопку <code>Update Keys</code>). Вам не потрібно додавати їх вручну.",
    "p_components_intro": "Ці компоненти є \"мостом\" між вашими об'єктами на сцені та базою даних перекладів. Вони \"слухають\" зміни мови та автоматично підставляють правильний текст або асет.",
    "h2_localizedtext": "3.1. LocalizedText",
    "p_localizedtext_1": "Основний компонент для відображення перекладеного тексту. Він розміщується на об'єктах з <code>Text</code>, <code>TMP_Text</code> та <code>TextMesh</code>.",
    "li_localizedtext_1": "<code>localizationKey</code>: Ключ, що використовується для пошуку перекладу. Генерується автоматично.",
    "li_localizedtext_2": "<code>isStyleOnly</code>: Якщо <code>true</code>, компонент застосовуватиме лише стилі (шрифт, RTL), але не змінюватиме сам текст. Корисно для елементів, текст яких керується іншим скриптом (напр., <code>LanguageSelector</code>).",
    "li_localizedtext_3": "<code>originalSourceText</code>: Оригінальний текст базовою мовою. Використовується як запасний варіант.",
    "h2_localizedasset": "3.2. LocalizedAsset",
    "p_localizedasset_1": "Використовується для заміни асетів (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code> тощо). Він автоматично визначає тип цільового компонента на об'єкті (<code>Image</code>, <code>AudioSource</code>) і замінює його ресурс.",
    "p_localizedasset_2": "Для компонентів з опцією <strong>Play on Awake</strong> (як-от <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> коректно перехоплює автозапуск, замінює асет, а потім запускає відтворення, щоб уникнути програвання нелокалізованого контенту.",
    "h2_localizedprefab": "3.3. LocalizedPrefab",
    "p_localizedprefab_1": "Компонент для локалізації цілих префабів. Він працює неруйнівно: не змінює оригінальний префаб, а створює екземпляр локалізованої версії як дочірній об'єкт, вимикаючи всі скрипти (<code>MonoBehaviour</code>), рендерери (<code>Renderer</code>) та колайдери (<code>Collider</code>) на оригінальному об'єкті. Це запобігає подвійному виконанню логіки та візуальним артефактам. Для коректної роботи в рантаймі його порядок виконання встановлено на -100 (<code>[DefaultExecutionOrder(-100)]</code>), щоб він виконувався раніше за інші скрипти.",
    "h2_uitklocalization": "3.4. UITKLocalization",
    "p_uitklocalization_1": "Додається до об'єктів з <code>UIDocument</code> і керує локалізацією всіх текстових елементів у документі UI Toolkit (UXML).",
    "h2_localizeddropdown": "3.5. LocalizedDropdown",
    "p_localizeddropdown_1": "Додається до <code>Dropdown</code> та <code>TMP_Dropdown</code> для перекладу їхніх опцій.",
    "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
    "p_localizedbehaviour_1": "Допоміжний компонент, що дозволяє вашим скриптам реагувати на зміну мови. Він автоматично знаходить і викликає методи, позначені атрибутом <code>[OnLanguageChange]</code>.",
    "h2_context_menu": "3.7. Контекстне меню \"Analyze for Localization\"",
    "p_context_menu_1": "Щоб швидко додати <code>LocalizedAsset</code> до об'єкта, ви можете клацнути правою кнопкою миші на потрібному компоненті (напр., <code>Image</code>, <code>AudioSource</code>) в інспекторі та вибрати <strong>Analyze for Localization</strong>. Інструмент сам додасть та налаштує компонент. (Це необов'язково, але можна використовувати для ручного додавання).",
    "h1_loc_tool_window": "Вікно \"Localization Tool\"",
    "h2_in_editor_preview": "4.1. Попередній перегляд у редакторі",
    "p_preview_1": "Безпосередньо під заголовком знаходиться випадаючий список <strong>Preview Language</strong>. Ця потужна функція дозволяє вам бачити, як виглядатиме локалізація будь-якою мовою прямо у вікні <strong>Scene</strong>, не запускаючи гру.",
    "li_preview_1": "<strong>Як це працює:</strong> Виберіть мову зі списку, і інструмент миттєво застосує відповідні переклади, шрифти, налаштування RTL та асети до всіх локалізованих об'єктів в активній сцені.",
    "li_preview_2": "<strong>Плейсхолдери:</strong> Якщо у вкладці <strong>Settings</strong> вибрано стиль плейсхолдерів (напр., <strong>Accents</strong> або <strong>Brackets</strong>), то в режимі попереднього перегляду замість реальних перекладів будуть відображатися ці плейсхолдери. Це ідеально для тестування верстки та пошуку нелокалізованих елементів.",
    "li_preview_3": "<strong>Безпека:</strong> Усі зміни, зроблені в режимі попереднього перегляду, є тимчасовими. Інструмент автоматично поверне все до початкового стану, коли ви виберете \"<strong>Revert to Original</strong>\", закриєте вікно, зміните сцену або перед збереженням сцени/префаба (завдяки компоненту <code>LocalizationPreviewProtector</code>).",
    "li_preview_4": "<strong>Захист від збоїв:</strong> Вбудована система <code>PreviewCrashProtector</code> автоматично відновить початковий стан об'єктів, якщо редактор Unity аварійно завершить роботу під час активного попереднього перегляду.",
    "h2_tab_settings": "4.2. Вкладка \"Налаштування\"",
    "p_settings_1": "Ваш центр керування. Тут ви визначаєте глобальні правила для всього процесу локалізації.",
    "li_settings_1": "<strong>Режим генерації ключів:</strong> Виберіть, як будуть створюватися ключі.<ul><li><code>UseTextAsKey</code>: Сам текст стає ключем. Ідеально для прототипів. Мінус: якщо змінити вихідний текст, ключ зміниться, і всі його переклади будуть втрачені.</li><li><code>AutoGenerateKeysOnly</code>: Ключ генерується на основі ієрархії та імені об'єкта. Надійно для продакшну. Плюс: переклади не ламаються при зміні тексту.</li><li><code>UseTextAsKeyWithCustomPriority</code> та <code>AutoGenerateWithCustomKeys</code>: Гібридні режими, що дозволяють встановлювати власні ключі в коді через атрибут <code>[LocalizableField(\"my_custom_key\")]</code>.</li><li><strong>Безпечна міграція:</strong> Ви можете змінити режим у будь-який час. Інструмент автоматично перенесе всі існуючі переклади на нову систему ключів.</li></ul>",
    "li_settings_2": "<strong>Керування мовами:</strong> Налаштуйте список мов. Для мов зі спеціальними символами призначте відповідний <strong>Font Asset</strong>. Увімкніть опцію <strong>RTL</strong> для мов, що пишуться справа наліво.",
    "li_settings_3": "<strong>Загальні налаштування:</strong><ul><li><code>Parse Prefabs</code>: Вмикає парсинг префабів.</li><li><code>Split files by language</code>: Визначає, як зберігати переклади (один великий файл або один файл на мову).</li><li><code>Translations Path</code>: Шлях для зберігання файлів перекладів <code>.json</code>. Важливо: папка повинна знаходитися всередині <code>Assets/StreamingAssets/</code>.</li></ul>",
    "li_settings_4": "<strong>Відлагодження та тестування:</strong><ul><li><code>Placeholder Style</code>: Виберіть стиль для відображення плейсхолдерів у режимі попереднього перегляду.</li></ul>",
    "li_settings_5": "<strong>Оновлення в реальному часі:</strong> Налаштування для завантаження перекладів з віддаленого сервера.",
    "li_settings_6": "<strong>Runtime API Key:</strong> Розділ для безпечного зберігання API-ключа, який може знадобитися в скомпільованій грі (зберігається в зашифрованому вигляді).",
    "h2_tab_content": "4.3. Вкладка \"Вміст\"",
    "p_content_1": "Тут ви вказуєте інструменту, де саме шукати текст.",
    "li_content_1": "<strong>Сцени для парсингу:</strong> Перетягніть сюди всі сцени для аналізу.",
    "li_content_2": "<strong>Папки з префабами:</strong> Вкажіть папки з префабами.",
    "li_content_3": "<strong>Динамічні тексти:</strong> Введіть тут рядки, які створюються виключно в коді (напр., \"Game Over\").",
    "li_content_4": "<strong>Ігнорування при парсингу:</strong> Вкажіть скрипти, компоненти або об'єкти для ігнорування.",
    "li_content_5": "<strong>Pin:</strong> Ця функція дозволяє \"закріпити\" об'єкт зі сцени до списку ігнорування. Замість тимчасового посилання на об'єкт, інструмент збереже його повний шлях в ієрархії, роблячи ігнорування постійним між сесіями (але зауважте, що перейменування об'єкта або його батька розірве цей зв'язок).",
    "h2_tab_actions": "4.4. Вкладка \"Дії\"",
    "p_actions_1": "Основна робоча вкладка.",
    "li_actions_1": "<strong>Update Keys:</strong> Запускає парсер, який оновлює ваші файли перекладів.",
    "li_actions_2": "<strong>Open Translation Editor:</strong> Відкриває окреме, більш зручне вікно для редагування всіх перекладів.",
    "li_actions_3": "<strong>Керування даними:</strong> Використовуйте для обміну даними з перекладачами (Експорт/Імпорт в CSV/XML/YAML/XLIFF, імпорт з Google Таблиць).",
    "li_actions_4": "<strong>Авто-переклад:</strong> Автоматично заповнює всі порожні рядки перекладу. Нові налаштування дозволяють керувати розміром пакета (<strong>Batch Size</strong>) та політикою повторних спроб (<strong>Retry Policy</strong>) для кожного сервісу (DeepL, Google, Microsoft) окремо. Інструмент відстежує кількість перекладених символів і попереджає про можливе перевищення лімітів.",
    "li_actions_5": "<strong>Небезпечна зона:</strong> Містить кнопки для повного видалення всіх компонентів локалізації з проєкту. Використовуйте з обережністю!",
    "h2_tab_assets": "4.5. Вкладка \"Асети\"",
    "p_assets_1": "Ця вкладка повністю присвячена локалізації нетекстових ресурсів.",
    "li_assets_1": "<strong>Створіть структуру папок (необов'язково):</strong> У розділі <strong>2. Asset Folder Generation</strong> натисніть <strong>Create Asset Folders Now</strong>.",
    "li_assets_2": "<strong>Налаштуйте категорії та правила іменування:</strong> У розділі <strong>3. Asset Categories & Scanning</strong> переконайтеся, що <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) відповідає вашим файлам (напр., <code>button_ok_en.png</code>).",
    "li_assets_3": "<strong>Розмістіть ваші асети:</strong> Покладіть локалізовані асети в папки.",
    "li_assets_4": "<strong>Проскануйте асети:</strong> У розділі <strong>4. Automation</strong> натисніть <strong>Scan Assets & Update Tables</strong>. Процес очищення став безпечнішим: тепер видаляються лише старі файли таблиць (<code>.asset</code>), а не вся папка.",
    "li_assets_5": "<strong>Прив'яжіть асети до об'єктів:</strong> Натисніть <strong>Analyze Project & Attach Components</strong>.",
    "h2_tab_report": "4.6. Вкладка \"Звіт\"",
    "p_report_1": "Після кожного парсингу цей звіт показує повну картину стану вашої локалізації.",
    "li_report_1": "<strong>Категорії:</strong> Усі ключі, Додані, Оновлені (текст змінився), Видалені, Дублікати, Мігровані, Пропущені (без змін).",
    "li_report_2": "<strong>Розширений пошук:</strong> Натисніть кнопку <strong>Find</strong> біля будь-якого запису, щоб миттєво знайти відповідний об'єкт у проєкті. Пошук працює асинхронно, не блокуючи редактор, і шукає по всіх сценах та префабах. Якщо ключ використовується в кількох місцях, з'явиться випадаючий список з усіма джерелами.",
    "h1_translation_editor": "Редактор таблиці перекладів",
    "p_editor_1": "Відкривається через <strong>Tools -> Localization -> Translation Table Editor</strong>. Це основний інструмент для ручного редагування перекладів.",
    "li_editor_1": "<strong>Розумне групування:</strong> Ключі для множини та роду (напр., <code>apple_count_one</code>, <code>apple_count_few</code>) автоматично об'єднуються в групи, що згортаються.",
    "li_editor_2": "<strong>Розширене редагування:</strong> Клацніть на комірці, щоб відкрити спливаюче вікно <strong>MultiLineEditWindow</strong>. Воно показує вихідний текст для порівняння, дозволяє швидко скопіювати його та перевіряє невідповідність плейсхолдерів (напр., <code>{username}</code>) у реальному часі, підсвічуючи відсутні або зайві.",
    "li_editor_3": "<strong>Валідація плейсхолдерів через коментарі:</strong> Ви можете явно вказати, які плейсхолдери повинні бути в перекладі, додавши спеціальну директиву до коментаря ключа, наприклад: <code>@placeholders: {username}, {score}</code>. <strong>MultiLineEditWindow</strong> буде використовувати цей список як основне джерело істини.",
    "li_editor_4": "<strong>Навігація та керування:</strong> Переміщуйтесь по таблиці за допомогою смуг прокрутки або утримуючи середню кнопку миші. Змінюйте ширину стовпців, перетягуючи роздільники. Зберігайте зміни за допомогою <code>Ctrl+S</code>.",
    "li_editor_5": "<strong>Повне Undo/Redo:</strong> Весь стек дій (зміни тексту, додавання/видалення ключів) повністю підтримується через <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.",
    "li_editor_6": "<strong>Резервні копії та автозбереження:</strong> Використовуйте кнопку <strong>Manage Backups</strong>. Інструмент також автоматично зберігає вашу сесію кожні кілька хвилин. У разі збою вам буде запропоновано відновити ваші зміни.",
    "h1_usage_examples": "Приклади використання",
    "h2_example_components": "6.1. Готові компоненти та приклади",
    "p_example_components_1": "Проєкт містить готові до використання скрипти, які служать чудовими прикладами.",
    "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Готовий компонент для створення UI випадаючого списку для перемикання мов. Він автоматично знаходить усі доступні мови та керує їх перемиканням.<br><strong>Як використовувати:</strong> Просто додайте компонент <code>LanguageSelector</code> на вашу сцену (напр., на порожній GameObject) та вкажіть ваш <code>TMP_Dropdown</code> в інспекторі.",
    "li_example_components_2": "<strong>Приклади коду:</strong> Щоб вивчити розширені техніки, такі як робота з <code>[LocalizableField]</code>, функцією <code>_()</code>, множиною та родом, вивчіть файли <code>StatPurchaseTest.cs</code> та <code>TestLocalization.cs</code>. Вони наочно демонструють реалізацію всіх основних можливостей інструменту в коді.",
    "h2_example_attribute": "6.2. Атрибут [LocalizableField]",
    "p_example_attribute_1": "Переважний метод для текстів, які є частиною конфігурації компонента в інспекторі. Парсер тепер може працювати з рядками, списками/масивами рядків і навіть полями всередині вкладених класів <code>[System.Serializable]</code>.",
    "code_example_attribute": "using Ankonoanko.Localization; // Необхідно для [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // Парсер знайде це поле і створить для нього ключ\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"You have failed the quest.\";\n    \n    // Ви можете встановити власний ключ\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Are you ready for an adventure?\";\n    \n    // Працює зі списками\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Find the treasure\" };\n    \n    // І навіть з вкладеними класами!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
    "h2_example_function": "6.3. Функція _() та атрибут [OnLanguageChange]",
    "p_example_function_1": "Використовуйте функцію <code>_()</code> для динамічного тексту, що змінюється під час гри. Метод, що оновлює UI, повинен бути позначений атрибутом <code>[OnLanguageChange]</code>, щоб він викликався автоматично при зміні мови. Компонент <code>LocalizedBehaviour</code> буде автоматично доданий до об'єкта для цієї мети.",
    "code_example_function": "// Щоб використовувати короткий виклик _(), додайте ці рядки\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Необхідно для [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Початкове оновлення\n    }\n    \n    // Цей метод буде викликаний автоматично при зміні мови\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Індексовані плейсхолдери (як у string.Format)\n        // Ключ: \"score_label\", Текст у файлі: \"Рахунок: {0}\"\n        scoreText.text = _(\"score_label\", score); // Результат: \"Рахунок: 100\"\n        \n        // 2. Іменовані плейсхолдери (рекомендується для читабельності)\n        // Ключ: \"welcome_message\", Текст: \"Ласкаво просимо, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Для складних випадків або високої продуктивності\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
    "h2_example_plurals": "6.4. Множина та рід",
    "p_example_plurals_1": "Інструмент тепер використовує більш точні правила для різних мовних груп.",
    "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Ключі: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Тексти: \"{0} яблуко\", \"{0} яблука\", \"{0} яблук\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Автоматично вибирає правильну форму\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Ключі: \"user_greeted_male\", \"user_greeted_female\"\n        // Тексти: \"Він прибув.\", \"Вона прибула.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
    "h1_important_notes": "Важливі примітки та попередження",
    "li_notes_1": "<strong>Резервні копії:</strong> Перед глобальними операціями (<code>Update Keys</code>, імпорт даних) завжди створюйте резервну копію через <strong>Translation Table Editor -> Manage Backups</strong>.",
    "li_notes_2": "<strong>Безпека API-ключа:</strong> Ключ для роботи в редакторі зберігається локально на вашій машині (в <code>EditorPrefs</code>) і не потрапляє в репозиторій. Для ключів, необхідних у білді гри, використовуйте розділ <strong>Runtime API Key</strong>.",
    "li_notes_3": "<strong>Папка <code>StreamingAssets</code>:</strong> Файли перекладів повинні знаходитися в підпапці <code>Assets/StreamingAssets/</code>, щоб бути включеними в білд гри.",
    "li_notes_4": "<strong>\"Захист від дурня\":</strong> Інструмент автоматично захищає вас від випадкового збереження тимчасових даних з режиму попереднього перегляду в сцену або префаб.",
    "li_notes_5": "<strong>Продуктивність:</strong> Виклик <code>_()</code> швидкий, але в циклах, що виконуються кожен кадр (напр., в <code>Update</code>), намагайтеся кешувати результат у змінну.",
    "li_notes_6": "<strong>Виключення <code>LanguageSelector</code> з парсингу:</strong> Об'єкт з компонентом <code>LanguageSelector</code> та його <code>TMP_Dropdown</code> необхідно додати до списку <strong>Ignore Specific Objects</strong> у вкладці <strong>Content</strong>. Це потрібно, щоб парсер не створював зайві ключі для опцій випадаючого списку, оскільки скрипт <code>LanguageSelector</code> заповнює їх динамічно під час виконання. Ігнорування запобігає конфліктам і зберігає чистоту файлів перекладу.",
    "li_notes_7": "<strong>Шрифти для <code>LanguageSelector</code>:</strong> Щоб вибрана мова у <code>TMP_Dropdown</code> коректно оновлювала свій шрифт, вручну додайте порожній компонент <code>LocalizedText</code> до дочірнього об'єкта <strong>Label</strong> випадаючого списку і встановіть прапорець <code>isStyleOnly</code>.",
    "h1_extending": "Розширення функціоналу",
    "h2_custom_parser": "8.1. Створення власного парсера",
    "p_custom_parser_1": "Ви можете легко розширити систему для підтримки власних компонентів, створивши свій власний клас парсера.",
    "li_custom_parser_1": "Створіть новий C# скрипт у папці <strong>Editor</strong> вашого проєкту.",
    "li_custom_parser_2": "Скопіюйте в нього шаблон, наведений нижче.",
    "li_custom_parser_3": "Змініть логіку відповідно до вашого компонента.",
    "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// ШАБЛОН для створення парсера для власного компонента.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Перевіряємо, чи є на об'єкті потрібний нам власний компонент.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Виходимо, якщо компонент не знайдено\n        }\n        \n        // 2. Отримуємо текст з полів власного компонента.\n        string titleText = component.Title;\n        \n        // 3. Перевіряємо, чи є текст валідним для локалізації.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Генеруємо ключ і джерело за допомогою хелперів з TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Повертаємо результат.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Повторюємо для інших полів...\n        // (можна додати суфікс, щоб зробити ключі унікальними)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
    "h1_faq": "ЧаПи та вирішення проблем",
    "h2_faq_installation": "9.1. Встановлення та швидкий старт",
    "q_faq_installation_1": "Що станеться, якщо в моєму проєкті вже є пакет com.unity.nuget.newtonsoft-json від іншого асета? Чи спробує інсталятор залежностей оновити його чи проігнорує?",
    "a_faq_installation_1": "Інсталятор перевіряє існування типу Newtonsoft.Json.JsonConvert. Якщо тип існує, він вважає залежність задоволеною і не намагатиметься встановлювати або оновлювати пакет. Це зроблено для запобігання конфліктам версій.",
    "q_faq_installation_2": "Я випадково натиснув \"Пропустити зараз\" і встановив прапорець \"Більше не питати\" для опціональних залежностей (напр., для підтримки CSV). Як я можу знову викликати вікно інсталятора, щоб встановити їх?",
    "a_faq_installation_2": "Ви можете вручну запустити перевірку залежностей у будь-який час через меню Tools -> Localization -> Check Dependencies. Це скине прапорець \"Більше не питати\" і знову покаже вікно з усіма відсутніми опціональними пакетами.",
    "q_faq_installation_3": "Інструмент не створив LocalizationSettings.asset у Assets/Resources. Чому це могло статися, і чи можу я створити його вручну через меню Assets -> Create?",
    "a_faq_installation_3": "Це може статися, якщо у вас немає папки Assets/Resources. Інструмент спробує її створити, але права доступу до файлової системи можуть цьому завадити. Так, ви можете створити асет вручну: клацніть правою кнопкою миші в папці Resources, виберіть Create -> Localization -> Settings. Інструмент знайде його автоматично.",
    "q_faq_installation_4": "Чи можу я перемістити файл LocalizationSettings.asset в іншу папку Resources, наприклад, Assets/MyGame/Resources? Чи знайде його інструмент?",
    "a_faq_installation_4": "Так. Інструмент використовує Resources.Load(), який шукає асет за назвою у всіх папках з ім'ям Resources у вашому проєкті. Важливо, щоб файл зберіг свою назву LocalizationSettings.asset.",
    "q_faq_installation_5": "Інсталятор залежностей завис або видав помилку. Чи можу я встановити залежності (Newtonsoft Json, Editor Coroutines) вручну через Unity Package Manager?",
    "a_faq_installation_5": "Так. Ви можете відкрити Window -> Package Manager, натиснути іконку \"+\" і вибрати \"Add package by name...\". Введіть назви пакетів: com.unity.nuget.newtonsoft-json та com.unity.editorcoroutines.",
    "h2_faq_components": "9.2. Основні компоненти",
    "q_faq_components_1": "Компонент LocalizedPrefab вимикає MonoBehaviours на оригінальному об'єкті. Що, якщо оригінальний об'єкт має скрипт, який створює інші об'єкти або підписується на події в Awake()? Чи буде виконаний цей код?",
    "a_faq_components_1": "Ні, не буде. Вимкнення MonoBehaviour запобігає виклику всіх \"магічних\" методів Unity, включаючи Awake(), OnEnable() та Start(). Це зроблено навмисно, щоб уникнути дублювання виконання логіки. Вся ініціалізація повинна відбуватися в скриптах на локалізованих версіях префаба.",
    "q_faq_components_2": "Якщо оригінальний префаб (LocalizedPrefab) має Rigidbody або інший фізичний компонент, чи буде він вимкнений? Чи вплине це на фізику, якщо локалізований префаб його не має?",
    "a_faq_components_2": "Так, фізична поведінка оригінального об'єкта буде нейтралізована. Компонент LocalizedPrefab знаходить усі компоненти Rigidbody та Rigidbody2D на своєму GameObject і встановлює їхню властивість isKinematic на true. Це ефективно видаляє їх з динамічних фізичних розрахунків, запобігаючи небажаній поведінці, такій як падіння невидимого об'єкта або реакція на зіткнення. Все ж рекомендується, щоб локалізована версія префаба містила всі необхідні фізичні компоненти для коректної поведінки.",
    "q_faq_components_3": "Компонент LocalizedAsset зберігає назву цільового компонента як рядок (_targetComponentTypeName). Що станеться, якщо я перейменую скрипт власного компонента або переміщу його в іншу збірку (Assembly Definition)? Чи перестане працювати LocalizedAsset для нього?",
    "a_faq_components_3": "Так, перестане. Компонент зберігає повне ім'я типу, включаючи простір імен та збірку. Перейменування скрипта або переміщення його в інший .asmdef змінить це ім'я, і LocalizedAsset не зможе знайти цільовий компонент. Вам потрібно буде запустити повторний аналіз через Analyze Project & Attach Components, щоб він оновив назву.",
    "q_faq_components_4": "Якщо на одному GameObject є два компоненти Image, як LocalizedAsset дізнається, який з них локалізувати? Чи буде він працювати з обома чи лише з першим знайденим?",
    "a_faq_components_4": "LocalizedAsset створюється для конкретного екземпляра компонента. Він зберігає посилання на цей компонент у коді. Якщо ви вручну додасте другий LocalizedAsset і за допомогою контекстного меню \"Analyze for Localization\" націлите його на другий Image, у вас буде два компоненти LocalizedAsset, кожен з яких керує своїм Image. Автоматичний аналізатор створить компонент лише для першого знайденого Image з локалізованим асетом.",
    "q_faq_components_5": "У документації зазначено, що LocalizedPrefab має порядок виконання -100. Що, якщо у мене є інший скрипт з порядком виконання -110, який намагається знайти дочірній об'єкт, створений LocalizedPrefab, у своєму Awake()? Чи встигне LocalizedPrefab створити свій екземпляр?",
    "a_faq_components_5": "Так, встигне. LocalizedPrefab створює екземпляр локалізованого префаба у своєму методі OnEnable(). Порядок виконання Unity гарантує, що всі методи Awake() виконуються перед усіма методами OnEnable(). Таким чином, ваш скрипт з порядком -110 виконає свій Awake(), потім LocalizedPrefab з порядком -100 виконає свій Awake(), і лише після цього будуть викликані їхні методи OnEnable() по порядку. Ваш скрипт не знайде об'єкт, бо він ще не буде створений.",
    "q_faq_components_6": "Компонент LocalizedText має опцію isStyleOnly. Якщо я її увімкну, а потім викличу в коді myLocalizedText.SetFormattedText(\"new_key\"), чи зміниться текст, чи тільки стиль (шрифт/RTL)?",
    "a_faq_components_6": "Зміниться і ключ, і текст. Програмний виклик SetFormattedText перевизначає поведінку isStyleOnly для цього конкретного оновлення. Опція isStyleOnly призначена для того, щоб компонент не реагував на глобальні зміни мови, але він завжди реагуватиме на пряму зміну ключа через код.",
    "q_faq_components_7": "LocalizedBehaviour автоматично знаходить методи з атрибутом [OnLanguageChange]. Чи знайде він приватні та захищені методи, чи вони повинні бути публічними?",
    "a_faq_components_7": "Він знайде методи з будь-яким модифікатором доступу (public, private, protected, internal). Рефлексія в Unity дозволяє виявляти всі методи екземпляра незалежно від їхнього рівня доступу.",
    "q_faq_components_8": "Компонент LocalizedAsset перехоплює Play on Awake. Що станеться, якщо інший скрипт на тому ж об'єкті спробує отримати доступ до асета (напр., audioSource.clip.length) в Awake() або Start() до того, як LocalizedAsset його замінить? Чи можливий NullReferenceException або використання старого асета?",
    "a_faq_components_8": "Можливе використання старого (нелокалізованого) асета. LocalizedAsset виконує заміну у своєму OnEnable(). Методи Awake() всіх скриптів виконуються до OnEnable(). Якщо ваш скрипт звертається до audioSource.clip в Awake(), він отримає оригінальний кліп. Якщо він звертається до нього в Start(), результат залежатиме від порядку виконання скриптів. Щоб гарантовано отримати доступ до локалізованого асета, або встановіть пізніший порядок виконання для вашого скрипта, або звертайтеся до асета в методі, позначеному [OnLanguageChange].",
    "h2_faq_window": "9.3. Вікно \"Localization Tool\"",
    "h3_faq_window_preview": "Попередній перегляд у редакторі",
    "q_faq_window_preview_1": "Я відкрив префаб у режимі Prefab Mode, застосував In-Editor Preview і натиснув Ctrl+S. Чи будуть тимчасові дані попереднього перегляду збережені в асет префаба? Як LocalizationPreviewProtector обробляє цей випадок?",
    "a_faq_window_preview_1": "Ні, не будуть. LocalizationPreviewProtector перехоплює подію збереження асета (OnWillSaveAssets) і автоматично викликає RevertEditorPreview() перед тим, як Unity запише зміни на диск. Таким чином, префаб буде збережений у своєму початковому, нелокалізованому стані.",
    "q_faq_window_preview_2": "Якщо я увімкну In-Editor Preview і редактор Unity аварійно завершить роботу, а файл Temp/localization_preview_recovery.json пошкодиться (напр., буде порожнім або невалідним JSON), що станеться при наступному запуску?",
    "a_faq_window_preview_2": "PreviewCrashProtector обгорнутий у блок try-catch. Якщо десеріалізація JSON зазнає невдачі, в консоль буде виведено помилку про неможливість відновлення, і процес тихо завершиться. Ваша сцена залишиться в \"зламаному\" стані, в якому вона була на момент збою. У цьому випадку вам потрібно буде вручну вибрати \"Revert to Original\" у вікні інструменту, щоб примусово відкотити зміни.",
    "q_faq_window_preview_3": "У режимі In-Editor Preview для LocalizedPrefab створюється тимчасовий екземпляр. Чи будуть на цьому екземплярі виконані методи Awake() та Start()? Чи може це викликати помилки, якщо вони не призначені для роботи в режимі редагування?",
    "a_faq_window_preview_3": "Так, будуть. PrefabUtility.InstantiatePrefab у режимі редагування викликає Awake() та OnEnable(). Якщо ці методи містять логіку, яка не повинна виконуватися в редакторі (напр., доступ до синглтонів, які існують тільки в режимі Play Mode), це може викликати помилки. Рекомендується використовувати if (Application.isPlaying) або #if UNITY_EDITOR для захисту такого коду.",
    "h3_faq_window_settings": "Вкладка \"Налаштування\"",
    "q_faq_window_settings_1": "Я можу змінити Key Generation Mode з UseTextAsKey на AutoGenerateKeysOnly в середині проєкту. Що саме станеться з моїми існуючими перекладами? Чи будуть вони зіставлені з новими ключами?",
    "a_faq_window_settings_1": "Так, будуть. При зміні режиму інструмент виконує \"безпечну міграцію\": він повторно парсить весь проєкт, створює нові ключі за новими правилами, але зіставляє старі та нові ключі через оригінальний текст. Потім він переносить усі ваші існуючі переклади та коментарі зі старих ключів на нові. Ваші переклади не будуть втрачені.",
    "q_faq_window_settings_2": "Якщо я додам мову з кодом, для якого немає правил плюралізації (напр., \"kz\" для казахської) до списку підтримуваних мов, яке правило буде використовуватися за замовчуванням?",
    "a_faq_window_settings_2": "Буде використано DefaultPluralRule, яке підходить для англійської та більшості європейських мов (форми для \"one\" та \"other\").",
    "q_faq_window_settings_3": "Що, якщо я вкажу Translations Path не в StreamingAssets, а в звичайній папці, наприклад, Assets/MyTranslations? Чи будуть файли json включені в білд гри?",
    "a_faq_window_settings_3": "Ні, не будуть. Тільки асети, що знаходяться в папці StreamingAssets або Resources, гарантовано включаються в білд. Якщо ви вкажете інший шлях, локалізація працюватиме в редакторі, але не працюватиме в скомпільованій грі, оскільки файли перекладів не будуть частиною білда.",
    "q_faq_window_settings_4": "API-ключ для авто-перекладу зберігається в EditorPrefs. Якщо я працюю над проєктом на двох різних комп'ютерах, чи потрібно мені вводити ключ на кожній машині окремо?",
    "a_faq_window_settings_4": "Так. EditorPrefs - це локальне сховище для кожного комп'ютера. Вам потрібно буде ввести API-ключ на кожній машині, з якої ви плануєте використовувати функцію авто-перекладу.",
    "h3_faq_window_content": "Вкладка \"Вміст\"",
    "q_faq_window_content_1": "Що, якщо я додам сцену до Scenes to Parse, яка не включена в Build Settings? Чи вплине це на щось, крім самого процесу парсингу?",
    "a_faq_window_content_1": "Ні, не вплине. Список Scenes to Parse використовується виключно для того, щоб інструмент знав, які сцени відкривати та аналізувати на наявність тексту. Він ніяк не пов'язаний зі сценами, які потраплять у фінальний білд вашої гри.",
    "q_faq_window_content_2": "Я додав об'єкт до Ignore Specific Objects (тимчасовий список). Якщо я зроблю з цього об'єкта префаб, чи буде екземпляр цього префаба також ігноруватися?",
    "a_faq_window_content_2": "Ні, не буде. Тимчасовий список зберігає пряме посилання на об'єкт на сцені. Коли ви створюєте префаб, це новий асет. Його екземпляри - це інші об'єкти, і правило ігнорування на них не поширюватиметься. Щоб постійно ігнорувати префаби, їх потрібно додавати до списку ігнорування як асет префаба.",
    "q_faq_window_content_3": "Якщо я додам компонент TMPro.TMP_Text до Parsing Ignores -> Ignore Component Types, але на сцені є об'єкт з LocalizedText, який вже посилається на цей TMP_Text, що станеться при наступному Update Keys? Чи буде ключ видалено?",
    "a_faq_window_content_3": "Так, буде. Коли ви натискаєте Update Keys, парсер повторно сканує весь проєкт. Він побачить, що тип TMPro.TMP_Text слід ігнорувати, і не буде генерувати для нього ключ. Під час процесу порівняння старих і нових ключів він визначить, що старий ключ більше не використовується, і позначить його як \"Removed\".",
    "q_faq_window_content_4": "У документації сказано, що \"Pin\" зберігає повний шлях до об'єкта і зламається при перейменуванні. Що, якщо я зроблю префаб з об'єкта, а потім перейменую оригінальний об'єкт — чи продовжить \"Pin\" працювати для екземплярів префаба?",
    "a_faq_window_content_4": "Ні, не продовжить. \"Pin\" зберігає абсолютний шлях в ієрархії сцени на момент натискання кнопки (напр., Canvas/Panel/Button). Цей шлях не пов'язаний з логікою префабів. Екземпляри префабів матимуть такий самий шлях, але якщо ви перейменуєте батьківський об'єкт на сцені, \"Pin\" перестане працювати і для оригіналу, і для екземплярів.",
    "q_faq_window_content_5": "Якщо я використовую \"Pin\" для дочірнього об'єкта всередині екземпляра префаба, який шлях буде збережено: відносно кореня префаба чи кореня сцени? Чи буде він працювати в інших сценах?",
    "a_faq_window_content_5": "Буде збережено повний шлях від кореня сцени. Наприклад, MyPrefab(Clone)/Content/Icon. Цей \"закріплений\" шлях працюватиме лише в тій сцені, де ви його створили. В інших сценах такий шлях, швидше за все, не буде знайдено.",
    "h3_faq_window_actions": "Вкладка \"Дії\"",
    "h3_faq_window_assets": "Вкладка \"Асети\"",
    "h3_faq_window_report": "Вкладка \"Звіт\"",
    "h2_faq_editor": "9.4. Редактор перекладів",
    "h2_faq_examples": "9.5. Приклади використання та код",
    "h2_faq_notes": "9.6. Важливі нюанси та попередження",
    "h2_faq_extending": "9.7. Розширення функціоналу",
    "q_faq_window_actions_1": "Що станеться, якщо під час пакетного авто-перекладу обірветься інтернет-з'єднання? Чи спробує інструмент повторно відправити невдалий пакет згідно з Retry Policy, чи процес повністю перерветься?",
    "a_faq_window_actions_1": "Інструмент спробує повторно відправити саме той пакет, який не вдався, згідно з налаштуваннями Retry Policy (кількість спроб і затримка). Якщо всі спроби для цього пакета зазнають невдачі, процес перекладу для поточної мови буде перервано, і в консоль буде виведено помилку. Переклад для наступних мов у черзі не розпочнеться.",
    "q_faq_window_actions_2": "Якщо я імпортую CSV-файл, який містить ключі, що вже існують у проєкті, але з порожніми значеннями для деяких мов, чи замінять ці порожні значення мої існуючі переклади, чи будуть проігноровані?",
    "a_faq_window_actions_2": "Порожні значення замінять існуючі переклади. Процес імпорту вважає CSV-файл \"джерелом істини\". Якщо значення для ключа welcome_message в колонці ru порожнє, поточний український переклад для цього ключа буде перезаписано.",
    "q_faq_window_actions_3": "Розділ \"Небезпечна зона\" дозволяє видаляти всі компоненти. Чи видалить він компоненти з префабів, що знаходяться в папках, не вказаних у Prefab Folders на вкладці Content?",
    "a_faq_window_actions_3": "Так, видалить. Функції в \"Небезпечній зоні\" сканують усі префаби в проєкті (AssetDatabase.FindAssets(\"t:Prefab\")), а не лише ті, що вказані в списку для парсингу, щоб забезпечити максимально повне очищення.",
    "q_faq_window_actions_4": "При імпорті з Google Таблиць, як я повинен форматувати колонку з коментарями, щоб спрацювала валідація плейсхолдерів за допомогою директиви @placeholders:?",
    "a_faq_window_actions_4": "У вашому документі Google Таблиць колонка повинна мати назву \"Developer Notes\". У клітинках цієї колонки ви можете писати коментарі як зазвичай. Щоб вказати плейсхолдери, просто додайте рядок виду @placeholders: {username}, {score} в тексті коментаря. Інструмент автоматично розпізнає цю директиву при імпорті.",
    "q_faq_window_actions_5": "Чи може інструмент імпортувати дані з кількох аркушів одного документа Google Таблиць, чи він працює тільки з одним аркушем за GID?",
    "a_faq_window_actions_5": "Інструмент працює тільки з одним аркушем за раз. URL для імпорту містить параметр gid=..., який унікально ідентифікує конкретний аркуш у документі. Щоб імпортувати дані з іншого аркуша, вам потрібно скопіювати його URL (з іншим gid) і виконати імпорт повторно.",
    "q_faq_window_assets_1": "Що, якщо у мене в одній папці для сканування є два асети з однаковим ключем, але різними типами (напр., sound_effect_en.mp3 та sound_effect_en.wav)? Який з них потрапить до таблиці асетів?",
    "a_faq_window_assets_1": "Сканер асетів завантажує їх, вказуючи очікуваний тип (AssetDatabase.LoadAssetAtPath(path, expectedType)). Для категорії AudioClip він буде шукати та завантажувати лише файли, які Unity розпізнає як AudioClips. Якщо обидва файли є валідними аудіокліпами, до таблиці потрапить той, який буде оброблений останнім, фактично перезаписавши попередній. Рекомендується уникати таких дублікатів.",
    "q_faq_window_assets_2": "Якщо я натисну Scan Assets & Analyze Project, і на сцені є об'єкт Image, для якого вже існує локалізований спрайт, але сам об'єкт Image ще не має компонента LocalizedAsset, чи додасть інструмент компонент і автоматично вставить ключ?",
    "a_faq_window_assets_2": "Так, саме так це і працює. \"Analyze Project\" знаходить компонент Image, дивиться на назву спрайта, що йому призначений (напр., icon_play_en), витягує з неї ключ (icon_play) та мову (en), а потім додає компонент LocalizedAsset до цього GameObject і вписує в нього ключ icon_play.",
    "q_faq_window_assets_3": "Чи можу я використовувати однаковий Naming Rule для різних категорій асетів, якщо у них різні Scan Folders? Чи не викличе це конфліктів?",
    "a_faq_window_assets_3": "Так, можете. Конфліктів не буде, оскільки для кожної категорії створюється окрема таблиця асетів (LocalizedAssetTable). Ключі з категорії \"Sprites\" не перетинаються з ключами з категорії \"AudioClips\", навіть якщо вони називаються однаково.",
    "q_faq_window_assets_4": "Якщо локалізований асет (напр., button_ok_en.png) знаходиться не в корені Scan Folder, а в підпапці, чи знайде його сканер?",
    "a_faq_window_assets_4": "Так, знайде. Сканер використовує опцію SearchOption.AllDirectories, що означає, що він рекурсивно перевірить усі підпапки всередині вказаної вами Scan Folder.",
    "q_faq_window_report_1": "Кнопка \"Find\" шукає об'єкт асинхронно. Що, якщо я запущу пошук, а потім одразу натисну Update Keys? Чи перерветься пошук?",
    "a_faq_window_report_1": "Так, перерветься. Будь-яка нова дія, що вимагає блокування UI (як-от Update Keys), зупинить поточну корутину пошуку. З'явиться діалогове вікно з пропозицією зупинити поточний пошук, щоб розпочати новий.",
    "q_faq_window_report_2": "Якщо ключ використовується в кількох місцях (напр., на двох різних кнопках у різних сценах), як це буде відображено у звіті в категорії \"Duplicates\"?",
    "a_faq_window_report_2": "Категорія \"Duplicates\" покаже всі джерела для цього ключа. Ви побачите один запис для ключа, а в полі \"Source\" будуть перераховані всі шляхи (в сцені 1 і сцені 2). Кнопка \"Find\" у цьому випадку відкриє випадаючий список, дозволяючи вам вибрати, до якого об'єкта перейти.",
    "q_faq_window_report_3": "Якщо я натисну \"Find\" для ключа, який використовується тільки в коді (через функцію _()), що станеться? Чи зможе інструмент знайти та підсвітити C# скрипт?",
    "a_faq_window_report_3": "Так. Система пошуку спеціально навчена розпізнавати джерела типу script MyScript.cs. Коли ви натиснете \"Find\", вона шукатиме асет MyScript.cs у проєкті та підсвітить (ping) його у вікні Project.",
    "q_faq_editor_1": "Що має вищий пріоритет для валідації плейсхолдерів: директива @placeholders: у коментарі чи плейсхолдери, знайдені в тексті вихідної мови? Наприклад, якщо у вихідному тексті є {name}, а в коментарі написано @placeholders: {username}.",
    "a_faq_editor_1": "Пріоритет має директива @placeholders: у коментарі. Вона вважається явною вказівкою від розробника та \"джерелом істини\". У вашому прикладі редактор вимагатиме {username} у перекладі і проігнорує {name} з вихідного тексту.",
    "q_faq_editor_2": "Якщо я зроблю помилку в директиві (напр., @placeholder: замість @placeholders:), чи буде вона проігнорована, чи інструмент видасть попередження?",
    "a_faq_editor_2": "Вона буде просто проігнорована. Інструмент шукає точну відповідність @placeholders:. Якщо директива написана з помилкою, вона буде розцінена як частина звичайного коментаря, а валідація працюватиме по-старому - на основі плейсхолдерів з вихідного тексту.",
    "q_faq_editor_3": "Система автозбереження створює файли в папці Backups/AutoSaves. Чи будуть ці файли автоматично видалені після успішного ручного збереження або закриття вікна?",
    "a_faq_editor_3": "Так. При успішному ручному збереженні або нормальному закритті вікна (коли ви зберігаєте зміни) всі файли автозбереження видаляються, щоб не пропонувати відновлення при наступному запуску. Вони залишаються тільки у випадку аварійного завершення роботи редактора.",
    "q_faq_editor_4": "Якщо я зміню ширину стовпців у редакторі, чи збережуться ці налаштування між сесіями Unity?",
    "a_faq_editor_4": "Так. Ширина стовпців зберігається в EditorPrefs кожного разу, коли ви закриваєте вікно редактора перекладів, і буде відновлена при наступному його відкритті.",
    "q_faq_editor_5": "Чи підтримує спливаюче вікно редагування тексту (MultiLineEditWindow) власний стек Undo/Redo (через Ctrl+Z) для змін, зроблених у ньому?",
    "a_faq_editor_5": "Так. MultiLineEditWindow має власний тимчасовий стек Undo/Redo, який працює, поки вікно відкрите. Це дозволяє вам скасовувати та повторювати зміни тексту всередині цього вікна. Як тільки ви зберігаєте результат (закриваючи вікно), ця зміна записується як одна дія в глобальний стек Undo/Redo основного редактора.",
    "q_faq_examples_1": "Що станеться, якщо імена властивостей в анонімному типі, переданому у функцію _(), не збігаються з плейсхолдерами в рядку? Наприклад, _(\"Привіт, {username}\", new { user_name = \"Боб\" }). Чи буде помилка, чи плейсхолдер просто не буде замінено?",
    "a_faq_examples_1": "Помилки не буде. Плейсхолдер {username} просто не буде замінено, і ви отримаєте в результаті рядок \"Привіт, {username}\". Заміна відбувається лише при точному збігу імен.",
    "q_faq_examples_2": "Атрибут [LocalizableField] працює для приватних полів. Чи буде він працювати для статичних полів?",
    "a_faq_examples_2": "Так, буде. Парсер використовує рефлексію для пошуку полів з прапорами BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, тому він знайде та обробить статичні поля.",
    "q_faq_examples_3": "Якщо я поставлю атрибут [OnLanguageChange] на метод з параметрами (напр., void UpdateUI(string newLang)), що станеться? Чи буде помилка компіляції чи попередження під час виконання?",
    "a_faq_examples_3": "Помилки компіляції не буде, але під час виконання в консолі Unity з'явиться попередження від LocalizedBehaviour. Він повідомить, що знайшов метод з атрибутом, але проігнорував його, оскільки метод має параметри. Такий метод не буде викликаний.",
    "q_faq_examples_4": "Я використовую _(\"apple_count\", count). Якщо для поточної мови немає ключа apple_count_one (для count = 1), яку форму вибере система? Чи використає вона apple_count_other як запасний варіант?",
    "a_faq_examples_4": "Так. Якщо конкретна форма (_one, _few тощо) не знайдена, система спробує використати ключ із суфіксом _other як запасний варіант. Якщо і його не знайдено, буде використано переклад для базового ключа apple_count.",
    "q_faq_examples_5": "Функція _(\"key\", new { username = \"Alex\" }) використовує анонімний тип. Чи не створить це надмірне \"навантаження\" на збирач сміття (GC) при частих викликах у методі Update() порівняно з передачею попередньо створеного Dictionary<string, object>?",
    "a_faq_examples_5": "Так, створить. Кожен виклик new { ... } виділяє пам'ять у керованій купі, що створює додаткову роботу для збирача сміття. Для тексту, який оновлюється кожен кадр (в Update або LateUpdate), значно продуктивніше створити Dictionary<string, object> один раз у Start(), і лише оновлювати його значення в Update() перед передачею у функцію _().",
    "q_faq_notes_1": "У документації рекомендується додавати LanguageSelector до списку ігнорування. Що саме зламається, якщо я забуду це зробити? Чи будуть створені зайві ключі для \"Option A, Option B\"?",
    "a_faq_notes_1": "Так. Якщо ви не додасте LanguageSelector до списку ігнорування, парсер розцінить його TMP_Dropdown як звичайний випадаючий список. Він знайде стандартні \"Option A, Option B, Option C\", які створює Unity, і додасть для них ключі у ваші файли перекладів. Це засмітить ваші файли непотрібними ключами, оскільки LanguageSelector все одно видалить ці опції під час виконання і створить свої власні.",
    "q_faq_notes_2": "Якщо я забуду додати порожній LocalizedText з увімкненим прапорцем isStyleOnly на Label всередині TMP_Dropdown, який використовується LanguageSelector, чи не зміниться шрифт? Чому це необхідно?",
    "a_faq_notes_2": "Так, шрифт не зміниться. Це необхідно, тому що LanguageSelector безпосередньо змінює властивість label.text. Без LocalizedText на цьому об'єкті система локалізації не знає, що до цього елемента потрібно застосовувати стилі (шрифт, RTL) при зміні мови. Порожній LocalizedText з isStyleOnly служить \"маркером\" для системи, кажучи: \"Стеж за цим об'єктом і застосовуй до нього стилі, але не чіпай його текст\".",
    "q_faq_notes_3": "Виклик _() у методі Update() не рекомендується. Але що, якщо мені потрібно оновлювати текст кожен кадр (напр., таймер)? Який найпродуктивніший спосіб це зробити, кешуючи лише рядок формату?",
    "a_faq_notes_3": "Найпродуктивніший підхід - це кешувати рядок формату в Start() або в методі [OnLanguageChange], а в Update() використовувати звичайний string.Format. Приклад: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Це дозволяє уникнути пошуку ключа в словнику кожен кадр, що значно швидше.",
    "q_faq_extending_1": "Чи буде мій власний парсер викликатися автоматично після кожного Update Keys? Чи потрібно мені його десь реєструвати, чи достатньо просто мати в проєкті клас, що реалізує ITextComponentParser?",
    "a_faq_extending_1": "Достатньо просто мати клас. Коли TextParser запускається, він за допомогою рефлексії знаходить усі класи в проєкті, що реалізують інтерфейс ITextComponentParser, і автоматично викликає їхній метод Parse() для кожного GameObject. Ручна реєстрація не потрібна.",
    "q_faq_extending_2": "Що, якщо в моєму власному парсері виникне виняток? Чи перерве це весь процес парсингу, чи інструмент безпечно продовжить роботу з іншими парсерами?",
    "a_faq_extending_2": "Виняток у вашому власному парсері перерве процес. Основний цикл парсингу не обгортає виклики до власних парсерів у блок try-catch. Якщо ваш метод Parse() викине необроблений виняток,",
    "toggle_notes_title": "Перемкнути нотатки",
    "mindmap_toggle_title": "Показати інтелект-карту",
    "on_this_page_title": "На цій сторінці",
    "my_notes_title": "Мої нотатки",
    "no_notes_message_new": "Наведіть курсор на текст, щоб додати нотатку.",
    "notes_add_title": "Додати нотатку до цього блоку",
    "notes_placeholder": "Ваша нотатка...",
    "notes_close_title": "Закрити",
    "notes_goto_title": "Перейти до тексту",
    "notes_edit_title": "Редагувати нотатку",
    "notes_delete_title": "Видалити нотатку",
    "notes_edit_text": "Редагувати",
    "copy_code_copy": "Копіювати",
    "copy_code_copied": "Скопійовано!",
    "copy_code_error": "Помилка",
    "error_loading_title": "Помилка завантаження",
    "error_loading_message": "Будь ласка, перевірте з'єднання та оновіть сторінку.",
    "lightbox_aria_close": "Закрити переглядач зображень",
    "lightbox_image_alt": "Збільшене зображення",
    "mindmap_preset_full": "Повний вигляд",
    "mindmap_preset_quick_start": "Швидкий старт",
    "mindmap_preset_dev": "Робочий процес розробника",
    "mindmap_preset_translator": "Робочий процес перекладача",
    "mindmap_edge_configure": "1. Налаштувати",
    "mindmap_edge_specify_content": "2. Вказати вміст",
    "mindmap_edge_parse_project": "3. Аналізувати проєкт",
    "mindmap_edge_creates_components": "Створює компоненти",
    "mindmap_edge_generates": "Генерує",
    "mindmap_edge_opens": "Відкриває",
    "mindmap_edge_manages_assets": "Керує асетами для",
    "mindmap_edge_defines_rules": "Визначає правила для",
    "mindmap_edge_reports_on": "Звітує про",
    "mindmap_edge_enables_reaction": "Дозволяє реакцію через",
    "mindmap_edge_processed_by": "Обробляється",
    "mindmap_edge_edited_in": "Редагується в",
    "mindmap_edge_extends": "Розширює",
    "mindmap_edge_warns_about": "Попереджає про",
    "mindmap_edge_relates_to": "Відноситься до",
    "mindmap_edge_recommends_for": "Рекомендує для",
    "mindmap_edge_see_faq": "Див. ЧаПи"
}