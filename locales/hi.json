{
  "page_title": "यूनिटी स्थानीयकरण उपकरण दस्तावेज़ीकरण",
  "toc_title": "विषयसूची",
  "toc_search_placeholder": "दस्तावेज़ीकरण खोजें...",
  "nav_introduction": "1. परिचय",
  "nav_quick_start": "2. त्वरित शुरुआत",
  "nav_components": "3. मुख्य घटक",
  "nav_loc_tool_window": "4. \"स्थानीयकरण उपकरण\" विंडो",
  "nav_translation_editor": "5. अनुवाद संपादक",
  "nav_ai_profiles": "6. AI और अनुवाद प्रोफाइल (नया v1.1)",
  "nav_usage_examples": "7. उपयोग के उदाहरण",
  "nav_important_notes": "8. महत्वपूर्ण नोट्स",
  "nav_extending": "9. कार्यक्षमता का विस्तार",
  "nav_faq": "10. अक्सर पूछे जाने वाले प्रश्न और समस्या निवारण",
  "nav_key_features": "मुख्य विशेषताएँ",
  "nav_installation": "2.1. स्थापना",
  "nav_initial_setup": "2.2. प्रारंभिक सेटअप",
  "nav_localizedtext": "3.1. स्थानीयकृत टेक्स्ट",
  "nav_localizedasset": "3.2. स्थानीयकृत संपत्ति",
  "nav_localizedprefab": "3.3. स्थानीयकृत प्रीफैब",
  "nav_uitklocalization": "3.4. यूआईटीके स्थानीयकरण",
  "nav_localizeddropdown": "3.5. स्थानीयकृत ड्रॉपडाउन",
  "nav_localizedbehaviour": "3.6. स्थानीयकृत व्यवहार",
  "nav_context_menu": "3.7. संदर्भ मेनू",
  "nav_in_editor_preview": "4.1. इन-एडिटर और प्रीफैब पूर्वावलोकन",
  "nav_tab_settings": "4.2. \"सेटिंग्स\" टैब",
  "nav_tab_content": "4.3. \"सामग्री\" टैब (v1.1 में पुन: डिज़ाइन किया गया)",
  "nav_tab_actions": "4.4. \"क्रियाएँ\" टैब",
  "nav_tab_assets": "4.5. \"संपत्तियाँ\" टैब",
  "nav_tab_report": "4.6. \"रिपोर्ट\" टैब",
  "nav_ai_profiles_overview": "6.1. अनुवाद प्रोफाइल",
  "nav_custom_ai": "6.2. कस्टम AI और मॉडल",
  "nav_ai_context": "6.3. संदर्भ और शब्दावली",
  "nav_ai_assistant": "6.4. AI सहायक कमांड",
  "nav_example_components": "7.1. तैयार घटक",
  "nav_example_attribute": "7.2. [LocalizableField] विशेषता",
  "nav_example_function": "7.3. _() फ़ंक्शन",
  "nav_example_plurals": "7.4. बहुवचन और लिंग",
  "nav_custom_parser": "9.1. एक पार्सर बनाना",
  "nav_faq_installation": "10.1. स्थापना और त्वरित शुरुआत",
  "nav_faq_components": "10.2. मुख्य घटक",
  "nav_faq_window": "10.3. \"स्थानीयकरण उपकरण\" विंडो",
  "nav_faq_window_actions": "10.3. \"स्थानीयकरण उपकरण\" विंडो - \"क्रियाएँ\" टैब",
  "nav_faq_window_assets": "10.3. \"स्थानीयकरण उपकरण\" विंडो - \"संपत्तियाँ\" टैब",
  "nav_faq_window_report": "10.3. \"स्थानीयकरण उपकरण\" विंडो - \"रिपोर्ट\" टैब",
  "nav_faq_editor": "10.4. अनुवाद संपादक",
  "nav_faq_examples": "10.5. उपयोग के उदाहरण और कोड",
  "nav_faq_notes": "10.6. महत्वपूर्ण बारीकियाँ और चेतावनियाँ",
  "nav_faq_extending": "10.7. कार्यक्षमता का विस्तार",
  "h1_introduction": "परिचय",
  "p_intro_1": "यह उपकरण यूनिटी में गेम और एप्लिकेशन को स्थानीयकृत करने के लिए एक व्यापक समाधान है। यह टेक्स्ट और संपत्तियों को एकत्र करने की प्रक्रिया को स्वचालित करता है, एक शक्तिशाली इंटरफ़ेस के माध्यम से अनुवादों का प्रबंधन करता है, मशीन अनुवाद सेवाओं (कस्टम AI सहित) के साथ एकीकृत होता है, और गेम में स्थानीयकृत सामग्री को गतिशील रूप से अपडेट करता है।",
  "h2_key_features": "मुख्य विशेषताएँ",
  "li_feature_1": "<strong>उन्नत पार्सिंग:</strong> दृश्यों, प्रीफैब्स, यूआई टूलकिट (यूएक्सएमएल), और सी# स्क्रिप्ट्स की स्वचालित स्कैनिंग, जिसमें <code>[LocalizableField]</code> विशेषता के साथ चिह्नित फ़ील्ड, साथ ही नेस्टेड कक्षाएं और सूचियाँ शामिल हैं।",
  "li_feature_2": "<strong>किसी भी संपत्ति का स्थानीयकरण:</strong> स्प्राइट्स, ऑडियो, प्रीफैब्स, सामग्री आदि का प्रबंधन करें।",
  "li_feature_3": "<strong>शक्तिशाली अनुवाद संपादक:</strong> ऑटो-सेविंग, पूर्ण पूर्ववत/फिर से करें समर्थन, स्मार्ट कुंजी समूहीकरण, और <strong>नया v1.1 में:</strong> मल्टी-सिलेक्शन क्रियाएं।",
  "li_feature_4": "<strong>AI और मशीन अनुवाद (v1.1):</strong> DeepL, Google, Microsoft, और <strong>कस्टम AI (OpenAI, Gemini, Claude, Ollama)</strong> को संदर्भ जागरूकता के साथ समर्थन करने वाला नया प्रोफाइल सिस्टम।",
  "li_feature_5": "<strong>लचीला आयात/निर्यात:</strong> सीएसवी, एक्सएमएल, वाईएएमएल, एक्सएलआईएफएफ के लिए समर्थन, और गूगल शीट्स से सीधे आयात।",
  "li_feature_6": "<strong>इन-एडिटर लाइव पूर्वावलोकन:</strong> गेम चलाए बिना सीन व्यू या <strong>प्रीफैब मोड</strong> में किसी भी भाषा का पूर्वावलोकन करें।",
  "li_feature_7": "<strong>बहुवचन और लिंग समर्थन:</strong> बहुवचन रूपों (स्लाविक, अरबी और अन्य भाषाओं के नियमों के साथ) और लिंग का सही संचालन।",
  "li_feature_8": "<strong>पूर्ण आरटीएल समर्थन:</strong> दाएं-से-बाएं भाषाओं का सही प्रदर्शन।",
  "li_feature_9": "<strong>लाइव अपडेट:</strong> गेम शुरू होने पर रिमोट सर्वर से अद्यतित अनुवाद लोड करें।",
  "li_feature_10": "<strong>बैकअप प्रबंधक:</strong> बैकअप बनाने और पुनर्स्थापित करने के लिए एक अंतर्निहित उपकरण।",
  "h1_quick_start": "त्वरित शुरुआत और सेटअप",
  "h2_installation": "2.1. स्थापना",
  "li_install_1": "संपत्ति को अपने यूनिटी प्रोजेक्ट फ़ोल्डर में कॉपी करें।",
  "li_install_2": "उपकरण स्वचालित रूप से आवश्यक निर्भरताओं की जांच करेगा। दिखाई देने वाले डायलॉग बॉक्स में स्थापना की पुष्टि करें।",
  "li_install_3": "बुनियादी कार्यक्षमता के लिए आवश्यक निर्भरताएँ (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) आवश्यक हैं।",
  "li_install_4": "वैकल्पिक निर्भरताएँ (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) अतिरिक्त सुविधाएँ सक्षम करती हैं।",
  "li_install_5": "अनुशंसित पैकेजों को स्थापित करने के लिए <strong>Install Selected</strong> पर क्लिक करें।",
  "li_install_6": "स्थापना के बाद, <strong>Tools -> Localization Tool</strong> मेनू के माध्यम से मुख्य उपकरण विंडो खोलें।",
  "h2_initial_setup": "2.2. प्रारंभिक सेटअप",
  "li_setup_1": "<strong>सेटिंग्स बनाएँ:</strong> पहली बार खोलने पर, उपकरण <code>Assets/Resources</code> फ़ोल्डर में एक <code>LocalizationSettings.asset</code> फ़ाइल बनाएगा।",
  "li_setup_2": "<strong>भाषाएँ कॉन्फ़िगर करें:</strong> <strong>Settings</strong> टैब में <strong>Language Management</strong> के अंतर्गत, सुनिश्चित करें कि आपकी मुख्य भाषा (जैसे, अंग्रेजी के लिए <code>en</code>) <strong>Source Language</strong> के रूप में चुनी गई है। उन सभी भाषाओं को सक्षम करें जिनका आप समर्थन करने की योजना बना रहे हैं।",
  "li_setup_3": "<strong>पार्सिंग के लिए सामग्री निर्दिष्ट करें:</strong> <strong>Content</strong> टैब में, विश्लेषण के लिए सभी दृश्यों को <strong>Scenes to Parse</strong> सूची में जोड़ें। यदि आप टेक्स्ट वाले प्रीफैब का उपयोग करते हैं, तो सुनिश्चित करें कि उनके फ़ोल्डर <strong>Prefab Folders</strong> में जोड़े गए हैं।",
  "li_setup_4": "<strong>पहला पार्सर रन:</strong> <strong>Actions</strong> टैब पर जाएँ और <code>Update Keys</code> बटन पर क्लिक करें। उपकरण आपके प्रोजेक्ट को स्कैन करेगा, अनुवाद फ़ाइलें बनाएगा, और स्वचालित रूप से आवश्यक घटकों (<code>LocalizedText</code>, <code>LocalizedAsset</code>, आदि) को गेम ऑब्जेक्ट्स में जोड़ देगा।",
  "h1_components": "मुख्य घटक (स्वचालित रूप से असाइन किए गए)",
  "warning_box_components": "<strong>महत्वपूर्ण नोट:</strong> नीचे वर्णित सभी घटक पार्सिंग के दौरान गेम ऑब्जेक्ट्स में स्वचालित रूप से जोड़े जाते हैं (जब आप <code>Update Keys</code> बटन पर क्लिक करते हैं)। आपको उन्हें मैन्युअल रूप से जोड़ने की आवश्यकता नहीं है।",
  "p_components_intro": "ये घटक दृश्य में आपके ऑब्जेक्ट्स और अनुवाद डेटाबेस के बीच \"पुल\" हैं। वे भाषा परिवर्तनों को \"सुनते हैं\" और स्वचालित रूप से सही टेक्स्ट या संपत्ति को प्रतिस्थापित करते हैं।",
  "h2_localizedtext": "3.1. स्थानीयकृत टेक्स्ट",
  "p_localizedtext_1": "अनुवादित टेक्स्ट प्रदर्शित करने के लिए मुख्य घटक। यह <code>Text</code>, <code>TMP_Text</code>, और <code>TextMesh</code> वाले ऑब्जेक्ट्स पर रखा जाता है।",
  "li_localizedtext_1": "<code>localizationKey</code>: अनुवाद खोजने के लिए उपयोग की जाने वाली कुंजी। स्वचालित रूप से उत्पन्न होती है।",
  "li_localizedtext_2": "<code>isStyleOnly</code>: यदि <code>true</code>, तो घटक केवल शैलियों (फ़ॉन्ट, आरटीएल) को लागू करेगा लेकिन टेक्स्ट को नहीं बदलेगा। उन तत्वों के लिए उपयोगी है जिनका टेक्स्ट किसी अन्य स्क्रिप्ट (जैसे, <code>LanguageSelector</code>) द्वारा प्रबंधित किया जाता है।",
  "li_localizedtext_3": "<code>originalSourceText</code>: आधार भाषा में मूल टेक्स्ट। फ़ॉलबैक के रूप में उपयोग किया जाता है।",
  "h2_localizedasset": "3.2. स्थानीयकृत संपत्ति",
  "p_localizedasset_1": "संपत्तियों (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code>, आदि) को स्वैप करने के लिए उपयोग किया जाता है। यह स्वचालित रूप से ऑब्जेक्ट पर लक्ष्य घटक प्रकार (<code>Image</code>, <code>AudioSource</code>) का पता लगाता है और उसके संसाधन को प्रतिस्थापित करता है।",
  "p_localizedasset_2": "<strong>Play on Awake</strong> विकल्प वाले घटकों (जैसे <code>AudioSource</code>, <code>VideoPlayer</code>) के लिए, <code>LocalizedAsset</code> ऑटो-प्ले को सही ढंग से रोकता है, संपत्ति को स्वैप करता है, और फिर गैर-स्थानीयकृत सामग्री को चलाने से बचने के लिए प्लेबैक शुरू करता है।",
  "h2_localizedprefab": "3.3. स्थानीयकृत प्रीफैब",
  "p_localizedprefab_1": "पूरे प्रीफैब को स्थानीयकृत करने के लिए एक घटक। यह गैर-विनाशकारी रूप से काम करता है: यह मूल प्रीफैब को संशोधित नहीं करता है, बल्कि स्थानीयकृत संस्करण का एक उदाहरण एक बाल ऑब्जेक्ट के रूप में बनाता है, मूल ऑब्जेक्ट पर सभी स्क्रिप्ट्स (<code>MonoBehaviour</code>), रेंडरर्स (<code>Renderer</code>), और कोलाइडर्स (<code>Collider</code>) को अक्षम कर देता है। यह दोहरी तर्क निष्पादन और दृश्य कलाकृतियों को रोकता है। सही रनटाइम संचालन के लिए, इसका निष्पादन क्रम -100 (<code>[DefaultExecutionOrder(-100)]</code>) पर सेट किया गया है ताकि यह सुनिश्चित हो सके कि यह अन्य स्क्रिप्ट्स से पहले चलता है।",
  "h2_uitklocalization": "3.4. यूआईटीके स्थानीयकरण",
  "p_uitklocalization_1": "<code>UIDocument</code> वाले ऑब्जेक्ट्स में जोड़ा गया और यूआई टूलकिट दस्तावेज़ (यूएक्सएमएल) के भीतर सभी टेक्स्ट तत्वों के स्थानीयकरण का प्रबंधन करता है।",
  "h2_localizeddropdown": "3.5. स्थानीयकृत ड्रॉपडाउन",
  "p_localizeddropdown_1": "<code>Dropdown</code> और <code>TMP_Dropdown</code> में उनके विकल्पों का अनुवाद करने के लिए जोड़ा गया।",
  "h2_localizedbehaviour": "3.6. स्थानीयकृत व्यवहार",
  "p_localizedbehaviour_1": "एक उपयोगिता घटक जो आपकी स्क्रिप्ट्स को भाषा परिवर्तनों पर प्रतिक्रिया करने की अनुमति देता है। यह स्वचालित रूप से <code>[OnLanguageChange]</code> विशेषता के साथ चिह्नित विधियों को ढूंढता है और कॉल करता है।",
  "h2_context_menu": "3.7. \"स्थानीयकरण के लिए विश्लेषण करें\" संदर्भ मेनू",
  "p_context_menu_1": "किसी ऑब्जेक्ट में <code>LocalizedAsset</code> को जल्दी से जोड़ने के लिए, आप इंस्पेक्टर में वांछित घटक (जैसे, <code>Image</code>, <code>AudioSource</code>) पर राइट-क्लिक कर सकते हैं और <strong>Analyze for Localization</strong> का चयन कर सकते हैं। उपकरण स्वयं घटक को जोड़ेगा और कॉन्फ़िगर करेगा। (यह वैकल्पिक है लेकिन मैन्युअल जोड़ के लिए इस्तेमाल किया जा सकता है)।",
  "h1_loc_tool_window": "\"स्थानीयकरण उपकरण\" विंडो",
  "h2_in_editor_preview": "4.1. इन-एडिटर और प्रीफैब पूर्वावलोकन",
  "p_preview_1": "हेडर के ठीक नीचे <strong>Preview Language</strong> ड्रॉपडाउन सूची है। यह शक्तिशाली सुविधा आपको यह देखने की अनुमति देती है कि गेम चलाए बिना <strong>Scene</strong> विंडो या <strong>Prefab Mode</strong> में सीधे किसी भी भाषा में स्थानीयकरण कैसा दिखेगा।",
  "li_preview_1": "<strong>यह कैसे काम करता है:</strong> सूची से एक भाषा चुनें, और उपकरण तुरंत संबंधित अनुवाद, फोंट, आरटीएल सेटिंग्स, और संपत्तियों को सक्रिय दृश्य या खुले प्रीफैब में सभी स्थानीयकरण योग्य ऑब्जेक्ट्स पर लागू करेगा।",
  "li_preview_2": "<strong>प्लेसहोल्डर:</strong> यदि <strong>Settings</strong> टैब में एक प्लेसहोल्डर शैली (जैसे, <strong>Accents</strong> या <strong>Brackets</strong>) का चयन किया गया है, तो ये प्लेसहोल्डर वास्तविक अनुवादों के बजाय पूर्वावलोकन मोड में प्रदर्शित होंगे। यह लेआउट का परीक्षण करने और अलोकलाइज्ड तत्वों को खोजने के लिए आदर्श है।",
  "li_preview_3": "<strong>सुरक्षा:</strong> पूर्वावलोकन मोड में किए गए सभी परिवर्तन अस्थायी हैं। जब आप \"<strong>Revert to Original</strong>\" का चयन करते हैं, विंडो बंद करते हैं, दृश्य बदलते हैं, या दृश्य/प्रीफैब को सहेजने से पहले (<code>LocalizationPreviewProtector</code> घटक के लिए धन्यवाद) उपकरण स्वचालित रूप से सब कुछ अपनी मूल स्थिति में वापस कर देगा।",
  "li_preview_4": "<strong>क्रैश सुरक्षा:</strong> अंतर्निहित <code>PreviewCrashProtector</code> प्रणाली स्वचालित रूप से ऑब्जेक्ट्स की मूल स्थिति को पुनर्स्थापित करेगी यदि यूनिटी संपादक पूर्वावलोकन सक्रिय होने पर क्रैश हो जाता है। अब प्रीफैब मोड में भी पुनर्स्थापना का समर्थन करता है।",
  "h2_tab_settings": "4.2. \"सेटिंग्स\" टैब",
  "p_settings_1": "आपका नियंत्रण केंद्र। यहां आप पूरी स्थानीयकरण प्रक्रिया के लिए वैश्विक नियम परिभाषित करते हैं।",
  "li_settings_1": "<strong>कुंजी निर्माण मोड:</strong> चुनें कि कुंजियाँ कैसे बनाई जाएंगी।<ul><li><code>UseTextAsKey</code>: टेक्स्ट स्वयं कुंजी बन जाता है। प्रोटोटाइप के लिए आदर्श। नकारात्मक पक्ष: यदि आप स्रोत टेक्स्ट बदलते हैं, तो कुंजी बदल जाती है, और उसके सभी अनुवाद खो जाएंगे।</li><li><code>AutoGenerateKeysOnly</code>: कुंजी ऑब्जेक्ट के पदानुक्रम और नाम के आधार पर उत्पन्न होती है। उत्पादन के लिए विश्वसनीय। सकारात्मक पक्ष: टेक्स्ट बदलने पर अनुवाद नहीं टूटते हैं।</li><li><code>UseTextAsKeyWithCustomPriority</code> और <code>AutoGenerateWithCustomKeys</code>: हाइब्रिड मोड जो आपको <code>[LocalizableField(\"my_custom_key\")]</code> विशेषता के माध्यम से कोड में कस्टम कुंजियाँ सेट करने की अनुमति देते हैं।</li><li><strong>सुरक्षित प्रवासन:</strong> आप किसी भी समय मोड बदल सकते हैं। उपकरण स्वचालित रूप से सभी मौजूदा अनुवादों को नई कुंजी प्रणाली में स्थानांतरित कर देगा।</li></ul>",
  "li_settings_2": "<strong>भाषा प्रबंधन:</strong> भाषाओं की सूची कॉन्फ़िगर करें। विशेष वर्णों वाली भाषाओं के लिए, उपयुक्त <strong>Font Asset</strong> असाइन करें। दाएं-से-बाएं भाषाओं के लिए <strong>RTL</strong> विकल्प सक्षम करें।",
  "li_settings_3": "<strong>सामान्य सेटिंग्स:</strong><ul><li><code>Parse Prefabs</code>: प्रीफैब पार्सिंग सक्षम करता है।</li><li><code>Split files by language</code>: यह निर्धारित करता है कि अनुवाद कैसे संग्रहीत करें (एक बड़ी फ़ाइल या प्रति भाषा एक फ़ाइल)।</li><li><code>Translations Path</code>: <code>.json</code> अनुवाद फ़ाइलों को संग्रहीत करने का पथ। महत्वपूर्ण: फ़ोल्डर <code>Assets/StreamingAssets/</code> के अंदर होना चाहिए।</li></ul>",
  "li_settings_4": "<strong>डिबगिंग और परीक्षण:</strong><ul><li><code>Placeholder Style</code>: पूर्वावलोकन मोड में प्लेसहोल्डर प्रदर्शित करने के लिए शैली चुनें।</li></ul>",
  "li_settings_5": "<strong>लाइव अपडेट:</strong> रिमोट सर्वर से अनुवाद लोड करने के लिए सेटिंग्स।",
  "li_settings_6": "<strong>रनटाइम एपीआई कुंजी:</strong> संकलित गेम में आवश्यक हो सकने वाली एपीआई कुंजी को सुरक्षित रूप से संग्रहीत करने के लिए एक अनुभाग (एन्क्रिप्टेड रूप में संग्रहीत)।",
  "h2_tab_content": "4.3. \"सामग्री\" टैब (v1.1 में पुन: डिज़ाइन किया गया)",
  "p_content_1": "यहां आप उपकरण को बताते हैं कि टेक्स्ट को ठीक से कहां देखना है। इंटरफ़ेस को बेहतर उपयोगिता के लिए पूरी तरह से पुन: डिज़ाइन किया गया है।",
  "li_content_1": "<strong>पार्स करने के लिए दृश्य:</strong> विश्लेषण के लिए सभी दृश्यों को यहां खींचें और छोड़ें।",
  "li_content_2": "<strong>प्रीफैब फ़ोल्डर:</strong> प्रीफैब वाले फ़ोल्डर निर्दिष्ट करें। अब बड़े प्रोजेक्ट्स के लिए पृष्ठन और खोज का समर्थन करता है।",
  "li_content_3": "<strong>गतिशील ग्रंथ:</strong> यहां विशेष रूप से कोड में बनाई गई स्ट्रिंग्स दर्ज करें (जैसे, \"गेम ओवर\")।",
  "li_content_4": "<strong>पार्सिंग উপেক্ষা:</strong> अनदेखा करने के लिए स्क्रिप्ट्स, घटक, या ऑब्जेक्ट्स निर्दिष्ट करें।",
  "li_content_5": "<strong>पिन:</strong> यह सुविधा आपको दृश्य से किसी ऑब्जेक्ट को अनदेखा सूची में \"पिन\" करने की अनुमति देती है। ऑब्जेक्ट के अस्थायी संदर्भ के बजाय, उपकरण पदानुक्रम में अपना पूरा पथ सहेज लेगा, जिससे अनदेखी सत्रों के बीच बनी रहेगी।",
  "h2_tab_actions": "4.4. \"क्रियाएँ\" टैब",
  "p_actions_1": "मुख्य कार्य टैब।",
  "li_actions_1": "<strong>कुंजियाँ अपडेट करें:</strong> पार्सर चलाता है, जो आपकी अनुवाद फ़ाइलों को अपडेट करता है।",
  "li_actions_2": "<strong>अनुवाद संपादक खोलें:</strong> सभी अनुवादों को संपादित करने के लिए एक अलग, अधिक सुविधाजनक विंडो खोलता है।",
  "li_actions_3": "<strong>डेटा प्रबंधन:</strong> अनुवादकों के साथ डेटा का आदान-प्रदान करने के लिए उपयोग करें (सीएसवी/एक्सएमएल/वाईएएमएल/एक्सएलआईएफएफ में निर्यात/आयात, गूगल शीट्स से आयात)।",
  "li_actions_4": "<strong>ऑटो-अनुवाद:</strong> सभी खाली अनुवाद स्ट्रिंग्स को स्वचालित रूप से सक्रिय **अनुवाद प्रोफाइल** का उपयोग करके भरता है।",
  "li_actions_5": "<strong>खतरा क्षेत्र:</strong> प्रोजेक्ट से सभी स्थानीयकरण घटकों को पूरी तरह से हटाने के लिए बटन शामिल हैं। सावधानी से प्रयोग करें!",
  "h2_tab_assets": "4.5. \"संपत्तियाँ\" टैब",
  "p_assets_1": "यह टैब पूरी तरह से गैर-पाठ संसाधनों को स्थानीयकृत करने के लिए समर्पित है।",
  "li_assets_1": "<strong>एक फ़ोल्डर संरचना बनाएँ (वैकल्पिक):</strong> अनुभाग <strong>2. Asset Folder Generation</strong> में, <strong>Create Asset Folders Now</strong> पर क्लिक करें।",
  "li_assets_2": "<strong>श्रेणियाँ और नामकरण नियम कॉन्फ़िगर करें:</strong> अनुभाग <strong>3. Asset Categories & Scanning</strong> में, सुनिश्चित करें कि <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) आपकी फ़ाइलों से मेल खाता है (जैसे, <code>button_ok_en.png</code>)।",
  "li_assets_3": "<strong>अपनी संपत्तियाँ रखें:</strong> स्थानीयकृत संपत्तियों को फ़ोल्डरों में रखें।",
  "li_assets_4": "<strong>संपत्तियाँ स्कैन करें:</strong> अनुभाग <strong>4. Automation</strong> में, <strong>Scan Assets & Update Tables</strong> पर क्लिक करें। सफाई प्रक्रिया सुरक्षित हो गई है: अब केवल पुरानी तालिका फ़ाइलें (<code>.asset</code>) हटाई जाती हैं, न कि पूरा फ़ोल्डर।",
  "li_assets_5": "<strong>संपत्तियों को ऑब्जेक्ट्स से लिंक करें:</strong> <strong>Analyze Project & Attach Components</strong> पर क्लिक करें।",
  "h2_tab_report": "4.6. \"रिपोर्ट\" टैब",
  "p_report_1": "प्रत्येक पार्सिंग के बाद, यह रिपोर्ट आपकी स्थानीयकरण स्थिति की पूरी तस्वीर दिखाती है।",
  "li_report_1": "<strong>श्रेणियाँ:</strong> सभी कुंजियाँ, जोड़ी गईं, अपडेट की गईं (टेक्स्ट बदला गया), हटाई गईं, डुप्लिकेट, माइग्रेट की गईं, छोड़ी गईं (अपरिवर्तित)।",
  "li_report_2": "<strong>उन्नत खोज:</strong> प्रोजेक्ट में संबंधित ऑब्जेक्ट को तुरंत खोजने के लिए किसी भी प्रविष्टि के बगल में <strong>Find</strong> बटन पर क्लिक करें। खोज अतुल्यकालिक रूप से काम करती है, संपादक को अवरुद्ध नहीं करती है, और सभी दृश्यों और प्रीफैब्स में खोज करती है।",
  "h1_translation_editor": "5. अनुवाद तालिका संपादक",
  "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong> के माध्यम से खुलता है। यह अनुवादों को मैन्युअल रूप से संपादित करने का मुख्य उपकरण है।",
  "li_editor_1": "<strong>स्मार्ट समूहीकरण:</strong> बहुवचन और लिंग के लिए कुंजियाँ (जैसे, <code>apple_count_one</code>, <code>apple_count_few</code>) स्वचालित रूप से बंधने योग्य समूहों में संयुक्त हो जाती हैं।",
  "li_editor_2": "<strong>उन्नत संपादन:</strong> <strong>MultiLineEditWindow</strong> पॉपअप खोलने के लिए एक सेल पर क्लिक करें। यह तुलना के लिए स्रोत टेक्स्ट दिखाता है और प्लेसहोल्डर को मान्य करता है।",
  "li_editor_3": "<strong>उन्नत चयन (नया):</strong> व्यक्तिगत सेल्स, पंक्तियों या पूरे कॉलम (भाषाओं) के चयन का समर्थन करता है।",
  "li_editor_4": "<strong>सामूहिक क्रियाएं (नया):</strong> सामूहिक संचालन करने के लिए एक चयन पर राइट-क्लिक करें: चयनित सेल्स का ऑटो-अनुवाद करें, सामग्री साफ़ करें, या कुंजियाँ हटाएँ।",
  "li_editor_5": "<strong>स्मार्ट नेविगेशन (नया):</strong> कीबोर्ड तीरों और शॉर्टकट (सहेजने के लिए Ctrl+S, पूर्ववत/फिर से करें के लिए Ctrl+Z/Y) का उपयोग करके तालिका को नेविगेट करें।",
  "li_editor_6": "<strong>लंबाई जांच (नया):</strong> स्रोत टेक्स्ट की तुलना में काफी लंबे अनुवादों को उजागर करने के लिए \"Has Length Issues\" फ़िल्टर का उपयोग करें (विन्यास योग्य सीमा)।",
  "h1_ai_profiles": "6. AI और अनुवाद प्रोफाइल (नया v1.1)",
  "h2_ai_profiles_overview": "6.1. अनुवाद प्रोफाइल",
  "p_ai_intro": "संस्करण 1.1 एक नया **अनुवाद प्रोफाइल** सिस्टम (ScriptableObject) पेश करता है। यह अनुवाद सेवा सेटिंग्स को वैश्विक सेटिंग्स से हटाकर व्यक्तिगत प्रोफाइल एसेट्स में ले जाता है, जिससे आप आसानी से कॉन्फ़िगरेशन बदल सकते हैं।",
  "li_ai_1": "<strong>प्रोफाइल बनाएं:</strong> प्रोजेक्ट दृश्य में राइट-क्लिक करें -> बनाएं -> स्थानीयकरण -> अनुवाद प्रोफाइल।",
  "li_ai_2": "<strong>सेवाएं:</strong> DeepL, Google Translate, Microsoft Azure, और **कस्टम AI** का समर्थन करता है।",
  "li_ai_3": "<strong>सेटिंग्स:</strong> प्रत्येक प्रोफाइल अपनी एपीआई कुंजी, सीमाएं (बैच आकार, अधिकतम वर्ण), और मॉडल सेटिंग्स संग्रहीत करता है।",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> लोकप्रिय सेवाओं (OpenAI, Gemini, Claude, Ollama) के लिए प्रोफाइल को जल्दी से बनाने के लिए अंतर्निहित जनरेटर का उपयोग करें।",
  "h2_custom_ai": "6.2. कस्टम AI और मॉडल",
  "p_custom_ai": "<strong>कस्टम AI</strong> सेवा प्रकार आपको REST API के माध्यम से किसी भी LLM को जोड़ने की अनुमति देता है।",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> एक लचीला कार्यान्वयन जो OpenAI-संगत एपीआई (स्थानीय LLM सहित Ollama के माध्यम से) के साथ संवाद कर सकता है।",
  "li_custom_ai_2": "<strong>टेम्प्लेट:</strong> अपनी एपीआई की आवश्यकताओं से मेल खाने के लिए अनुरोध बॉडी JSON टेम्प्लेट को अनुकूलित करें।",
  "h2_ai_context": "6.3. संदर्भ और शब्दावली",
  "p_ai_context": "अनुवाद की गुणवत्ता में सुधार के लिए, AI को अब अतिरिक्त संदर्भ प्राप्त होता है:",
  "li_context_1": "<strong>डेवलपर नोट्स:</strong> अनुवाद तालिका से टिप्पणियाँ AI को संदर्भ के रूप में पास की जाती हैं।",
  "li_context_2": "<strong>ऑब्जेक्ट पाथ:</strong> यदि कोई टिप्पणी मौजूद नहीं है, तो ऑब्जेक्ट के पदानुक्रम पाथ (जैसे, <code>MainMenu/Canvas/StartButton</code>) का उपयोग फ़ॉलबैक संदर्भ के रूप में किया जाता है।",
  "li_context_3": "<strong>शब्दावली:</strong> आप शब्दों और नामों के लिए विशिष्ट अनुवादों को लागू करने के लिए प्रोफाइल में एक CSV शब्दावली लोड कर सकते हैं।",
  "h2_ai_assistant": "6.4. AI सहायक कमांड",
  "p_ai_assistant": "अनुवाद तालिका संपादक में, अब आप संदर्भ मेनू (राइट-क्लिक -> AI: ...) के माध्यम से चयनित सेल्स पर कस्टम AI कमांड चला सकते हैं।",
  "li_assistant_1": "<strong>विन्यास योग्य:</strong> अपनी अनुवाद प्रोफाइल में कमांड परिभाषित करें (जैसे, \"व्याकरण ठीक करें\", \"औपचारिक बनाएं\", \"यूआई के लिए छोटा करें\")।",
  "li_assistant_2": "<strong>बैच प्रोसेसिंग:</strong> उन सभी पर कमांड लागू करने के लिए कई सेल्स का चयन करें।",
  "h1_usage_examples": "7. उपयोग के उदाहरण",
  "h2_example_components": "7.1. तैयार घटक और उदाहरण",
  "p_example_components_1": "प्रोजेक्ट में उपयोग के लिए तैयार स्क्रिप्ट्स शामिल हैं जो उत्कृष्ट उदाहरण के रूप में काम करती हैं।",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> भाषा स्विचिंग के लिए यूआई ड्रॉपडाउन सूची बनाने के लिए एक तैयार घटक। यह स्वचालित रूप से सभी उपलब्ध भाषाओं को ढूंढता है और उनके स्विचिंग का प्रबंधन करता है।<br><strong>कैसे उपयोग करें:</strong> बस अपने दृश्य में <code>LanguageSelector</code> घटक जोड़ें (जैसे, एक खाली गेमऑब्जेक्ट पर) और इंस्पेक्टर में अपना <code>TMP_Dropdown</code> निर्दिष्ट करें।",
  "li_example_components_2": "<strong>कोड उदाहरण:</strong> <code>[LocalizableField]</code>, <code>_()</code> फ़ंक्शन, बहुवचन और लिंग के साथ काम करने जैसी उन्नत तकनीकों को सीखने के लिए, <code>StatPurchaseTest.cs</code> और <code>TestLocalization.cs</code> फ़ाइलों का अध्ययन करें। वे कोड में उपकरण की सभी मुख्य विशेषताओं के कार्यान्वयन को स्पष्ट रूप से प्रदर्शित करते हैं।",
  "h2_example_attribute": "7.2. [LocalizableField] विशेषता",
  "p_example_attribute_1": "इंस्पेक्टर में किसी घटक के कॉन्फ़िगरेशन का हिस्सा बनने वाले टेक्स्ट के लिए पसंदीदा तरीका। पार्सर अब स्ट्रिंग्स, स्ट्रिंग्स की सूचियों/सरणियों, और यहां तक कि नेस्टेड <code>[System.Serializable]</code> कक्षाओं के भीतर फ़ील्ड के साथ काम कर सकता है।",
  "code_example_attribute": "using Ankonoanko.Localization; // [LocalizableField] के लिए आवश्यक\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // पार्सर इस फ़ील्ड को ढूंढेगा और इसके लिए एक कुंजी बनाएगा\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"आप खोज में विफल हो गए हैं।\";\n    \n    // आप एक कस्टम कुंजी सेट कर सकते हैं\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"क्या आप एक साहसिक कार्य के लिए तैयार हैं?\";\n    \n    // सूचियों के साथ काम करता है\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"खजाना खोजें\" };\n    \n    // और नेस्टेड कक्षाओं के साथ भी!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. _() फ़ंक्शन और [OnLanguageChange] विशेषता",
  "p_example_function_1": "गेमप्ले के दौरान बदलने वाले गतिशील टेक्स्ट के लिए <code>_()</code> फ़ंक्शन का उपयोग करें। यूआई को अपडेट करने वाली विधि को <code>[OnLanguageChange]</code> विशेषता के साथ चिह्नित किया जाना चाहिए ताकि भाषा बदलने पर इसे स्वचालित रूप से कॉल किया जा सके। इस उद्देश्य के लिए ऑब्जेक्ट में एक <code>LocalizedBehaviour</code> घटक स्वचालित रूप से जोड़ा जाएगा।",
  "code_example_function": "// छोटे _() कॉल का उपयोग करने के लिए, इन पंक्तियों को जोड़ें\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange] के लिए आवश्यक\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // प्रारंभिक अपडेट\n    }\n    \n    // भाषा बदलने पर यह विधि स्वचालित रूप से कॉल की जाएगी\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. अनुक्रमित प्लेसहोल्डर (string.Format की तरह)\n        // कुंजी: \"score_label\", फ़ाइल में टेक्स्ट: \"स्कोर: {0}\"\n        scoreText.text = _(\"score_label\", score); // परिणाम: \"स्कोर: 100\"\n        \n        // 2. नामित प्लेसहोल्डर (पठनीयता के लिए अनुशंसित)\n        // कुंजी: \"welcome_message\", टेक्स्ट: \"स्वागत है, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // जटिल मामलों या उच्च प्रदर्शन के लिए\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. बहुवचन और लिंग",
  "p_example_plurals_1": "उपकरण अब विभिन्न भाषा समूहों के लिए अधिक सटीक नियमों का उपयोग करता है।",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // कुंजियाँ: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // ग्रंथ: \"{0} सेब\", \"{0} सेब\", \"{0} सेब\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // स्वचालित रूप से सही रूप का चयन करता है\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // कुंजियाँ: \"user_greeted_male\", \"user_greeted_female\"\n        // ग्रंथ: \"वह आ गया है।\", \"वह आ गई है।\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "8. महत्वपूर्ण नोट्स और चेतावनियाँ",
  "li_notes_1": "<strong>बैकअप:</strong> वैश्विक संचालन (<code>Update Keys</code>, डेटा आयात) से पहले, हमेशा <strong>Translation Table Editor -> Manage Backups</strong> के माध्यम से एक बैकअप बनाएँ।",
  "li_notes_2": "<strong>एपीआई कुंजी सुरक्षा:</strong> संपादक में काम करने के लिए कुंजी आपकी मशीन पर स्थानीय रूप से संग्रहीत होती है (<code>EditorPrefs</code> में) और रिपॉजिटरी में नहीं जाती है। गेम बिल्ड में आवश्यक कुंजियों के लिए, <strong>Runtime API Key</strong> अनुभाग का उपयोग करें।",
  "li_notes_3": "<strong><code>StreamingAssets</code> फ़ोल्डर:</strong> अनुवाद फ़ाइलों को गेम बिल्ड में शामिल करने के लिए <code>Assets/StreamingAssets/</code> के एक सबफ़ोल्डर में होना चाहिए।",
  "li_notes_4": "<strong>\"मूर्ख-प्रूफिंग\":</strong> उपकरण आपको पूर्वावलोकन मोड से अस्थायी डेटा को गलती से किसी दृश्य या प्रीफैब में सहेजने से स्वचालित रूप से बचाता है।",
  "li_notes_5": "<strong>प्रदर्शन:</strong> <code>_()</code> कॉल तेज़ है, लेकिन हर फ्रेम चलने वाले लूप में (जैसे, <code>Update</code> में), परिणाम को एक चर में कैश करने का प्रयास करें।",
  "li_notes_6": "<strong>पार्सिंग से <code>LanguageSelector</code> को बाहर करना:</strong> <code>LanguageSelector</code> घटक और उसके <code>TMP_Dropdown</code> वाले ऑब्जेक्ट को <strong>Content</strong> टैब में <strong>Ignore Specific Objects</strong> सूची में जोड़ा जाना चाहिए। यह पार्सर को ड्रॉपडाउन विकल्पों के लिए अतिरिक्त कुंजियाँ बनाने से रोकने के लिए आवश्यक है, क्योंकि <code>LanguageSelector</code> स्क्रिप्ट उन्हें रनटाइम पर गतिशील रूप से भरती है। अनदेखा करना संघर्षों को रोकता है और अनुवाद फ़ाइलों को साफ रखता है।",
  "li_notes_7": "<strong><code>LanguageSelector</code> के लिए फ़ॉन्ट्स:</strong> <code>TMP_Dropdown</code> में चयनित भाषा के लिए अपने फ़ॉन्ट को सही ढंग से अपडेट करने के लिए, ड्रॉपडाउन के चाइल्ड <strong>Label</strong> ऑब्जेक्ट में मैन्युअल रूप से एक खाली <code>LocalizedText</code> घटक जोड़ें और <code>isStyleOnly</code> बॉक्स को चेक करें।",
  "h1_extending": "9. कार्यक्षमता का विस्तार",
  "h2_custom_parser": "9.1. एक कस्टम पार्सर बनाना",
  "p_custom_parser_1": "आप अपनी स्वयं की पार्सर क्लास बनाकर कस्टम घटकों का समर्थन करने के लिए सिस्टम को आसानी से विस्तारित कर सकते हैं।",
  "li_custom_parser_1": "अपने प्रोजेक्ट के <strong>Editor</strong> फ़ोल्डर में एक नई C# स्क्रिप्ट बनाएँ।",
  "li_custom_parser_2": "नीचे दिए गए टेम्पलेट को उसमें कॉपी करें।",
  "li_custom_parser_3": "अपने घटक से मेल खाने के लिए तर्क को संशोधित करें।",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// एक कस्टम घटक के लिए एक पार्सर बनाने के लिए टेम्पलेट।\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. जांचें कि क्या ऑब्जेक्ट में हमें आवश्यक कस्टम घटक है।\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // यदि घटक नहीं मिला तो बाहर निकलें\n        }\n        \n        // 2. कस्टम घटक के फ़ील्ड से टेक्स्ट प्राप्त करें।\n        string titleText = component.Title;\n        \n        // 3. जांचें कि क्या टेक्स्ट स्थानीयकरण के लिए मान्य है।\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. TextParser से सहायकों का उपयोग करके कुंजी और स्रोत उत्पन्न करें।\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. परिणाम लौटाएँ।\n            yield return (titleText, key, source);\n        }\n        \n        // 6. अन्य फ़ील्ड के लिए दोहराएँ...\n        // (कुंजियों को अद्वितीय बनाने के लिए एक प्रत्यय जोड़ा जा सकता है)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "10. अक्सर पूछे जाने वाले प्रश्न और समस्या निवारण",
  "h2_faq_installation": "10.1. स्थापना और त्वरित शुरुआत",
  "q_faq_installation_1": "क्या होता है यदि मेरे प्रोजेक्ट में पहले से ही किसी अन्य संपत्ति से com.unity.nuget.newtonsoft-json पैकेज है? क्या निर्भरता इंस्टॉलर इसे अपडेट करने या अनदेखा करने का प्रयास करेगा?",
  "a_faq_installation_1": "इंस्टॉलर Newtonsoft.Json.JsonConvert प्रकार के अस्तित्व की जांच करता है। यदि प्रकार मौजूद है, तो यह निर्भरता को संतुष्ट मानता है और पैकेज को स्थापित या अपडेट करने का प्रयास नहीं करेगा। यह संस्करण संघर्षों को रोकने के लिए किया जाता है।",
  "q_faq_installation_2": "मैंने गलती से \"अभी के लिए छोड़ें\" पर क्लिक किया और वैकल्पिक निर्भरताओं (जैसे, सीएसवी समर्थन के लिए) के लिए \"फिर से न पूछें\" को चेक किया। मैं उन्हें स्थापित करने के लिए इंस्टॉलर विंडो को फिर से कैसे ला सकता हूं?",
  "a_faq_installation_2": "आप किसी भी समय Tools -> Localization -> Check Dependencies मेनू के माध्यम से मैन्युअल रूप से निर्भरता जांच शुरू कर सकते हैं। यह \"फिर से न पूछें\" ध्वज को रीसेट कर देगा और सभी लापता वैकल्पिक पैकेजों के साथ विंडो को फिर से दिखाएगा।",
  "q_faq_installation_3": "उपकरण ने Assets/Resources में LocalizationSettings.asset नहीं बनाया। ऐसा क्यों हो सकता है, और क्या मैं इसे Assets -> Create मेनू के माध्यम से मैन्युअल रूप से बना सकता हूं?",
  "a_faq_installation_3": "यह हो सकता है यदि आपके पास Assets/Resources फ़ोल्डर नहीं है। उपकरण इसे बनाने का प्रयास करेगा, लेकिन फ़ाइल सिस्टम अनुमतियाँ इसे रोक सकती हैं। हां, आप संपत्ति को मैन्युअल रूप से बना सकते हैं: Resources फ़ोल्डर में राइट-क्लिक करें, Create -> Localization -> Settings चुनें। उपकरण इसे स्वचालित रूप से ढूंढ लेगा।",
  "q_faq_installation_4": "क्या मैं LocalizationSettings.asset फ़ाइल को किसी अन्य Resources फ़ोल्डर में ले जा सकता हूं, उदाहरण के लिए, Assets/MyGame/Resources? क्या उपकरण अभी भी इसे ढूंढ पाएगा?",
  "a_faq_installation_4": "हाँ। उपकरण Resources.Load() का उपयोग करता है, जो आपके प्रोजेक्ट में Resources नामक सभी फ़ोल्डरों में नाम से एक संपत्ति की खोज करता है। महत्वपूर्ण बात यह है कि फ़ाइल अपना नाम LocalizationSettings.asset रखती है।",
  "q_faq_installation_5": "निर्भरता इंस्टॉलर जम गया या एक त्रुटि दी। क्या मैं निर्भरताओं (Newtonsoft Json, Editor Coroutines) को यूनिटी पैकेज मैनेजर के माध्यम से मैन्युअल रूप से स्थापित कर सकता हूं?",
  "a_faq_installation_5": "हाँ। आप Window -> Package Manager खोल सकते हैं, \"+\" आइकन पर क्लिक करें, और \"Add package by name...\" चुनें। पैकेज नाम दर्ज करें: com.unity.nuget.newtonsoft-json और com.unity.editorcoroutines।",
  "h2_faq_components": "10.2. मुख्य घटक",
  "q_faq_components_1": "LocalizedPrefab घटक मूल ऑब्जेक्ट पर MonoBehaviours को अक्षम कर देता है। क्या होगा यदि मूल ऑब्जेक्ट में एक स्क्रिप्ट है जो Awake() में अन्य ऑब्जेक्ट्स बनाती है या घटनाओं की सदस्यता लेती है? क्या यह कोड निष्पादित होगा?",
  "a_faq_components_1": "नहीं, यह नहीं होगा। MonoBehaviour को अक्षम करने से Unity के सभी \"जादू\" विधियों को कॉल करने से रोका जाता है, जिसमें Awake(), OnEnable(), और Start() शामिल हैं। यह जानबूझकर दोहरी तर्क निष्पादन से बचने के लिए किया जाता है। सभी आरंभीकरण प्रीफैब के स्थानीयकृत संस्करणों पर स्क्रिप्ट में होना चाहिए।",
  "q_faq_components_2": "यदि मूल प्रीफैब (LocalizedPrefab) में एक Rigidbody या कोई अन्य भौतिकी घटक है, तो क्या यह अक्षम हो जाएगा? क्या यह भौतिकी को प्रभावित करेगा यदि स्थानीयकृत प्रीफैब में यह नहीं है?",
  "a_faq_components_2": "हाँ, मूल ऑब्जेक्ट का भौतिकी व्यवहार निष्प्रभावी हो जाएगा। LocalizedPrefab घटक अपने GameObject पर सभी Rigidbody और Rigidbody2D घटकों को ढूंढता है और उनकी isKinematic संपत्ति को सही पर सेट करता है। यह उन्हें गतिशील भौतिकी गणनाओं से प्रभावी रूप से हटा देता है, जिससे एक अदृश्य वस्तु के गिरने या टक्करों पर प्रतिक्रिया करने जैसे अवांछित व्यवहार को रोका जा सकता है। यह अभी भी अनुशंसा की जाती है कि प्रीफैब के स्थानीयकृत संस्करण में सही व्यवहार के लिए सभी आवश्यक भौतिकी घटक हों।",
  "q_faq_components_3": "LocalizedAsset घटक लक्ष्य घटक नाम को एक स्ट्रिंग (_targetComponentTypeName) के रूप में संग्रहीत करता है। क्या होता है यदि मैं एक कस्टम घटक स्क्रिप्ट का नाम बदलता हूं या इसे किसी अन्य असेंबली (असेंबली परिभाषा) में ले जाता हूं? क्या LocalizedAsset इसके लिए काम करना बंद कर देगा?",
  "a_faq_components_3": "हां, यह काम करना बंद कर देगा। घटक नामस्थान और असेंबली सहित पूर्ण प्रकार का नाम संग्रहीत करता है। स्क्रिप्ट का नाम बदलने या इसे किसी अन्य .asmdef में ले जाने से यह नाम बदल जाएगा, और LocalizedAsset लक्ष्य घटक को नहीं ढूंढ पाएगा। नाम को अपडेट करने के लिए आपको Analyze Project & Attach Components के माध्यम से एक और विश्लेषण चलाने की आवश्यकता होगी।",
  "q_faq_components_4": "यदि एक ही GameObject पर दो Image घटक हैं, तो LocalizedAsset को कैसे पता चलेगा कि किसे स्थानीयकृत करना है? क्या यह दोनों के साथ काम करेगा या केवल पहले वाले के साथ जिसे वह पाता है?",
  "a_faq_components_4": "एक LocalizedAsset एक विशिष्ट घटक उदाहरण के लिए बनाया गया है। यह कोड में उस घटक का एक संदर्भ रखता है। यदि आप मैन्युअल रूप से एक दूसरा LocalizedAsset जोड़ते हैं और दूसरे Image को लक्षित करने के लिए \"Analyze for Localization\" संदर्भ मेनू का उपयोग करते हैं, तो आपके पास दो LocalizedAsset घटक होंगे, प्रत्येक अपने स्वयं के Image का प्रबंधन करेगा। स्वचालित विश्लेषक केवल पहले Image के लिए एक घटक बनाएगा जिसमें एक स्थानीयकरण योग्य संपत्ति मिलती है।",
  "q_faq_components_5": "दस्तावेज़ीकरण में कहा गया है कि LocalizedPrefab का निष्पादन क्रम -100 है। क्या होगा यदि मेरे पास निष्पादन क्रम -110 के साथ एक और स्क्रिप्ट है जो अपने Awake() में LocalizedPrefab द्वारा बनाए गए एक बाल ऑब्जेक्ट को खोजने का प्रयास करती है? क्या LocalizedPrefab समय पर अपने उदाहरण को तत्काल कर पाएगा?",
  "a_faq_components_5": "हाँ, यह होगा। LocalizedPrefab अपने OnEnable() विधि में स्थानीयकृत प्रीफैब का उदाहरण बनाता है। Unity का निष्पादन क्रम गारंटी देता है कि सभी Awake() विधियाँ सभी OnEnable() विधियों से पहले निष्पादित होती हैं। इस प्रकार, क्रम -110 के साथ आपकी स्क्रिप्ट अपने Awake() को निष्पादित करेगी, फिर क्रम -100 के साथ LocalizedPrefab अपने Awake() को निष्पादित करेगा, और उसके बाद ही उनके OnEnable() विधियों को क्रम में बुलाया जाएगा। आपकी स्क्रिप्ट ऑब्जेक्ट को नहीं ढूंढ पाएगी क्योंकि यह अभी तक नहीं बनाया गया होगा।",
  "q_faq_components_6": "LocalizedText घटक में एक isStyleOnly विकल्प है। यदि मैं इसे सक्षम करता हूं और फिर कोड में myLocalizedText.SetFormattedText(\"new_key\") को कॉल करता हूं, तो क्या टेक्स्ट बदल जाएगा, या केवल शैली (फ़ॉन्ट/आरटीएल)?",
  "a_faq_components_6": "कुंजी और टेक्स्ट दोनों बदल जाएंगे। SetFormattedText को प्रोग्रामेटिक रूप से कॉल करना उस विशिष्ट अपडेट के लिए isStyleOnly व्यवहार को ओवरराइड करता है। isStyleOnly विकल्प का उद्देश्य घटक को वैश्विक भाषा परिवर्तनों पर प्रतिक्रिया करने से रोकना है, लेकिन यह हमेशा कोड के माध्यम से सीधे कुंजी परिवर्तन पर प्रतिक्रिया करेगा।",
  "q_faq_components_7": "LocalizedBehaviour स्वचालित रूप से [OnLanguageChange] विशेषता के साथ विधियों को ढूंढता है। क्या यह निजी और संरक्षित विधियों को ढूंढेगा, या उन्हें सार्वजनिक होना चाहिए?",
  "a_faq_components_7": "यह किसी भी एक्सेस संशोधक (सार्वजनिक, निजी, संरक्षित, आंतरिक) के साथ विधियों को ढूंढेगा। Unity में प्रतिबिंब उनके एक्सेस स्तर की परवाह किए बिना सभी उदाहरण विधियों की खोज की अनुमति देता है।",
  "q_faq_components_8": "LocalizedAsset घटक Play on Awake को रोकता है। क्या होता है यदि एक ही ऑब्जेक्ट पर कोई अन्य स्क्रिप्ट Awake() या Start() में संपत्ति तक पहुंचने का प्रयास करती है (जैसे, audioSource.clip.length) इससे पहले कि LocalizedAsset इसे स्वैप कर दे? क्या NullReferenceException या पुरानी संपत्ति का उपयोग संभव है?",
  "a_faq_components_8": "पुरानी (गैर-स्थानीयकृत) संपत्ति का उपयोग संभव है। LocalizedAsset अपने OnEnable() में स्वैप करता है। सभी स्क्रिप्ट्स की Awake() विधियाँ OnEnable() से पहले निष्पादित होती हैं। यदि आपकी स्क्रिप्ट Awake() में audioSource.clip तक पहुंचती है, तो उसे मूल क्लिप मिलेगी। यदि यह Start() में पहुंचती है, तो परिणाम स्क्रिप्ट निष्पादन क्रम पर निर्भर करेगा। स्थानीयकृत संपत्ति तक पहुंच की गारंटी के लिए, या तो अपनी स्क्रिप्ट के लिए बाद का निष्पादन क्रम सेट करें या [OnLanguageChange] के साथ चिह्नित विधि में संपत्ति तक पहुंचें।",
  "h2_faq_window": "10.3. \"स्थानीयकरण उपकरण\" विंडो",
  "h3_faq_window_preview": "इन-एडिटर पूर्वावलोकन",
  "q_faq_window_preview_1": "मैंने प्रीफैब मोड में एक प्रीफैब खोला, इन-एडिटर पूर्वावलोकन लागू किया, और Ctrl+S दबाया। क्या अस्थायी पूर्वावलोकन डेटा प्रीफैब संपत्ति में सहेजा जाएगा? LocalizationPreviewProtector इस मामले को कैसे संभालता है?",
  "a_faq_window_preview_1": "नहीं, यह सहेजा नहीं जाएगा। LocalizationPreviewProtector संपत्ति सहेजने की घटना (OnWillSaveAssets) को रोकता है और Unity द्वारा डिस्क पर परिवर्तनों को लिखने से पहले स्वचालित रूप से RevertEditorPreview() को कॉल करता है। इस प्रकार, प्रीफैब अपनी मूल, गैर-स्थानीयकृत स्थिति में सहेजा जाएगा।",
  "q_faq_window_preview_2": "यदि मैं इन-एडिटर पूर्वावलोकन सक्षम करता हूं और यूनिटी संपादक क्रैश हो जाता है, और Temp/localization_preview_recovery.json फ़ाइल दूषित हो जाती है (जैसे, खाली या अमान्य JSON), तो अगले लॉन्च पर क्या होगा?",
  "a_faq_window_preview_2": "PreviewCrashProtector एक ट्राई-कैच ब्लॉक में लिपटा हुआ है। यदि JSON डिसेरियलाइज़ेशन विफल हो जाता है, तो पुनर्प्राप्त करने में असमर्थता के बारे में कंसोल में एक त्रुटि लॉग की जाएगी, और प्रक्रिया चुपचाप समाप्त हो जाएगी। आपका दृश्य उस \"टूटी हुई\" स्थिति में रहेगा जिसमें वह क्रैश के समय था। इस मामले में, परिवर्तनों के रोलबैक को बाध्य करने के लिए आपको टूल विंडो में मैन्युअल रूप से \"Revert to Original\" का चयन करना होगा।",
  "q_faq_window_preview_3": "LocalizedPrefab के लिए इन-एडिटर पूर्वावलोकन मोड में, एक अस्थायी उदाहरण बनाया जाता है। क्या इस उदाहरण पर Awake() और Start() विधियाँ निष्पादित होंगी? क्या इससे त्रुटियाँ हो सकती हैं यदि वे संपादन मोड में चलने के लिए डिज़ाइन नहीं किए गए हैं?",
  "a_faq_window_preview_3": "हाँ, वे होंगे। संपादन मोड में PrefabUtility.InstantiatePrefab Awake() और OnEnable() को कॉल करता है। यदि इन विधियों में तर्क है जो संपादक में नहीं चलना चाहिए (जैसे, केवल प्ले मोड में मौजूद सिंगलटन तक पहुंचना), तो इससे त्रुटियाँ हो सकती हैं। ऐसे कोड की सुरक्षा के लिए if (Application.isPlaying) या #if UNITY_EDITOR का उपयोग करने की अनुशंसा की जाती है।",
  "h3_faq_window_settings": "\"सेटिंग्स\" टैब",
  "q_faq_window_settings_1": "मैं मध्य-प्रोजेक्ट में कुंजी निर्माण मोड को UseTextAsKey से AutoGenerateKeysOnly में बदल सकता हूं। मेरे मौजूदा अनुवादों के साथ वास्तव में क्या होगा? क्या वे नई कुंजियों पर मैप किए जाएंगे?",
  "a_faq_window_settings_1": "हाँ, वे होंगे। मोड बदलते समय, उपकरण एक \"सुरक्षित प्रवासन\" करता है: यह पूरे प्रोजेक्ट को फिर से पार्स करता है, नए नियमों के अनुसार नई कुंजियाँ बनाता है, लेकिन पुरानी और नई कुंजियों को मूल टेक्स्ट के माध्यम से मैप करता है। फिर यह आपके सभी मौजूदा अनुवादों और टिप्पणियों को पुरानी कुंजियों से नई कुंजियों में स्थानांतरित करता है। आपके अनुवाद नहीं खोएंगे।",
  "q_faq_window_settings_2": "यदि मैं समर्थित भाषाओं की सूची में एक ऐसी भाषा जोड़ता हूं जिसमें बहुवचन नियम नहीं हैं (जैसे, कज़ाख के लिए \"kz\"), तो डिफ़ॉल्ट रूप से कौन सा नियम उपयोग किया जाएगा?",
  "a_faq_window_settings_2": "DefaultPluralRule का उपयोग किया जाएगा, जो अंग्रेजी और अधिकांश यूरोपीय भाषाओं (\"एक\" और \"अन्य\" के रूपों) के लिए उपयुक्त है।",
  "q_faq_window_settings_3": "क्या होगा यदि मैं StreamingAssets में नहीं, बल्कि Assets/MyTranslations जैसे एक नियमित फ़ोल्डर में अनुवाद पथ निर्दिष्ट करता हूं? क्या json फ़ाइलें गेम बिल्ड में शामिल होंगी?",
  "a_faq_window_settings_3": "नहीं, वे नहीं होंगे। केवल StreamingAssets या Resources फ़ोल्डर में स्थित संपत्तियाँ बिल्ड में शामिल होने की गारंटी हैं। यदि आप एक अलग पथ निर्दिष्ट करते हैं, तो स्थानीयकरण संपादक में काम करेगा लेकिन संकलित गेम में काम नहीं करेगा, क्योंकि अनुवाद फ़ाइलें बिल्ड का हिस्सा नहीं होंगी।",
  "q_faq_window_settings_4": "ऑटो-अनुवाद एपीआई कुंजी EditorPrefs में संग्रहीत है। यदि मैं दो अलग-अलग कंप्यूटरों पर प्रोजेक्ट पर काम कर रहा हूं, तो क्या मुझे प्रत्येक मशीन पर अलग से कुंजी दर्ज करने की आवश्यकता है?",
  "a_faq_window_settings_4": "हाँ। EditorPrefs प्रत्येक कंप्यूटर के लिए स्थानीय भंडारण है। आपको प्रत्येक मशीन पर एपीआई कुंजी दर्ज करने की आवश्यकता होगी जिससे आप ऑटो-अनुवाद सुविधा का उपयोग करने की योजना बना रहे हैं।",
  "h3_faq_window_content": "\"सामग्री\" टैब",
  "q_faq_window_content_1": "क्या होगा यदि मैं पार्स करने के लिए दृश्यों में एक ऐसा दृश्य जोड़ता हूं जो बिल्ड सेटिंग्स में शामिल नहीं है? क्या यह पार्सिंग प्रक्रिया के अलावा किसी और चीज को प्रभावित करेगा?",
  "a_faq_window_content_1": "नहीं, यह नहीं होगा। पार्स करने के लिए दृश्यों की सूची का उपयोग विशेष रूप से उपकरण को यह बताने के लिए किया जाता है कि कौन से दृश्यों को खोलना और टेक्स्ट के लिए विश्लेषण करना है। इसका आपके गेम के अंतिम बिल्ड में समाप्त होने वाले दृश्यों से कोई लेना-देना नहीं है।",
  "q_faq_window_content_2": "मैंने विशिष्ट ऑब्जेक्ट्स को अनदेखा करें (अस्थायी सूची) में एक ऑब्जेक्ट जोड़ा। यदि मैं इस ऑब्जेक्ट से एक प्रीफैब बनाता हूं, तो क्या इस प्रीफैब का उदाहरण भी अनदेखा किया जाएगा?",
  "a_faq_window_content_2": "नहीं, यह नहीं होगा। अस्थायी सूची दृश्य में ऑब्जेक्ट का सीधा संदर्भ संग्रहीत करती है। जब आप एक प्रीफैब बनाते हैं, तो यह एक नई संपत्ति होती है। इसके उदाहरण अलग-अलग ऑब्जेक्ट होते हैं, और अनदेखा नियम उन पर लागू नहीं होगा। प्रीफैब को स्थायी रूप से अनदेखा करने के लिए, उन्हें एक प्रीफैब संपत्ति के रूप में अनदेखा सूची में जोड़ा जाना चाहिए।",
  "q_faq_window_content_3": "यदि मैं पार्सिंग উপেক্ষা -> घटक प्रकारों को अनदेखा करें में TMPro.TMP_Text घटक जोड़ता हूं, लेकिन दृश्य में एक LocalizedText वाला एक ऑब्जेक्ट है जो पहले से ही इस TMP_Text का संदर्भ देता है, तो अगले अपडेट कीज़ पर क्या होगा? क्या कुंजी हटा दी जाएगी?",
  "a_faq_window_content_3": "हाँ, यह होगा। जब आप अपडेट कीज़ पर क्लिक करते हैं, तो पार्सर पूरे प्रोजेक्ट को फिर से स्कैन करता है। यह देखेगा कि TMPro.TMP_Text प्रकार को अनदेखा किया जाना चाहिए और इसके लिए एक कुंजी उत्पन्न नहीं करेगा। पुरानी और नई कुंजियों की तुलना करने की प्रक्रिया के दौरान, यह निर्धारित करेगा कि पुरानी कुंजी का अब उपयोग नहीं किया जाता है और इसे \"हटाया गया\" के रूप में चिह्नित करेगा।",
  "q_faq_window_content_4": "दस्तावेज़ीकरण कहता है कि \"पिन\" ऑब्जेक्ट का पूरा पथ सहेजता है और यदि इसका नाम बदला जाता है तो टूट जाएगा। क्या होगा यदि मैं ऑब्जेक्ट से एक प्रीफैब बनाता हूं और फिर मूल ऑब्जेक्ट का नाम बदलता हूं - क्या \"पिन\" प्रीफैब उदाहरणों के लिए काम करना जारी रखेगा?",
  "a_faq_window_content_4": "नहीं, यह नहीं होगा। \"पिन\" बटन क्लिक किए जाने के समय दृश्य पदानुक्रम में पूर्ण पथ सहेजता है (जैसे, कैनवस/पैनल/बटन)। यह पथ प्रीफैब तर्क से संबंधित नहीं है। प्रीफैब उदाहरणों का एक ही पथ होगा, लेकिन यदि आप दृश्य में मूल ऑब्जेक्ट का नाम बदलते हैं, तो \"पिन\" मूल और उदाहरणों दोनों के लिए काम करना बंद कर देगा।",
  "q_faq_window_content_5": "यदि मैं एक प्रीफैब उदाहरण के अंदर एक बाल ऑब्जेक्ट के लिए \"पिन\" का उपयोग करता हूं, तो कौन सा पथ सहेजा जाएगा: प्रीफैब रूट के सापेक्ष या दृश्य रूट के सापेक्ष? क्या यह अन्य दृश्यों में काम करेगा?",
  "a_faq_window_content_5": "दृश्य रूट से पूरा पथ सहेजा जाएगा। उदाहरण के लिए, MyPrefab(Clone)/Content/Icon। यह \"पिन किया गया\" पथ केवल उसी दृश्य में काम करेगा जहां आपने इसे बनाया था। अन्य दृश्यों में, ऐसा पथ मिलने की संभावना नहीं है।",
  "h3_faq_window_actions": "\"क्रियाएँ\" टैब",
  "h3_faq_window_assets": "\"संपत्तियाँ\" टैब",
  "h3_faq_window_report": "\"रिपोर्ट\" टैब",
  "h2_faq_editor": "10.4. अनुवाद संपादक",
  "h2_faq_examples": "10.5. उपयोग के उदाहरण और कोड",
  "h2_faq_notes": "10.6. महत्वपूर्ण बारीकियाँ और चेतावनियाँ",
  "h2_faq_extending": "10.7. कार्यक्षमता का विस्तार",
  "q_faq_window_actions_1": "क्या होता है यदि बैच ऑटो-अनुवाद के दौरान इंटरनेट कनेक्शन खो जाता है? क्या उपकरण पुन: प्रयास नीति के अनुसार विफल बैच को फिर से प्रयास करेगा, या प्रक्रिया पूरी तरह से बाधित हो जाएगी?",
  "a_faq_window_actions_1": "उपकरण पुन: प्रयास नीति सेटिंग्स (प्रयासों की संख्या और देरी) के अनुसार, विफल हुए सटीक बैच को फिर से भेजने का प्रयास करेगा। यदि इस बैच के लिए सभी प्रयास विफल हो जाते हैं, तो वर्तमान भाषा के लिए अनुवाद प्रक्रिया बाधित हो जाएगी, और कंसोल में एक त्रुटि लॉग की जाएगी। कतार में अगली भाषाओं के लिए अनुवाद शुरू नहीं होगा।",
  "q_faq_window_actions_2": "यदि मैं एक सीएसवी फ़ाइल आयात करता हूं जिसमें ऐसी कुंजियाँ हैं जो प्रोजेक्ट में पहले से मौजूद हैं लेकिन कुछ भाषाओं के लिए खाली मानों के साथ, क्या ये खाली मान मेरे मौजूदा अनुवादों को प्रतिस्थापित करेंगे या अनदेखा कर दिए जाएंगे?",
  "a_faq_window_actions_2": "खाली मान मौजूदा अनुवादों को प्रतिस्थापित करेंगे। आयात प्रक्रिया सीएसवी फ़ाइल को \"सत्य का स्रोत\" मानती है। यदि ru कॉलम में कुंजी welcome_message के लिए मान खाली है, तो इस कुंजी के लिए वर्तमान रूसी अनुवाद ओवरराइट हो जाएगा।",
  "q_faq_window_actions_3": "\"खतरा क्षेत्र\" अनुभाग सभी घटकों को हटाने की अनुमति देता है। क्या यह उन प्रीफैब से घटकों को हटा देगा जो सामग्री टैब पर प्रीफैब फ़ोल्डर्स में निर्दिष्ट नहीं किए गए फ़ोल्डरों में हैं?",
  "a_faq_window_actions_3": "हाँ, यह होगा। \"खतरा क्षेत्र\" में फ़ंक्शन प्रोजेक्ट में सभी प्रीफैब को स्कैन करते हैं (AssetDatabase.FindAssets(\"t:Prefab\")), न कि केवल पार्सिंग सूची में निर्दिष्ट किए गए लोगों को, ताकि यथासंभव पूरी तरह से सफाई सुनिश्चित हो सके।",
  "q_faq_window_actions_4": "@placeholders: निर्देश का उपयोग करके प्लेसहोल्डर सत्यापन के लिए मुझे Google शीट्स से आयात करते समय टिप्पणी कॉलम को कैसे प्रारूपित करना चाहिए?",
  "a_faq_window_actions_4": "आपके Google शीट्स दस्तावेज़ में, कॉलम का शीर्षक \"डेवलपर नोट्स\" होना चाहिए। इस कॉलम की कोशिकाओं में, आप हमेशा की तरह टिप्पणियां लिख सकते हैं। प्लेसहोल्डर निर्दिष्ट करने के लिए, बस टिप्पणी टेक्स्ट में @placeholders: {username}, {score} जैसी एक पंक्ति जोड़ें। आयात करने पर उपकरण इस निर्देश को स्वचालित रूप से पहचान लेगा।",
  "q_faq_window_actions_5": "क्या उपकरण एक ही Google शीट्स दस्तावेज़ की कई शीटों से डेटा आयात कर सकता है, या यह केवल प्रति GID एक शीट के साथ काम करता है?",
  "a_faq_window_actions_5": "उपकरण एक समय में केवल एक शीट के साथ काम करता है। आयात URL में एक gid=... पैरामीटर शामिल होता है, जो दस्तावेज़ में एक विशिष्ट शीट की विशिष्ट रूप से पहचान करता है। किसी अन्य शीट से डेटा आयात करने के लिए, आपको उसका URL (एक अलग gid के साथ) कॉपी करना होगा और आयात फिर से करना होगा।",
  "q_faq_window_assets_1": "क्या होगा यदि मेरे पास एक ही स्कैन फ़ोल्डर में एक ही कुंजी लेकिन अलग-अलग प्रकारों के साथ दो संपत्तियाँ हैं (जैसे, sound_effect_en.mp3 और sound_effect_en.wav)? संपत्ति तालिका में कौन सी समाप्त होगी?",
  "a_faq_window_assets_1": "संपत्ति स्कैनर उन्हें अपेक्षित प्रकार निर्दिष्ट करते हुए लोड करता है (AssetDatabase.LoadAssetAtPath(path, expectedType))। AudioClip श्रेणी के लिए, यह केवल उन फ़ाइलों को खोजेगा और लोड करेगा जिन्हें Unity AudioClips के रूप में पहचानता है। यदि दोनों फ़ाइलें मान्य ऑडियो क्लिप हैं, तो जो अंतिम संसाधित होती है वह तालिका में शामिल हो जाएगी, प्रभावी रूप से पिछले वाले को ओवरराइट कर देगी। ऐसे डुप्लिकेट से बचने की अनुशंसा की जाती है।",
  "q_faq_window_assets_2": "यदि मैं स्कैन एसेट्स और प्रोजेक्ट का विश्लेषण करें पर क्लिक करता हूं, और दृश्य में एक इमेज ऑब्जेक्ट है जिसके लिए एक स्थानीयकृत स्प्राइट पहले से मौजूद है, लेकिन इमेज ऑब्जेक्ट में अभी तक एक LocalizedAsset घटक नहीं है, तो क्या उपकरण घटक जोड़ देगा और स्वचालित रूप से कुंजी डालेगा?",
  "a_faq_window_assets_2": "हाँ, यह ठीक उसी तरह काम करता है। \"प्रोजेक्ट का विश्लेषण करें\" इमेज घटक को ढूंढता है, उसे सौंपे गए स्प्राइट के नाम को देखता है (जैसे, icon_play_en), उससे कुंजी (icon_play) और भाषा (en) निकालता है, और फिर उस गेमऑब्जेक्ट में एक LocalizedAsset घटक जोड़ता है और उसमें कुंजी icon_play लिखता है।",
  "q_faq_window_assets_3": "क्या मैं अलग-अलग संपत्ति श्रेणियों के लिए एक ही नामकरण नियम का उपयोग कर सकता हूं यदि उनके पास अलग-अलग स्कैन फ़ोल्डर हैं? क्या इससे संघर्ष होगा?",
  "a_faq_window_assets_3": "हाँ, आप कर सकते हैं। कोई संघर्ष नहीं होगा, क्योंकि प्रत्येक श्रेणी के लिए एक अलग संपत्ति तालिका (LocalizedAssetTable) बनाई जाती है। \"स्प्राइट्स\" श्रेणी की कुंजियाँ \"ऑडियोक्लिप्स\" श्रेणी की कुंजियों के साथ ओवरलैप नहीं होती हैं, भले ही उनका नाम एक ही हो।",
  "q_faq_window_assets_4": "यदि एक स्थानीयकरण योग्य संपत्ति (जैसे, button_ok_en.png) स्कैन फ़ोल्डर के रूट में नहीं है, बल्कि एक सबफ़ोल्डर में है, तो क्या स्कैनर इसे ढूंढेगा?",
  "a_faq_window_assets_4": "हाँ, यह होगा। स्कैनर SearchOption.AllDirectories विकल्प का उपयोग करता है, जिसका अर्थ है कि यह आपके द्वारा निर्दिष्ट स्कैन फ़ोल्डर के भीतर सभी सबफ़ोल्डरों की पुनरावर्ती रूप से जांच करेगा।",
  "q_faq_window_report_1": " \"ढूंढें\" बटन ऑब्जेक्ट को अतुल्यकालिक रूप से खोजता है। क्या होगा यदि मैं एक खोज शुरू करता हूं और फिर तुरंत अपडेट कीज़ पर क्लिक करता हूं? क्या खोज बाधित हो जाएगी?",
  "a_faq_window_report_1": "हाँ, यह बाधित हो जाएगी। यूआई अवरोधन की आवश्यकता वाली कोई भी नई क्रिया (जैसे अपडेट कीज़) वर्तमान खोज कोरूटीन को रोक देगी। एक संवाद बॉक्स दिखाई देगा, जो आपको एक नई खोज शुरू करने के लिए वर्तमान खोज को रोकने के लिए प्रेरित करेगा।",
  "q_faq_window_report_2": "यदि किसी कुंजी का उपयोग कई स्थानों पर किया जाता है (जैसे, विभिन्न दृश्यों में दो अलग-अलग बटनों पर), तो यह रिपोर्ट में \"डुप्लिकेट\" श्रेणी के अंतर्गत कैसे प्रदर्शित होगा?",
  "a_faq_window_report_2": "\"डुप्लिकेट\" श्रेणी उस कुंजी के लिए सभी स्रोतों को दिखाएगी। आप कुंजी के लिए एक प्रविष्टि देखेंगे, और \"स्रोत\" फ़ील्ड सभी पथों (दृश्य 1 और दृश्य 2 में) को सूचीबद्ध करेगा। इस मामले में \"ढूंढें\" बटन एक ड्रॉपडाउन सूची खोलेगा, जिससे आप यह चुन सकेंगे कि किस ऑब्जेक्ट पर नेविगेट करना है।",
  "q_faq_window_report_3": "यदि मैं केवल कोड में उपयोग की जाने वाली कुंजी के लिए \"ढूंढें\" पर क्लिक करता हूं (_() फ़ंक्शन के माध्यम से), तो क्या होगा? क्या उपकरण सी# स्क्रिप्ट को ढूंढ और हाइलाइट कर पाएगा?",
  "a_faq_window_report_3": "हाँ। खोज प्रणाली विशेष रूप से स्क्रिप्ट MyScript.cs जैसे स्रोतों को पहचानने के लिए प्रशिक्षित है। जब आप \"ढूंढें\" पर क्लिक करते हैं, तो यह प्रोजेक्ट में MyScript.cs संपत्ति की खोज करेगा और इसे प्रोजेक्ट विंडो में हाइलाइट (पिंग) करेगा।",
  "q_faq_editor_1": "प्लेसहोल्डर सत्यापन के लिए किसकी प्राथमिकता अधिक है: टिप्पणी में @placeholders: निर्देश या स्रोत भाषा टेक्स्ट में पाए गए प्लेसहोल्डर? उदाहरण के लिए, यदि स्रोत टेक्स्ट में {name} है और टिप्पणी में @placeholders: {username} लिखा है।",
  "a_faq_editor_1": "टिप्पणी में @placeholders: निर्देश की प्राथमिकता है। इसे डेवलपर से एक स्पष्ट निर्देश और \"सत्य का स्रोत\" माना जाता है। आपके उदाहरण में, संपादक को अनुवाद में {username} की आवश्यकता होगी और स्रोत टेक्स्ट से {name} को अनदेखा कर देगा।",
  "q_faq_editor_2": "यदि मैं निर्देश में एक टाइपो करता हूं (जैसे, @placeholders: के बजाय @placeholder:), तो क्या इसे अनदेखा कर दिया जाएगा या उपकरण एक चेतावनी जारी करेगा?",
  "a_faq_editor_2": "इसे बस अनदेखा कर दिया जाएगा। उपकरण @placeholders: के सटीक मिलान की तलाश करता है। यदि निर्देश गलत वर्तनी है, तो इसे एक नियमित टिप्पणी का हिस्सा माना जाएगा, और सत्यापन पुराने तरीके से काम करेगा - स्रोत टेक्स्ट से प्लेसहोल्डर के आधार पर।",
  "q_faq_editor_3": "ऑटोसेव सिस्टम बैकअप/ऑटोसेव फ़ोल्डर में फ़ाइलें बनाता है। क्या ये फ़ाइलें एक सफल मैन्युअल सेव या विंडो बंद करने के बाद स्वचालित रूप से हटा दी जाएंगी?",
  "a_faq_editor_3": "हाँ। एक सफल मैन्युअल सेव या सामान्य विंडो बंद होने पर (जब आप परिवर्तन सहेजते हैं), सभी ऑटोसेव फ़ाइलें हटा दी जाती हैं ताकि अगले लॉन्च पर पुनर्प्राप्ति के लिए संकेत न दिया जा सके। वे केवल एक संपादक क्रैश की स्थिति में रहते हैं।",
  "q_faq_editor_4": "यदि मैं संपादक में कॉलम की चौड़ाई बदलता हूं, तो क्या ये सेटिंग्स यूनिटी सत्रों के बीच सहेजी जाएंगी?",
  "a_faq_editor_4": "हाँ। हर बार जब आप अनुवाद संपादक विंडो बंद करते हैं तो कॉलम की चौड़ाई EditorPrefs में सहेजी जाती है और अगली बार जब आप इसे खोलते हैं तो पुनर्स्थापित हो जाएगी।",
  "q_faq_editor_5": "क्या टेक्स्ट संपादन पॉपअप विंडो (MultiLineEditWindow) इसके भीतर किए गए परिवर्तनों के लिए अपने स्वयं के पूर्ववत/फिर से करें स्टैक (Ctrl+Z के माध्यम से) का समर्थन करती है?",
  "a_faq_editor_5": "हाँ। MultiLineEditWindow का अपना अस्थायी पूर्ववत/फिर से करें स्टैक है जो विंडो खुली होने पर काम करता है। यह आपको उस विंडो के भीतर टेक्स्ट परिवर्तनों को पूर्ववत करने और फिर से करने की अनुमति देता है। एक बार जब आप परिणाम सहेज लेते हैं (विंडो बंद करके), तो यह परिवर्तन मुख्य संपादक के वैश्विक पूर्ववत/फिर से करें स्टैक में एकल क्रिया के रूप में दर्ज किया जाता है।",
  "q_faq_examples_1": "_() फ़ंक्शन में पास किए गए अनाम प्रकार में संपत्ति के नाम स्ट्रिंग में प्लेसहोल्डर से मेल नहीं खाते हैं तो क्या होता है? उदाहरण के लिए, _(\"नमस्ते, {username}\", नया { user_name = \"बॉब\" })। क्या कोई त्रुटि होगी, या प्लेसहोल्डर को बस प्रतिस्थापित नहीं किया जाएगा?",
  "a_faq_examples_1": "कोई त्रुटि नहीं होगी। {username} प्लेसहोल्डर को बस प्रतिस्थापित नहीं किया जाएगा, और आपको परिणाम के रूप में स्ट्रिंग \"नमस्ते, {username}\" मिलेगा। प्रतिस्थापन केवल एक सटीक नाम मिलान के साथ होता है।",
  "q_faq_examples_2": "[LocalizableField] विशेषता निजी क्षेत्रों के लिए काम करती है। क्या यह स्थिर क्षेत्रों के लिए काम करेगी?",
  "a_faq_examples_2": "हाँ, यह होगा। पार्सर बाइंडिंगफ्लैग्स.पब्लिक | बाइंडिंगफ्लैग्स.नॉनपब्लिक | बाइंडिंगफ्लैग्स.इंस्टेंस | बाइंडिंगफ्लैग्स.स्टैटिक फ्लैग के साथ क्षेत्रों को खोजने के लिए प्रतिबिंब का उपयोग करता है, इसलिए यह स्थिर क्षेत्रों को ढूंढेगा और संसाधित करेगा।",
  "q_faq_examples_3": "यदि मैं [OnLanguageChange] विशेषता को मापदंडों के साथ एक विधि पर रखता हूं (जैसे, शून्य UpdateUI(स्ट्रिंग newLang)), तो क्या होगा? क्या कोई संकलन त्रुटि या रनटाइम चेतावनी होगी?",
  "a_faq_examples_3": "कोई संकलन त्रुटि नहीं होगी, लेकिन रनटाइम पर यूनिटी कंसोल में LocalizedBehaviour से एक चेतावनी दिखाई देगी। यह रिपोर्ट करेगा कि उसने विशेषता के साथ एक विधि ढूंढी लेकिन उसे अनदेखा कर दिया क्योंकि विधि में पैरामीटर हैं। ऐसी विधि को कॉल नहीं किया जाएगा।",
  "q_faq_examples_4": "मैं _(\"apple_count\", count) का उपयोग कर रहा हूं। यदि वर्तमान भाषा के लिए कोई कुंजी apple_count_one नहीं है (count = 1 के लिए), तो सिस्टम कौन सा रूप चुनेगा? क्या यह apple_count_other को फ़ॉलबैक के रूप में उपयोग करेगा?",
  "a_faq_examples_4": "हाँ। यदि कोई विशिष्ट रूप (_one, _few, आदि) नहीं मिलता है, तो सिस्टम _other प्रत्यय के साथ कुंजी को फ़ॉलबैक के रूप में उपयोग करने का प्रयास करेगा। यदि वह भी नहीं मिलता है, तो आधार कुंजी apple_count के लिए अनुवाद का उपयोग किया जाएगा।",
  "q_faq_examples_5": "फ़ंक्शन _(\"key\", नया { username = \"एलेक्स\" }) एक अनाम प्रकार का उपयोग करता है। क्या यह एक पूर्व-निर्मित शब्दकोश<स्ट्रिंग, ऑब्जेक्ट> पास करने की तुलना में एक अपडेट() विधि में लगातार कॉल के साथ कचरा संग्रहकर्ता (जीसी) पर एक अत्यधिक \"भार\" नहीं बनाएगा?",
  "a_faq_examples_5": "हाँ, यह होगा। नया { ... } का प्रत्येक कॉल प्रबंधित ढेर पर मेमोरी आवंटित करता है, जो कचरा संग्रहकर्ता के लिए अतिरिक्त काम बनाता है। हर फ्रेम (अपडेट या लेटअपडेट में) अपडेट होने वाले टेक्स्ट के लिए, स्टार्ट() में एक बार एक शब्दकोश<स्ट्रिंग, ऑब्जेक्ट> बनाना, और अपडेट() में केवल इसके मानों को अपडेट करना और इसे _() फ़ंक्शन में पास करना काफी अधिक प्रदर्शनकारी है।",
  "q_faq_notes_1": "दस्तावेज़ीकरण भाषा चयनकर्ता को अनदेखा सूची में जोड़ने की अनुशंसा करता है। क्या वास्तव में टूट जाएगा अगर मैं ऐसा करना भूल जाता हूं? क्या \"विकल्प ए, विकल्प बी\" के लिए अतिरिक्त कुंजियाँ बनाई जाएंगी?",
  "a_faq_notes_1": "हाँ। यदि आप भाषा चयनकर्ता को अनदेखा सूची में नहीं जोड़ते हैं, तो पार्सर इसके टीएमपी_ड्रॉपडाउन को एक नियमित ड्रॉपडाउन के रूप में मानेगा। यह डिफ़ॉल्ट \"विकल्प ए, विकल्प बी, विकल्प सी\" ढूंढेगा जो यूनिटी बनाता है और उनके लिए आपकी अनुवाद फ़ाइलों में कुंजियाँ जोड़ देगा। यह आपकी फ़ाइलों को अनावश्यक कुंजियों से भर देगा, क्योंकि भाषा चयनकर्ता इन विकल्पों को रनटाइम पर हटा देगा और वैसे भी अपना बना लेगा।",
  "q_faq_notes_2": "यदि मैं भाषा चयनकर्ता द्वारा उपयोग किए जाने वाले टीएमपी_ड्रॉपडाउन के अंदर लेबल पर isStyleOnly चेकबॉक्स सक्षम के साथ एक खाली स्थानीयकृत टेक्स्ट जोड़ना भूल जाता हूं, तो क्या फ़ॉन्ट नहीं बदलेगा? यह क्यों आवश्यक है?",
  "a_faq_notes_2": "हाँ, फ़ॉन्ट नहीं बदलेगा। यह आवश्यक है क्योंकि भाषा चयनकर्ता सीधे label.text संपत्ति को बदलता है। इस ऑब्जेक्ट पर एक स्थानीयकृत टेक्स्ट के बिना, स्थानीयकरण प्रणाली को नहीं पता है कि भाषा बदलने पर इस तत्व को शैलियों (फ़ॉन्ट, आरटीएल) को लागू करने की आवश्यकता है। isStyleOnly के साथ एक खाली स्थानीयकृत टेक्स्ट सिस्टम के लिए एक \"मार्कर\" के रूप में कार्य करता है, जो कहता है: \"इस ऑब्जेक्ट को देखें और इस पर शैलियाँ लागू करें, लेकिन इसके टेक्स्ट को न छुएं\"।",
  "q_faq_notes_3": "अपडेट() विधि में _() को कॉल करने की अनुशंसा नहीं की जाती है। लेकिन क्या होगा यदि मुझे हर फ्रेम टेक्स्ट अपडेट करने की आवश्यकता है (जैसे, एक टाइमर)? केवल प्रारूप स्ट्रिंग को कैश करते हुए ऐसा करने का सबसे प्रदर्शनकारी तरीका क्या है?",
  "a_faq_notes_3": "सबसे प्रदर्शनकारी तरीका स्टार्ट() में या [OnLanguageChange] विधि में प्रारूप स्ट्रिंग को कैश करना है, और अपडेट() में नियमित string.Format का उपयोग करना है। उदाहरण: निजी स्ट्रिंग टाइमर प्रारूप; [OnLanguageChange] शून्य अपडेटटाइमर प्रारूप() { टाइमर प्रारूप = _(\"टाइमर_प्रारूप\"); } शून्य अपडेट() { myTextComponent.text = string.Format(टाइमर प्रारूप, timeLeft); } यह हर फ्रेम शब्दकोश में कुंजी को देखने से बचाता है, जो काफी तेज है।",
  "q_faq_extending_1": "क्या मेरा कस्टम पार्सर हर अपडेट कीज़ के बाद स्वचालित रूप से कॉल किया जाएगा? क्या मुझे इसे कहीं पंजीकृत करने की आवश्यकता है, या क्या प्रोजेक्ट में ITextComponentParser को लागू करने वाली एक क्लास का होना ही काफी है?",
  "a_faq_extending_1": "बस क्लास का होना ही काफी है। जब TextParser चलता है, तो यह प्रोजेक्ट में उन सभी क्लासों को खोजने के लिए प्रतिबिंब का उपयोग करता है जो ITextComponentParser इंटरफ़ेस को लागू करते हैं और प्रत्येक GameObject के लिए स्वचालित रूप से उनके Parse() विधि को कॉल करते हैं। किसी मैन्युअल पंजीकरण की आवश्यकता नहीं है।",
  "q_faq_extending_2": "क्या होगा यदि मेरे कस्टम पार्सर में कोई अपवाद होता है? क्या यह पूरी पार्सिंग प्रक्रिया को बाधित करेगा, या क्या उपकरण सुरक्षित रूप से अन्य पार्सर्स के साथ जारी रहेगा?",
  "a_faq_extending_2": "आपके कस्टम पार्सर में एक अपवाद प्रक्रिया को बाधित करेगा। मुख्य पार्सिंग लूप कस्टम पार्सर्स को कॉल को ट्राई-कैच ब्लॉक में नहीं लपेटता है। यदि आपकी Parse() विधि एक अनहैंडल अपवाद फेंकती है,",
  "toggle_notes_title": "टिप्पणियाँ टॉगल करें",
  "mindmap_toggle_title": "माइंड मैप दिखाएं",
  "on_this_page_title": "इस पेज पर",
  "my_notes_title": "मेरी टिप्पणियाँ",
  "no_notes_message_new": "एक टिप्पणी जोड़ने के लिए टेक्स्ट पर होवर करें।",
  "notes_add_title": "इस ब्लॉक में एक टिप्पणी जोड़ें",
  "notes_placeholder": "आपकी टिप्पणी...",
  "notes_close_title": "बंद करें",
  "notes_goto_title": "टेक्स्ट पर जाएं",
  "notes_edit_title": "टिप्पणी संपादित करें",
  "notes_delete_title": "टिप्पणी हटाएं",
  "notes_edit_text": "संपादित करें",
  "copy_code_copy": "कॉपी करें",
  "copy_code_copied": "कॉपी किया गया!",
  "copy_code_error": "त्रुटि",
  "error_loading_title": "लोडिंग त्रुटि",
  "error_loading_message": "कृपया अपना कनेक्शन जांचें और रीफ्रेश करें।",
  "lightbox_aria_close": "छवि व्यूअर बंद करें",
  "lightbox_image_alt": "बड़ा दृश्य",
  "mindmap_preset_full": "पूर्ण दृश्य",
  "mindmap_preset_quick_start": "त्वरित शुरुआत",
  "mindmap_preset_dev": "डेवलपर वर्कफ़्लो",
  "mindmap_preset_translator": "अनुवादक वर्कफ़्लो",
  "mindmap_edge_configure": "1. कॉन्फ़िगर करें",
  "mindmap_edge_specify_content": "2. सामग्री निर्दिष्ट करें",
  "mindmap_edge_parse_project": "3. प्रोजेक्ट पार्स करें",
  "mindmap_edge_creates_components": "घटक बनाता है",
  "mindmap_edge_generates": "उत्पन्न करता है",
  "mindmap_edge_opens": "खोलता है",
  "mindmap_edge_manages_assets": "के लिए संपत्ति का प्रबंधन करता है",
  "mindmap_edge_defines_rules": "के लिए नियम परिभाषित करता है",
  "mindmap_edge_reports_on": "पर रिपोर्ट करता है",
  "mindmap_edge_enables_reaction": "के माध्यम से प्रतिक्रिया सक्षम करता है",
  "mindmap_edge_processed_by": "द्वारा संसाधित",
  "mindmap_edge_edited_in": "में संपादित",
  "mindmap_edge_extends": "विस्तार करता है",
  "mindmap_edge_warns_about": "के बारे में चेतावनी देता है",
  "mindmap_edge_relates_to": "से संबंधित है",
  "mindmap_edge_recommends_for": "के लिए अनुशंसा करता है",
  "mindmap_edge_see_faq": "FAQ देखें"
}