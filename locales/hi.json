{
  "a_faq_addressables_1": "सुनिश्चित करें कि Addressables पैकेज स्थापित है, सेटिंग्स बनाई गई हैं, और आपने समूहों में कुंजियाँ पंजीकृत करने के लिए \"Scan Assets & Generate Tables\" पर क्लिक किया है।",
  "a_faq_addressables_2": "एसेट्स फ़ोल्डर में एक <code>Translation Profile</code> बनाएँ, सेवा प्रकार का चयन करें, एपीआई कुंजी दर्ज करें, और इस प्रोफ़ाइल को <code>Settings</code> विंडो में असाइन करें।",
  "a_faq_addressables_3": "Migration विंडो (Components / Import टैब) में एक \"Enable Stubs\" बटन है जो Emergency Stubs फीचर को सक्रिय करता है। यह I2 Localization या Unity Localization के लिए नकली placeholder क्लास बनाता है ताकि आपके प्रोजेक्ट को उन प्लगइन्स को हटाने के बाद तुरंत कंपाइल किया जा सके। यह फीचर ANKO_ENABLE_MIGRATION_STUBS डिफाइन सिंबल को टॉगल करके काम करता है। यह \"The type name 'Localize' could not be found\" त्रुटियों को रोकता है और आपको नया सिस्टम उपयोग करने के लिए कोड को सही ढंग से रीफ़ैक्टर करने का समय देता है। Enable Stubs पुराने localization प्लगइन को हटाने के बाद कंपाइलेशन त्रुटियों को ठीक करने की अनुमति देता है। v2.0 में, migration सिस्टम को <strong>Migration Profiles</strong> के साथ विस्तारित किया गया है, जिससे अन्य प्लगइन्स से अधिक मजबूत ट्रांज़िशन नियम संभव होते हैं।",
  "a_faq_audio_smart_update": "टूल स्मार्ट बैचिंग का उपयोग MD5 हैशिंग के साथ करता है ताकि केवल तभी ऑडियो फ़ाइलों को पुन: जेनरेट किया जा सके जब स्रोत टेक्स्ट बदल गया हो। यह आपके टेक्स्ट सामग्री के MD5 हैश की गणना करता है और इसकी तुलना पहले से जेनरेट की गई ऑडियो फ़ाइलों से करता है। यदि टेक्स्ट नहीं बदला है, तो यह पुन: जनरेशन को छोड़ देता है, जिससे आपके API क्रेडिट्स की बचत होती है। यह अनावश्यक API कॉल को रोकता है और ऑडियो पुन: जेनरेट करते समय लागत को कम करता है। टूल आपके टेक्स्ट को हैश करता है और यदि स्रोत टेक्स्ट बदल गया है तो ही ऑडियो फ़ाइलों को पुन: जेनरेट करता है, जिससे आपके API क्रेडिट्स की बचत होती है।",
  "a_faq_components_1": "नहीं, ऐसा नहीं होगा। एक MonoBehaviour को अक्षम करने से यूनिटी के सभी \"जादुई\" मेथड्स को कॉल होने से रोका जाता है, जिसमें Awake(), OnEnable(), और Start() शामिल हैं। यह जानबूझकर किया जाता है ताकि डुप्लिकेट लॉजिक निष्पादन से बचा जा सके। सभी आरंभीकरण प्रीफ़ैब के स्थानीयकृत संस्करणों पर स्क्रिप्ट में होना चाहिए।",
  "a_faq_components_2": "हाँ, मूल ऑब्जेक्ट के भौतिकी व्यवहार को बेअसर कर दिया जाएगा। LocalizedPrefab घटक अपने GameObject पर सभी Rigidbody और Rigidbody2D घटकों को ढूंढता है और उनके isKinematic प्रॉपर्टी को true पर सेट करता है। यह उन्हें गतिशील भौतिकी गणनाओं से प्रभावी ढंग से हटा देता है, जिससे एक अदृश्य वस्तु के गिरने या टकराव पर प्रतिक्रिया करने जैसे अवांछित व्यवहार को रोका जाता है। फिर भी यह अनुशंसा की जाती है कि प्रीफ़ैब के स्थानीयकृत संस्करण में सही व्यवहार के लिए सभी आवश्यक भौतिकी घटक शामिल हों।",
  "a_faq_components_3": "हाँ, यह करेगा। घटक पूर्ण प्रकार नाम संग्रहीत करता है, जिसमें नेमस्पेस और असेंबली शामिल हैं। स्क्रिप्ट का नाम बदलने या इसे किसी अन्य .asmdef में ले जाने से यह नाम बदल जाएगा, और LocalizedAsset लक्ष्य घटक को खोज नहीं पाएगा। आपको नाम अपडेट करने के लिए Analyze Project & Attach Components के माध्यम से फिर से विश्लेषण चलाना होगा।",
  "a_faq_components_4": "एक LocalizedAsset एक विशिष्ट घटक इंस्टेंस के लिए बनाया गया है। यह कोड में उस घटक का एक संदर्भ रखता है। यदि आप मैन्युअल रूप से एक दूसरा LocalizedAsset जोड़ते हैं और दूसरे Image को लक्षित करने के लिए \"Analyze for Localization\" संदर्भ मेनू का उपयोग करते हैं, तो आपके पास दो LocalizedAsset घटक होंगे, प्रत्येक अपने Image का प्रबंधन करेगा। स्वचालित विश्लेषक केवल पहले Image के लिए एक घटक बनाएगा जिसमें इसे स्थानीयकरण योग्य एसेट मिलता है।",
  "a_faq_components_5": "हाँ, ऐसा होगा। LocalizedPrefab अपने OnEnable() मेथड में स्थानीयकृत प्रीफ़ैब का इंस्टेंस बनाता है। यूनिटी का निष्पादन क्रम गारंटी देता है कि सभी Awake() मेथड्स सभी OnEnable() मेथड्स से पहले निष्पादित होते हैं। इस प्रकार, आपकी स्क्रिप्ट -110 क्रम के साथ अपना Awake() निष्पादित करेगी, फिर -100 क्रम के साथ LocalizedPrefab अपना Awake() निष्पादित करेगा, और उसके बाद ही उनके OnEnable() मेथड्स को क्रम से कॉल किया जाएगा। आपकी स्क्रिप्ट ऑब्जेक्ट को नहीं ढूंढेगी क्योंकि इसे अभी तक नहीं बनाया गया होगा।",
  "a_faq_components_6": "कुंजी और टेक्स्ट दोनों बदलेंगे। SetFormattedText को प्रोग्रामेटिक रूप से कॉल करने से उस विशिष्ट अपडेट के लिए isStyleOnly व्यवहार ओवरराइड हो जाता है। isStyleOnly विकल्प घटक को वैश्विक भाषा परिवर्तनों पर प्रतिक्रिया करने से रोकने के लिए अभिप्रेत है, लेकिन यह कोड के माध्यम से प्रत्यक्ष कुंजी परिवर्तन पर हमेशा प्रतिक्रिया करेगा।",
  "a_faq_components_7": "यह किसी भी एक्सेस मॉडिफ़ायर (public, private, protected, internal) वाले मेथड्स को ढूंढेगा। यूनिटी में रिफ्लेक्शन उनके एक्सेस स्तर की परवाह किए बिना सभी इंस्टेंस मेथड्स की खोज की अनुमति देता है।",
  "a_faq_components_8": "पुराने (गैर-स्थानीयकृत) एसेट का उपयोग संभव है। LocalizedAsset अपने OnEnable() में स्वैप करता है। सभी स्क्रिप्ट के Awake() मेथड्स OnEnable() से पहले निष्पादित होते हैं। यदि आपकी स्क्रिप्ट Awake() में audioSource.clip को एक्सेस करती है, तो उसे मूल क्लिप मिलेगी। यदि यह Start() में इसे एक्सेस करती है, तो परिणाम स्क्रिप्ट निष्पादन क्रम पर निर्भर करेगा। स्थानीयकृत एसेट तक पहुंच की गारंटी के लिए, या तो अपनी स्क्रिप्ट के लिए बाद का निष्पादन क्रम सेट करें या [OnLanguageChange] से चिह्नित मेथड में एसेट को एक्सेस करें।",
  "a_faq_custom_keys_attribute": "हाँ। <strong>Content Tab</strong> में 'Attributes to Scan' के तहत, आप कोई भी एट्रीब्यूट नाम जोड़ सकते हैं (उदाहरण के लिए, <code>[Header]</code>, <code>[TermsPopup]</code>)। पार्सर उस एट्रीब्यूट वाले किसी भी स्ट्रिंग फ़ील्ड को स्थानीयकरण योग्य मानेगा।",
  "a_faq_custom_provider_1": "सुनिश्चित करें कि आपकी क्लास <code>IAssetProvider</code> को इम्प्लीमेंट करती है, ABSTRACT नहीं है, और <code>[AssetProviderPlugin]</code> एट्रिब्यूट से मार्क की गई है। साथ ही, स्टार्टअप के दौरान कंसोल में किसी भी reflection-संबंधित त्रुटियों की जाँच करें, क्योंकि टूल सभी असेंबलियों को प्रोवाइडर्स के लिए स्कैन करता है।",
  "a_faq_editor_1": "टिप्पणी में @placeholders: डायरेक्टिव की प्राथमिकता है। इसे डेवलपर से एक स्पष्ट निर्देश और \"सत्य का स्रोत\" माना जाता है। आपके उदाहरण में, संपादक को अनुवाद में {username} की आवश्यकता होगी और स्रोत टेक्स्ट से {name} को नज़रअंदाज़ कर देगा।",
  "a_faq_editor_2": "इसे बस नज़रअंदाज़ कर दिया जाएगा। टूल @placeholders: की सटीक मिलान की तलाश करता है। यदि डायरेक्टिव गलत लिखा गया है, तो इसे एक नियमित टिप्पणी का हिस्सा माना जाएगा, और सत्यापन पुराने तरीके से काम करेगा - स्रोत टेक्स्ट से प्लेसहोल्डर के आधार पर।",
  "a_faq_editor_3": "हाँ। एक सफल मैन्युअल सेव या सामान्य विंडो बंद होने पर (जब आप परिवर्तन सहेजते हैं), अगले लॉन्च पर रिकवरी के लिए प्रेरित करने से बचने के लिए सभी ऑटोसेव फ़ाइलें हटा दी जाती हैं। वे केवल एडिटर क्रैश की स्थिति में ही रहते हैं।",
  "a_faq_editor_4": "हाँ। कॉलम की चौड़ाई EditorPrefs में हर बार जब आप अनुवाद संपादक विंडो बंद करते हैं तो सहेजी जाती हैं और अगली बार जब आप इसे खोलते हैं तो पुनर्स्थापित हो जाएंगी।",
  "a_faq_editor_5": "हाँ। MultiLineEditWindow का अपना अस्थायी अनडू/रिडू स्टैक होता है जो विंडो खुली होने पर काम करता है। यह आपको उस विंडो के भीतर टेक्स्ट परिवर्तनों को अनडू और रिडू करने की अनुमति देता है। एक बार जब आप परिणाम सहेजते हैं (विंडो बंद करके), यह परिवर्तन मुख्य संपादक के वैश्विक अनडू/रिडू स्टैक में एक एकल कार्रवाई के रूप में दर्ज किया जाता है।",
  "a_faq_examples_1": "कोई त्रुटि नहीं होगी। {username} प्लेसहोल्डर को बस बदला नहीं जाएगा, और आपको परिणाम के रूप में स्ट्रिंग \"Hello, {username}\" मिलेगी। प्रतिस्थापन केवल एक सटीक नाम मिलान के साथ होता है।",
  "a_faq_examples_2": "हाँ, यह करेगा। पार्सर BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static फ़्लैग के साथ फ़ील्ड खोजने के लिए रिफ्लेक्शन का उपयोग करता है, इसलिए यह स्थिर फ़ील्ड को ढूंढेगा और संसाधित करेगा।",
  "a_faq_examples_3": "कोई संकलन त्रुटि नहीं होगी, लेकिन रनटाइम पर यूनिटी कंसोल में LocalizedBehaviour से एक चेतावनी दिखाई देगी। यह रिपोर्ट करेगा कि उसे एट्रीब्यूट वाला एक मेथड मिला लेकिन उसने इसे नज़रअंदाज़ कर दिया क्योंकि मेथड में पैरामीटर हैं। ऐसे मेथड को कॉल नहीं किया जाएगा।",
  "a_faq_examples_4": "हाँ। यदि कोई विशिष्ट रूप (_one, _few, आदि) नहीं मिलता है, तो सिस्टम फ़ॉलबैक के रूप में _other प्रत्यय वाली कुंजी का उपयोग करने का प्रयास करेगा। यदि वह भी नहीं मिलता है, तो base कुंजी apple_count के लिए अनुवाद का उपयोग किया जाएगा।",
  "a_faq_examples_5": "हाँ, यह बनाएगा। new { ... } के लिए प्रत्येक कॉल प्रबंधित हीप पर मेमोरी आवंटित करता है, जो कचरा संग्राहक के लिए अतिरिक्त काम बनाता है। हर फ़्रेम में अपडेट होने वाले टेक्स्ट के लिए (Update या LateUpdate में), Start() में एक बार Dictionary<string, object> बनाना, और _() फ़ंक्शन में पास करने से पहले Update() में केवल इसके मानों को अपडेट करना काफी अधिक प्रदर्शनकारी है।",
  "a_faq_examples_6": "जाँच करें कि क्या आपके मेथड में पैरामीटर हैं। <code>[OnLanguageChange]</code> एट्रीब्यूट केवल **पैरामीटर रहित** मेथड्स (उदाहरण के लिए, <code>void UpdateUI()</code>) पर काम करता है। यदि आपके मेथड को तर्क की आवश्यकता है, तो इसे एक पैरामीटर रहित मेथड में लपेटें।",
  "a_faq_extending_1": "केवल क्लास होना ही पर्याप्त है। जब TextParser चलता है, तो यह प्रोजेक्ट में ITextComponentParser इंटरफ़ेस को लागू करने वाली सभी क्लासेस को खोजने के लिए रिफ्लेक्शन का उपयोग करता है और स्वचालित रूप से प्रत्येक GameObject के लिए उनके Parse() मेथड को कॉल करता है। किसी मैन्युअल पंजीकरण की आवश्यकता नहीं है।",
  "a_faq_extending_2": "आपके कस्टम पार्सर में एक अपवाद प्रक्रिया को बाधित करेगा। मुख्य पार्सिंग लूप कस्टम पार्सर के लिए कॉल को try-catch ब्लॉक में नहीं लपेटता है। यदि आपका Parse() मेथड एक अनहैंडल्ड अपवाद फेंकता है,",
  "a_faq_installation_1": "इंस्टॉलर Newtonsoft.Json.JsonConvert प्रकार के अस्तित्व की जाँच करता है। यदि प्रकार मौजूद है, तो यह निर्भरता को संतुष्ट मानता है और पैकेज को स्थापित या अपडेट करने का प्रयास नहीं करेगा। यह संस्करण विरोधों को रोकने के लिए किया जाता है।",
  "a_faq_installation_2": "आप Tools -> Localization -> Check Dependencies मेनू के माध्यम से किसी भी समय मैन्युअल रूप से निर्भरता जाँच को ट्रिगर कर सकते हैं। यह \"Don't ask again\" ध्वज को रीसेट कर देगा और सभी लापता वैकल्पिक पैकेजों के साथ विंडो को फिर से दिखाएगा।",
  "a_faq_installation_3": "ऐसा तब हो सकता है जब आपके पास Assets/Resources फ़ोल्डर न हो। टूल इसे बनाने का प्रयास करेगा, लेकिन फ़ाइल सिस्टम अनुमतियाँ इसे रोक सकती हैं। हाँ, आप एसेट को मैन्युअल रूप से बना सकते हैं: Resources फ़ोल्डर में राइट-क्लिक करें, Create -> Localization -> Settings का चयन करें। टूल इसे स्वचालित रूप से ढूंढ लेगा।",
  "a_faq_installation_4": "हाँ। टूल Resources.Load() का उपयोग करता है, जो आपके प्रोजेक्ट में Resources नाम के सभी फ़ोल्डरों में नाम से एक एसेट खोजता है। महत्वपूर्ण बात यह है कि फ़ाइल अपना नाम LocalizationSettings.asset रखती है।",
  "a_faq_installation_5": "हाँ। आप Window -> Package Manager खोल सकते हैं, \"+\" आइकन पर क्लिक कर सकते हैं, और \"Add package by name...\" का चयन कर सकते हैं। पैकेज नाम दर्ज करें: com.unity.nuget.newtonsoft-json और com.unity.editorcoroutines।",
  "a_faq_notes_1": "हाँ। यदि आप LanguageSelector को नज़रअंदाज़ करने की सूची में नहीं जोड़ते हैं, तो पार्सर इसके TMP_Dropdown को एक नियमित ड्रॉपडाउन मानेगा। यह यूनिटी द्वारा बनाए गए डिफ़ॉल्ट \"Option A, Option B, Option C\" को ढूंढेगा और उन्हें आपकी अनुवाद फ़ाइलों में जोड़ने के लिए कुंजियाँ बनाएगा। यह आपकी फ़ाइलों को अनावश्यक कुंजियों से भर देगा, क्योंकि LanguageSelector रनटाइम पर इन विकल्पों को हटा देगा और वैसे भी अपना खुद का बनाएगा।",
  "a_faq_notes_2": "हाँ, फ़ॉन्ट नहीं बदलेगा। यह आवश्यक है क्योंकि LanguageSelector सीधे label.text प्रॉपर्टी को बदलता है। इस ऑब्जेक्ट पर LocalizedText के बिना, स्थानीयकरण प्रणाली को पता नहीं होता है कि भाषा बदलने पर इस तत्व को स्टाइल (फ़ॉन्ट, RTL) लागू करने की आवश्यकता है। isStyleOnly के साथ एक खाली LocalizedText सिस्टम के लिए एक \"मार्कर\" के रूप में कार्य करता है, यह कहते हुए: \"इस ऑब्जेक्ट को देखें और इस पर स्टाइल लागू करें, लेकिन इसके टेक्स्ट को न छुएं\"।",
  "a_faq_notes_3": "सबसे अधिक प्रदर्शनकारी दृष्टिकोण Start() में या [OnLanguageChange] मेथड में प्रारूप स्ट्रिंग को कैश करना है, और Update() में नियमित string.Format का उपयोग करना है। उदाहरण: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } यह हर फ़्रेम में डिक्शनरी में कुंजी को देखने से बचाता है, जो काफी तेज़ है।",
  "a_faq_runtime_api_key_distinction": "<strong>प्रश्न: 'Translation Service Keys' और 'Runtime API Key' में क्या अंतर है?</strong><br>उत्तर: <strong>Translation Service Keys</strong> (OpenAI, DeepL) का उपयोग <strong>Unity Editor</strong> में अनुवाद उत्पन्न करने के लिए किया जाता है। इन्हें आपके कंप्यूटर के रजिस्ट्री (EditorPrefs) में संग्रहीत किया जाता है और बिल्ड में शामिल नहीं होते हैं।<br><strong>Runtime API Key</strong> का उपयोग <strong>Game Build</strong> द्वारा लाइव अपडेट्स प्राप्त करने के लिए किया जाता है। यह बिल्ड में शामिल होता है (एन्क्रिप्टेड)।",
  "a_faq_tts_voices": "अपने <strong>Translation Profile</strong> (Inspector) में, 'Voice Mappings' सूची का उपयोग करें। आप एक रेगुलर एक्सप्रेशन पैटर्न (जैसे <code>^hero_.*</code>) को एक विशिष्ट Voice ID से मैप कर सकते हैं। जनरेटर कुंजी नाम के आधार पर स्वचालित रूप से सही आवाज़ चुनेगा।",
  "a_faq_window_actions_1": "टूल Retry Policy सेटिंग्स (प्रयासों की संख्या और देरी) के अनुसार विफल हुए सटीक बैच को फिर से भेजने का प्रयास करेगा। यदि इस बैच के लिए सभी प्रयास विफल हो जाते हैं, तो वर्तमान भाषा के लिए अनुवाद प्रक्रिया बाधित हो जाएगी, और कंसोल में एक त्रुटि लॉग की जाएगी। कतार में अगली भाषाओं के लिए अनुवाद शुरू नहीं होगा।",
  "a_faq_window_actions_2": "खाली मान मौजूदा अनुवादों को बदल देंगे। आयात प्रक्रिया CSV फ़ाइल को \"सत्य का स्रोत\" मानती है। यदि ru कॉलम में कुंजी welcome_message का मान खाली है, तो इस कुंजी के लिए वर्तमान रूसी अनुवाद अधिलेखित हो जाएगा।",
  "a_faq_window_actions_3": "हाँ, ऐसा होगा। \"Danger Zone\" में फ़ंक्शन प्रोजेक्ट में सभी प्रीफ़ैब को स्कैन करते हैं (AssetDatabase.FindAssets(\"t:Prefab\")), न कि केवल पार्सिंग सूची में निर्दिष्ट लोगों को, ताकि सबसे पूर्ण सफ़ाई सुनिश्चित की जा सके।",
  "a_faq_window_actions_4": "आपके गूगल शीट्स दस्तावेज़ में, कॉलम का शीर्षक \"Developer Notes\" होना चाहिए। इस कॉलम के सेल में, आप सामान्य रूप से टिप्पणियाँ लिख सकते हैं। प्लेसहोल्डर निर्दिष्ट करने के लिए, टिप्पणी टेक्स्ट में @placeholders: {username}, {score} जैसी एक पंक्ति जोड़ें। टूल आयात पर इस डायरेक्टिव को स्वचालित रूप से पहचान लेगा।",
  "a_faq_window_actions_5": "टूल एक समय में केवल एक शीट के साथ काम करता है। आयात URL में एक gid=... पैरामीटर शामिल होता है, जो दस्तावेज़ में एक विशिष्ट शीट की विशिष्ट रूप से पहचान करता है। दूसरी शीट से डेटा आयात करने के लिए, आपको उसका URL (एक अलग gid के साथ) कॉपी करना होगा और आयात फिर से करना होगा।",
  "a_faq_window_assets_1": "एसेट स्कैनर उन्हें अपेक्षित प्रकार निर्दिष्ट करके लोड करता है (AssetDatabase.LoadAssetAtPath(path, expectedType))। AudioClip श्रेणी के लिए, यह केवल उन फ़ाइलों को खोजेगा और लोड करेगा जिन्हें यूनिटी AudioClip के रूप में पहचानता है। यदि दोनों फ़ाइलें मान्य ऑडियो क्लिप हैं, तो जो अंतिम रूप से संसाधित होती है वह तालिका में शामिल होगी, जो प्रभावी रूप से पिछली वाली को अधिलेखित कर देगी। इस तरह के डुप्लिकेट से बचने की अनुशंसा की जाती है।",
  "a_faq_window_assets_2": "हाँ, यह ठीक उसी तरह काम करता है। \"Analyze Project\" Image घटक को ढूंढता है, उस पर असाइन किए गए स्प्राइट के नाम को देखता है (उदाहरण के लिए, icon_play_en), उससे कुंजी (icon_play) और भाषा (en) निकालता है, और फिर उस GameObject में एक LocalizedAsset घटक जोड़ता है और उसमें icon_play कुंजी लिखता है।",
  "a_faq_window_assets_3": "हाँ, आप कर सकते हैं। कोई विरोध नहीं होगा, क्योंकि प्रत्येक श्रेणी के लिए एक अलग एसेट तालिका (LocalizedAssetTable) बनाई जाती है। \"Sprites\" श्रेणी की कुंजियाँ \"AudioClips\" श्रेणी की कुंजियों के साथ ओवरलैप नहीं होती हैं, भले ही उनका नाम समान हो।",
  "a_faq_window_assets_4": "हाँ, यह ढूंढेगा। स्कैनर SearchOption.AllDirectories विकल्प का उपयोग करता है, जिसका अर्थ है कि यह आपके द्वारा निर्दिष्ट Scan Folder के भीतर सभी सबफ़ोल्डरों को पुनरावर्ती रूप से जाँच करेगा।",
  "a_faq_window_content_1": "नहीं, ऐसा नहीं होगा। Scenes to Parse सूची का उपयोग विशेष रूप से टूल को यह बताने के लिए किया जाता है कि टेक्स्ट के लिए किन सीन को खोलना और विश्लेषण करना है। यह किसी भी तरह से उन सीन से संबंधित नहीं है जो आपके गेम के अंतिम बिल्ड में समाप्त होंगे।",
  "a_faq_window_content_2": "नहीं, ऐसा नहीं होगा। अस्थायी सूची सीन में ऑब्जेक्ट के लिए एक सीधा संदर्भ संग्रहीत करती है। जब आप एक प्रीफ़ैब बनाते हैं, तो यह एक नया एसेट होता है। इसके इंस्टेंस अलग-अलग ऑब्जेक्ट होते हैं, और नज़रअंदाज़ करने का नियम उन पर लागू नहीं होगा। प्रीफ़ैब को स्थायी रूप से नज़रअंदाज़ करने के लिए, उन्हें एक प्रीफ़ैब एसेट के रूप में नज़रअंदाज़ करने की सूची में जोड़ा जाना चाहिए।",
  "a_faq_window_content_3": "हाँ, ऐसा होगा। जब आप Update Keys पर क्लिक करते हैं, तो पार्सर पूरे प्रोजेक्ट को फिर से स्कैन करता है। यह देखेगा कि TMPro.TMP_Text प्रकार को नज़रअंदाज़ किया जाना चाहिए और इसके लिए एक कुंजी जेनरेट नहीं करेगा। पुरानी और नई कुंजियों की तुलना करने की प्रक्रिया के दौरान, यह निर्धारित करेगा कि पुरानी कुंजी अब उपयोग में नहीं है और इसे \"Removed\" के रूप में चिह्नित करेगा।",
  "a_faq_window_content_4": "नहीं, ऐसा नहीं होगा। \"Pin\" बटन पर क्लिक किए जाने के क्षण सीन पदानुक्रम में पूर्ण पथ को बचाता है (उदाहरण के लिए, Canvas/Panel/Button)। यह पथ प्रीफ़ैब लॉजिक से संबंधित नहीं है। प्रीफ़ैब इंस्टेंस में एक ही पथ होगा, लेकिन यदि आप सीन में मूल ऑब्जेक्ट का नाम बदलते हैं, तो \"Pin\" मूल और इंस्टेंस दोनों के लिए काम करना बंद कर देगा।",
  "a_faq_window_content_5": "सीन रूट से पूर्ण पथ सहेजा जाएगा। उदाहरण के लिए, MyPrefab(Clone)/Content/Icon। यह \"pinned\" पथ केवल उसी सीन में काम करेगा जहाँ आपने इसे बनाया था। अन्य सीन में, इस तरह का पथ मिलने की संभावना नहीं है।",
  "a_faq_window_preview_1": "नहीं, यह सहेजा नहीं जाएगा। PreviewSafetyBridge एसेट सहेजने इवेंट (OnWillSaveAssets) को इंटरसेप्ट करता है और Unity द्वारा डिस्क पर बदलाव लिखे जाने से पहले स्वचालित रूप से RevertEditorPreview() को कॉल करता है। इस प्रकार, prefab अपनी मूल, अनलोकलाइज़्ड स्थिति में सहेजा जाएगा।",
  "a_faq_window_preview_2": "PreviewRecoveryService क्रैश रिकवरी को संभालता है। यदि Unity क्रैश हो जाता है, तो सेवा अगले लॉन्च पर बैकअप फ़ाइल का पता लगाती है और सीन की स्थिति को पुनर्स्थापित करने का प्रयास करती है। यदि स्वचालित रिकवरी विफल हो जाती है, तो आपको टूल विंडो में मैन्युअल रूप से \"Revert to Original\" चुनना पड़ सकता है।",
  "a_faq_window_preview_3": "हाँ, वे होंगे। Edit Mode में PrefabUtility.InstantiatePrefab Awake() और OnEnable() को कॉल करता है। यदि इन मेथड्स में ऐसा लॉजिक है जो एडिटर में नहीं चलना चाहिए (उदाहरण के लिए, सिंगलटन तक पहुंचना जो केवल Play Mode में मौजूद हैं), तो यह त्रुटियों का कारण बन सकता है। ऐसे कोड को सुरक्षित रखने के लिए if (Application.isPlaying) या #if UNITY_EDITOR का उपयोग करने की अनुशंसा की जाती है।",
  "a_faq_window_report_1": "हाँ, यह बाधित होगी। कोई भी नई कार्रवाई जिसके लिए UI ब्लॉकिंग की आवश्यकता होती है (जैसे Update Keys) वर्तमान खोज कोरूटीन को रोक देगी। एक डायलॉग बॉक्स दिखाई देगा, जो आपको एक नई खोज शुरू करने के लिए वर्तमान खोज को रोकने के लिए प्रेरित करेगा।",
  "a_faq_window_report_2": "\"Duplicates\" श्रेणी उस कुंजी के लिए सभी स्रोत दिखाएगी। आपको कुंजी के लिए एक एंट्री दिखाई देगी, और \"Source\" फ़ील्ड सभी पथों को सूचीबद्ध करेगा (सीन 1 और सीन 2 में)। इस मामले में \"Find\" बटन एक ड्रॉपडाउन सूची खोलेगा, जिससे आप यह चुन सकते हैं कि किस ऑब्जेक्ट पर नेविगेट करना है।",
  "a_faq_window_report_3": "हाँ। खोज प्रणाली को विशेष रूप से MyScript.cs जैसी स्क्रिप्ट स्रोतों को पहचानने के लिए प्रशिक्षित किया जाता है। जब आप \"Find\" पर क्लिक करते हैं, तो यह प्रोजेक्ट में MyScript.cs एसेट को खोजेगा और इसे प्रोजेक्ट विंडो में हाइलाइट (पिंग) करेगा।",
  "a_faq_window_settings_1": "हाँ, वे होंगे। मोड बदलते समय, टूल एक \"सुरक्षित माइग्रेशन\" करता है: यह पूरे प्रोजेक्ट को फिर से पार्स करता है, नए नियमों के अनुसार नई कुंजियाँ बनाता है, लेकिन मूल टेक्स्ट के माध्यम से पुरानी और नई कुंजियों को मैप करता है। फिर यह आपके सभी मौजूदा अनुवादों और टिप्पणियों को पुरानी कुंजियों से नई कुंजियों में स्थानांतरित कर देता है। आपके अनुवाद खोएंगे नहीं।",
  "a_faq_window_settings_2": "DefaultPluralRule का उपयोग किया जाएगा, जो अंग्रेजी और अधिकांश यूरोपीय भाषाओं के लिए उपयुक्त है (\"one\" और \"other\" के लिए रूप)।",
  "a_faq_window_settings_3": "नहीं, वे नहीं होंगी। केवल StreamingAssets या Resources फ़ोल्डर में स्थित एसेट्स को बिल्ड में शामिल करने की गारंटी है। यदि आप एक अलग पथ निर्दिष्ट करते हैं, तो स्थानीयकरण संपादक में काम करेगा लेकिन संकलित गेम में काम नहीं करेगा, क्योंकि अनुवाद फ़ाइलें बिल्ड का हिस्सा नहीं होंगी।",
  "a_faq_window_settings_4": "हाँ। EditorPrefs प्रत्येक कंप्यूटर के लिए स्थानीय स्टोरेज है। आपको प्रत्येक मशीन पर <strong>Translation Service API Key</strong> (Editor उपयोग जैसे OpenAI/DeepL के लिए) दर्ज करनी होगी। हालांकि, <strong>Runtime API Key</strong> (बिल्ड्स में उपयोग होने वाला) प्रोजेक्ट सेटिंग्स में संग्रहीत होता है और स्रोत नियंत्रण (source control) के माध्यम से साझा किया जाता है (एन्क्रिप्टेड)।",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "कॉपी किया गया!",
  "copy_code_copy": "कॉपी करें",
  "copy_code_error": "त्रुटि",
  "error_loading_message": "कृपया अपना कनेक्शन जाँचें और ताज़ा करें।",
  "error_loading_title": "लोडिंग त्रुटि",
  "h1_ai_audio": "AI ऑडियो / टेक्स्ट-टू-स्पीच",
  "h1_ai_profiles": "AI & अनुवाद प्रोफ़ाइल",
  "h1_api_snippets": "API और कोड स्निपेट्स",
  "h1_components": "मुख्य घटक (स्वचालित रूप से असाइन किए गए)",
  "h1_extending": "कार्यक्षमता का विस्तार करना",
  "h1_faq": "सामान्य प्रश्न और समस्या निवारण",
  "h1_font_glyph_manager": "फ़ॉन्ट और ग्लिफ़ प्रबंधक",
  "h1_important_notes": "महत्वपूर्ण नोट्स और चेतावनियाँ",
  "h1_introduction": "परिचय",
  "h1_loc_tool_window": "\"स्थानीयकरण टूल\" विंडो",
  "h1_migration_tool": "माइग्रेशन टूल",
  "h1_quick_start": "त्वरित शुरुआत और सेटअप",
  "h1_tms": "बाहरी TMS एकीकरण (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "अनुवाद तालिका संपादक",
  "h1_usage_examples": "उपयोग के उदाहरण",
  "h2_ai_assistant": "AI सहायक कमांड्स",
  "h2_ai_audio_setup": "सेटअप",
  "h2_ai_audio_usage": "उपयोग",
  "h2_ai_context": "संदर्भ & शब्दकोश",
  "h2_ai_profiles_overview": "अनुवाद प्रोफ़ाइल्स",
  "h2_async_api": "असिंक्रोनस एपीआई (Addressables)",
  "h2_backup_manager": "बैकअप मैनेजर",
  "h2_bridge_generation": "C# ब्रिज (स्ट्रॉन्गली टाइप्ड एक्सेस) उत्पन्न करें",
  "h2_custom_ai": "कस्टम AI & मॉडल",
  "h2_custom_asset_provider": "एक कस्टम एसेट प्रोवाइडर बनाना",
  "h2_custom_attributes": "कस्टम एट्रिब्यूट स्कैनिंग",
  "h2_custom_parser": "एक कस्टम पार्सर बनाना",
  "h2_example_attribute": "[LocalizableField] एट्रिब्यूट",
  "h2_example_components": "तैयार घटक और उदाहरण",
  "h2_example_components_updated": "अद्यतन LanguageSelector.cs",
  "h2_example_function": "_() फ़ंक्शन और [OnLanguageChange] एट्रिब्यूट",
  "h2_example_plurals": "बहुवचन और लिंग",
  "h2_faq_addressables": "Addressables और माइग्रेशन",
  "h2_faq_audio": "AI ऑडियो / टेक्स्ट-टू-स्पीच",
  "h2_faq_components": "मुख्य घटक",
  "h2_faq_editor": "अनुवाद संपादक",
  "h2_faq_examples": "उपयोग उदाहरण और कोड",
  "h2_faq_extending": "कार्यात्मकता का विस्तार",
  "h2_faq_installation": "स्थापना & त्वरित प्रारंभ",
  "h2_faq_notes": "महत्वपूर्ण बारीकियां और चेतावनियां",
  "h2_faq_window": "\"Localization Tool\" विंडो",
  "h2_font_glyph_manager_features": "विशेषताएँ",
  "h2_in_editor_preview": "एडिटर में & Prefab पूर्वावलोकन",
  "h2_initial_setup": "प्रारंभिक सेटअप",
  "h2_installation": "स्थापना",
  "h2_key_features": "मुख्य विशेषताएँ",
  "h2_live_updates_guide": "लाइव अपडेट्स गाइड",
  "h2_localizedasset": "स्थानीयकृत एसेट",
  "h2_localizedasset_updated": "LocalizedAsset एसिंक्रोनस लोडिंग",
  "h2_localizedbehaviour": "स्थानीयकृत Behaviour",
  "h2_localizeddropdown": "स्थानीयकृत ड्रॉपडाउन",
  "h2_localizedprefab": "स्थानीयकृत Prefab",
  "h2_localizedtext": "स्थानीयकृत पाठ",
  "h2_migration_custom": "कस्टम प्रोफ़ाइल बनाना",
  "h2_migration_google_sheets": "Google Sheets कुंजी",
  "h2_migration_import_formats": "इम्पोर्ट फ़ॉर्मेट्स (CSV & Google Sheets)",
  "h2_migration_stubs": "सुरक्षित माइग्रेशन & इमरजेंसी स्टब्स",
  "h2_migration_tool_features": "विशेषताएँ",
  "h2_migration_workflow": "माइग्रेशन वर्कफ़्लो गाइड",
  "h2_preview_overlay": "सीन व्यू ओवरले",
  "h2_safety_caps": "सीमाएँ & सुरक्षा कोटा",
  "h2_script_parsing_rules": "स्क्रिप्ट पार्सिंग नियम (अनुकूलता)",
  "h2_tab_actions": "\"क्रियाएँ\" टैब",
  "h2_tab_assets": "\"एसेट्स\" टैब",
  "h2_tab_content": "\"Content\" टैब",
  "h2_tab_report": "\"रिपोर्ट\" टैब",
  "h2_tab_settings": "\"सेटिंग्स\" टैब",
  "h2_tab_tutorials": "\"Tutorials\" टैब",
  "h2_tms_setup": "सेटअप और उपयोग",
  "h2_tms_supported": "समर्थित सेवाएँ",
  "h2_uitklocalization": "UITK स्थानीयकरण",
  "h2_visual_debugging_guide": "विज़ुअल डिबगिंग",
  "h2_window_footer": "विंडो फुटर (स्टेटस बार)",
  "h2_window_header": "विंडो हेडर और टूलबार",
  "h2_window_sidebar": "मुख्य मेनू (साइडबार)",
  "h3_actions_autotranslate": "स्वचालित अनुवाद",
  "h3_actions_danger": "खतरे का क्षेत्र",
  "h3_actions_data": "डेटा प्रबंधन",
  "h3_actions_editor": "अनुवाद संपादक",
  "h3_actions_parsing": "पार्सिंग",
  "h3_actions_tms_integration": "बाहरी सेवाएँ (TMS)",
  "h3_assets_automation": "स्वचालन",
  "h3_assets_categories": "एसेट श्रेणियाँ",
  "h3_assets_folder_gen": "फ़ोल्डर निर्माण",
  "h3_assets_loading": "लोडिंग रणनीति",
  "h3_assets_storage": "भंडारण विन्यास",
  "h3_attribute_cheat_sheet": "त्वरित संदर्भ: क्या करें और क्या न करें",
  "h3_attribute_features": "समर्थित प्रकार और विशेषताएँ",
  "h3_attribute_limitations": "सीमाएं",
  "h3_content_components_ignore": "अनदेखा करने के लिए कंपोनेंट प्रकार",
  "h3_content_dynamic_keys": "डायनामिक कुंजी उपसर्ग",
  "h3_content_dynamic_texts": "डायनामिक टेक्स्ट",
  "h3_content_objects_ignore": "अनदेखा करने के लिए ऑब्जेक्ट्स",
  "h3_content_prefabs": "Prefab फ़ोल्डर",
  "h3_content_regex": "अनदेखे रेगेक्स पैटर्न",
  "h3_content_scenes": "पार्स करने के लिए सीन",
  "h3_content_script_rules": "स्क्रिप्ट पार्सिंग नियम",
  "h3_content_scripts_ignore": "अनदेखा करने के लिए स्क्रिप्ट्स",
  "h3_custom_provider_steps": "इम्प्लीमेंटेशन स्टेप्स",
  "h3_faq_window_actions": "\"कार्रवाई\" टैब",
  "h3_faq_window_assets": "\"एसेट्स\" टैब",
  "h3_faq_window_content": "\"सामग्री\" टैब",
  "h3_faq_window_preview": "इन-एडिटर प्रीव्यू",
  "h3_faq_window_report": "\"रिपोर्ट\" टैब",
  "h3_faq_window_settings": "\"सेटिंग्स\" टैब",
  "h3_mode_auto": "AutoGenerateKeysOnly (मानक)",
  "h3_mode_hybrid": "हाइब्रिड मोड (कस्टम प्रायोरिटी)",
  "h3_mode_text": "UseTextAsKey (सरलीकृत)",
  "h3_report_all_keys": "सभी कुंजियाँ",
  "h3_settings_debugging": "डिबगिंग",
  "h3_settings_general": "सामान्य सेटिंग्स",
  "h3_settings_keygen": "की निर्माण",
  "h3_settings_languages": "भाषा प्रबंधन",
  "h3_settings_liveupdates": "लाइव अपडेट्स",
  "h3_settings_pseudo": "स्यूडो-लोकलाइज़ेशन सेटिंग्स",
  "h3_settings_runtimeapi": "रनटाइम API",
  "h3_settings_tools": "सामान्य एवं डेवलपर टूल्स",
  "h3_tutorials_list": "ट्यूटोरियल सूची",
  "lbl_not_supported": "समर्थित नहीं है",
  "lbl_supported": "पूरी तरह से समर्थित",
  "li_actions_1": "<strong>पार्सिंग:</strong><ul><li><strong>Update Keys:</strong> 'Content' टैब सेटिंग्स द्वारा परिभाषित पूर्ण प्रोजेक्ट स्कैन।</li><li><strong>Scan Selected Assets:</strong> प्रोजेक्ट व्यू में वर्तमान में चयनित फ़ाइलों/फ़ोल्डरों को **केवल** स्कैन करता है। आंशिक अपडेट के लिए सुरक्षित है क्योंकि यह स्वचालित रूप से 'Remove Missing Keys' को अक्षम कर देता है।</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> सभी अनुवादों को संपादित करने के लिए एक अलग, अधिक सुविधाजनक विंडो खोलता है।",
  "li_actions_3": "<strong>डेटा प्रबंधन:</strong> अनुवादकों के साथ डेटा का आदान-प्रदान करने के लिए उपयोग करें (CSV/XML/YAML/XLIFF में एक्सपोर्ट/इम्पोर्ट, Google Sheets से इम्पोर्ट)। <strong>Google Sheets:</strong> 'Edit' लिंक और 'Publish to Web' URLs दोनों का समर्थन करता है (GID पैरामीटर जांचें)।",
  "li_actions_4": "<strong>ऑटो-अनुवाद:</strong> सक्रिय <strong>Translation Profile</strong> का उपयोग करके सभी खाली अनुवाद स्ट्रिंग्स को स्वचालित रूप से भरता है।",
  "li_actions_5": "<strong>खतरा क्षेत्र:</strong> प्रोजेक्ट से सभी स्थानीयकरण घटकों को पूरी तरह से हटाने के लिए बटन शामिल हैं। सावधानी के साथ उपयोग करें!",
  "li_ai_1": "<strong>प्रोफ़ाइल बनाएँ:</strong> प्रोजेक्ट व्यू में राइट-क्लिक करें -> Create -> Localization -> Translation Profile।",
  "li_ai_2": "<strong>सेवाएँ:</strong> दीपएल, गूगल ट्रांसलेट, माइक्रोसॉफ्ट एज्योर, और <strong>कस्टम AI</strong> का समर्थन करता है।",
  "li_ai_3": "<strong>सेटिंग्स:</strong> प्रत्येक प्रोफ़ाइल अपनी स्वयं की एपीआई कुंजी, सीमाएँ (बैच आकार, अधिकतम वर्ण), और मॉडल सेटिंग्स संग्रहीत करती है।",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> लोकप्रिय सेवाओं (OpenAI, Gemini, Claude, Ollama) के लिए त्वरित रूप से प्रोफ़ाइल बनाने के लिए अंतर्निहित जनरेटर का उपयोग करें।",
  "li_ai_audio_generate": "<strong>Translation Table Editor</strong> में, पंक्तियाँ/सेल चुनें -> राइट-क्लिक करें -> <strong>Generate Audio</strong>।",
  "li_ai_audio_hash": "<strong>स्मार्ट अपडेट और हैशिंग:</strong> टूल आपके टेक्स्ट सामग्री के MD5 हैश की गणना करता है और यदि स्रोत टेक्स्ट बदल गया है तो ही ऑडियो फ़ाइलों को पुन: जेनरेट करता है, जिससे आपके API क्रेडिट्स की बचत होती है। यह पता लगाता है कि क्या अंतिम ऑडियो जनरेशन के बाद अनुवाद बदल गया है। संपादक इन पंक्तियों को 'Outdated' आइकन (पीला) के साथ हाइलाइट करता है, जिससे आप **केवल** बदली हुई पंक्तियों को अपडेट कर सकते हैं। यह स्मार्ट बैचिंग सुविधा अनावश्यक API कॉल को रोकती है और ऑडियो पुन: जेनरेट करते समय लागत को कम करती है। टूल आपके टेक्स्ट को हैश करता है और यदि स्रोत टेक्स्ट बदल गया है तो ही ऑडियो फ़ाइलों को पुन: जेनरेट करता है, जिससे आपके API क्रेडिट्स की बचत होती है।",
  "li_ai_audio_profile": "<strong>Settings</strong> में, <strong>Active Audio Profile</strong> का चयन करें (जैसे, OpenAI TTS या ElevenLabs)।",
  "li_ai_audio_save": "फ़ाइलें प्रोफ़ाइल में निर्दिष्ट फ़ोल्डर में सहेजी जाती हैं।",
  "li_ai_audio_voice_mapping": "<strong>Voice Mapping (Multi-Speaker):</strong> विभिन्न AI आवाज़ों को विभिन्न पात्रों को स्वचालित रूप से असाइन करें। <strong>Voice Mappings</strong> सूची का उपयोग करके रेगेक्स पैटर्न (उदा. <code>^hero_.*</code>) को विशिष्ट Voice IDs से लिंक करें। टूल ऑडियो जनरेशन के दौरान कुंजी नाम के आधार पर सही आवाज़ स्वचालित रूप से चुन लेगा।",
  "li_ai_provider_settings": "<strong>प्रोवाइडर सेटिंग्स:</strong> प्रत्येक सेवा API Keys, मॉडल (जैसे, GPT-4o, Sonnet), और आवाज़ विशेष पैरामीटर (Stability, Similarity) को कॉन्फ़िगर करने की अनुमति देती है।",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Addressables एसेट्स को असिंक्रोनस रूप से लोड करने के लिए इसका उपयोग करें। यह एक <code>Task&lt;T&gt;</code> लौटाता है।",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) एक लिंग-विशिष्ट अनुवाद लौटाता है।",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> भाषा-विशिष्ट नियमों के आधार पर सही बहुवचन रूप लौटाता है।",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> भाषा बदलने के लिए एक coroutine (<code>IEnumerator</code>)। हमेशा <code>StartCoroutine()</code> का उपयोग करें।",
  "li_assets_1": "<strong>फ़ोल्डर संरचना बनाएँ (वैकल्पिक):</strong> अनुभाग <strong>2. Asset Folder Generation</strong> में, <strong>Create Asset Folders Now</strong> पर क्लिक करें।",
  "li_assets_2": "<strong>श्रेणियाँ और नामकरण नियम कॉन्फ़िगर करें:</strong> अनुभाग <strong>3. Asset Categories & Scanning</strong> में, सुनिश्चित करें कि <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) आपकी फ़ाइलों से मेल खाता है (उदाहरण के लिए, <code>button_ok_en.png</code>)।",
  "li_assets_3": "<strong>अपने एसेट्स रखें:</strong> स्थानीयकृत एसेट्स को फ़ोल्डरों में रखें।",
  "li_assets_4": "<strong>एसेट्स स्कैन करें:</strong> अनुभाग <strong>4. Automation</strong> में, <strong>Scan Assets & Update Tables</strong> पर क्लिक करें। सफ़ाई प्रक्रिया सुरक्षित हो गई है: अब केवल पुरानी तालिका फ़ाइलें (<code>.asset</code>) हटाई जाती हैं, न कि पूरा फ़ोल्डर।",
  "li_assets_5": "<strong>एसेट्स को ऑब्जेक्ट्स से लिंक करें:</strong> <strong>Analyze Project & Attach Components</strong> पर क्लिक करें।",
  "li_assets_6": "<strong>Addressables एकीकरण:</strong> यदि <strong>Addressables</strong> मोड सक्षम है, तो स्कैनिंग के दौरान एसेट्स को स्वचालित रूप से <code>{Category}/{Language}/{Key}</code> प्रारूप में पते के साथ Addressables समूहों में पंजीकृत किया जाएगा।",
  "li_assets_addressables_naming": "<strong>नामकरण कन्वेंशन:</strong> स्कैन करते समय, टूल स्वचालित रूप से Addressable Addresses को <code>{Category}/{Language}/{Key}</code> प्रारूप में सेट करता है। <strong>इन पतों का मैन्युअल रूप से नाम न बदलें</strong>, क्योंकि LocalizationManager रनटाइम पर एसेट्स लोड करने के लिए इस विशिष्ट प्रारूप पर निर्भर करता है।",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> यदि सक्षम किया गया है, तो टूल पहले एसेट लोकलाइज़ेशन के दौरान सभी समर्थित भाषाओं के लिए आवश्यक डायरेक्टरी संरचना स्वचालित रूप से बना देगा।",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> आपके नियमों के अनुसार लोकलाइज़्ड एसेट्स के लिए फ़ोल्डर संरचना स्वचालित रूप से बनाएं।",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> सभी लोकलाइज़्ड एसेट्स (स्प्राइट्स, ऑडियो, आदि) के लिए रूट डायरेक्टरी निर्धारित करें। प्रति-भाषा फ़ोल्डरों की संरचना निर्दिष्ट करने के लिए <code>{lang}</code> वेरिएबल का उपयोग करें।",
  "li_assistant_1": "<strong>विन्यास योग्य:</strong> अपने Translation Profile में कमांड परिभाषित करें (उदाहरण के लिए, \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\")।",
  "li_assistant_2": "<strong>बैच प्रोसेसिंग:</strong> कमांड को एक साथ उन सभी पर लागू करने के लिए कई सेल का चयन करें।",
  "li_assistant_3": "<strong>Custom Commands:</strong> <strong>Translation Profile</strong> इंस्पेक्टर में अपने स्वयं के प्रॉम्प्ट्स निर्धारित करें (<code>AIAssistantCommand</code> की सूची)। प्रत्येक कमांड में एक <strong>Label</strong> (कॉन्टेक्स्ट मेन्यू में दिखता है) और एक <strong>Prompt</strong> (AI को भेजे जाने वाले निर्देश, जैसे, 'पाइरेट शैली में पुनर्लेखन करें') होता है।",
  "li_attr_feat_1": "<strong>कलेक्शंस:</strong> <code>List&lt;string&gt;</code> और <code>string[]</code> का समर्थन करता है। कुंजियां <code>_0</code>, <code>_1</code>, आदि प्रत्ययों के साथ जेनरेट की जाती हैं। आप सभी आइटम्स को उपसर्ग करने के लिए सूची फ़ील्ड पर एक कस्टम कुंजी का भी उपयोग कर सकते हैं।",
  "li_attr_feat_2": "<strong>एक्सेस मॉडिफायर्स:</strong> <code>private</code>, <code>protected</code>, <code>internal</code>, और <code>public</code> फ़ील्ड्स के साथ काम करता है।",
  "li_attr_feat_3": "<strong>कस्टम एट्रीब्यूट्स:</strong> <em>कंटेंट टैब</em> सेटिंग्स में, आप <code>HeaderAttribute</code>, <code>TooltipAttribute</code>, या कोई भी कस्टम एट्रीब्यूट नाम जोड़ सकते हैं। पार्सर तब इन एट्रीब्यूट्स वाले फ़ील्ड्स (उदा. <code>[Header(\"Text\")]</code>) को लोकलाइज़ेबल स्ट्रिंग्स के रूप में मानेगा!",
  "li_attr_feat_4": "<strong>नेस्टेड ऑब्जेक्ट्स:</strong> `[System.Serializable]` से चिह्नित क्लास या स्ट्रक्ट के अंदर फ़ील्ड को पुनरावर्ती रूप से स्कैन करता है। इसमें एकल इंस्टेंस और नेस्टेड ऑब्जेक्ट्स की सूचियां शामिल हैं।",
  "li_attr_feat_5": "<strong>फ़ॉर्मेटेड स्ट्रिंग्स:</strong> इंटरपोलेटेड स्ट्रिंग्स (<code>$\"Text {0}\"</code>), वर्बेटिम स्ट्रिंग्स (<code>@\"Text\"</code>), और कंकैटनेशन (<code>\"A\" + \"B\"</code>) का समर्थन करता है।",
  "li_attr_limit_1": "<strong>प्रॉपर्टीज़ समर्थित हैं:</strong> पार्सर दोनों <code>Fields</code> और <code>Properties</code> को स्कैन करता है। एक Getter आवश्यक है।",
  "li_attr_limit_2": "<strong>डिक्शनरीज़:</strong> <code>Dictionary&lt;T, string&gt;</code> सीधे पार्सिंग के लिए समर्थित नहीं है।",
  "li_attr_limit_3": "<strong>स्टेटिक फ़ील्ड्स:</strong> कोड फ़ाइलों में स्टैटिक एनालिसिस (रेगेक्स) के माध्यम से समर्थित हैं, लेकिन गेमऑब्जेक्ट्स पर मजबूत पहचान के लिए इंस्टेंस फ़ील्ड्स का उपयोग करने की आमतौर पर सलाह दी जाती है।",
  "li_backup_desc": "परिवर्तनों को ट्रैक करें और अपने अनुवादों के पिछले संस्करणों को पुनर्स्थापित करें।",
  "li_backup_rollback": "<strong>रोलबैक:</strong> चयनित कुंजियों या पूरी तालिका को तुरंत पिछले स्थिति में पुनर्स्थापित करें।",
  "li_backup_snapshots": "<strong>स्नैपशॉट्स:</strong> बड़े ऑपरेशनों से पहले नामित रीस्टोर पॉइंट बनाता है।",
  "li_cheat_base_private": "<strong>बेस प्राइवेट फ़ील्ड्स:</strong> समर्थित (स्कैनर बेस क्लास फ़ाइलों को सीधे पढ़ता है)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> एरेज़",
  "li_cheat_concatenation": "<strong>स्ट्रिंग कंकैटनेशन:</strong> <code>\"A\" + \"B\"</code> (समर्थित)",
  "li_cheat_constructor_args": "<strong>जटिल कंस्ट्रक्टर आर्ग्यूमेंट्स:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>डिक्शनरीज़</strong> (यूनिटी इंस्पेक्टर द्वारा स्वाभाविक रूप से सीरियलाइजेबल नहीं हैं)",
  "li_cheat_headers": "Attributes जैसे <code>[Header(\"...\")]</code> (पूरी तरह समर्थित)",
  "li_cheat_nested_lists": "<strong>नेस्टेड ऑब्जेक्ट्स की सूचियाँ</strong> (उदाहरण के लिए <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>वेरिएबल्स और कॉन्स्टेंट्स:</strong> <code>const string s = \"Value\";</code> or <code>static string</code> (समर्थित, Roslyn समान फ़ाइल से मानों को हल करता है)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> फ़ील्ड्स (समर्थित)",
  "li_cheat_properties": "<strong>प्रॉपर्टीज़:</strong> <code>{ get; set; }</code> (ऑटो-प्रॉपर्टीज़ और फुल प्रॉपर्टीज़ समर्थित)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (यदि रेफ़रेंस किया गया हो तो समर्थित)",
  "li_cheat_serializable": "नेस्टेड <code>[Serializable] class</code> (इन्वेंटरी आइटम, डायलॉग नोड्स)",
  "li_cheat_static": "<strong>स्टैटिक फ़ील्ड्स:</strong> <code>public static string</code> (पूरी तरह समर्थित)",
  "li_cheat_structs": "<strong>स्ट्रक्ट्स & रिकॉर्ड्स:</strong> समर्थित (रिकर्सिव स्कैनिंग)",
  "li_cheat_ternary": "<strong>लॉजिक/टर्निटी:</strong> <code>cond ? \"A\" : \"B\"</code> (पार्सर मान निर्धारित नहीं कर सकता)",
  "li_cheat_unattached": "<strong>अनअटैच्ड स्क्रिप्ट्स:</strong> समर्थित (स्कैनर प्रोजेक्ट में सभी .cs फ़ाइलें पढ़ता है)",
  "li_content_1": "<strong>Scenes to Parse:</strong> विश्लेषण के लिए सभी सीन को यहाँ खींचें और छोड़ें।",
  "li_content_2": "<strong>Prefab Folders:</strong> प्रीफ़ैब वाले फ़ोल्डरों को निर्दिष्ट करें। अब बड़े प्रोजेक्ट के लिए पेजिंग और खोज का समर्थन करता है।",
  "li_content_3": "<strong>Dynamic Texts:</strong> यहाँ कोड में विशेष रूप से बनाई गई स्ट्रिंग्स दर्ज करें (उदाहरण के लिए, \"Game Over\")।",
  "li_content_4": "<strong>Component Types to Ignore:</strong> स्कैनिंग के दौरान छोड़ने के लिए Unity Component प्रकार निर्दिष्ट करें।",
  "li_content_5": "<strong>Pin to Ignore:</strong> यह सुविधा आपको सीन से किसी ऑब्जेक्ट को स्थायी रूप से अनदेखा सूची में \\\"pin\\\" करने की अनुमति देती है।",
  "li_content_6": "<strong>Scripts to Ignore:</strong> विशिष्ट C# स्क्रिप्ट्स या पूरे फ़ोल्डर जोड़ें ताकि उन्हें पार्सिंग से बाहर रखा जा सके।",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> कुंजियों के लिए उपसर्गों की सूची (उदा., <code>Item_</code>) जो सफ़ाई के दौरान हटाए नहीं जाएंगे।",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> संभावित डायनामिक के रूप में पहचाने जाने वाले उपसर्ग (उदा., <code>quest_item_</code>) निर्धारित करें। यह टूल को स्थैतिक UI लेबल और डेटा-ड्रिवन कुंजियों के बीच अंतर करने में मदद करता है।",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> कोड के माध्यम से डायनामिक रूप से अपडेट होने वाले टेक्स्ट के लिए पैटर्न कॉन्फ़िगर करें। यह स्कैनर को रनटाइम पर बदलने वाले टेक्स्ट के लिए अतिरिक्त कुंजियों के निर्माण से रोकता है।",
  "li_content_regex_example": "<strong>कस्टम रैपर उदाहरण:</strong> यदि आप <code>MyGame.Loc(\"KEY\")</code> जैसी कस्टम फ़ंक्शन का उपयोग करते हैं, तो regex के साथ एक स्क्रिप्ट पार्सिंग नियम जोड़ें: <code>\\\\bMyGame\\\\.Loc\\\\s*\\\\(\\\\s*\\\"([^\\\"]*)\\\"</code>.",
  "li_content_regex_presets": "<strong>अवहेलित रेगेक्स पैटर्न:</strong> जल्दी से URLs, Emails आदि जैसे डायनेमिक कंटेंट को बाहर करने के लिए <strong>'सामान्य पैटर्न जोड़ें'</strong> पर क्लिक करें।",
  "li_content_scanner": "<strong>Roslyn कोड स्कैनर:</strong> एक गहरा स्थैतिक विश्लेषण इंजन जो मजबूत कुंजी पहचान के लिए C# सिंटैक्स ट्री को समझता है।",
  "li_content_scanner_details_1": "<strong>स्मार्ट कॉल डिटेक्शन:</strong> स्वचालित रूप से <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code>, और <code>GetTranslation(\"Text\")</code> कॉल्स को खोजता है। यह इन कॉल्स के लिए <strong>Text-As-Key</strong> मोड लागू करता है ताकि प्लूरलाइज़ेशन और जेंडर जैसी रनटाइम सुविधाएँ सही ढंग से काम करें।",
  "li_content_scanner_details_2": "<strong>कॉन्स्टेंट रिज़ॉल्यूशन:</strong> स्कैनर इतना स्मार्ट है कि `const` या `static readonly` स्ट्रिंग वेरिएबल्स को हल कर सके। यदि आप <code>_ (MyConst)</code> का उपयोग करते हैं, तो यह `MyConst` का मान (यदि उसी क्लास में परिभाषित है) खोजेगा और उसे स्रोत टेक्स्ट के रूप में उपयोग करेगा।",
  "li_content_scanner_details_3": "<strong>गुणधर्म और मेटाडेटा:</strong> यह किसी भी फ़ील्ड या प्रॉपर्टी को स्कैन करता है जिसमें `[LocalizableField]`, `[Header]`, या `[Tooltip]` (यदि कॉन्फ़िगर किया गया हो) हो। यह <strong>ऐरेज़</strong>, <strong>सूचियों</strong>, और यहाँ तक कि <strong>नेस्टेड सीरियलाइज़ेबल क्लासेज़</strong> को पुनरावर्ती रूप से संभालता है।",
  "li_content_scanner_details_4": "<strong>आधुनिक C# समर्थन:</strong> C# 9.0+ सिंटैक्स के लिए पूर्ण समर्थन, जिसमें टार्गेट-टाइप्ड <code>new()</code> एक्सप्रेशन, इम्प्लिसिट ऐरे निर्माण, और इंटरपोलेटेड स्ट्रिंग्स (`$\"String {0}\"`) शामिल हैं।",
  "li_content_script_rules_attributes": "<strong>स्कैन करने के लिए एट्रिब्यूट्स:</strong> कस्टम एट्रिब्यूट्स (जैसे <code>[Header]</code> या <code>[Tooltip]</code>) परिभाषित करें जिन्हें पार्सर को स्थानीयकृत स्ट्रिंग स्रोत के रूप में पहचानना चाहिए।",
  "li_content_script_rules_bridge_name": "<strong>ब्रिज क्लास नाम:</strong> आपको उत्पन्न स्थैतिक क्लास का नाम निर्धारित करने की अनुमति देता है।",
  "li_content_script_rules_bridges": "<strong>C# ब्रिज बनाएं:</strong> स्वचालित रूप से एक स्थैतिक क्लास (जैसे <code>AnkoLoc</code>) बनाता है जो सभी कुंजियों तक टाइप-सेफ पहुंच प्रदान करता है, मैजिक स्ट्रिंग्स को समाप्त करता है और IDE ऑटो-कम्प्लीशन को सक्षम करता है।",
  "li_context_1": "<strong>डेवलपर नोट्स:</strong> अनुवाद तालिका से टिप्पणियाँ AI को संदर्भ के रूप में पास की जाती हैं।",
  "li_context_2": "<strong>ऑब्जेक्ट पथ:</strong> यदि कोई टिप्पणी मौजूद नहीं है, तो ऑब्जेक्ट के पदानुक्रम पथ (जैसे, <code>MainMenu/Canvas/StartButton</code>) का उपयोग फ़ॉलबैक संदर्भ के रूप में किया जाता है।",
  "li_context_3": "<strong>शब्दावली:</strong> आप प्रोफ़ाइल में एक CSV शब्दावली लोड कर सकते हैं ताकि शर्तों और नामों के लिए विशिष्ट अनुवाद लागू किए जा सकें।",
  "li_context_4": "<strong>प्रोजेक्ट विवरण:</strong> अपने गेम की सेटिंग और दर्शकों का वर्णन करें ताकि AI सामान्य संदर्भ को समझ सके।",
  "li_context_5": "<strong>स्वर और शैली:</strong> इच्छित व्यक्तित्व (जैसे 'मित्रवत', 'पेशेवर', 'समुद्री डाकू') और फ़ॉर्मेटिंग नियम निर्धारित करें।",
  "li_context_glossary": "<strong>डिक्शनरी मैनेजर:</strong> शब्दकोश के साथ सीधे 'Add', 'Edit', या 'Remove' टर्म्स के लिए इंटरैक्ट करें। केस सेंसिटिविटी और 'Do Not Translate' प्रकारों का समर्थन करता है।",
  "li_context_optimization": "<strong>टोकन ऑप्टिमाइज़ेशन:</strong> सिस्टम संदर्भ को बुद्धिमानी से संकुचित करता है और कैश को पुन: उपयोग करता है ताकि टोकन उपयोग और लागत कम हो सके।",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> एक लचीला कार्यान्वयन जो OpenAI-संगत APIs (Ollama के माध्यम से स्थानीय LLM सहित) के साथ संचार कर सकता है।",
  "li_custom_ai_2": "<strong>टेम्प्लेट्स और प्रमाणीकरण:</strong> अनुरोध को पूरी तरह से अनुकूलित करें। <ul><li><strong>प्रमाणीकरण:</strong> <code>Auth Header Key</code> (जैसे, <code>Authorization</code>) और <code>Format</code> (जैसे, <code>Bearer {0}</code>) कॉन्फ़िगर करें। क्वेरी पैरामीटर में API कुंजी का समर्थन करता है।</li><li><strong>बॉडी टेम्प्लेट:</strong> टेक्स्ट के लिए <code>{model}</code> और <code>{prompt}</code> जैसे प्लेसहोल्डर वाले JSON टेम्प्लेट का उपयोग करें, या ऑडियो के लिए <code>{input}</code> और <code>{voice}</code>।</li><li><strong>रिस्पॉन्स पाथ:</strong> परिणाम के लिए JSON पाथ परिभाषित करें (जैसे, <code>choices[0].message.content</code>)।</li></ul>",
  "li_custom_ai_3": "<strong>अंतर्निहित सुरक्षा सुविधाएँ:</strong> AI मॉडल द्वारा अक्सर लौटाए जाने वाले टूटे हुए फ़ॉर्मेटिंग टैग (जैसे <ph0>) को स्वचालित रूप से ठीक करें, विश्वसनीय और सुसंगत अनुवाद सुनिश्चित करें।",
  "li_custom_parser_1": "अपने प्रोजेक्ट के <strong>Editor</strong> फ़ोल्डर में एक नई C# स्क्रिप्ट बनाएँ।",
  "li_custom_parser_2": "नीचे दिए गए टेम्पलेट को उसमें कॉपी करें।",
  "li_custom_parser_3": "अपने घटक से मेल खाने के लिए लॉजिक को संशोधित करें।",
  "li_custom_provider_manual_reg": "<strong>मैनुअल रजिस्ट्रेशन:</strong> उन्नत परिदृश्यों (जैसे DI इंजेक्शन या लेज़ी इनिट) के लिए, आप अपने प्रोवाइडर को <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> के माध्यम से मैन्युअल रूप से रजिस्टर कर सकते हैं।",
  "li_custom_provider_step_1": "<strong>इंटरफ़ेस को लागू करें:</strong> एक नई क्लास बनाएं जो <code>IAssetProvider</code> को इम्प्लीमेंट करती है। आपको अपने सिस्टम के API का उपयोग करके <code>Load&lt;T&gt;</code> (सिंक्रोनस) और <code>LoadAsync&lt;T&gt;</code> (असिंक्रोनस) एसेट्स को कैसे लोड करना है, परिभाषित करना होगा।",
  "li_custom_provider_step_2": "<strong>लाइफ़साइकल निर्धारित करें:</strong> <code>Initialize</code>, <code>Dispose</code>, और <code>UnloadAll</code> को इम्प्लीमेंट करें। ये मेथड्स <code>LocalizationManager</code> द्वारा भाषा बदलते समय या संसाधनों को साफ़ करते समय कॉल किए जाते हैं।",
  "li_custom_provider_step_3": "<strong>भाषा सुरक्षा:</strong> सक्रिय भाषा बदलने पर <code>SetCurrentLanguage</code> मेथड कॉल किया जाता है। इसका उपयोग आंतरिक पाथ्स को अपडेट करने या एसेट मेटाडेटा को पुनः प्राप्त करने के लिए करें।",
  "li_custom_provider_step_4": "<strong>ऑटो-डिस्कवरी (सिफ़ारिश किया गया):</strong> अपनी क्लास को <code>[AssetProviderPlugin]</code> एट्रिब्यूट से सजाएँ। इससे आपका प्रोवाइडर तुरंत <strong>Settings Tab -&gt; Asset Loading Strategy</strong> ड्रॉपडाउन में दिखाई देगा।",
  "li_editor_1": "<strong>स्मार्ट समूहन:</strong> बहुवचन और लिंग के लिए कुंजियाँ (उदाहरण के लिए, <code>apple_count_one</code>, <code>apple_count_few</code>) स्वचालित रूप से ढहने योग्य समूहों में संयोजित हो जाती हैं।",
  "li_editor_2": "<strong>उन्नत संपादन:</strong> <strong>MultiLineEditWindow</strong> पॉपअप खोलने के लिए एक सेल पर क्लिक करें। यह तुलना के लिए स्रोत टेक्स्ट दिखाता है और प्लेसहोल्डर को मान्य करता है।",
  "li_editor_3": "<strong>उन्नत चयन:</strong> लचीले चयन मोड्स का समर्थन करता है: व्यक्तिगत सेल्स, पूरी पंक्तियाँ, या विशिष्ट कॉलम (भाषाएँ)। जटिल चयन के लिए <code>Ctrl+Click</code> और <code>Shift+Click</code> का उपयोग करें।",
  "li_editor_4": "<strong>बड़े पैमाने पर कार्य:</strong> एक साथ हजारों सेल्स पर ऑपरेशन्स चलाएँ। अपने चयन पर राइट-क्लिक करें ताकि: <ul><li><strong>ऑटो-ट्रांसलेट:</strong> सक्रिय AI प्रोफ़ाइल का उपयोग करके गायब अनुवाद भरें।</li><li><strong>स्रोत से भरें:</strong> अनुवादों को जल्दी रीसेट करें।</li><li><strong>लॉक टॉगल करें:</strong> 'परफेक्ट' अनुवादों को आकस्मिक ओवरराइट से बचाएँ।</li><li><strong>ऑडियो जेनरेट करें:</strong> चयनित वाक्यांशों के लिए TTS को बैच प्रोसेस करें।</li></ul>",
  "li_editor_5": "<strong>उच्च-प्रदर्शन नेविगेशन:</strong> एडिटर स्मूद स्क्रॉलिंग के लिए वर्चुअलाइज़्ड 'MultiColumnListView' का उपयोग करता है जिसमें 10k+ कुंजियाँ हैं। कीबोर्ड नेविगेशन (एरोज़/टैब) और शक्तिशाली शॉर्टकट्स का समर्थन करता है: <code>Ctrl+S</code> (सेव), <code>Ctrl+Z/Y</code> (अंडू/रीडू), <code>Ctrl+F</code> (सर्च फोकस)।",
  "li_editor_6": "<strong>उन्नत सर्च प्रीसेट्स:</strong> विशेष फ़िल्टरों का उपयोग करके अपने प्रोजेक्ट का ऑडिट करें: <ul><li><strong>स्थिति:</strong> अनूदित नहीं (वर्तमान/कोई भी भाषा), स्रोत के समान, लॉक्ड।</li><li><strong>सामग्री:</strong> टिप्पणी मौजूद, प्लेसहोल्डर मौजूद/गायब, लंबाई समस्याएँ (ऑटो-डिटेक्टेड)।</li><li><strong>संरचना:</strong> बहुवचन, लिंग-संबंधी, या दोनों।</li><li><strong>ऑडियो:</strong> ऑडियो गायब, पुराना (हैश मिसमैच)।</li></ul>",
  "li_editor_7": "<strong>स्मार्ट ऑडियो मैनेजमेंट:</strong> आपके TTS फ़ाइलों की 'ताज़गी' को ट्रैक करता है। यदि आप अनुवाद टेक्स्ट को संपादित करते हैं, तो एक <strong>पीला संकेतक (पुराना)</strong> दिखाई देता है, जो दर्शाता है कि ऑडियो फ़ाइल का हैश अब टेक्स्ट से मेल नहीं खाता। एक क्लिक से केवल पुराने फ़ाइलें पुनः उत्पन्न होती हैं।",
  "li_editor_8": "<strong>लॉकिंग मैकेनिज़्म:</strong> व्याख्या: <ul><li><strong>लॉक्ड सेल्स/रोज़:</strong> <strong>ऑटो-ट्रांसलेट</strong>, <strong>CSV/Google इम्पोर्ट</strong>, या <strong>स्रोत से भरें</strong> द्वारा किसी भी संशोधन को रोकता है।</li><li><strong>उपयोग केस:</strong> उन 'गोल्डन' अनुवादों को लॉक करें जो मूल वक्ताओं द्वारा मैन्युअली सत्यापित किए गए हैं।</li><li><strong>बुल्क नियंत्रण:</strong> पूरे भाषाओं या विशिष्ट फीचर्स (जैसे कैरेक्टर नाम) को प्रोजेक्ट-व्यापी लॉक करें।</li></ul>",
  "li_editor_layout": "<strong>डायनामिक मल्टी-पेन लेआउट:</strong> 3-पेन सिस्टम का उपयोग करके 'फिक्स्ड' कॉलम (जैसे Keys) को बाएँ तरफ पिन करें जबकि मध्य में 20+ भाषाओं को स्क्रॉल करें। हेडर कॉन्टेक्स्ट मेन्यू के माध्यम से कॉलम विज़िबिलिटी टॉगल करें।",
  "li_editor_regex": "<strong>रेजेक्स सर्च:</strong> मुख्य विंडो और टेबल एडिटर दोनों <strong>रेगुलर एक्सप्रेशन्स</strong> का समर्थन करते हैं। यदि आपके क्वेरी में <code>* + ? ^ $ [ ] ( ) { } | .</code> जैसे प्रतीक हैं, तो इसे स्वचालित रूप से रेजेक्स माना जाता है (उदाहरण के लिए, <code>^item_.*</code> सभी कुंजियों को खोजने के लिए जो 'item_' से शुरू होती हैं)।",
  "li_editor_structure": "<strong>टेबल्स और ग्रुप्स:</strong> डेटा को टेबल्स (फ़ाइलें) में व्यवस्थित किया जाता है, जो एडिटर में ग्रुप्स (फ़ोल्डर्स) के रूप में दिखाए जाते हैं ताकि नेविगेशन बेहतर हो।",
  "li_editor_ui_test": "<strong>बिल्ट-इन UI टेस्टिंग:</strong> <ul><li><strong>लेंथ एक्सपैंशन स्लाइडर:</strong> टेक्स्ट विस्तार (0% - 100%) का सिमुलेशन करें ताकि देखें कि आपका UI जर्मन या रूसी जैसी लंबी भाषाओं को एडिटर से बाहर निकले बिना कैसे संभालता है।</li><li><strong>रिच टेक्स्ट रेंडरर:</strong> टैग्स (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) के रेंडरिंग को टॉगल करें ताकि गेम चलाए बिना स्टाइलिंग की पुष्टि हो सके।</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> भाषा स्विचिंग के लिए एक UI ड्रॉपडाउन सूची बनाने के लिए एक तैयार घटक। यह स्वचालित रूप से सभी उपलब्ध भाषाओं को ढूंढता है और उनके स्विचिंग का प्रबंधन करता है।<br><strong>उपयोग कैसे करें:</strong> बस अपनी सीन में <code>LanguageSelector</code> घटक जोड़ें (जैसे, एक खाली GameObject पर) और इंस्पेक्टर में अपना <code>TMP_Dropdown</code> निर्दिष्ट करें।",
  "li_example_components_2": "<strong>कोड उदाहरण:</strong> <code>[LocalizableField]</code>, <code>_()</code> फ़ंक्शन, बहुवचन, और लिंग के साथ काम करने जैसी उन्नत तकनीकों को सीखने के लिए, <code>StatPurchaseTest.cs</code> और <code>TestLocalization.cs</code> फ़ाइलों का अध्ययन करें। वे कोड में टूल की सभी मुख्य विशेषताओं के कार्यान्वयन को स्पष्ट रूप से प्रदर्शित करते हैं।",
  "li_example_components_new": "<strong>नया (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. <code>IEnumerator</code> लौटाता है। इसे यील्ड किया जाना चाहिए।",
  "li_example_components_old": "<strong>पुराना:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (सिंक्रोनस void) - <strong>Deprecated</strong>. कॉरूटीन संस्करण का उपयोग करें।",
  "li_feature_1": "<strong>उन्नत पार्सिंग:</strong> सीन, प्रीफ़ैब, UI टूलकिट (UXML), और C# स्क्रिप्ट का स्वचालित स्कैनिंग, जिसमें <code>[LocalizableField]</code> एट्रीब्यूट से चिह्नित फ़ील्ड्स के साथ-साथ नेस्टेड क्लासेस और सूचियाँ भी शामिल हैं।",
  "li_feature_10": "<strong>बैकअप मैनेजर:</strong> बैकअप बनाने और पुनर्स्थापित करने के लिए एक अंतर्निहित टूल।",
  "li_feature_11": "<strong>AI संचालित:</strong> अनुकूलन योग्य प्रोफाइल के माध्यम से OpenAI, Anthropic (Claude), Google Gemini, और स्थानीय LLM (Ollama) के लिए समर्थन।",
  "li_feature_12": "<strong>टेक्स्ट-टू-स्पीच (TTS):</strong> AI (OpenAI, ElevenLabs) का उपयोग करके स्थानीयकृत स्ट्रिंग्स के लिए ऑडियो फ़ाइलों का निर्माण।",
  "li_feature_13": "<strong>माइग्रेशन टूल:</strong> I2 Localization और Unity Localization प्लगइन्स से स्वचालित रूप से संक्रमण के लिए टूल।",
  "li_feature_14": "<strong>फ़ॉन्ट और ग्लिफ़ प्रबंधक:</strong> उपयोग किए गए वर्णों का विश्लेषण करने और फ़ॉन्ट में लापता ग्लिफ़ खोजने के लिए टूल।",
  "li_feature_15": "<strong>विज़ुअल डीबगिंग:</strong> त्वरित डीबगिंग के लिए पदानुक्रम में आइकन और सीन व्यू में लेबल।",
  "li_feature_2": "<strong>किसी भी एसेट का स्थानीयकरण:</strong> स्प्राइट, ऑडियो, प्रीफ़ैब, मटीरियल, आदि का प्रबंधन करें।",
  "li_feature_3": "<strong>शक्तिशाली ट्रांसलेशन एडिटर:</strong> एक केंद्रीकृत इंटरफ़ेस जिसमें ऑटो-सेव, पूर्ण Undo/Redo समर्थन, स्मार्ट की ग्रुपिंग, और मल्टी-सेलेक्शन एक्शन शामिल हैं।",
  "li_feature_4": "<strong>AI और मशीन ट्रांसलेशन:</strong> प्रोफ़ाइल सिस्टम जो DeepL, Google, Microsoft, और <strong>कस्टम AI (OpenAI, Gemini, Claude, Ollama)</strong> को कॉन्टेक्स्ट अवेयरनेस के साथ सपोर्ट करता है।",
  "li_feature_5": "<strong>लचीला आयात/निर्यात:</strong> CSV, XML, YAML, XLIFF के लिए समर्थन, और गूगल शीट्स से सीधा आयात।",
  "li_feature_6": "<strong>लाइव प्रीव्यू:</strong> गेम चलाए बिना सीन व्यू या <strong>प्रीफ़ैब मोड</strong> में किसी भी भाषा का प्रीव्यू करें।",
  "li_feature_7": "<strong>बहुवचन और लिंग समर्थन:</strong> पूर्ण CLDR समर्थन (v43). इसमें नियम शामिल हैं: <strong>एशियाई</strong> (कोई नहीं), <strong>अंग्रेज़ी/जर्मनिक</strong> (One, Other), <strong>फ़्रेंच</strong> (One 0-1), <strong>स्लाविक</strong> (One, Few, Many - RU, UK, PL), <strong>अरबी</strong>, <strong>सेल्टिक</strong>, <strong>बाल्टिक</strong> (LT, LV), और अधिक।",
  "li_feature_8": "<strong>पूर्ण RTL समर्थन:</strong> दाएं-से-बाएं भाषाओं का सही प्रदर्शन।",
  "li_feature_9": "<strong>लाइव अपडेट:</strong> गेम शुरू होने पर एक रिमोट सर्वर से अप-टू-डेट अनुवाद लोड करें।",
  "li_feature_tool_translation": "<strong>पूरी तरह से अनूदित UI:</strong> टूल का इंटरफ़ेस स्थानीयकरण योग्य है। आप <strong>Main Window header</strong> में ड्रॉपडाउन का उपयोग करके एडिटर भाषा बदल सकते हैं।",
  "li_font_global": "<strong>ग्लोबल रिपोर्ट:</strong> सभी भाषाओं में सभी गायब ग्लिफ़्स की रिपोर्ट बनाता है।",
  "li_font_glyph_analyze": "सभी अनुवादों का विश्लेषण करता है और जाँचता है कि क्या असाइन किया गया फ़ॉन्ट (TMP_FontAsset) सभी उपयोग किए गए वर्णों का समर्थन करता है।",
  "li_font_glyph_copy": "फ़ॉन्ट एटलस जनरेशन के लिए सभी यूनिक भाषा अक्षरों को कॉपी करने की अनुमति देता है। टेक्सचर स्पेस को ऑप्टिमाइज़ करने के लिए <strong>ASCII, नंबर, और पंक्चुएशन को बाहर करने वाले फ़िल्टर</strong> शामिल हैं।",
  "li_font_glyph_missing": "लापता ग्लिफ़ की एक सूची दिखाता है।",
  "li_font_glyph_workflow": "<strong>TMP के लिए कार्यप्रवाह:</strong> 1. स्कैन चलाएँ। 2. लापता ग्लिफ़ वाली एक भाषा का चयन करें। 3. <strong>'Copy Character Set'</strong> पर क्लिक करें। 4. Window -> TextMeshPro -> Font Asset Creator खोलें। 5. आपके गेम को ठीक उसी वर्णों वाले एटलस को जेनरेट करने के लिए क्लिपबोर्ड को 'Character Sequence (Custom Range)' फ़ील्ड में पेस्ट करें।",
  "li_font_unicode": "<strong>यूनिकोड रेंजेज़:</strong> अपने अनुवादों में उपयोग किए गए विशिष्ट यूनिकोड रेंजेज़ (जैसे Basic Latin, Cyrillic) देखें ताकि फ़ॉन्ट एसेट्स को ऑप्टिमाइज़ किया जा सके।",
  "li_footer_status": "<strong>स्थिति और प्रगति:</strong> पार्सिंग, इम्पोर्टिंग, या AI जेनरेशन कार्यों पर रीयल-टाइम फीडबैक।",
  "li_header_lang_selector": "<strong>एडिटर भाषा:</strong> टूल के इंटरफ़ेस भाषा को बदलें। टूल UI पूरी तरह से स्थानीयकृत किया जा सकता है।",
  "li_header_preview_btn": "<strong>प्रिव्यू टॉगल:</strong> इन-एडिटर प्रिव्यू को जल्दी से सक्षम या अक्षम करें। मूल सीन मानों को पुनर्स्थापित करने के लिए 'Revert' बटन का उपयोग करें।",
  "li_header_toolbar_buttons": "<strong>ग्लोबल टूलबार:</strong> डॉक्यूमेंटेशन, डिस्कॉर्ड, सेटिंग्स एसेट, डिपेंडेंसी चेकर, और रिव्यू पेज तक सीधा पहुंच।",
  "li_install_1": "<strong>महत्वपूर्ण (v2.0 अपडेट):</strong> यदि आप v1.x से अपग्रेड कर रहे हैं, तो आपको इम्पोर्ट करने से पहले पुराने `Ankonoanko` फ़ोल्डर को <strong>हटाना ही होगा</strong>। संस्करण 2.0 को नेमस्पेस बदलावों के कारण साफ़ इंस्टॉलेशन की आवश्यकता है।",
  "li_install_2": "टूल स्वचालित रूप से आवश्यक निर्भरताओं की जाँच करेगा। दिखाई देने वाले डायलॉग बॉक्स में इंस्टॉलेशन की पुष्टि करें।",
  "li_install_3": "बुनियादी कार्यक्षमता के लिए आवश्यक निर्भरताएँ (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) ज़रूरी हैं।",
  "li_install_4": "वैकल्पिक निर्भरताएँ (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) अतिरिक्त सुविधाओं को सक्षम करती हैं।",
  "li_install_5": "अनुशंसित पैकेजों को स्थापित करने के लिए <strong>Install Selected</strong> पर क्लिक करें।",
  "li_install_6": "इंस्टॉलेशन के बाद, <strong>Tools -> Localization Tool</strong> मेनू के माध्यम से मुख्य टूल विंडो खोलें।",
  "li_install_7": "यदि आप एसिंक्रोनस एसेट लोडिंग का उपयोग करने की योजना बना रहे हैं, तो पैकेज मैनेजर के माध्यम से <strong>Addressables</strong> पैकेज स्थापित करें।",
  "li_live_updates_1": "<strong>सक्षम करें:</strong> Settings में, 'Enable Live Updates' को चेक करें।",
  "li_live_updates_2": "<strong>स्रोत:</strong> एक <code>Live Update URL</code> प्रदान करें जो JSON डिक्शनरी लौटाता हो, या एक <code>Google Sheet URL</code>।",
  "li_live_updates_3": "<strong>कैश:</strong> अनुवाद स्थानीय रूप से <code>liveUpdateCachePath</code> पर कैश किए जाते हैं ताकि गेम ऑफ़लाइन भी काम करे।",
  "li_live_updates_4": "<strong>सुरक्षा:</strong> यदि आपके सर्वर को प्रमाणीकरण की आवश्यकता है तो <strong>Runtime API Key</strong> (एन्क्रिप्टेड) का उपयोग करें।",
  "li_localizedtext_1": "<code>localizationKey</code>: अनुवाद खोजने के लिए उपयोग की जाने वाली कुंजी। यह ऑटो-जनरेटेड या मैन्युअली असाइन की जा सकती है।",
  "li_localizedtext_2": "<code>isStyleOnly</code>: यदि <code>true</code> है, तो कंपोनेंट केवल स्टाइल्स (फ़ॉन्ट, RTL) लागू करेगा लेकिन टेक्स्ट स्वयं नहीं बदलेगा। यह डायनामिक टेक्स्ट एलिमेंट्स (जैसे स्क्रिप्ट में `_()` कॉल्स द्वारा अपडेट किया गया टेक्स्ट) के लिए महत्वपूर्ण है।",
  "li_localizedtext_3": "<code>originalSourceText</code>: आधार भाषा में मूल टेक्स्ट। फ़ॉलबैक के रूप में उपयोग किया जाता है।",
  "li_localizedtext_key_override": "<strong>मैन्युअल कुंजी ओवरराइड:</strong> आप कुंजी के बगल में 'Edit' आइकन पर क्लिक करके मैन्युअल रूप से कुंजी दर्ज कर सकते हैं। स्वचालित जनरेशन पर वापस जाने के लिए 'X' का उपयोग करें। यह <code>LocalizedText</code>, <code>LocalizedDropdown</code> (प्रत्येक विकल्प के लिए अलग-अलग) और <code>UITKLocalization</code> के लिए काम करता है।",
  "li_localizedtext_search_key": "<strong>टेबल में खोजें:</strong> मैग्नीफ़ाइंग ग्लास आइकन पर क्लिक करें ताकि तुरंत ट्रांसलेशन टेबल खुल जाए और उस विशिष्ट कुंजी पर फोकस हो।",
  "li_migration_csv_details_1": "<strong>स्मार्ट फ़िल्टरिंग:</strong> इम्पोर्टर स्वचालित रूप से उन पंक्तियों को स्किप करता है जो एसेट पाथ जैसी दिखती हैं (जैसे <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>) ताकि आपका टेक्स्ट डेटाबेस साफ़ रहे।",
  "li_migration_csv_details_2": "<strong>'Type' कॉलम:</strong> यदि 'Type' कॉलम मौजूद है (I2 फ़ॉर्मेट), तो केवल 'Text' के रूप में चिह्नित या खाली टाइप वाली पंक्तियों को इम्पोर्ट किया जाता है। एसेट्स इम्पोर्ट करने के लिए, माइग्रेशन प्रोफ़ाइल्स का उपयोग करके उन्हें <code>LocalizedAsset</code> में मैप करें।",
  "li_migration_csv_req_1": "<strong>की कॉलम:</strong> इसका नाम <code>Key</code> (केस-इंसेंसिटिव) होना चाहिए या आपके माइग्रेशन प्रोफ़ाइल में परिभाषित होना चाहिए।",
  "li_migration_csv_req_2": "<strong>भाषा कॉलम:</strong> कोई भी कॉलम जो इग्नोर नहीं किया गया है, उसे भाषा कोड (जैसे 'en', 'ja', 'English') माना जाता है। टूल इनको आपके प्रोजेक्ट की भाषाओं से फज़ी-मैच करने की कोशिश करता है।",
  "li_migration_csv_req_3": "<strong>टिप्पणियाँ:</strong> <code>Desc</code>, <code>Description</code>, या <code>Comment</code> नाम वाले कॉलम डेवलपर नोट्स के रूप में आयात किए जाते हैं। यह सूची <strong>Migration Profile</strong> में कॉन्फ़िगर की जा सकती है।",
  "li_migration_custom_1": "Project View में राइट-क्लिक करें -> Create -> Anko Localization -> Migration Profile.",
  "li_migration_custom_2": "<strong>नियम:</strong> रूपांतरण नियम परिभाषित करें (यदि [Source Component] के साथ [Context Filter] है, तो [Target Component] में बदलें)। नियम <strong>Priority</strong> (उच्च संख्याएँ पहले प्रोसेस होती हैं), <strong>Harvest Assets</strong> (स्वचालित रूप से Sprites या Audio जैसे रेफ़रेंस्ड एसेट्स निकालते और रजिस्टर करते हैं), और <strong>Context Filtering</strong> को समर्थन देते हैं ताकि एक ही ऑब्जेक्ट पर कई कंपोनेंट्स को अलग किया जा सके।",
  "li_migration_fallback_keys": "<strong>फ़ॉलबैक की फ़ील्ड्स:</strong> लेगेसी कॉम्पोनेन्ट्स से कीज़ निकालते समय जांचने के लिए अतिरिक्त फ़ील्ड नाम निर्दिष्ट करें। उपयोगी यदि आपका पुराना सिस्टम कीज़ के लिए गैर-मानक प्रॉपर्टी नामों का उपयोग करता है।",
  "li_migration_gs_1": "<strong>एक्सेस:</strong> शीट को साझा किया जाना चाहिए ('Anyone with the link can view') या वेब पर प्रकाशित किया जाना चाहिए।",
  "li_migration_gs_2": "<strong>शीट टैब्स (GID):</strong> URL में <code>gid=...</code> पैरामीटर शामिल होना चाहिए। यह टूल को बताता है कि कौन सा टैब पढ़ना है (उदाहरण के लिए, <code>gid=0</code> आमतौर पर पहला टैब/शीट होता है)।",
  "li_migration_ignored_headers": "<strong>अनदेखे CSV हेडर्स:</strong> इम्पोर्ट के दौरान स्किप किए जाने वाले कॉलम परिभाषित करें (जैसे, 'Type', 'Description')। यह टूल को मेटाडेटा कॉलम को भाषा डेटा के रूप में मानने से रोकता है।",
  "li_migration_legacy_components": "<strong>अतिरिक्त लेगेसी कॉम्पोनेन्ट्स:</strong> टूल को माइग्रेशन स्कैन के दौरान 'लेगेसी' के रूप में पहचानने के लिए कंपोनेंट नाम मैन्युअली सूचीबद्ध करें, भले ही कोई प्रत्यक्ष रूपांतरण नियम परिभाषित न हो।",
  "li_migration_profile_details": "<strong>उन्नत प्रोफ़ाइल सेटिंग्स:</strong><ul><li><code>CsvKeyHeader</code>: Key कॉलम के लिए हेडर नाम।</li><li><code>CsvCommentHeaders</code>: डेवलपर नोट्स/टिप्पणियों के रूप में मानने के लिए हेडर की सूची।</li><li><code>IgnoredCsvHeaders</code>: स्किप करने के लिए कॉलम (जैसे 'Type' या 'Status' मेटाडेटा) ताकि उन्हें भाषाओं के रूप में न माना जाए।</li><li><code>AssetExtensions</code>: स्कैनिंग के दौरान एसेट्स के रूप में पहचाने जाने वाले फ़ाइल प्रकार।</li><li><code>FallbackKeyFields</code>: यदि प्राथमिक कुंजी फ़ील्ड खाली है तो जांचने के लिए अतिरिक्त फ़ील्ड नाम।</li></ul>",
  "li_migration_rule_fields": "<strong>नियम कॉन्फ़िगरेशन:</strong><ul><li><code>Priority</code>: उच्च मान पहले प्रोसेस होते हैं। विशिष्ट मामलों को सामान्य मामलों से पहले संभालने के लिए इसका उपयोग करें।</li><li><code>Context Filter</code>: केवल तभी नियम लागू करें जब समान ऑब्जेक्ट पर एक विशिष्ट कंपोनेंट (जैसे <code>Text</code>) मौजूद हो।</li><li><code>Harvest Assets</code>: यदि सक्षम है, तो लेगेसी कंपोनेंट से वर्तमान एसेट (जैसे Sprite) निकालता है और एसेट टेबल में रजिस्टर करता है।</li><li><code>Asset Field Path</code>: हर्वेस्टिंग के लिए एसेट रेफ़रेंस वाले फ़ील्ड का पाथ।</li><li><code>Additional Data Path</code>: ड्रॉपडाउन जैसे जटिल कंपोनेंट्स के लिए कई मान/विकल्प हर्वेस्ट करने के लिए उपयोग किया जाता है।</li></ul>",
  "li_migration_stubs_1": "<strong>समस्या:</strong> आप पुराने प्लगइन एसेट्स को डिलीट कर देते हैं। Unity गायब स्क्रिप्ट्स (जैसे <code>Localize</code> कंपोनेंट गायब) का पता लगाता है। एडिटर कंपाइलेशन एरर मोड में चला जाता है।",
  "li_migration_stubs_2": "<strong>Solution:</strong> 'Emergency Stubs' फीचर हल्के, खाली क्लासेस बनाता है जिनके नाम और नेमस्पेस पुराने प्लगइन के बिल्कुल समान होते हैं। यह कंपाइलर को संतुष्ट करता है।",
  "li_migration_stubs_3": "<strong>कार्यप्रवाह:</strong> 1. क्लिक करें <strong>Enable Emergency Stubs</strong> (यह आपके प्रोजेक्ट सेटिंग्स में <code>ANKO_ENABLE_MIGRATION_STUBS</code> जोड़ता है)। 2. पुराने प्लगइन फ़ोल्डर को हटाएँ। 3. Unity नकली क्लासेज़ का उपयोग करके सफलतापूर्वक पुनः संकलित होता है। 4. <strong>Component Converter</strong> चलाएँ ताकि स्टब्स को आधिकारिक कंपोनेंट्स से बदल सकें। 5. रिफैक्टरिंग पूर्ण होने पर <strong>Disable Stubs</strong> पर क्लिक करें।",
  "li_migration_tool_converter": "<strong>चरण 2: घटक कनवर्टर:</strong> सीन और प्रीफ़ैब स्कैन करें। स्वचालित रूप से पुराने घटकों (उदाहरण के लिए, <code>Localize</code>) को <code>LocalizedText</code> / <code>LocalizedAsset</code> से बदलता है, कुंजियाँ स्थानांतरित करता है।",
  "li_migration_tool_fields": "<strong>Profile Settings:</strong> कॉन्फ़िगर करने योग्य 'Source Plugin' प्रकार और 'Asset Mapping' नियम टेक्सचर और ऑडियो का सही ट्रांसफ़र सुनिश्चित करते हैं।",
  "li_migration_tool_import": "<strong>चरण 1: डेटा आयात:</strong> एक कुंजी डेटाबेस बनाने के लिए CSV (I2) या XLIFF (Unity Loc) फ़ाइलें आयात करें।",
  "li_migration_tool_profiles": "<strong>Migration Profiles:</strong> कस्टम प्रोफ़ाइल बनाएँ ताकि 3rd पार्टी प्लगइन्स (I2, Unity Loc) से एसेट्स और सेटिंग्स को मैप किया जा सके।",
  "li_migration_tool_safemode": "<strong>सेफ़ मोड और इमरजेंसी स्टब्स:</strong> कंपोनेंट्स को हटाने के बजाय अक्षम किया जाता है। इसमें महत्वपूर्ण <strong>Emergency Stubs</strong> फीचर शामिल है (जो <code>ANKO_ENABLE_MIGRATION_STUBS</code> डिफ़ाइन सिंबल द्वारा सक्रिय होता है): I2 Localization या Unity Localization के लिए नकली प्लेसहोल्डर क्लासेज़ बनाता है ताकि प्लगइन्स हटाने के बाद आपका प्रोजेक्ट तुरंत कम्पाइल हो सके। यह \"The type name 'Localize' could not be found\" त्रुटियों को रोकता है और आपको नया सिस्टम उपयोग करने के लिए कोड को सही ढंग से रीफ़ैक्टर करने का समय देता है। Enable Stubs आपको पुराने लोकलाइज़ेशन प्लगइन को हटाने के बाद कम्पाइलेशन त्रुटियों को ठीक करने की अनुमति देता है।",
  "li_migration_tool_setup": "<strong>चरण 0: सेटअप:</strong> घटक नामों को कॉन्फ़िगर करें (उदाहरण के लिए, I2 के लिए <code>Localize</code>) और फ़ील्ड जहाँ कुंजी संग्रहीत है। प्रीसेट उपलब्ध हैं।",
  "li_migration_workflow_1": "<strong>1. Backup:</strong> शुरू करने से पहले अपने प्रोजेक्ट को स्रोत नियंत्रण (Git) में कमिट करें या फ़ाइल बैकअप बनाएं।",
  "li_migration_workflow_2": "<strong>2. Enable Stubs:</strong> माइग्रेशन टूल खोलें -> 'Safe Mode' टैब। अपने लक्ष्य सिस्टम (I2/UnityLoc) के लिए <strong>Enable Emergency Stubs</strong> पर क्लिक करें। यह आपके प्रोजेक्ट में हल्के नकली क्लासेस बनाता है।",
  "li_migration_workflow_3": "<strong>3. Remove Old Plugin:</strong> पुराने प्लगइन फ़ोल्डर को हटाएँ (जैसे, 'Assets/Plugins/I2')। Unity पुनः संकलित होगा। स्टब्स की वजह से, आपको <strong>NOT</strong> 'Type not found' त्रुटियाँ नहीं मिलेंगी, और सभी कंपोनेंट रेफ़रेंसेज़ प्रीफ़ैब्स पर संरक्षित रहेंगी।",
  "li_migration_workflow_4": "<strong>4. Import Data:</strong> 'Import Data' टैब में, अपना Source CSV/XLIFF लोड करें। प्रीव्यू सत्यापित करें और <strong>Import</strong> पर क्लिक करें। यह AnKo अनुवाद तालिकाओं को भरता है।",
  "li_migration_workflow_5": "<strong>5. Convert Components:</strong> 'Component Converter' टैब में, 'Entire Project' चुनें और <strong>Scan & Convert</strong> पर क्लिक करें। टूल पुराने स्टब्स को 'LocalizedText'/'LocalizedAsset' कंपोनेंट्स से बदलता है, और कुंजियों को ट्रांसफ़र करता है।",
  "li_migration_workflow_6": "<strong>6. Cleanup:</strong> जब सब कुछ काम कर रहा हो, <strong>Disable Stubs</strong> पर क्लिक करें और Unity को फिर से पुनः संकलित होने दें।",
  "li_notes_1": "<strong>बैकअप:</strong> बड़े बदलावों से पहले हमेशा <strong>Translation Table Editor -> Manage Backups</strong> के माध्यम से बैकअप बनाएँ। बैकअप <code>LocalizationBackups</code> फ़ोल्डर में **प्रोजेक्ट रूट पर (Assets फ़ोल्डर के बाहर)** संग्रहीत होते हैं ताकि आपके यूनिटी प्रोजेक्ट को साफ रखा जा सके और आयात के समय को कम किया जा सके।",
  "li_notes_2": "<strong>API कुंजी सुरक्षा:</strong> संपादक में काम करने के लिए कुंजी आपकी मशीन पर स्थानीय रूप से संग्रहीत होती है (<code>EditorPrefs</code> में) और रिपॉजिटरी में नहीं जाती है। गेम बिल्ड में आवश्यक कुंजियों के लिए, <strong>Runtime API Key</strong> अनुभाग का उपयोग करें।",
  "li_notes_3": "<strong><code>StreamingAssets</code> फ़ोल्डर:</strong> अनुवाद फ़ाइलें गेम बिल्ड में शामिल होने के लिए <code>Assets/StreamingAssets/</code> के एक सबफ़ोल्डर में होनी चाहिए।",
  "li_notes_4": "<strong>\"फूल-प्रूफिंग\":</strong> टूल स्वचालित रूप से आपको प्रीव्यू मोड से अस्थायी डेटा को गलती से सीन या प्रीफ़ैब में सहेजने से बचाता है।",
  "li_notes_5": "<strong>प्रदर्शन:</strong> <code>_()</code> कॉल तेज़ है, लेकिन हर फ़्रेम में चलने वाले लूप में (जैसे, <code>Update</code> में), परिणाम को एक वेरिएबल में कैश करने का प्रयास करें।",
  "li_notes_6": "<strong><code>LanguageSelector</code> को पार्सिंग से बाहर करना:</strong> <code>LanguageSelector</code> घटक और उसके <code>TMP_Dropdown</code> वाले ऑब्जेक्ट को <strong>Content</strong> टैब में <strong>Ignore Specific Objects</strong> सूची में जोड़ा जाना चाहिए। यह आवश्यक है ताकि पार्सर ड्रॉपडाउन विकल्पों के लिए अतिरिक्त कुंजियाँ बनाने से बच सके, क्योंकि <code>LanguageSelector</code> स्क्रिप्ट उन्हें रनटाइम पर गतिशील रूप से पॉप्युलेट करती है। नज़रअंदाज़ करने से विरोधों को रोका जाता है और अनुवाद फ़ाइलों को साफ रखा जाता है।",
  "li_notes_7": "<strong><code>LanguageSelector</code> के लिए फ़ॉन्ट:</strong> <code>TMP_Dropdown</code> में चयनित भाषा के लिए अपने फ़ॉन्ट को सही ढंग से अपडेट करने के लिए, ड्रॉपडाउन के चाइल्ड <strong>Label</strong> ऑब्जेक्ट में मैन्युअल रूप से एक खाली <code>LocalizedText</code> घटक जोड़ें और <code>isStyleOnly</code> बॉक्स को चेक करें।",
  "li_notes_addressables_code": "<strong>कोड और Addressables:</strong> यदि आप <strong>Addressables (Async)</strong> मोड पर स्विच करते हैं, तो आपको अपनी स्क्रिप्ट्स में <code>GetLocalizedAssetAsync<T>()</code> का उपयोग करना **चाहिए**। सिंक्रोनस <code>GetLocalizedAsset<T>()</code> को कॉल करने से null वापस आएगा और मुख्य थ्रेड फ्रीज को रोकने के लिए एक चेतावनी लॉग होगी।",
  "li_notes_addressables_sync_warning": "<strong>सिंक बनाम एसिंक:</strong> यदि आप <strong>Addressables (Async)</strong> मोड पर स्विच करते हैं, तो आपको अपने कोड को <code>GetLocalizedAssetAsync<T>()</code> का उपयोग करने के लिए अपडेट करना **चाहिए**। सिंक्रोनस मेथड को कॉल करने से null वापस आएगा और मुख्य थ्रेड को फ्रीज होने से बचाने के लिए एक चेतावनी लॉग होगी।",
  "li_preview_1": "<strong>यह कैसे काम करता है:</strong> सूची से एक भाषा का चयन करें, और टूल सक्रिय सीन या खोले गए प्रीफ़ैब में सभी स्थानीयकरण योग्य ऑब्जेक्ट्स पर तुरंत संबंधित अनुवाद, फ़ॉन्ट, RTL सेटिंग्स, और एसेट्स लागू करेगा।",
  "li_preview_2": "<strong>प्लेसहोल्डर:</strong> यदि <strong>Settings</strong> टैब में एक प्लेसहोल्डर स्टाइल (जैसे, <strong>Accents</strong> या <strong>Brackets</strong>) का चयन किया जाता है, तो ये प्लेसहोल्डर वास्तविक अनुवादों के बजाय प्रीव्यू मोड में प्रदर्शित किए जाएंगे। यह लेआउट का परीक्षण करने और गैर-स्थानीयकृत तत्वों को खोजने के लिए आदर्श है।",
  "li_preview_3": "<strong>सुरक्षा:</strong> प्रीव्यू मोड में किए गए सभी परिवर्तन अस्थायी होते हैं। जब आप \"<strong>Revert to Original</strong>\" का चयन करते हैं, विंडो बंद करते हैं, सीन बदलते हैं, या किसी सीन/प्रीफ़ैब को सहेजने से पहले (<code>LocalizationPreviewProtector</code> घटक के कारण) टूल स्वचालित रूप से सब कुछ अपनी मूल स्थिति में वापस ला देगा।",
  "li_preview_4": "<strong>क्रैश सुरक्षा:</strong> सिस्टम प्रीव्यू करने से पहले सीन की स्थिति का स्वचालित रूप से <code>Library</code> फ़ोल्डर में बैकअप लेता है। यदि यूनिटी क्रैश हो जाता है या आप प्रीव्यू करते समय बलपूर्वक बंद कर देते हैं, तो टूल अगले लॉन्च पर रिकवरी फ़ाइल का पता लगाता है और मूल सीन स्थिति को पुनर्स्थापित करने की पेशकश करता है।",
  "li_preview_overlay_1": "<strong>Access:</strong> ओवरले स्वचालित रूप से Scene View में दिखाई देता है। आप इसे Unity Overlay मेनू (<code>Space</code> कुंजी Scene View में) के माध्यम से टॉगल कर सकते हैं।",
  "li_preview_overlay_2": "<strong>Functionality:</strong> मुख्य विंडो खोले बिना वर्तमान Preview Language को जल्दी बदलने के लिए एक ड्रॉपडाउन प्रदान करता है।",
  "li_report_1": "<strong>श्रेणियाँ:</strong> सभी कुंजियाँ, जोड़ी गईं, अपडेट की गईं (टेक्स्ट बदला गया), हटाई गईं, डुप्लिकेट, माइग्रेट की गईं, छोड़ दी गईं (अपरिवर्तित)।",
  "li_report_2": "<strong>उन्नत खोज:</strong> प्रोजेक्ट में संबंधित ऑब्जेक्ट को तुरंत खोजने के लिए किसी भी एंट्री के बगल में <strong>Find</strong> बटन पर क्लिक करें। खोज एसिंक्रोनस रूप से काम करती है, संपादक को ब्लॉक नहीं करती है, और सभी सीन और प्रीफ़ैब में खोज करती है।",
  "li_report_all_keys": "<strong>सभी कुंजियाँ:</strong> प्रोजेक्ट में पहचानी गई सभी लोकलाइज़ेशन कुंजियों की सूची, जिसमें खोज और फ़िल्टरिंग विकल्प शामिल हैं।",
  "li_report_btn_clear": "<strong>रिपोर्ट साफ़ करें:</strong> वर्तमान सत्र की मेमोरी से सभी स्कैन परिणाम हटाता है।",
  "li_report_btn_copy_all": "<strong>सभी कुंजियाँ कॉपी करें:</strong> वर्तमान श्रेणी में सभी लोकलाइज़ेशन कुंजियों को सिस्टम क्लिपबोर्ड पर कॉपी करता है।",
  "li_report_btn_load_last": "<strong>आखिरी स्कैन लोड करें:</strong> पुनः स्कैन किए बिना सबसे हालिया प्रोजेक्ट विश्लेषण के परिणाम तुरंत पुनर्स्थापित करता है।",
  "li_report_btn_save": "<strong>रिपोर्ट सहेजें:</strong> वर्तमान स्कैन परिणामों को बाहरी दस्तावेज़ीकरण या ऑडिटिंग के लिए टेक्स्ट या CSV फ़ाइल में निर्यात करता है।",
  "li_report_source_filter": "<strong>स्रोत फ़िल्टर:</strong> उनके मूल के आधार पर परिणाम को संकीर्ण करें (जैसे, केवल स्क्रिप्ट्स, सीन, या Prefabs में पाए गए कुंजियों को दिखाएँ)।",
  "li_safety_global_limit": "<strong>Global Monthly Limit:</strong> <code>monthlyCharLimit</code> (डिफ़ॉल्ट: 500,000 अक्षर) सभी अनुरोधों के लिए सर्किट ब्रेकर के रूप में कार्य करता है। आप <code>enableApiLimitWarning</code> के माध्यम से चेतावनियों को टॉगल कर सकते हैं।",
  "li_safety_profile_limit": "<strong>Profile Limits:</strong> प्रत्येक Translation Profile अपने 'Max Chars Per Request' और 'Batch Size' को सेट करने की अनुमति देता है।",
  "li_settings_1": "<strong>कुंजी जनरेशन मोड:</strong> आपके टेक्स्ट के लिए अद्वितीय पहचानकर्ता बनाने की रणनीति निर्धारित करता है:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(डिफ़ॉल्ट - अनुशंसित)</strong>: सीन/Prefab नाम और ऑब्जेक्ट पदानुक्रम के आधार पर कुंजियों को जनरेट करता है (उदाहरण: <code>scene_Menu_BtnPlay_682412</code>)। बड़े प्रोजेक्ट्स के लिए सबसे अच्छा है क्योंकि यह अद्वितीयता सुनिश्चित करता है और टेक्स्ट परिवर्तन से अप्रभावित रहता है।</li><li><code>UseTextAsKey</code>: स्रोत टेक्स्ट को स्वयं कुंजी के रूप में उपयोग करता है (उदाहरण: \"Start Game\" → <code>Start Game</code>)। तेज़ प्रोटोटाइपिंग के लिए आदर्श जहाँ कुंजियों को मानव‑पठनीय होना चाहिए।</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(हाइब्रिड)</strong>: सबसे लचीला मोड। यह पहले जांचता है कि क्या किसी कंपोनेंट में पहले से मैन्युअल रूप से असाइन की गई कुंजी या <code>[LocalizableField(key=\"...\")]</code> है। यदि कोई कुंजी नहीं है, तो यह एक पदानुक्रमित कुंजी जनरेट करता है। मौजूदा कार्य को संरक्षित रखते हुए नई सामग्री को स्वचालित करने के लिए इसका उपयोग करें।</li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(हाइब्रिड)</strong>: ऊपर जैसा ही, लेकिन यदि कोई मैन्युअल कुंजी नहीं मिलती है तो टेक्स्ट स्वयं पर वापस लौटता है। मौजूदा कंपोनेंट्स और डेटा का सम्मान करता है।</li><li><code>Manual</code>: स्कैनर कभी नई कुंजियाँ नहीं बनाता। यह केवल उन ऑब्जेक्ट्स को अपडेट करता है जिनमें पहले से ही कुंजी के साथ लोकलाइज़ेशन कंपोनेंट मौजूद है। सख्त मैन्युअल नियंत्रण के लिए उपयुक्त।</li></ul>",
  "li_settings_10": "<strong>देव टूल:</strong> सेटिंग्स टैब के निचले भाग में, आप उपयोगिता बटन पा सकते हैं जैसे <strong>Clear Saved Language Pref</strong> (PlayerPrefs में सहेजी गई भाषा को रीसेट करता है ताकि गेम फिर से Default भाषा के साथ शुरू हो सके)।",
  "li_settings_11": "<strong>तकनीकी ड्रॉपडाउन विकल्प:</strong> स्ट्रिंग मानों की एक सूची (डिफ़ॉल्ट: 'Option A', 'Option B', 'Option C') जिसे पार्सर ड्रॉपडाउन को स्कैन करते समय **नज़रअंदाज़** करेगा। यह आपकी अनुवाद तालिका को यूनिटी के डिफ़ॉल्ट UI प्लेसहोल्डर टेक्स्ट से साफ रखता है।",
  "li_settings_2": "<strong>भाषा प्रबंधन:</strong><ul><li><strong>Source Language:</strong> आपकी यूनिटी सीन/प्रीफ़ैब (विकास भाषा) में उपयोग की जाने वाली भाषा।</li><li><strong>Default Language:</strong> यदि उपयोगकर्ता की सिस्टम भाषा समर्थित नहीं है, तो पहले गेम लॉन्च पर चुनी गई भाषा।</li><li><strong>सूची:</strong> समर्थित भाषाओं का प्रबंधन करें, विशिष्ट <strong>Font Assets</strong> असाइन करें, और <strong>RTL</strong> समर्थन सक्षम करें।</li></ul>",
  "li_settings_3": "<strong>सामान्य सेटिंग्स:</strong> प्रोजेक्ट-व्यापी व्यवहार के लिए कॉन्फ़िगरेशन:<ul><li><code>Translations Save Path</code>: .json अनुवाद फ़ाइलों को संग्रहीत करने के लिए रूट डायरेक्टरी। गेम में एक्सेस के लिए, इसे Assets/Resources या Assets/StreamingAssets के अंदर होना चाहिए।</li><li><code>Safe Mode</code>: एक सुरक्षा परत जो प्रोजेक्ट में असंगतियों या गायब डिपेंडेंसीज़ का पता चलने पर ऑपरेशन्स (जैसे Auto-Translate) को ब्लॉक कर देती है।</li><li><code>Remove Missing Keys</code>: यदि सक्षम है, तो स्कैनर प्रोजेक्ट अपडेट के दौरान डेटाबेस से उन एंट्रीज़ को स्वचालित रूप से हटा देगा जो अब किसी सीन या Prefab में मौजूद नहीं हैं।</li><li><code>Parse Inactive Objects</code>: निर्धारित करता है कि टूल को निष्क्रिय या छिपे हुए GameObjects को स्कैन और लोकलाइज़ करना चाहिए या नहीं।</li><li><code>Parse All Prefabs</code>: प्रोजेक्ट में प्रत्येक Prefab को स्कैन करता है। यदि अक्षम है, तो केवल Content टैब में निर्दिष्ट फ़ोल्डरों में मौजूद Prefabs प्रोसेस होते हैं।</li><li><code>Fill Comments By Paths</code>: स्वचालित रूप से अनुवाद तालिका में 'Comment' फ़ील्ड को ऑब्जेक्ट के सीन/Prefab पदानुक्रम पाथ से भरता है।</li><li><code>Split Files by Language</code>: अनुवाद डेटाबेस को कई फ़ाइलों में विभाजित करता है (जैसे, en.json, ja.json)। बड़े प्रोजेक्ट्स में रनटाइम मेमोरी ओवरहेड कम करने के लिए अत्यधिक अनुशंसित।</li><li><code>Allow Empty Source/Keys</code>: टूल को उन ऑब्जेक्ट्स को रजिस्टर और ट्रैक करने की अनुमति देता है भले ही उनका स्रोत टेक्स्ट खाली हो। कोड द्वारा विशेष रूप से सेट किए गए डायनेमिक टेक्स्ट के लिए उपयोगी।</li><li><code>Attach to Regex-Ignored Text</code>: टूल को उन ऑब्जेक्ट्स में लोकलाइज़ेशन कंपोनेंट जोड़ने के लिए मजबूर करता है जिनका टेक्स्ट एक एक्सक्लूज़न regex (जैसे संख्याएँ) से मेल खाता है, जिससे मैन्युअल ओवरराइड संभव हो सके।</li><li><code>Find Settings Asset</code>: एक यूटिलिटी बटन जो तुरंत LocalizationSettings.asset फ़ाइल को पिंग करता है और आपके प्रोजेक्ट विंडो में चयन करता है।</li></ul>",
  "li_settings_4": "<strong>डिबगिंग और टेस्टिंग:</strong><ul><li><code>Placeholder Style</code>: प्रिव्यू मोड में प्लेसहोल्डर दिखाने के लिए स्टाइल चुनें।</li><li><code>Pseudo-Localization</code>: <strong>'Custom Pseudo'</strong> चुनें ताकि उन्नत लेआउट टेस्टिंग सेटिंग्स (Expansion Factor, Accents, और Delimiters) दिख सकें।</li></ul>",
  "li_settings_5": "<strong>लाइव अपडेट:</strong> रिमोट सर्वर से अनुवाद लोड करने के लिए सेटिंग्स।",
  "li_settings_6": "<strong>Runtime API Key:</strong> आपके API कुंजी को <strong>Live Updates</strong> (गेम में नई अनुवादों को प्राप्त करना) के लिए सुरक्षित रूप से संग्रहीत करता है। यह एडिटर में उपयोग की जाने वाली Translation Service कुंजियों से अलग है। बिल्ड में कुंजी <strong>obfuscated</strong> (एन्क्रिप्टेड) होती है ताकि स्ट्रिंग सर्च से आसान एक्सट्रैक्शन रोका जा सके, लेकिन याद रखें: कोई भी क्लाइंट-साइड सीक्रेट 100% सुरक्षित नहीं है।",
  "li_settings_7": "<strong>Asset Loading Strategy:</strong> <code>Resources (Legacy)</code>, <code>Addressables (Async)</code>, और <code>Custom</code> में से चयन। चेतावनी: इस मोड को बदलने के लिए प्रोजेक्ट को पुनः स्कैन करना आवश्यक है। मोबाइल और WebGL के लिए मेमोरी उपयोग कम करने हेतु Addressables मोड अत्यधिक अनुशंसित है।",
  "li_settings_8": "<strong>ऑटो-ट्रांसलेशन:</strong> AI‑ड्रिवेन लोकलाइज़ेशन के लिए <strong>Translation Profiles</strong> सिस्टम का उपयोग करता है। कॉन्फ़िगरेशन में शामिल है:<ul><li><code>Text & Audio Profiles</code>: विभिन्न सेवाओं (जैसे OpenAI, DeepL, Google) को कॉन्फ़िगर करने के लिए ScriptableObject प्रोफाइल्स चुनें या बनाएं।</li><li><code>Presets Folder</code>: वह डायरेक्टरी जहाँ आपके ट्रांसलेशन प्रिसेट और प्रोफाइल्स संग्रहीत होते हैं।</li><li><code>Target Languages</code>: सभी प्रोजेक्ट भाषाओं की सूची, जिसमें वास्तविक समय स्थिति, प्रोग्रेस बार, और चयनित प्रोफ़ाइल के लिए कैरेक्टर काउंट शामिल हैं।</li><li><code>Start Auto Translation</code>: निर्दिष्ट प्रोफ़ाइल्स का उपयोग करके सभी चयनित भाषाओं के लिए प्रक्रिया शुरू करता है।</li></ul>",
  "li_settings_9": "<strong>डिबगिंग सुधार:</strong><ul><li><code>Show Hierarchy Icons</code>: हायरार्की में स्थिति आइकन्स (हरा टिक / पीला चेतावनी) दिखाता है। <strong>परफ़ॉर्मेंस ऑप्टिमाइज़्ड:</strong> कैशिंग का उपयोग करके बड़े सीन में भी शून्य लैग सुनिश्चित करता है।</li><li><code>Show Scene View Labels</code>: सीन व्यू में सीधे विज़ुअल डिबगिंग। लेबल्स इंटरैक्टिव हैं: किसी भी सीन लेबल पर राइट‑क्लिक करके तुरंत लोकलाइज़ेशन कुंजी को क्लिपबोर्ड में कॉपी करें।</li></ul>",
  "li_settings_asset_folder_rule": "<strong>फ़ोल्डर स्ट्रक्चर नियम:</strong> स्थानीयकृत एसेट्स जनरेट करते समय सबफ़ोल्डर्स की संरचना को परिभाषित करता है (उदाहरण: <code>{lang}/{category}</code>)।",
  "li_settings_bridge_name": "<strong>ब्रिज क्लास नाम:</strong> उत्पन्न स्थैतिक क्लास का नाम अनुकूलित करने की अनुमति देता है (डिफ़ॉल्ट है <code>AnkoLoc</code>)।",
  "li_settings_general_safe_mode": "<strong>सेफ़ मोड:</strong> सुनिश्चित करता है कि यदि कोई ऑपरेशन प्रोजेक्ट की असंगत स्थिति पैदा कर सकता है तो वह आगे नहीं बढ़ेगा।",
  "li_settings_lang_culture_fallback": "<strong>संस्कृति फ़ॉलबैक उपयोग करें:</strong> यदि कोई विशिष्ट क्षेत्रीय बोली (जैसे <code>en‑AU</code>) अनुपलब्ध है, तो टूल बेस भाषा (<code>en</code>) का उपयोग करने का प्रयास करेगा, फिर <strong>Default Language</strong> पर फ़ॉलबैक करेगा।",
  "li_settings_lang_follow_system": "<strong>सिस्टम भाषा का पालन करें:</strong> पहली लॉन्च पर खिलाड़ी के OS भाषा के अनुसार गेम भाषा को स्वचालित रूप से बदलता है।",
  "li_settings_live_updates_security": "<strong>Security:</strong> रनटाइम API कुंजियों को बिल्ड में एन्क्रिप्ट (AES) किया जाता है ताकि आकस्मिक एक्सट्रैक्शन रोका जा सके। हमेशा HTTPS उपयोग करें।",
  "li_settings_pseudo_accents": "<strong>एक्सेंट्स उपयोग करें:</strong> मानक अक्षरों को एक्सेंटेड संस्करणों (जैसे <code>å</code>, <code>é</code>) से बदलता है। यह सुनिश्चित करने के लिए उपयोग करें कि आपके फ़ॉन्ट सभी आवश्यक ग्लिफ़्स को सपोर्ट करते हैं।",
  "li_settings_pseudo_brackets": "<strong>ब्रैकेट्स जोड़ें:</strong> टेक्स्ट को <code>[ ]</code> में लपेटता है ताकि स्थानीयकृत स्ट्रिंग्स की शुरुआत और अंत की पुष्टि हो सके, जिससे टेक्स्ट ट्रंकेशन या कंकैटनेशन समस्याओं की पहचान में मदद मिलती है।",
  "li_settings_pseudo_expand_length": "<strong>लंबाई बढ़ाएँ:</strong> जर्मन या रूसी जैसी भाषाओं में सामान्य टेक्स्ट विस्तार का सिमुलेशन करता है, अंत में अतिरिक्त अक्षर जोड़कर।",
  "li_settings_pseudo_expansion_factor": "<strong>विस्तार कारक:</strong> टेक्स्ट लंबाई सिमुलेशन के लिए गुणक (उदाहरण: 2.0 टेक्स्ट को दो गुना लंबा बना देगा)।",
  "li_settings_pseudo_prefix": "<strong>कस्टम प्रीफ़िक्स:</strong> प्रत्येक स्थानीयकृत टेक्स्ट की शुरुआत में एक विशिष्ट स्ट्रिंग (जैसे <code>PSEUDO‑</code>) जोड़ें।",
  "li_settings_pseudo_suffix": "<strong>कस्टम सफ़िक्स:</strong> प्रत्येक स्थानीयकृत टेक्स्ट के अंत में एक विशिष्ट स्ट्रिंग जोड़ें।",
  "li_settings_return_source": "<strong>यदि गायब हो तो स्रोत लौटाएँ:</strong> यदि सक्षम है, तो वर्तमान भाषा के लिए कोई अनुवाद न मिलने पर सिस्टम स्रोत भाषा में टेक्स्ट (या स्वयं कुंजी) लौटाएगा।",
  "li_settings_tms_timeout": "<strong>TMS टाइमआउट:</strong> बाहरी TMS सेवाओं के नेटवर्क अनुरोधों के लिए अधिकतम प्रतीक्षा समय (सेकंड में) निर्दिष्ट करता है।",
  "li_settings_tool_check_deps": "<strong>डिपेंडेंसीज़ जांचें:</strong> आवश्यक पैकेज (जैसे Newtonsoft) और वैकल्पिक इंटीग्रेशन के लिए प्रोजेक्ट को पुनः स्कैन करता है।",
  "li_settings_tool_cleanup": "<strong>पूर्ण प्रोजेक्ट क्लीनअप:</strong> एक विनाशकारी टूल जो प्रोजेक्ट से सभी Anko Localization कंपोनेंट्स और डेटा को हटा देता है (सावधानी से उपयोग करें!).",
  "li_settings_tool_clear_prefs": "<strong>भाषा प्रेफ़रेंसेज़ साफ़ करें:</strong> PlayerPrefs में सहेजी गई भाषा को रीसेट करता है, जिससे अगली लॉन्च पर गेम डिफ़ॉल्ट या सिस्टम भाषा का उपयोग करेगा।",
  "li_settings_tool_font_manager": "<strong>फ़ॉन्ट मैनेजर:</strong> फ़ॉन्ट और ग्लिफ़ मैनेजर खोलता है ताकि गायब अक्षरों का विश्लेषण किया सके और अनुकूलित फ़ॉन्ट एसेट्स जनरेट किए जा सकें।",
  "li_settings_tool_migration": "<strong>माइग्रेशन टूल:</strong> I2 Localization या Unity Localization से डेटा और कंपोनेंट्स को स्थानांतरित करने में सहायता करता है।",
  "li_settings_tool_test_center": "<strong>लोकलाइज़ेशन टेस्ट सेंटर:</strong> प्रोजेक्ट स्वास्थ्य की जाँच, टूटे रेफ़रेंसेज़ की जांच, और लोकलाइज़ेशन इंटेग्रिटी सुनिश्चित करने के लिए एक डायग्नोस्टिक टूल।",
  "li_setup_1": "<strong>सेटिंग्स बनाएँ:</strong> पहली बार खोलने पर, टूल <code>Assets/Resources</code> फ़ोल्डर में एक <code>LocalizationSettings.asset</code> फ़ाइल बनाएगा।",
  "li_setup_2": "<strong>भाषाएँ और मोड कॉन्फ़िगर करें:</strong> Settings टैब में, सुनिश्चित करें कि आपका <strong>Source Language</strong> सही है। साथ ही, <strong>Key Generation Mode</strong> की जाँच करें (डिफ़ॉल्ट <code>AutoGenerateKeysOnly</code> है, जो अधिकांश प्रोजेक्ट्स के लिए अनुशंसित है)।",
  "li_setup_3": "<strong>पार्सिंग के लिए सामग्री निर्दिष्ट करें:</strong> <strong>Content</strong> टैब में, विश्लेषण के लिए सभी सीन को <strong>Scenes to Parse</strong> सूची में जोड़ें। यदि आप टेक्स्ट के साथ प्रीफ़ैब का उपयोग करते हैं, तो सुनिश्चित करें कि उनके फ़ोल्डर <strong>Prefab Folders</strong> में जोड़े गए हैं।",
  "li_setup_4": "<strong>पहला पार्सर रन:</strong> <strong>Actions</strong> टैब पर जाएँ और <code>Update Keys</code> बटन पर क्लिक करें। टूल आपके प्रोजेक्ट को स्कैन करेगा, अनुवाद फ़ाइलें बनाएगा, और गेम ऑब्जेक्ट्स में आवश्यक घटक (<code>LocalizedText</code>, <code>LocalizedAsset</code>, आदि) को स्वचालित रूप से जोड़ देगा।",
  "li_setup_5": "<strong>सेटिंग्स और बिल्ड (महत्वपूर्ण):</strong> टूल स्वचालित रूप से <code>LocalizationSettings.asset</code> को <code>Project Settings -> Player -> Preloaded Assets</code> में जोड़ता है। <br>⚠️ <strong>सुरक्षा जाँच:</strong> यदि सेटिंग्स Preloaded Assets से गायब हैं और Resources फ़ोल्डर में नहीं हैं, तो टूल गेम को शुरू होने पर क्रैश होने से रोकने के लिए <code>BuildFailedException</code> के साथ <strong>बिल्ड को ब्लॉक कर देगा</strong>।",
  "li_sidebar_presets": "<strong>सर्च प्रिसेट्स:</strong> सामान्य कार्यों जैसे अनूदित न किए गए स्ट्रिंग्स या गायब प्लेसहोल्डर्स वाली कुंजियों को खोजने के लिए पूर्वनिर्धारित फ़िल्टर।",
  "li_sidebar_search": "<strong>ग्लोबल सर्च:</strong> आपके प्रोजेक्ट की सभी तालिकाओं में विशिष्ट कुंजियों या टेक्स्ट की खोज।",
  "li_tms_crowdin": "<strong>Crowdin:</strong> प्रोजेक्ट आईडी और एपीआई कुंजी की आवश्यकता होती है। स्रोत XLIFF अपलोड करने और अनुवाद को ZIP आर्काइव के रूप में डाउनलोड करने का समर्थन करता है। <em>उन्नत:</em> <code>File Name</code> (Crowdin में लक्ष्य पथ)।",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> एपीआई कुंजी की आवश्यकता होती है। छोटे प्रोजेक्ट्स के लिए सरल और तेज़ एकीकरण। <em>उन्नत:</em> <code>Import/Export Params</code> (अतिरिक्त Loco एपीआई फ़्लैग जैसे <code>&tag=v1</code> या <code>&status=translated</code> जोड़ने की अनुमति देता है)।",
  "li_tms_phrase": "<strong>Phrase:</strong> एंटरप्राइज़-ग्रेड स्थानीयकरण प्रबंधन। <em>उन्नत:</em> <code>Update Translations/Descriptions</code> फ़्लैग्स जो नियंत्रित करते हैं कि Phrase अपलोड पर मौजूदा डेटा को ओवरराइट करे या नहीं।",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> संगठन/प्रोजेक्ट स्लग और एपीआई टोकन प्रमाणीकरण का समर्थन करता है। <em>उन्नत:</em> <code>Resource Slug</code> (यदि संसाधन मौजूद नहीं है तो स्वचालित रूप से बनाता है)।",
  "li_tutorials_1": "<strong>इंटरैक्टिव लर्निंग:</strong> गाइड्स विशिष्ट UI तत्वों को हाइलाइट करते हैं और आपके कार्यों की प्रतीक्षा करते हैं।",
  "li_tutorials_2": "<strong>उपलब्ध लेसन्स:</strong>",
  "li_tutorials_editor": "<strong>ट्रांसलेशन एडिटर:</strong> स्प्रेडशीट-समतुल्य एडिटर की उन्नत सुविधाएँ।",
  "li_tutorials_list": "<strong>Tutorial List:</strong> टूल की मुख्य विशेषताओं के लिए इंटरैक्टिव गाइड्स तक पहुँचें।",
  "li_tutorials_migration": "<strong>माइग्रेशन:</strong> अन्य लोकलाइज़ेशन सिस्टम्स (I2, Unity Localization) से कैसे माइग्रेट करें।",
  "li_tutorials_quickstart": "<strong>क्विक स्टार्ट:</strong> टेक्स्ट और एसेट्स के लिए बेसिक सेटअप।",
  "li_tutorials_size": "<strong>Tutorial Size:</strong> इंटरैक्टिव गाइड्स का UI स्केल और विस्तार स्तर (कॉम्पैक्ट से एक्स्ट्रा लार्ज) को समायोजित करता है। ट्यूटोरियल्स टैब के हेडर में स्थित है।",
  "li_vis_debug_1": "<strong>Hierarchy Icons:</strong> समस्याओं (Missing Key, Missing Component) को तुरंत पहचानें। शून्य प्रदर्शन प्रभाव के लिए अनुकूलित।",
  "li_vis_debug_2": "<strong>Scene View Labels:</strong> प्रत्येक स्थानीयकृत ऑब्जेक्ट के ऊपर कुंजी दिखाता है। <strong>Right-click</strong> लेबल पर 'Copy Key' या 'Select Object' करने के लिए।",
  "li_vis_debug_3": "<strong>Overlays:</strong> सीन व्यू ओवरले (Space बार) का उपयोग करके प्रीव्यू भाषाओं को तुरंत बदलें।",
  "lightbox_aria_close": "छवि दर्शक बंद करें",
  "lightbox_image_alt": "बढ़ा हुआ दृश्य",
  "mindmap_edge_configure": "1. कॉन्फ़िगर करें",
  "mindmap_edge_creates_components": "घटक बनाता है",
  "mindmap_edge_defines_rules": "नियम परिभाषित करता है",
  "mindmap_edge_edited_in": "में संपादित",
  "mindmap_edge_enables_reaction": "के माध्यम से प्रतिक्रिया सक्षम करता है",
  "mindmap_edge_extends": "विस्तार करता है",
  "mindmap_edge_generates": "जनरेट करता है",
  "mindmap_edge_manages_assets": "एसेट्स का प्रबंधन करता है",
  "mindmap_edge_opens": "खोलता है",
  "mindmap_edge_parse_project": "3. प्रोजेक्ट पार्स करें",
  "mindmap_edge_processed_by": "द्वारा संसाधित",
  "mindmap_edge_recommends_for": "के लिए अनुशंसा करता है",
  "mindmap_edge_relates_to": "से संबंधित है",
  "mindmap_edge_reports_on": "पर रिपोर्ट करता है",
  "mindmap_edge_see_faq": "सामान्य प्रश्न देखें",
  "mindmap_edge_specify_content": "2. सामग्री निर्दिष्ट करें",
  "mindmap_edge_warns_about": "के बारे में चेतावनी देता है",
  "mindmap_node_ai_ecosystem": "एआई पारिस्थितिकी तंत्र",
  "mindmap_node_async_code": "असिंक्रोनस / एड्रेसेबल्स",
  "mindmap_node_dev_tools": "उपकरण और उपयोगिताएँ",
  "mindmap_node_tms_integration": "टीएमएस एकीकरण",
  "mindmap_preset_ai": "एआई और स्वचालन",
  "mindmap_preset_dev": "डेवलपर कार्यप्रवाह",
  "mindmap_preset_full": "पूर्ण दृश्य",
  "mindmap_preset_quick_start": "त्वरित शुरुआत",
  "mindmap_preset_tools": "उपकरण और एकीकरण",
  "mindmap_preset_translator": "अनुवादक कार्यप्रवाह",
  "mindmap_toggle_title": "माइंड मैप दिखाएँ",
  "my_notes_title": "मेरे नोट्स",
  "no_notes_message_new": "एक नोट जोड़ने के लिए टेक्स्ट पर होवर करें।",
  "notes_add_title": "इस ब्लॉक में एक नोट जोड़ें",
  "notes_close_title": "बंद करें",
  "notes_delete_title": "नोट हटाएँ",
  "notes_edit_text": "संपादित करें",
  "notes_edit_title": "नोट संपादित करें",
  "notes_goto_title": "टेक्स्ट पर जाएँ",
  "notes_placeholder": "आपका नोट...",
  "on_this_page_title": "इस पृष्ठ पर",
  "p_actions_1": "मुख्य कार्य टैब।",
  "p_ai_assistant": "अनुवाद तालिका संपादक में, अब आप संदर्भ मेनू (राइट-क्लिक -> AI: ...) के माध्यम से चयनित सेल पर कस्टम AI कमांड चला सकते हैं।",
  "p_ai_audio_economy": "<strong>लागत बचत:</strong> टूल आपके टेक्स्ट के MD5 हैश की गणना करता है और यदि स्रोत टेक्स्ट बदल गया है तो ही ऑडियो फ़ाइलों को पुन: जेनरेट करता है, जिससे आपके API क्रेडिट्स की बचत होती है। यदि आप कोई अनुवाद बदलते हैं, तो सिस्टम केवल उस विशिष्ट ऑडियो फ़ाइल को 'Outdated' के रूप में फ़्लैग करता है। केवल वही पुन: जेनरेट करने के लिए 'Generate Missing/Outdated' का उपयोग करें जो बदला है, जिससे API क्रेडिट्स की बचत होती है। टूल आपके टेक्स्ट को हैश करता है और यदि स्रोत टेक्स्ट बदल गया है तो ही ऑडियो फ़ाइलों को पुन: जेनरेट करता है, स्मार्ट बैचिंग के माध्यम से आपके API क्रेडिट्स की बचत होती है।",
  "p_ai_context": "अनुवाद की गुणवत्ता में सुधार के लिए, AI को अब अतिरिक्त संदर्भ प्राप्त होता है:",
  "p_ai_intro": "टूल <strong>Translation Profile</strong> सिस्टम (ScriptableObject) का उपयोग करता है। यह अनुवाद सेवा सेटिंग्स को व्यक्तिगत प्रोफ़ाइल एसेट्स में रखता है, जिससे आप कॉन्फ़िगरेशन को आसानी से बदल सकते हैं।",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code> रनटाइम स्थानीयकरण प्रबंधन के लिए एक मजबूत एपीआई प्रदान करता है। नीचे वे प्रमुख मेथड्स हैं जो आप अपनी स्क्रिप्ट्स में उपयोग करेंगे।",
  "p_assets_1": "यह टैब पूरी तरह से गैर-टेक्स्ट संसाधनों को स्थानीयकृत करने के लिए समर्पित है।",
  "p_async_api": "Addressables का उपयोग करते समय, एसेट्स तुरंत लोड नहीं होते हैं। फ्रेम ड्रॉप्स को रोकने के लिए आपको असिंक्रोनस एपीआई का उपयोग करना चाहिए।",
  "p_bridge_description": "टूल में की एक्सेस के लिए एक स्टैटिक क्लास जेनरेटर शामिल है, जिससे आप मैजिक स्ट्रिंग्स की बजाय स्ट्रॉन्गली टाइप्ड रेफ़रेंसेज़ का उपयोग कर सकते हैं। यह टाइपो को रोकने में मदद करता है और IDE ऑटोकम्प्लीशन को सक्षम करता है।",
  "p_bridge_usage_title": "उपयोग उदाहरण:",
  "p_components_intro": "ये घटक सीन में आपकी वस्तुओं और अनुवाद डेटाबेस के बीच \"पुल\" हैं। वे भाषा परिवर्तनों के लिए \"सुनते\" हैं और सही टेक्स्ट या एसेट को स्वचालित रूप से प्रतिस्थापित करते हैं।",
  "p_content_1": "यहाँ आप टूल को बताते हैं कि वास्तव में टेक्स्ट कहाँ खोजना है। बेहतर उपयोगिता के लिए इंटरफ़ेस को पूरी तरह से पुनर् डिज़ाइन किया गया है।",
  "p_custom_ai": "<strong>Custom AI</strong> सेवा प्रकार आपको REST API के माध्यम से किसी भी LLM को कनेक्ट करने की अनुमति देता है।",
  "p_custom_asset_provider_1": "एक कस्टम प्रोवाइडर विकसित करने से आप अपने स्वयं के एसेट मैनेजमेंट सिस्टम (जैसे, एक कस्टम क्लाउड लोडर, एक विशिष्ट आंतरिक बंडलिंग सिस्टम, या डेटाबेस-चालित एसेट रिपॉजिटरी) को सीधे लोकलाइज़ेशन वर्कफ़्लो में एकीकृत कर सकते हैं।",
  "p_custom_asset_provider_intro": "Asset Provider सिस्टम यह सारांशित करता है कि एसेट्स (स्प्राइट्स, ऑडियो, Prefabs, आदि) रनटाइम पर कैसे लोड होते हैं। यह एक <strong>Plugin Registry</strong> का उपयोग करता है जो स्वचालित रूप से किसी भी क्लास इम्प्लीमेंटेशन को खोजता है जो <code>IAssetProvider</code> को <code>[AssetProviderPlugin]</code> एट्रिब्यूट के साथ चिह्नित करता है। यह कस्टम लोडिंग सिस्टम (जैसे क्लाउड लोडर या आंतरिक बंडलिंग) को कोर टूलकिट को संशोधित किए बिना सहज एकीकरण की अनुमति देता है।",
  "p_custom_attributes_description": "फ़ंक्शन कॉल्स के अतिरिक्त, आप अपने स्क्रिप्ट्स में किसी भी स्ट्रिंग फ़ील्ड को कस्टम एट्रिब्यूट्स का उपयोग करके लोकलाइज़ेबल चिह्नित कर सकते हैं। डिफ़ॉल्ट रूप से, टूल <code>[LocalizableField]</code> को पहचानता है, लेकिन आप किसी भी एट्रिब्यूट नाम (जैसे <code>[Header]</code> या <code>[Tooltip]</code>) को <strong>Attributes to Scan</strong> सूची में जोड़ सकते हैं।",
  "p_custom_parser_1": "आप अपनी खुद की पार्सर क्लास बनाकर कस्टम घटकों का समर्थन करने के लिए सिस्टम का आसानी से विस्तार कर सकते हैं।",
  "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong> के माध्यम से खुलता है। यह अनुवादों को मैन्युअल रूप से संपादित करने के लिए मुख्य टूल है।",
  "p_example_attribute_1": "स्क्रिप्ट वेरिएबल्स को स्थानीयकृत करने का सबसे शक्तिशाली तरीका। यह <strong>private, protected, and public</strong> फ़ील्ड्स के साथ काम करता है। पार्सर पुनरावर्ती रूप से <strong>Arrays, Lists</strong>, और <strong>Nested Serializable Classes</strong> को संभालता है। यह अन्य एट्रिब्यूट्स (जैसे <code>[Header]</code> या <code>[Tooltip]</code>) के लिए भी कुंजियाँ उत्पन्न कर सकता है यदि सेटिंग्स में कॉन्फ़िगर किया गया हो।",
  "p_example_components_1": "प्रोजेक्ट में तैयार स्क्रिप्ट शामिल हैं जो उत्कृष्ट उदाहरण के रूप में काम करती हैं।",
  "p_example_components_updated": "कोड बदल गया है। भाषा लोडिंग (विशेष रूप से Addressables का उपयोग करते समय) अब एसिंक्रोनस है।",
  "p_example_function_1": "गेमप्ले के दौरान बदलने वाले गतिशील टेक्स्ट के लिए <code>_()</code> फ़ंक्शन का उपयोग करें। UI को अपडेट करने वाले मेथड को <code>[OnLanguageChange]</code> एट्रीब्यूट से चिह्नित किया जाना चाहिए ताकि भाषा बदलने पर इसे स्वचालित रूप से कॉल किया जा सके। इस उद्देश्य के लिए ऑब्जेक्ट में एक <code>LocalizedBehaviour</code> घटक स्वचालित रूप से जोड़ा जाएगा।",
  "p_example_plurals_1": "टूल अब विभिन्न भाषा समूहों के लिए अधिक सटीक नियमों का उपयोग करता है।",
  "p_font_glyph_manager_access": "<strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong> के माध्यम से एक्सेस करें।",
  "p_intro_1": "यह टूल यूनिटी में गेम्स और एप्लिकेशन को स्थानीयकृत करने के लिए एक व्यापक समाधान है। यह टेक्स्ट और एसेट्स को इकट्ठा करने, एक शक्तिशाली इंटरफ़ेस के माध्यम से अनुवादों का प्रबंधन करने, मशीन अनुवाद सेवाओं (कस्टम AI सहित) के साथ एकीकृत करने और गेम में स्थानीयकृत सामग्री को गतिशील रूप से अपडेट करने की प्रक्रिया को स्वचालित करता है।",
  "p_live_updates_guide": "लाइव अपडेट्स सिस्टम आपके गेम को रनटाइम पर रिमोट सर्वर या गूगल शीट से नई अनुवाद प्राप्त करने की अनुमति देता है, बिना नए बिल्ड की आवश्यकता के।",
  "p_localizedasset_1": "भाषा के आधार पर एसेट्स को स्वैप करने के लिए उपयोग किया जाता है। स्वचालित रूप से घटक प्रकार का पता लगाता है। समर्थन करता है: <ul><li><strong>2D:</strong> स्प्राइट (<code>Image</code>, <code>SpriteRenderer</code>), टेक्सचर (<code>RawImage</code>)।</li><li><strong>ऑडियो/वीडियो:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>।</li><li><strong>3D/एनीमेशन:</strong> <code>MeshFilter</code> (मेष), <code>Renderer</code> (मटीरियल), <code>Animator</code> (कंट्रोलर), <code>PlayableDirector</code> (टाइमलाइन)।</li></ul>",
  "p_localizedasset_2": "<strong>Play on Awake</strong> विकल्प वाले घटकों (जैसे <code>AudioSource</code>, <code>VideoPlayer</code>) के लिए, <code>LocalizedAsset</code> ऑटो-प्ले को सही ढंग से रोकता है, एसेट को स्वैप करता है, और फिर गैर-स्थानीयकृत सामग्री को चलाने से बचने के लिए प्लेबैक शुरू करता है।",
  "p_localizedasset_updated": "घटक अब एसिंक्रोनस लोडिंग का समर्थन करता है। ध्यान दें कि यदि एसेट्स क्लाउड/डिस्क (Addressables) से लोड किए जाते हैं तो भाषा बदलते समय थोड़ी देरी हो सकती है।",
  "p_localizedbehaviour_1": "एक उपयोगिता घटक जो आपकी स्क्रिप्ट्स को भाषा परिवर्तनों पर प्रतिक्रिया करने की अनुमति देता है। यह स्वचालित रूप से <code>[OnLanguageChange]</code> एट्रीब्यूट से चिह्नित मेथड्स को ढूंढता है और कॉल करता है।",
  "p_localizeddropdown_1": "<code>Dropdown</code> और <code>TMP_Dropdown</code> में उनके विकल्पों का अनुवाद करने के लिए जोड़ा गया।",
  "p_localizedprefab_1": "संपूर्ण प्रीफ़ैब को स्थानीयकृत करने के लिए एक घटक। यह गैर-विनाशकारी रूप से काम करता है: यह मूल प्रीफ़ैब को संशोधित नहीं करता है बल्कि स्थानीयकृत संस्करण का एक इंस्टेंस चाइल्ड ऑब्जेक्ट के रूप में बनाता है, मूल ऑब्जेक्ट पर सभी स्क्रिप्ट (<code>MonoBehaviour</code>), रेंडरर (<code>Renderer</code>), और कोलाइडर (<code>Collider</code>) को अक्षम कर देता है। यह दोहरी लॉजिक निष्पादन और विज़ुअल कलाकृतियों को रोकता है। सही रनटाइम ऑपरेशन के लिए, इसकी निष्पादन क्रम को -100 पर सेट किया जाता है (<code>[DefaultExecutionOrder(-100)]</code>) यह सुनिश्चित करने के लिए कि यह अन्य स्क्रिप्ट से पहले चलता है।",
  "p_localizedtext_1": "अनुवादित टेक्स्ट प्रदर्शित करने के लिए मुख्य घटक। इसे <code>Text</code>, <code>TMP_Text</code>, और <code>TextMesh</code> वाले ऑब्जेक्ट्स पर रखा जाता है।",
  "p_migration_custom": "आप कस्टम सिस्टम या विशिष्ट प्रोजेक्ट सेटअप का समर्थन करने के लिए अपने स्वयं के माइग्रेशन प्रोफ़ाइल बना सकते हैं। प्रत्येक प्रोफ़ाइल में <strong>Rules</strong> की एक सूची होती है जो परिभाषित करती है कि घटकों और उनके फ़ील्ड्स को कैसे परिवर्तित किया जाना चाहिए। नियमों की जांच उनके <strong>Priority</strong> के क्रम में की जाती है।",
  "p_migration_custom_advanced": "माइग्रेशन प्रोफ़ाइल इम्पोर्ट और डिटेक्शन प्रक्रिया को फाइन-ट्यून करने के लिए उन्नत सेटिंग्स प्रदान करती हैं:",
  "p_migration_google_sheet": "आप फ़ाइलें डाउनलोड किए बिना सीधे गूगल शीट URL से इम्पोर्ट कर सकते हैं।",
  "p_migration_import_csv": "टूल मानक CSV फ़ाइलों (कॉमा-सेपरेटेड) को सपोर्ट करता है। पहली पंक्ति हेडर होनी चाहिए।",
  "p_migration_stubs": "माइग्रेशन के दौरान एक सामान्य समस्या यह है कि पुराना प्लगइन (जैसे I2) हटाने से बिल्ड टूट जाता है, जिससे Unity को माइग्रेशन टूल को स्वयं कंपाइल करने से रोका जाता है।",
  "p_migration_tool_access": "<strong>Tools -> Anko Localization Tool -> Migration Tool</strong> के माध्यम से एक्सेस करें।",
  "p_migration_tool_desc": "अन्य स्थानीयकरण प्रणालियों (I2 Localization, Unity Localization) से संक्रमण के लिए टूल।",
  "p_preview_1": "हेडर के ठीक नीचे <strong>Preview Language</strong> ड्रॉपडाउन सूची है। यह शक्तिशाली सुविधा आपको यह देखने की अनुमति देती है कि गेम चलाए बिना <strong>Scene</strong> विंडो या <strong>Prefab Mode</strong> में स्थानीयकरण किसी भी भाषा में कैसा दिखेगा।",
  "p_preview_overlay": "और भी तेज़ इटरेशन के लिए, आप समर्पित <strong>Localization Preview Overlay</strong> का उपयोग करके सीधे सीन व्यू से भाषाएँ बदल सकते हैं।",
  "p_report_1": "प्रत्येक पार्सिंग के बाद, यह रिपोर्ट आपके स्थानीयकरण स्थिति की पूरी तस्वीर दिखाती है।",
  "p_safety_caps": "अनजाने में उच्च लागत या बड़ी ट्रैफ़िक जांचों को रोकने के लिए:",
  "p_script_parsing_rules_description": "टूल को इस तरह कॉन्फ़िगर किया जा सकता है कि वह कस्टम फ़ंक्शन्स या प्रतिस्पर्धी सिस्टम्स (जैसे I2 Localization) में उपयोग की गई लोकलाइज़ेशन कीज़ को पहचान सके, बिना आपके मौजूदा कोड को बदले। यह स्कैनर द्वारा आपके स्क्रिप्ट्स से कीज़ निकालने के लिए उपयोग किए जाने वाले रेगेक्स पैटर्न को परिभाषित करके हासिल किया जाता है।",
  "p_script_parsing_rules_usage": "<strong>Content</strong> टैब में, <strong>Script Parsing Rules</strong> के तहत, आप ऐसे नियम जोड़ सकते हैं जो आपके विशिष्ट फ़ंक्शन कॉल्स से मेल खाते हों। उदाहरण के लिए, <code>I2.Loc.Get(\"key\")</code> को सपोर्ट करने के लिए, आप एक ऐसा नियम जोड़ सकते हैं जिसमें पैटर्न पैरेंथेसिस के अंदर की स्ट्रिंग को कैप्चर करे।",
  "p_settings_1": "आपका नियंत्रण केंद्र। यहाँ आप संपूर्ण स्थानीयकरण प्रक्रिया के लिए वैश्विक नियम परिभाषित करते हैं।",
  "p_ths_setup": "1. <strong>Actions -> External Services</strong> पर जाएँ।<br>2. अपने सेवा प्रदाता को चुनें।<br>3. API Keys और Project IDs दर्ज करें।<br>4. Settings window में <strong>Push</strong> (Upload Keys) और <strong>Pull</strong> (Download Translations) बटन का उपयोग करें।",
  "p_tms_intro": "यह उपकरण अब लोकप्रिय अनुवाद प्रबंधन प्रणालियों के साथ सिंक्रनाइज़ेशन का समर्थन करता है। आप स्रोत कुंजियों को पुश कर सकते हैं और अनुवादों को सीधे Unity के भीतर पुल कर सकते हैं।",
  "p_tms_setup": "1. <strong>Settings -> TMS Integration</strong> पर जाएँ।<br>2. अपनी सेवा प्रदाता चुनें।<br>3. एपीआई कुंजियों और प्रोजेक्ट आईडी दर्ज करें।<br>4. Settings विंडो में <strong>Push</strong> (कुंजियों को अपलोड) और <strong>Pull</strong> (अनुवाद डाउनलोड) बटन का उपयोग करें।",
  "p_tutorials_1": "ट्यूटोरियल टैब इंटरैक्टिव स्टेप-बाय-स्टेप गाइड्स प्रदान करता है जो आपको Unity एडिटर के भीतर सीधे टूल की सुविधाओं में महारत हासिल करने में मदद करते हैं।",
  "p_uitklocalization_1": "<code>UIDocument</code> वाले ऑब्जेक्ट्स में जोड़ा गया। किसी भी तत्व पर <strong>Labels, Buttons, HelpBox, Foldout, ProgressBar (title), TextField (label & placeholder), DropdownField (label & choices), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), and Tooltips</strong> के स्थानीयकरण का समर्थन करता है। यदि UI Builder में IDs सेट हैं तो पहचानकर्ता नाम बदलने पर भी स्थिर रहते हैं।",
  "p_window_footer": "वर्तमान स्थिति, बैकग्राउंड ऑपरेशन्स की प्रगति, और टूल संस्करण दिखाता है।",
  "p_window_header": "टॉप बार प्रीव्यू कंट्रोल्स और यूटिलिटी टूल्स तक वैश्विक पहुँच प्रदान करता है जो चयनित टैब की परवाह किए बिना बना रहता है।",
  "p_window_sidebar": "साइडबार विभिन्न फ़ंक्शनल टैब्स और ग्लोबल सर्च टूल्स के बीच नेविगेशन को संभालता है।",
  "page_title": "यूनिटी लोकलाइज़ेशन टूल दस्तावेज़ीकरण",
  "q_faq_addressables_1": "मैंने Addressables मोड सक्षम किया, लेकिन एसेट्स लोड नहीं हो रहे हैं। मुझे क्या जाँच करनी चाहिए?",
  "q_faq_addressables_2": "मैं DeepL/Google के लिए समर्थन कैसे जोड़ूँ?",
  "q_faq_addressables_3": "माइग्रेटर I2/UnityLoc को हटाने के बाद संकलन त्रुटियाँ दिखाता है। मैं इसे कैसे ठीक कर सकता हूँ?",
  "q_faq_audio_smart_update": "ऑडियो फ़ाइलों को पुन: जेनरेट करते समय टूल API क्रेडिट्स को कैसे बचाता है?",
  "q_faq_components_1": "LocalizedPrefab कंपोनेंट मूल ऑब्जेक्ट पर MonoBehaviours को डिसेबल कर देता है। यदि मूल ऑब्जेक्ट में ऐसा स्क्रिप्ट है जो Awake() में अन्य ऑब्जेक्ट्स बनाता है या इवेंट्स की सदस्यता लेता है तो क्या होगा?",
  "q_faq_components_2": "यदि मूल प्रीफ़ैब (LocalizedPrefab) में Rigidbody या कोई अन्य भौतिकी घटक है, तो क्या इसे अक्षम कर दिया जाएगा? क्या यह भौतिकी को प्रभावित करेगा यदि स्थानीयकृत प्रीफ़ैब में यह नहीं है?",
  "q_faq_components_3": "LocalizedAsset घटक लक्ष्य घटक नाम को एक स्ट्रिंग (_targetComponentTypeName) के रूप में संग्रहीत करता है। क्या होगा यदि मैं एक कस्टम घटक स्क्रिप्ट का नाम बदलता हूँ या इसे किसी अन्य असेंबली (Assembly Definition) में ले जाता हूँ? क्या LocalizedAsset इसके लिए काम करना बंद कर देगा?",
  "q_faq_components_4": "यदि एक ही GameObject पर दो Image घटक हैं, तो LocalizedAsset को कैसे पता चलेगा कि किसे स्थानीयकृत करना है? क्या यह दोनों के साथ काम करेगा या केवल पहले वाले के साथ जो इसे मिलता है?",
  "q_faq_components_5": "दस्तावेज़ीकरण बताता है कि LocalizedPrefab का निष्पादन क्रम -100 है। क्या होगा यदि मेरे पास -110 के निष्पादन क्रम के साथ एक और स्क्रिप्ट है जो अपने Awake() में LocalizedPrefab द्वारा बनाए गए एक चाइल्ड ऑब्जेक्ट को खोजने की कोशिश करती है? क्या LocalizedPrefab ने समय पर अपना इंस्टेंस इंस्टेंटिएट कर दिया होगा?",
  "q_faq_components_6": "LocalizedText घटक में isStyleOnly विकल्प है। यदि मैं इसे सक्षम करता हूँ और फिर कोड में myLocalizedText.SetFormattedText(\"new_key\") को कॉल करता हूँ, तो क्या टेक्स्ट बदलेगा, या केवल स्टाइल (फ़ॉन्ट/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour स्वचालित रूप से [OnLanguageChange] एट्रीब्यूट वाले मेथड्स को ढूंढता है। क्या यह निजी और संरक्षित मेथड्स को ढूंढेगा, या उन्हें सार्वजनिक होना चाहिए?",
  "q_faq_components_8": "LocalizedAsset घटक Play on Awake को रोकता है। क्या होगा यदि उसी ऑब्जेक्ट पर कोई अन्य स्क्रिप्ट LocalizedAsset ने इसे स्वैप करने से पहले Awake() या Start() में एसेट को एक्सेस करने का प्रयास करती है (उदाहरण के लिए, audioSource.clip.length)? क्या NullReferenceException या पुराने एसेट का उपयोग संभव है?",
  "q_faq_custom_keys_attribute": "क्या मैं [LocalizableField] के बजाय कुंजियों के लिए अपनी खुद की एट्रीब्यूट का उपयोग कर सकता हूँ?",
  "q_faq_custom_provider_1": "मेरे कस्टम प्रोवाइडर सेटिंग्स ड्रॉपडाउन में क्यों नहीं दिख रहा है?",
  "q_faq_editor_1": "प्लेसहोल्डर सत्यापन के लिए किसकी उच्च प्राथमिकता है: टिप्पणी में @placeholders: डायरेक्टिव या स्रोत भाषा टेक्स्ट में पाए गए प्लेसहोल्डर? उदाहरण के लिए, यदि स्रोत टेक्स्ट में {name} है और टिप्पणी @placeholders: {username} कहती है।",
  "q_faq_editor_2": "यदि मैं डायरेक्टिव में टाइपो करता हूँ (उदाहरण के लिए, @placeholders: के बजाय @placeholder:), तो क्या इसे नज़रअंदाज़ कर दिया जाएगा या टूल एक चेतावनी जारी करेगा?",
  "q_faq_editor_3": "ऑटोसेव सिस्टम Backups/AutoSaves फ़ोल्डर में फ़ाइलें बनाता है। क्या सफल मैन्युअल सेव या विंडो बंद करने के बाद ये फ़ाइलें स्वचालित रूप से हटा दी जाएंगी?",
  "q_faq_editor_4": "यदि मैं संपादक में कॉलम की चौड़ाई बदलता हूँ, तो क्या ये सेटिंग्स यूनिटी सत्रों के बीच सहेजी जाएंगी?",
  "q_faq_editor_5": "क्या टेक्स्ट संपादन पॉपअप विंडो (MultiLineEditWindow) इसके भीतर किए गए परिवर्तनों के लिए अपने स्वयं के अनडू/रिडू स्टैक (Ctrl+Z के माध्यम से) का समर्थन करता है?",
  "q_faq_examples_1": "क्या होगा यदि _() फ़ंक्शन में पास किए गए अनाम प्रकार में संपत्ति के नाम स्ट्रिंग में प्लेसहोल्डर से मेल नहीं खाते हैं? उदाहरण के लिए, _(\"Hello, {username}\", new { user_name = \"Bob\" })। क्या कोई त्रुटि होगी, या प्लेसहोल्डर बस बदला नहीं जाएगा?",
  "q_faq_examples_2": "[LocalizableField] एट्रीब्यूट निजी फ़ील्ड के लिए काम करता है। क्या यह स्थिर फ़ील्ड के लिए काम करेगा?",
  "q_faq_examples_3": "यदि मैं [OnLanguageChange] एट्रीब्यूट को पैरामीटर वाले मेथड पर रखता हूँ (उदाहरण के लिए, void UpdateUI(string newLang)), तो क्या होगा? क्या कोई संकलन त्रुटि होगी या रनटाइम चेतावनी?",
  "q_faq_examples_4": "मैं _(\"apple_count\", count) का उपयोग कर रहा हूँ। यदि वर्तमान भाषा के लिए कोई कुंजी apple_count_one नहीं है (count = 1 के लिए), तो सिस्टम कौन सा रूप चुनेगा? क्या यह फ़ॉलबैक के रूप में apple_count_other का उपयोग करेगा?",
  "q_faq_examples_5": "फ़ंक्शन _(\"key\", new { username = \"Alex\" }) एक अनाम प्रकार का उपयोग करता है। क्या यह एक पूर्व-निर्मित Dictionary<string, object> पास करने की तुलना में एक Update() मेथड में लगातार कॉल के साथ कचरा संग्राहक (GC) पर अत्यधिक \"लोड\" नहीं बनाएगा?",
  "q_faq_examples_6": "मेरा [OnLanguageChange] से चिह्नित मेथड कॉल नहीं हो रहा है। क्यों?",
  "q_faq_extending_1": "क्या मेरा कस्टम पार्सर हर Update Keys के बाद स्वचालित रूप से कॉल किया जाएगा? क्या मुझे इसे कहीं पंजीकृत करने की आवश्यकता है, या परियोजना में ITextComponentParser को लागू करने वाली एक क्लास होना ही पर्याप्त है?",
  "q_faq_extending_2": "क्या होगा यदि मेरे कस्टम पार्सर में एक अपवाद होता है? क्या यह पूरी पार्सिंग प्रक्रिया को बाधित करेगा, या टूल अन्य पार्सर के साथ सुरक्षित रूप से जारी रहेगा?",
  "q_faq_installation_1": "क्या होगा यदि मेरे प्रोजेक्ट में पहले से ही किसी अन्य एसेट से com.unity.nuget.newtonsoft-json पैकेज है? क्या निर्भरता इंस्टॉलर इसे अपडेट करने का प्रयास करेगा या इसे नज़रअंदाज़ करेगा?",
  "q_faq_installation_2": "मैंने गलती से \"Skip for Now\" पर क्लिक किया और वैकल्पिक निर्भरताओं (उदाहरण के लिए, CSV समर्थन के लिए) के लिए \"Don't ask again\" चेक किया। मैं उन्हें स्थापित करने के लिए इंस्टॉलर विंडो को फिर से कैसे ला सकता हूँ?",
  "q_faq_installation_3": "टूल ने Assets/Resources में LocalizationSettings.asset फ़ाइल नहीं बनाई। ऐसा क्यों हो सकता है, और क्या मैं इसे Assets -> Create मेनू के माध्यम से मैन्युअल रूप से बना सकता हूँ?",
  "q_faq_installation_4": "क्या मैं LocalizationSettings.asset फ़ाइल को किसी अन्य Resources फ़ोल्डर में ले जा सकता हूँ, उदाहरण के लिए, Assets/MyGame/Resources? क्या टूल इसे तब भी ढूंढेगा?",
  "q_faq_installation_5": "निर्भरता इंस्टॉलर फ्रीज हो गया या एक त्रुटि दी। क्या मैं यूनिटी पैकेज मैनेजर के माध्यम से निर्भरताओं (Newtonsoft Json, Editor Coroutines) को मैन्युअल रूप से स्थापित कर सकता हूँ?",
  "q_faq_notes_1": "दस्तावेज़ीकरण LanguageSelector को नज़रअंदाज़ करने की सूची में जोड़ने की अनुशंसा करता है। यदि मैं ऐसा करना भूल जाता हूँ तो वास्तव में क्या टूट जाएगा? क्या \"Option A, Option B\" के लिए अतिरिक्त कुंजियाँ बनाई जाएंगी?",
  "q_faq_notes_2": "यदि मैं LanguageSelector द्वारा उपयोग किए जाने वाले TMP_Dropdown के अंदर Label पर isStyleOnly चेकबॉक्स सक्षम के साथ एक खाली LocalizedText जोड़ना भूल जाता हूँ, तो क्या फ़ॉन्ट नहीं बदलेगा? यह क्यों आवश्यक है?",
  "q_faq_notes_3": "Update() मेथड में _() को कॉल करने की अनुशंसा नहीं की जाती है। लेकिन क्या होगा यदि मुझे हर फ़्रेम में टेक्स्ट अपडेट करने की आवश्यकता है (उदाहरण के लिए, एक टाइमर)? केवल प्रारूप स्ट्रिंग को कैश करना सबसे अधिक प्रदर्शनकारी तरीका क्या है?",
  "q_faq_tts_voices": "मैं वर्णों को विशिष्ट आवाज़ें कैसे असाइन करूँ?",
  "q_faq_window_actions_1": "यदि बैच ऑटो-अनुवाद के दौरान इंटरनेट कनेक्शन खो जाता है तो क्या होगा? क्या टूल Retry Policy के अनुसार विफल बैच को फिर से प्रयास करेगा, या प्रक्रिया पूरी तरह से बाधित हो जाएगी?",
  "q_faq_window_actions_2": "यदि मैं एक CSV फ़ाइल आयात करता हूँ जिसमें प्रोजेक्ट में पहले से मौजूद कुंजियाँ हैं लेकिन कुछ भाषाओं के लिए खाली मान हैं, तो क्या ये खाली मान मेरे मौजूदा अनुवादों को बदल देंगे या उन्हें नज़रअंदाज़ कर दिया जाएगा?",
  "q_faq_window_actions_3": "\"Danger Zone\" अनुभाग सभी घटकों को हटाने की अनुमति देता है। क्या यह उन प्रीफ़ैब से घटकों को हटा देगा जो Content टैब पर Prefab Folders में निर्दिष्ट नहीं हैं?",
  "q_faq_window_actions_4": "गूगल शीट्स से आयात करते समय, मुझे @placeholders: डायरेक्टिव का उपयोग करके प्लेसहोल्डर सत्यापन के लिए टिप्पणियों कॉलम को कैसे प्रारूपित करना चाहिए?",
  "q_faq_window_actions_5": "क्या टूल एक ही गूगल शीट्स दस्तावेज़ की कई शीट्स से डेटा आयात कर सकता है, या यह केवल प्रति GID एक शीट के साथ काम करता है?",
  "q_faq_window_assets_1": "क्या होगा यदि मेरे पास एक ही कुंजी वाले लेकिन एक ही स्कैन फ़ोल्डर में विभिन्न प्रकार के दो एसेट्स हैं (उदाहरण के लिए, sound_effect_en.mp3 और sound_effect_en.wav)? एसेट तालिका में कौन सा समाप्त होगा?",
  "q_faq_window_assets_2": "यदि मैं Scan Assets & Analyze Project पर क्लिक करता हूँ, और सीन में एक Image ऑब्जेक्ट है जिसके लिए एक स्थानीयकृत स्प्राइट पहले से मौजूद है, लेकिन Image ऑब्जेक्ट में अभी तक LocalizedAsset घटक नहीं है, तो क्या टूल घटक जोड़ेगा और कुंजी को स्वचालित रूप से डालेगा?",
  "q_faq_window_assets_3": "क्या मैं विभिन्न एसेट श्रेणियों के लिए एक ही Naming Rule का उपयोग कर सकता हूँ यदि उनके पास अलग-अलग Scan Folders हैं? क्या इससे विरोध होगा?",
  "q_faq_window_assets_4": "यदि एक स्थानीयकरण योग्य एसेट (उदाहरण के लिए, button_ok_en.png) Scan Folder की रूट में नहीं है, बल्कि एक सबफ़ोल्डर में है, तो क्या स्कैनर इसे ढूंढेगा?",
  "q_faq_window_content_1": "क्या होगा यदि मैं Scenes to Parse में एक सीन जोड़ता हूँ जो Build Settings में शामिल नहीं है? क्या यह पार्सिंग प्रक्रिया के अलावा किसी और चीज़ को प्रभावित करेगा?",
  "q_faq_window_content_2": "मैंने Ignore Specific Objects (अस्थायी सूची) में एक ऑब्जेक्ट जोड़ा। यदि मैं इस ऑब्जेक्ट से एक प्रीफ़ैब बनाता हूँ, तो क्या इस प्रीफ़ैब के इंस्टेंस को भी नज़रअंदाज़ किया जाएगा?",
  "q_faq_window_content_3": "यदि मैं TMPro.TMP_Text घटक को Parsing Ignores -> Ignore Component Types में जोड़ता हूँ, लेकिन सीन में एक ऑब्जेक्ट है जिसमें LocalizedText है जो पहले से ही इस TMP_Text को संदर्भित करता है, तो अगले Update Keys पर क्या होगा? क्या कुंजी हटा दी जाएगी?",
  "q_faq_window_content_4": "दस्तावेज़ीकरण कहता है कि \"Pin\" ऑब्जेक्ट के पूरे पथ को बचाता है और यदि इसका नाम बदला जाता है तो टूट जाएगा। क्या होगा यदि मैं ऑब्जेक्ट से एक प्रीफ़ैब बनाता हूँ और फिर मूल ऑब्जेक्ट का नाम बदलता हूँ - क्या \"Pin\" प्रीफ़ैब इंस्टेंस के लिए काम करना जारी रखेगा?",
  "q_faq_window_content_5": "यदि मैं एक प्रीफ़ैब इंस्टेंस के अंदर एक चाइल्ड ऑब्जेक्ट के लिए \"Pin\" का उपयोग करता हूँ, तो कौन सा पथ सहेजा जाएगा: प्रीफ़ैब रूट के सापेक्ष या सीन रूट के सापेक्ष? क्या यह अन्य सीन में काम करेगा?",
  "q_faq_window_preview_1": "मैंने Prefab Mode में एक प्रीफ़ैब खोला, In-Editor Preview लागू किया, और Ctrl+S दबाया। क्या अस्थायी प्रीव्यू डेटा प्रीफ़ैब एसेट में सहेजा जाएगा? LocalizationPreviewProtector इस मामले को कैसे संभालता है?",
  "q_faq_window_preview_2": "यदि मैं In-Editor Preview सक्षम करता हूँ और यूनिटी एडिटर क्रैश हो जाता है, और Temp/localization_preview_recovery.json फ़ाइल दूषित हो जाती है (उदाहरण के लिए, खाली या अमान्य JSON), तो अगले लॉन्च पर क्या होगा?",
  "q_faq_window_preview_3": "LocalizedPrefab के लिए In-Editor Preview मोड में, एक अस्थायी इंस्टेंस बनाया जाता है। क्या Awake() और Start() मेथड्स इस इंस्टेंस पर निष्पादित होंगे? क्या यह त्रुटियों का कारण बन सकता है यदि उन्हें Edit Mode में चलने के लिए डिज़ाइन नहीं किया गया है?",
  "q_faq_window_report_1": "\"Find\" बटन ऑब्जेक्ट को एसिंक्रोनस रूप से खोजता है। क्या होगा यदि मैं एक खोज शुरू करता हूँ और फिर तुरंत Update Keys पर क्लिक करता हूँ? क्या खोज बाधित होगी?",
  "q_faq_window_report_2": "यदि एक कुंजी का उपयोग कई स्थानों पर किया जाता है (उदाहरण के लिए, विभिन्न सीन में दो अलग-अलग बटनों पर), तो \"Duplicates\" श्रेणी के तहत रिपोर्ट में इसे कैसे प्रदर्शित किया जाएगा?",
  "q_faq_window_report_3": "यदि मैं एक कुंजी के लिए \"Find\" पर क्लिक करता हूँ जिसका उपयोग केवल कोड में किया जाता है (_() फ़ंक्शन के माध्यम से), तो क्या होगा? क्या टूल C# स्क्रिप्ट को ढूंढ और हाइलाइट कर पाएगा?",
  "q_faq_window_settings_1": "मैं प्रोजेक्ट के बीच में Key Generation Mode को UseTextAsKey से AutoGenerateKeysOnly में बदल सकता हूँ। मेरे मौजूदा अनुवादों का वास्तव में क्या होगा? क्या वे नई कुंजियों के लिए मैप किए जाएंगे?",
  "q_faq_window_settings_2": "यदि मैं समर्थित भाषाओं की सूची में एक भाषा को एक कोड के साथ जोड़ता हूँ जिसमें कोई बहुवचन नियम नहीं है (उदाहरण के लिए, कज़ाख के लिए \"kz\"), तो डिफ़ॉल्ट रूप से किस नियम का उपयोग किया जाएगा?",
  "q_faq_window_settings_3": "क्या होगा यदि मैं Translations Path को StreamingAssets में नहीं, बल्कि Assets/MyTranslations जैसे एक नियमित फ़ोल्डर में निर्दिष्ट करता हूँ? क्या json फ़ाइलें गेम बिल्ड में शामिल होंगी?",
  "q_faq_window_settings_4": "ऑटो-अनुवाद एपीआई कुंजी EditorPrefs में संग्रहीत है। यदि मैं दो अलग-अलग कंप्यूटरों पर प्रोजेक्ट पर काम कर रहा हूँ, तो क्या मुझे प्रत्येक मशीन पर कुंजी अलग से दर्ज करनी होगी?",
  "tip_best_practice": "<strong>प्रो टिप:</strong> यदि आपको किसी प्रॉपर्टी को स्थानीयकृत करने की आवश्यकता है, तो `[LocalizableField]` के साथ एक बैकिंग फ़ील्ड बनाएं और प्रॉपर्टी को अलग से उजागर करें।",
  "toc_search_placeholder": "दस्तावेज़ीकरण खोजें...",
  "toc_title": "विषय सूची",
  "toggle_notes_title": "नोट्स टॉगल करें",
  "warning_box_components": "<strong>महत्वपूर्ण नोट:</strong> नीचे वर्णित सभी घटक पार्सिंग के दौरान गेम ऑब्जेक्ट्स में स्वचालित रूप से जोड़े जाते हैं (जब आप <code>Update Keys</code> बटन पर क्लिक करते हैं)। आपको उन्हें मैन्युअल रूप से जोड़ने की आवश्यकता नहीं है।",
  "warning_tms_overwrite": "<strong>चेतावनी:</strong> TMS से पुल करने पर मिलते-जुलते कुंजियों के लिए स्थानीय अनुवाद ओवरराइट हो जाएंगे। सुनिश्चित करें कि आपका TMS एकमात्र सत्य स्रोत है।"
}