{
  "a_faq_addressables_1": "Убедитесь, что пакет Addressables установлен, настройки созданы, и вы нажали \"Scan Assets & Generate Tables\", чтобы зарегистрировать ключи в группах.",
  "a_faq_addressables_2": "Создайте <code>Translation Profile</code> в папке ассетов, выберите тип сервиса, введите ключ API и назначьте этот профиль в окне <code>Settings</code>.",
  "a_faq_addressables_3": "В окне миграции (вкладки Components / Import) есть кнопка \"Enable Stubs\", которая активирует функцию экстренных заглушек (Emergency Stubs). Это создает фиктивные классы-заглушки для I2 Localization или Unity Localization, чтобы ваш проект мог быть скомпилирован сразу после удаления этих плагинов. Функция работает путем переключения символа ANKO_ENABLE_MIGRATION_STUBS. Это предотвращает ошибки \"The type name 'Localize' could not be found\" и дает вам время на правильный рефакторинг кода для использования новой системы. Включение заглушек (Enable Stubs) позволяет исправить ошибки компиляции после удаления старого плагина локализации. В версии 2.0 система миграции была расширена с помощью <strong>профилей миграции</strong>, что позволяет использовать более надежные правила перехода от других плагинов.",
  "a_faq_audio_smart_update": "Инструмент использует умную пакетную обработку с MD5-хешированием для регенерации аудиофайлов, только когда исходный текст изменился. Он рассчитывает MD5-хеш вашего текстового контента и сравнивает его с ранее сгенерированными аудиофайлами. Если текст не изменился, он пропускает регенерацию, экономя ваши кредиты API. Это предотвращает ненужные вызовы API и снижает затраты при регенерации аудио. Инструмент хеширует ваш текст и регенерирует аудиофайлы, только если исходный текст изменился, экономя ваши кредиты API.",
  "a_faq_components_1": "Нет, не будет. Отключение MonoBehaviour предотвращает вызов всех «магических» методов Unity, включая Awake(), OnEnable() и Start(). Это сделано намеренно, чтобы избежать дублирования выполнения логики. Вся инициализация должна происходить в скриптах на локализованных версиях префаба.",
  "a_faq_components_2": "Да, физическое поведение оригинального объекта будет нейтрализовано. Компонент LocalizedPrefab находит все компоненты Rigidbody и Rigidbody2D на своем GameObject и устанавливает их свойство isKinematic в true. Это фактически удаляет их из динамических физических расчетов, предотвращая нежелательное поведение, например, падение невидимого объекта или реакцию на столкновения. По-прежнему рекомендуется, чтобы локализованная версия префаба содержала все необходимые физические компоненты для корректного поведения.",
  "a_faq_components_3": "Да, будет. Компонент сохраняет полное имя типа, включая пространство имён и сборку. Переименование скрипта или перемещение его в другой .asmdef изменит это имя, и LocalizedAsset не сможет найти целевой компонент. Вам потребуется запустить ещё один анализ через Analyze Project & Attach Components, чтобы обновить имя.",
  "a_faq_components_4": "LocalizedAsset создается для конкретного экземпляра компонента. Он хранит ссылку на этот компонент в коде. Если вы вручную добавите второй LocalizedAsset и используете контекстное меню \"Analyze for Localization\", чтобы нацелиться на второй Image, у вас будет два компонента LocalizedAsset, каждый из которых управляет своим Image. Автоматический анализатор создаст компонент только для первого Image с локализуемым ассетом, который он найдет.",
  "a_faq_components_5": "Да, успеет. LocalizedPrefab создает экземпляр локализованного префаба в своем методе OnEnable(). Порядок выполнения Unity гарантирует, что все методы Awake() выполняются до всех методов OnEnable(). Таким образом, ваш скрипт с порядком -110 выполнит свой Awake(), затем LocalizedPrefab с порядком -100 выполнит свой Awake(), и только после этого будут вызваны их методы OnEnable() по порядку. Ваш скрипт не найдет объект, потому что он еще не будет создан.",
  "a_faq_components_6": "Изменится и ключ, и текст. Вызов SetFormattedText программно переопределяет поведение isStyleOnly для этого конкретного обновления. Опция isStyleOnly предназначена для предотвращения реакции компонента на глобальные изменения языка, но он всегда будет реагировать на прямое изменение ключа через код.",
  "a_faq_components_7": "Он будет находить методы с любым модификатором доступа (public, private, protected, internal). Reflection в Unity позволяет обнаруживать все методы экземпляра независимо от их уровня доступа.",
  "a_faq_components_8": "Возможно использование старого (нелокализованного) ассета. LocalizedAsset выполняет подмену в своем OnEnable(). Методы Awake() всех скриптов выполняются до OnEnable(). Если ваш скрипт обращается к audioSource.clip в Awake(), он получит оригинальный клип. Если он обращается к нему в Start(), результат будет зависеть от порядка выполнения скриптов. Чтобы гарантировать доступ к локализованному ассету, либо установите более поздний порядок выполнения для вашего скрипта, либо обращайтесь к ассету в методе, помеченном [OnLanguageChange].",
  "a_faq_custom_keys_attribute": "Да. На вкладке <strong>Content Tab</strong> в разделе 'Attributes to Scan' вы можете добавить любое имя атрибута (например, <code>[Header]</code>, <code>[TermsPopup]</code>). Парсер будет рассматривать любое строковое поле с этим атрибутом как локализуемое.",
  "a_faq_custom_provider_1": "Убедитесь, что ваш класс реализует <code>IAssetProvider</code>, НЕ является абстрактным и помечен атрибутом <code>[AssetProviderPlugin]</code>. Также проверьте консоль на наличие ошибок, связанных с рефлексией, во время запуска, поскольку инструмент сканирует все сборки на предмет поставщиков.",
  "a_faq_editor_1": "Приоритет имеет директива @placeholders: в комментарии. Она считается явной инструкцией от разработчика и «источником истины». В вашем примере редактор будет требовать {username} в переводе и проигнорирует {name} из исходного текста.",
  "a_faq_editor_2": "Она будет просто проигнорирована. Инструмент ищет точное совпадение @placeholders:. Если директива написана с ошибкой, она будет рассматриваться как часть обычного комментария, и валидация будет работать по-старому - на основе заполнителей из исходного текста.",
  "a_faq_editor_3": "Да. При успешном ручном сохранении или нормальном закрытии окна (когда вы сохраняете изменения) все файлы автосохранения удаляются, чтобы избежать запроса на восстановление при следующем запуске. Они остаются только в случае аварийного завершения работы редактора.",
  "a_faq_editor_4": "Да. Ширина столбцов сохраняется в EditorPrefs при каждом закрытии окна редактора переводов и будет восстановлена при следующем открытии.",
  "a_faq_editor_5": "Да. MultiLineEditWindow имеет свой временный стек Undo/Redo, который работает, пока окно открыто. Это позволяет отменять и повторять изменения текста внутри этого окна. Как только вы сохраняете результат (закрывая окно), это изменение записывается как одно действие в глобальный стек Undo/Redo основного редактора.",
  "a_faq_examples_1": "Ошибки не будет. Заполнитель {username} просто не будет заменен, и вы получите строку \"Hello, {username}\" в результате. Замена происходит только при точном совпадении имени.",
  "a_faq_examples_2": "Да, будет. Парсер использует рефлексию для поиска полей с флагами BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, поэтому он найдет и обработает static поля.",
  "a_faq_examples_3": "Ошибки компиляции не будет, но в консоли Unity появится предупреждение от LocalizedBehaviour. Оно сообщит, что нашло метод с атрибутом, но проигнорировало его, потому что метод имеет параметры. Такой метод вызван не будет.",
  "a_faq_examples_4": "Да. Если конкретная форма (_one, _few и т.д.) не найдена, система попытается использовать ключ с суффиксом _other в качестве запасного варианта. Если и он не найден, будет использован перевод для базового ключа apple_count.",
  "a_faq_examples_5": "Да, создаст. Каждый вызов new { ... } выделяет память в управляемой куче, что создает дополнительную работу для сборщика мусора. Для текста, который обновляется каждый кадр (в Update или LateUpdate), значительно более производительно создать Dictionary<string, object> один раз в Start(), а в Update() только обновлять его значения, прежде чем передавать в функцию _().",
  "a_faq_examples_6": "Проверьте, есть ли у вашего метода параметры. Атрибут <code>[OnLanguageChange]</code> работает только для методов <strong>без параметров</strong> (например, <code>void UpdateUI()</code>). Если вашему методу требуются аргументы, оберните его в метод без параметров.",
  "a_faq_extending_1": "Достаточно просто иметь класс. Когда запускается TextParser, он использует рефлексию, чтобы найти все классы в проекте, которые реализуют интерфейс ITextComponentParser, и автоматически вызывает их метод Parse() для каждого GameObject. Ручная регистрация не требуется.",
  "a_faq_extending_2": "Исключение в вашем пользовательском парсере прервет процесс. Основной цикл парсинга не оборачивает вызовы пользовательских парсеров в блок try-catch. Если ваш метод Parse() сгенерирует необработанное исключение,",
  "a_faq_installation_1": "Установщик проверяет наличие типа Newtonsoft.Json.JsonConvert. Если тип существует, он считает зависимость удовлетворенной и не будет пытаться установить или обновить пакет. Это сделано для предотвращения конфликтов версий.",
  "a_faq_installation_2": "Вы можете вручную запустить проверку зависимостей в любое время через меню Tools -> Localization -> Check Dependencies. Это сбросит флаг \"Don't ask again\" и снова покажет окно со всеми отсутствующими необязательными пакетами.",
  "a_faq_installation_3": "Это может произойти, если у вас нет папки Assets/Resources. Инструмент попытается ее создать, но разрешения файловой системы могут этому помешать. Да, вы можете создать ассет вручную: щелкните правой кнопкой мыши в папке Resources, выберите Create -> Localization -> Settings. Инструмент найдет его автоматически.",
  "a_faq_installation_4": "Да. Инструмент использует Resources.Load(), который ищет ассет по имени во всех папках с именем Resources в вашем проекте. Главное, чтобы файл сохранил свое имя LocalizationSettings.asset.",
  "a_faq_installation_5": "Да. Вы можете открыть Window -> Package Manager, нажать иконку \"+\" и выбрать \"Add package by name...\". Введите имена пакетов: com.unity.nuget.newtonsoft-json и com.unity.editorcoroutines.",
  "a_faq_notes_1": "Да. Если вы не добавите LanguageSelector в список игнорирования, парсер будет рассматривать его TMP_Dropdown как обычный выпадающий список. Он найдет стандартные \"Option A, Option B, Option C\", которые создает Unity, и добавит ключи для них в ваши файлы переводов. Это засорит ваши файлы ненужными ключами, поскольку скрипт LanguageSelector все равно удалит эти опции во время выполнения и создаст свои.",
  "a_faq_notes_2": "Да, шрифт не изменится. Это необходимо потому, что LanguageSelector напрямую меняет свойство label.text. Без LocalizedText на этом объекте система локализации не знает, что этому элементу нужно применить стили (шрифт, RTL) при смене языка. Пустой LocalizedText с isStyleOnly служит «маркером» для системы, говорящим: «Следи за этим объектом и применяй к нему стили, но не трогай его текст».",
  "a_faq_notes_3": "Самый производительный подход — кэшировать строку формата в Start() или в методе [OnLanguageChange] и использовать обычный string.Format в Update(). Пример: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Это позволяет избежать поиска ключа в словаре каждый кадр, что значительно быстрее.",
  "a_faq_runtime_api_key_distinction": "<strong>В: В чем разница между 'ключами службы перевода' и 'ключом API для выполнения'?</strong><br>О: <strong>Ключи службы перевода</strong> (OpenAI, DeepL) используются в <strong>редакторе Unity</strong> для создания переводов. Они хранятся в реестре вашего компьютера (EditorPrefs) и НЕ включаются в сборку.<br><strong>Ключ API для выполнения</strong> используется <strong>сборкой игры</strong> для получения Live Updates. Он включается в сборку (зашифрованный).",
  "a_faq_tts_voices": "В вашем <strong>Translation Profile</strong> (Inspector) используйте список 'Voice Mappings'. Вы можете сопоставить шаблон Regex (например, <code>^hero_.*</code>) с конкретным Voice ID. Генератор автоматически выберет правильный голос на основе имени ключа.",
  "a_faq_window_actions_1": "Инструмент попытается повторно отправить именно тот пакет, который завершился неудачей, в соответствии с настройками Retry Policy (количество попыток и задержка). Если все попытки для этого пакета окажутся неудачными, процесс перевода для текущего языка будет прерван, и в консоль будет записана ошибка. Перевод для следующих языков в очереди не начнется.",
  "a_faq_window_actions_2": "Пустые значения заменят существующие переводы. Процесс импорта рассматривает CSV-файл как «источник истины». Если значение для ключа welcome_message в столбце ru пустое, текущий русский перевод для этого ключа будет перезаписан.",
  "a_faq_window_actions_3": "Да, удалит. Функции в \"Danger Zone\" сканируют все префабы в проекте (AssetDatabase.FindAssets(\"t:Prefab\")), а не только те, что указаны в списке парсинга, чтобы обеспечить максимально полную очистку.",
  "a_faq_window_actions_4": "В вашем документе Google Sheets столбец должен называться \"Developer Notes\". В ячейках этого столбца вы можете писать комментарии как обычно. Чтобы указать заполнители, просто добавьте строку, например, @placeholders: {username}, {score} в текст комментария. Инструмент автоматически распознает эту директиву при импорте.",
  "a_faq_window_actions_5": "Инструмент работает только с одним листом за раз. URL для импорта включает параметр gid=..., который однозначно идентифицирует конкретный лист в документе. Чтобы импортировать данные с другого листа, вам нужно скопировать его URL (с другим gid) и выполнить импорт снова.",
  "a_faq_window_assets_1": "Сканер ассетов загружает их, указывая ожидаемый тип (AssetDatabase.LoadAssetAtPath(path, expectedType)). Для категории AudioClip он будет искать и загружать только те файлы, которые Unity распознает как AudioClips. Если оба файла являются действительными аудиоклипами, то в таблицу попадет тот, который будет обработан последним, фактически перезаписав предыдущий. Рекомендуется избегать таких дубликатов.",
  "a_faq_window_assets_2": "Да, именно так это и работает. \"Analyze Project\" находит компонент Image, смотрит на имя назначенного ему спрайта (например, icon_play_en), извлекает из него ключ (icon_play) и язык (en), а затем добавляет компонент LocalizedAsset к этому GameObject и записывает в него ключ icon_play.",
  "a_faq_window_assets_3": "Да, можете. Конфликтов не будет, так как для каждой категории создается отдельная таблица ассетов (LocalizedAssetTable). Ключи из категории \"Sprites\" не пересекаются с ключами из категории \"AudioClips\", даже если они названы одинаково.",
  "a_faq_window_assets_4": "Да, найдет. Сканер использует опцию SearchOption.AllDirectories, что означает, что он будет рекурсивно проверять все вложенные папки внутри указанной вами Scan Folder.",
  "a_faq_window_content_1": "Нет, не повлияет. Список Scenes to Parse используется исключительно для того, чтобы инструмент знал, какие сцены нужно открыть и проанализировать на наличие текста. Он никак не связан со сценами, которые попадут в финальную сборку вашей игры.",
  "a_faq_window_content_2": "Нет, не будет. Временный список хранит прямую ссылку на объект в сцене. Когда вы создаете префаб, это новый ассет. Его экземпляры — это другие объекты, и правило игнорирования на них не распространится. Чтобы постоянно игнорировать префабы, их нужно добавлять в список игнорирования как ассет префаба.",
  "a_faq_window_content_3": "Да, будет. При нажатии Update Keys парсер повторно сканирует весь проект. Он увидит, что тип TMPro.TMP_Text должен быть проигнорирован, и не сгенерирует для него ключ. В процессе сравнения старых и новых ключей он определит, что старый ключ больше не используется, и пометит его как \"Removed\".",
  "a_faq_window_content_4": "Нет, не будет. \"Pin\" сохраняет абсолютный путь в иерархии сцены в момент нажатия кнопки (например, Canvas/Panel/Button). Этот путь не связан с логикой префабов. Экземпляры префаба будут иметь такой же путь, но если вы переименуете родительский объект в сцене, \"Pin\" перестанет работать как для оригинала, так и для экземпляров.",
  "a_faq_window_content_5": "Будет сохранен полный путь от корня сцены. Например, MyPrefab(Clone)/Content/Icon. Этот «закрепленный» путь будет работать только в той сцене, где вы его создали. В других сценах такой путь вряд ли будет найден.",
  "a_faq_window_preview_1": "Нет, он не будет сохранен. PreviewSafetyBridge перехватывает событие сохранения ассета (OnWillSaveAssets) и автоматически вызывает RevertEditorPreview() до того, как Unity запишет изменения на диск. Таким образом, Prefab будет сохранен в своем исходном, нелокализованном состоянии.",
  "a_faq_window_preview_2": "PreviewRecoveryService обрабатывает восстановление после сбоев. Если Unity дает сбой, служба обнаруживает файл резервной копии при следующем запуске и пытается восстановить состояние сцены. Если автоматическое восстановление не удается, вам может потребоваться вручную выбрать \"Revert to Original\" в окне инструмента.",
  "a_faq_window_preview_3": "Да, будут. PrefabUtility.InstantiatePrefab в режиме редактирования вызывает Awake() и OnEnable(). Если эти методы содержат логику, которая не должна выполняться в редакторе (например, обращение к синглтонам, которые существуют только в Play Mode), это может вызвать ошибки. Рекомендуется использовать if (Application.isPlaying) или #if UNITY_EDITOR для защиты такого кода.",
  "a_faq_window_report_1": "Да, будет прерван. Любое новое действие, требующее блокировки UI (например, Update Keys), остановит текущую сопрограмму поиска. Появится диалоговое окно с предложением остановить текущий поиск, чтобы начать новый.",
  "a_faq_window_report_2": "Категория \"Duplicates\" покажет все источники для этого ключа. Вы увидите одну запись для ключа, а поле \"Source\" будет содержать список всех путей (в сцене 1 и сцене 2). Кнопка \"Find\" в этом случае откроет выпадающий список, позволяющий выбрать, к какому объекту перейти.",
  "a_faq_window_report_3": "Да. Система поиска специально обучена распознавать источники, такие как script MyScript.cs. Когда вы нажимаете \"Find\", он будет искать ассет MyScript.cs в проекте и подсвечивать (ping) его в окне Project.",
  "a_faq_window_settings_1": "Да, будут. При смене режима инструмент выполняет «безопасную миграцию»: он повторно парсит весь проект, создает новые ключи по новым правилам, но сопоставляет старые и новые ключи через оригинальный текст. Затем он переносит все ваши существующие переводы и комментарии со старых ключей на новые. Ваши переводы не будут потеряны.",
  "a_faq_window_settings_2": "Будет использоваться DefaultPluralRule, который подходит для английского и большинства европейских языков (формы для \"one\" и \"other\").",
  "a_faq_window_settings_3": "Нет, не будут. Только ассеты, расположенные в папке StreamingAssets или Resources, гарантированно включаются в сборку. Если вы укажете другой путь, локализация будет работать в редакторе, но не будет работать в скомпилированной игре, так как файлы переводов не будут частью сборки.",
  "a_faq_window_settings_4": "Да. EditorPrefs — это локальное хранилище для каждого компьютера. Вам потребуется ввести <strong>ключ API службы перевода</strong> (для использования в редакторе, например OpenAI/DeepL) на каждой машине. Однако <strong>ключ API для выполнения</strong> (используемый в сборках) хранится в настройках проекта и передается через систему контроля версий (зашифрованный).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Правильный способ загрузки локализованных ассетов с помощью Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// ШАБЛОН для создания парсера для пользовательского компонента.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Проверяем, есть ли у объекта нужный нам пользовательский компонент.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Выход, если компонент не найден\n        }\n        \n        // 2. Получаем текст из полей пользовательского компонента.\n        string titleText = component.Title;\n        \n        // 3. Проверяем, подходит ли текст для локализации.\n        // Используем помощник ParsingLogic для проверки по шаблонам игнорирования\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Генерируем ключ и источник, используя помощники из ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Возвращаем результат.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Повторяем для других полей...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Имя, видимое пользователю\n        \"Description of your asset loading system\",  // ← Краткое описание\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Инициализация системы */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Замените вашей логикой\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Очистить кэш для нового языка\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // НЕУДАЧА: Словарь (Используйте Списки)\n\n[LocalizableField]\npublic int Number = 5; // НЕУДАЧА: Нестроковые типы",
  "code_example_function": "// 1. Добавьте статический импорт для краткого синтаксиса\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Простой поиск по ключу/тексту\n        _(\"Hello World\");\n        \n        // 3. Индексированное форматирование ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Именованные аргументы (интеллектуальное форматирование)\n        // Использует анонимный объект. Ключ = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Плюрализация (целочисленный аргумент)\n        // Автоматически находит key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Гендеризация (перечисление Gender)\n        // Автоматически находит key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Ручной словарь (высокая производительность / динамический)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Вложенность (рекурсивный перевод аргументов)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Ключи: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Тексты: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Автоматически выбирает правильную форму\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Ключи: \"user_greeted_male\", \"user_greeted_female\"\n        // Тексты: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "Скопировано!",
  "copy_code_copy": "Копировать",
  "copy_code_error": "Ошибка",
  "error_loading_message": "Пожалуйста, проверьте ваше соединение и обновите страницу.",
  "error_loading_title": "Ошибка загрузки",
  "h1_ai_audio": "AI Аудио / Преобразование текста в речь",
  "h1_ai_profiles": "Профили ИИ и перевода",
  "h1_api_snippets": "API и фрагменты кода",
  "h1_components": "Основные компоненты (назначаются автоматически)",
  "h1_extending": "Расширение функциональности",
  "h1_faq": "FAQ и устранение неполадок",
  "h1_font_glyph_manager": "Менеджер шрифтов и глифов",
  "h1_important_notes": "Важные примечания и предупреждения",
  "h1_introduction": "Введение",
  "h1_loc_tool_window": "Окно \"Localization Tool\"",
  "h1_migration_tool": "Инструмент миграции",
  "h1_quick_start": "Быстрый старт и настройка",
  "h1_tms": "Интеграция внешних TMS (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Редактор таблицы переводов",
  "h1_usage_examples": "Примеры использования",
  "h2_ai_assistant": "Команды AI‑ассистента",
  "h2_ai_audio_setup": "Настройка",
  "h2_ai_audio_usage": "Использование",
  "h2_ai_context": "Контекст и глоссарий",
  "h2_ai_profiles_overview": "Профили перевода",
  "h2_async_api": "Асинхронный API (Addressables)",
  "h2_backup_manager": "Менеджер резервного копирования",
  "h2_bridge_generation": "Сгенерировать C# мосты (строго типизированный доступ)",
  "h2_custom_ai": "Пользовательский ИИ и модели",
  "h2_custom_asset_provider": "Создание пользовательского поставщика ассетов",
  "h2_custom_attributes": "Сканирование пользовательских атрибутов",
  "h2_custom_parser": "Создание пользовательского парсера",
  "h2_example_attribute": "[LocalizableField] Атрибут",
  "h2_example_components": "Готовые компоненты и примеры",
  "h2_example_components_updated": "Обновленный LanguageSelector.cs",
  "h2_example_function": "Функция _() и атрибут [OnLanguageChange]",
  "h2_example_plurals": "Множественное число и род",
  "h2_faq_addressables": "Addressables и миграция",
  "h2_faq_audio": "AI Аудио / Преобразование текста в речь",
  "h2_faq_components": "Основные компоненты",
  "h2_faq_editor": "Редактор переводов",
  "h2_faq_examples": "Примеры использования и код",
  "h2_faq_extending": "Расширение функциональности",
  "h2_faq_installation": "Установка и быстрый старт",
  "h2_faq_notes": "Важные нюансы и предупреждения",
  "h2_faq_window": "Окно \"Localization Tool\"",
  "h2_font_glyph_manager_features": "Особенности",
  "h2_in_editor_preview": "Предпросмотр в редакторе и Prefab",
  "h2_initial_setup": "Начальная настройка",
  "h2_installation": "Установка",
  "h2_key_features": "Ключевые особенности",
  "h2_live_updates_guide": "Руководство по Live Updates",
  "h2_localizedasset": "ЛокализованныйРесурс",
  "h2_localizedasset_updated": "Асинхронная загрузка LocalizedAsset",
  "h2_localizedbehaviour": "ЛокализованныйBehaviour",
  "h2_localizeddropdown": "ЛокализованныйDropdown",
  "h2_localizedprefab": "ЛокализованныйPrefab",
  "h2_localizedtext": "ЛокализованныйТекст",
  "h2_migration_custom": "Создание пользовательских профилей",
  "h2_migration_google_sheets": "Ключ Google Sheets",
  "h2_migration_import_formats": "Форматы импорта (CSV и Google Sheets)",
  "h2_migration_stubs": "Безопасная миграция и экстренные заглушки",
  "h2_migration_tool_features": "Особенности",
  "h2_migration_workflow": "Руководство по рабочему процессу миграции",
  "h2_preview_overlay": "Наложение в окне Scene",
  "h2_safety_caps": "Лимиты и квоты безопасности",
  "h2_script_parsing_rules": "Правила парсинга скриптов (совместимость)",
  "h2_tab_actions": "Вкладка \"Actions\"",
  "h2_tab_assets": "Вкладка \"Assets\"",
  "h2_tab_content": "Вкладка \"Content\"",
  "h2_tab_report": "Вкладка \"Report\"",
  "h2_tab_settings": "Вкладка \"Settings\"",
  "h2_tab_tutorials": "Вкладка \"Tutorials\"",
  "h2_tms_setup": "Настройка и использование",
  "h2_tms_supported": "Поддерживаемые сервисы",
  "h2_uitklocalization": "UITKЛокализация",
  "h2_visual_debugging_guide": "Визуальная отладка",
  "h2_window_footer": "Нижний колонтитул окна (Строка состояния)",
  "h2_window_header": "Заголовок окна и панель инструментов",
  "h2_window_sidebar": "Главное меню (Боковая панель)",
  "h3_actions_autotranslate": "Автоперевод",
  "h3_actions_danger": "Опасная зона",
  "h3_actions_data": "Управление данными",
  "h3_actions_editor": "Редактор переводов",
  "h3_actions_parsing": "Парсинг",
  "h3_actions_tms_integration": "Внешние сервисы (TMS)",
  "h3_assets_automation": "Автоматизация",
  "h3_assets_categories": "Категории ассетов",
  "h3_assets_folder_gen": "Генерация папок",
  "h3_assets_loading": "Стратегия загрузки",
  "h3_assets_storage": "Конфигурация хранилища",
  "h3_attribute_cheat_sheet": "Краткий справочник: Что можно и чего нельзя",
  "h3_attribute_features": "Поддерживаемые типы и функции",
  "h3_attribute_limitations": "Ограничения",
  "h3_content_components_ignore": "Типы компонентов для игнорирования",
  "h3_content_dynamic_keys": "Префиксы динамических ключей",
  "h3_content_dynamic_texts": "Динамические тексты",
  "h3_content_objects_ignore": "Объекты для игнорирования",
  "h3_content_prefabs": "Папки Prefab",
  "h3_content_regex": "Игнорируемые шаблоны Regex",
  "h3_content_scenes": "Сцены для парсинга",
  "h3_content_script_rules": "Правила парсинга скриптов",
  "h3_content_scripts_ignore": "Скрипты для игнорирования",
  "h3_custom_provider_steps": "Этапы реализации",
  "h3_faq_window_actions": "Вкладка \"Действия\"",
  "h3_faq_window_assets": "Вкладка \"Активы\"",
  "h3_faq_window_content": "Вкладка \"Содержимое\"",
  "h3_faq_window_preview": "Предварительный просмотр в редакторе",
  "h3_faq_window_report": "Вкладка \"Отчет\"",
  "h3_faq_window_settings": "Вкладка \"Настройки\"",
  "h3_mode_auto": "AutoGenerateKeysOnly (Стандарт)",
  "h3_mode_hybrid": "Гибридные режимы (пользовательский приоритет)",
  "h3_mode_text": "UseTextAsKey (Упрощенный)",
  "h3_report_all_keys": "Все ключи",
  "h3_settings_debugging": "Отладка",
  "h3_settings_general": "Общие настройки",
  "h3_settings_keygen": "Генерация ключей",
  "h3_settings_languages": "Управление языками",
  "h3_settings_liveupdates": "Обновления в реальном времени",
  "h3_settings_pseudo": "Настройки псевдо-локализации",
  "h3_settings_runtimeapi": "Runtime API",
  "h3_settings_tools": "Общие и инструменты разработки",
  "h3_tutorials_list": "Список руководств",
  "lbl_not_supported": "НЕ поддерживается",
  "lbl_supported": "Полностью поддерживается",
  "li_actions_1": "<strong>Парсинг:</strong><ul><li><strong>Update Keys:</strong> Полное сканирование проекта, определенное настройками вкладки 'Content'.</li><li><strong>Scan Selected Assets:</strong> Сканирует ТОЛЬКО файлы/папки, выбранные в данный момент в Project View. Более безопасно для частичных обновлений, так как автоматически отключает 'Remove Missing Keys'.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Открывает отдельное, более удобное окно для редактирования всех переводов.",
  "li_actions_3": "<strong>Управление данными:</strong> Используется для обмена данными с переводчиками (Экспорт/Импорт в CSV/XML/YAML/XLIFF, импорт из Google Sheets). <strong>Google Sheets:</strong> Поддерживает как ссылки 'Edit', так и URL-адреса 'Publish to Web' (проверьте параметр GID).",
  "li_actions_4": "<strong>Автоперевод:</strong> Автоматически заполняет все пустые строки перевода, используя активный <strong>Translation Profile</strong>.",
  "li_actions_5": "<strong>Danger Zone:</strong> Содержит кнопки для полного удаления всех компонентов локализации из проекта. Используйте с осторожностью!",
  "li_ai_1": "<strong>Создание профиля:</strong> ПКМ в окне Project -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Сервисы:</strong> Поддерживает DeepL, Google Translate, Microsoft Azure и <strong>Custom AI</strong>.",
  "li_ai_3": "<strong>Настройки:</strong> Каждый профиль хранит свой собственный ключ API, лимиты (размер пакета, максимальное количество символов) и настройки модели.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Используйте встроенный генератор для быстрого создания профилей для популярных сервисов (OpenAI, Gemini, Claude, Ollama).",
  "li_ai_audio_generate": "В <strong>Translation Table Editor</strong> выберите строки/ячейки -> Правый клик -> <strong>Generate Audio</strong>.",
  "li_ai_audio_hash": "<strong>Умное обновление и хеширование:</strong> Инструмент рассчитывает MD5-хеш вашего текстового контента и регенерирует аудиофайлы, только если исходный текст изменился, экономя ваши кредиты API. Он обнаруживает, изменился ли перевод с момента последней генерации аудио. Редактор подсвечивает эти строки иконкой 'Outdated' (желтый), позволяя обновить ТОЛЬКО измененные строки. Эта функция умной пакетной обработки предотвращает ненужные вызовы API и снижает затраты при регенерации аудио. Инструмент хеширует ваш текст и регенерирует аудиофайлы, только если исходный текст изменился, экономя ваши кредиты API.",
  "li_ai_audio_profile": "В <strong>Settings</strong> выберите <strong>Active Audio Profile</strong> (например, OpenAI TTS или ElevenLabs).",
  "li_ai_audio_save": "Файлы сохраняются в папку, указанную в профиле.",
  "li_ai_audio_voice_mapping": "<strong>Voice Mapping (Multi-Speaker):</strong> Автоматически назначать разные AI‑голоса разным персонажам. Используйте список <strong>Voice Mappings</strong> для связывания шаблонов Regex (например, <code>^hero_.*</code>) с конкретными Voice ID. Инструмент автоматически выберет правильный голос на основе имени ключа при генерации аудио.",
  "li_ai_provider_settings": "<strong>Настройки провайдера:</strong> Каждый сервис позволяет настраивать API-ключи, модели (например, GPT-4o, Sonnet) и параметры, специфичные для голоса (стабильность, схожесть).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Используйте это для асинхронной загрузки ассетов Addressables. Возвращает <code>Task&lt;T&gt;</code>.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) возвращает перевод, зависящий от пола.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> возвращает правильную форму множественного числа в соответствии с правилами конкретного языка.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> Корутина (<code>IEnumerator</code>) для смены языка. Всегда используйте <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Создание структуры папок (необязательно):</strong> В разделе <strong>2. Asset Folder Generation</strong> нажмите <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Настройка категорий и правил именования:</strong> В разделе <strong>3. Asset Categories & Scanning</strong> убедитесь, что <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) соответствует вашим файлам (например, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Размещение ваших ассетов:</strong> Поместите локализованные ассеты в папки.",
  "li_assets_4": "<strong>Сканирование ассетов:</strong> В разделе <strong>4. Automation</strong> нажмите <strong>Scan Assets & Update Tables</strong>. Процесс очистки стал безопаснее: теперь удаляются только старые файлы таблиц (<code>.asset</code>), а не вся папка.",
  "li_assets_5": "<strong>Связывание ассетов с объектами:</strong> Нажмите <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Интеграция с Addressables:</strong> Если включен режим <strong>Addressables</strong>, при сканировании ассеты будут автоматически зарегистрированы в Addressables группах с адресами в форме <code>{Category}/{Language}/{Key}</code>.",
  "li_assets_addressables_naming": "<strong>Соглашение об именовании:</strong> При сканировании инструмент автоматически устанавливает Addressable Addresses в формате <code>{Category}/{Language}/{Key}</code>. <strong>Не переименовывайте</strong> эти адреса вручную, так как LocalizationManager полагается на этот конкретный формат для загрузки ассетов во время выполнения.",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> При включении инструмент автоматически создаст необходимую структуру каталогов для всех поддерживаемых языков при первой локализации ассетов.",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> Автоматически создаёт структуру папок для локализованных ассетов согласно вашим правилам.",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> Задайте корневой каталог для всех локализованных ассетов (Sprites, Audio и т.д.). Используйте переменную <code>{lang}</code> для указания структуры папок по языкам.",
  "li_assistant_1": "<strong>Настраиваемые:</strong> Определите команды в вашем Translation Profile (например, \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\").",
  "li_assistant_2": "<strong>Пакетная обработка:</strong> Выберите несколько ячеек, чтобы применить команду ко всем сразу.",
  "li_assistant_3": "<strong>Custom Commands:</strong> Определите собственные подсказки в инспекторе <strong>Translation Profile</strong> (Список <code>AIAssistantCommand</code>). Каждая команда имеет <strong>Label</strong> (отображается в контекстном меню) и <strong>Prompt</strong> (инструкции, отправляемые ИИ, например, 'Переписать в стиле пирата').",
  "li_attr_feat_1": "<strong>Коллекции:</strong> Поддерживает <code>List&lt;string&gt;</code> и <code>string[]</code>. Ключи генерируются с суффиксами <code>_0</code>, <code>_1</code> и т.д. Вы даже можете использовать пользовательский ключ для самого поля списка, чтобы добавить префикс ко всем элементам.",
  "li_attr_feat_2": "<strong>Модификаторы доступа:</strong> Работает с полями <code>private</code>, <code>protected</code>, <code>internal</code> и <code>public</code>.",
  "li_attr_feat_3": "<strong>Пользовательские атрибуты:</strong> В настройках <em>вкладки «Контент»</em> вы можете добавить <code>HeaderAttribute</code>, <code>TooltipAttribute</code> или любое имя пользовательского атрибута. Парсер будет рассматривать поля с этими атрибутами (например, <code>[Header(\"Text\")]</code>) как локализуемые строки!",
  "li_attr_feat_4": "<strong>Вложенные объекты:</strong> Рекурсивно сканирует поля внутри классов или структур, помеченных <code>[System.Serializable]</code>. Это включает как одиночные экземпляры, так и списки вложенных объектов.",
  "li_attr_feat_5": "<strong>Форматированные строки:</strong> Поддерживает интерполированные строки (<code>$\"Text {0}\"</code>), дословные строки (<code>@\"Text\"</code>) и конкатенацию (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Свойства поддерживаются:</strong> Парсер сканирует как <code>Fields</code>, так и <code>Properties</code>. Требуется геттер.",
  "li_attr_limit_2": "<strong>Словари:</strong> <code>Dictionary&lt;T, string&gt;</code> не поддерживается напрямую для парсинга.",
  "li_attr_limit_3": "<strong>Статические поля:</strong> Поддерживаются посредством статического анализа (регулярных выражений) в файлах кода, но обычно рекомендуется использовать поля экземпляра для надежного обнаружения на GameObjects.",
  "li_backup_desc": "Отслеживайте изменения и восстанавливайте предыдущие версии своих переводов.",
  "li_backup_rollback": "<strong>Откат:</strong> Мгновенно отменяйте изменения для выбранных ключей или всей таблицы до предыдущего состояния.",
  "li_backup_snapshots": "<strong>Снимки:</strong> Создает именованные точки восстановления перед массовыми операциями.",
  "li_cheat_base_private": "<strong>Базовые приватные поля:</strong> Поддерживаются (сканер читает файлы базовых классов напрямую)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, массивы <code>string[]</code>",
  "li_cheat_concatenation": "<strong>Конкатенация строк:</strong> <code>\"A\" + \"B\"</code> (Поддерживается)",
  "li_cheat_constructor_args": "<strong>Сложные аргументы конструктора:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>Словари</strong> (По умолчанию не сериализуются инспектором Unity)",
  "li_cheat_headers": "Атрибуты типа <code>[Header(\"...\")]</code> (Полностью поддерживаются)",
  "li_cheat_nested_lists": "<strong>Списки вложенных объектов</strong> (например, <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Переменные и константы:</strong> <code>const string s = \"Value\";</code> или <code>static string</code> (Поддерживается, Roslyn разрешает значения из того же файла)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> поля (Поддерживаются)",
  "li_cheat_properties": "<strong>Свойства:</strong> <code>{ get; set; }</code> (Автоматические свойства и полные свойства поддерживаются)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Поддерживаются, если на них есть ссылки)",
  "li_cheat_serializable": "Вложенный <code>[Serializable] class</code> (Элементы инвентаря, узлы диалога)",
  "li_cheat_static": "<strong>Статические поля:</strong> <code>public static string</code> (Полностью поддерживаются)",
  "li_cheat_structs": "<strong>Структуры и записи:</strong> Поддерживаются (рекурсивное сканирование)",
  "li_cheat_ternary": "<strong>Логика/Тернарный оператор:</strong> <code>cond ? \"A\" : \"B\"</code> (Парсер не может определить значение)",
  "li_cheat_unattached": "<strong>Непривязанные скрипты:</strong> Поддерживаются (сканер читает все файлы .cs в проекте)",
  "li_content_1": "<strong>Scenes to Parse:</strong> Перетащите сюда все сцены для анализа.",
  "li_content_2": "<strong>Prefab Folders:</strong> Укажите папки с префабами. Теперь поддерживает пагинацию и поиск для больших проектов.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Введите сюда строки, которые создаются исключительно в коде (например, \"Game Over\").",
  "li_content_4": "<strong>Component Types to Ignore:</strong> Укажите типы Unity Component, которые следует пропускать при сканировании.",
  "li_content_5": "<strong>Pin to Ignore:</strong> Эта функция позволяет постоянно \"закреплять\" объект из сцены в список игнорирования.",
  "li_content_6": "<strong>Scripts to Ignore:</strong> Добавьте конкретные C# скрипты ИЛИ целые папки, чтобы исключить их из парсинга.",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> Список префиксов для ключей (например, <code>Item_</code>), которые не будут удаляться при очистке.",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> Определите префиксы (например, <code>quest_item_</code>), которые следует считать потенциально динамичными. Это помогает инструменту различать статические метки UI и ключи, генерируемые данными.",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> Настройте шаблоны для текста, который обновляется динамически через код. Это предотвращает создание сканером избыточных ключей для текста, меняющегося во время выполнения.",
  "li_content_regex_example": "<strong>Пример пользовательского враппера:</strong> Если вы используете пользовательскую функцию, такую как <code>MyGame.Loc(\"KEY\")</code>, добавьте правило синтаксического анализа скриптов (Script Parsing Rule) с регулярным выражением: <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Игнорируемые регулярные выражения:</strong> Нажмите <strong>'Добавить общий шаблон'</strong>, чтобы быстро исключить динамический контент, такой как URL, Email и т.д.",
  "li_content_scanner": "<strong>Сканер кода Roslyn:</strong> Мощный движок статического анализа, который понимает деревья синтаксиса C# для надежного обнаружения ключей.",
  "li_content_scanner_details_1": "<strong>Умное обнаружение вызовов:</strong> автоматически находит вызовы <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> и <code>GetTranslation(\"Text\")</code>. Он принудительно применяет режим <strong>Text-As-Key</strong> для этих вызовов, чтобы обеспечить корректную работу таких функций времени выполнения, как плюрализация и гендер.",
  "li_content_scanner_details_2": "<strong>Разрешение констант:</strong> Сканер достаточно интеллектуален, чтобы разрешать строковые переменные `const` или `static readonly`. Если вы используете <code>_ (MyConst)</code>, он найдет значение `MyConst` (если оно определено в том же классе) и использует его в качестве исходного текста.",
  "li_content_scanner_details_3": "<strong>Attribute & Metadata:</strong> Сканирует любое поле или свойство с помощью `[LocalizableField]`, `[Header]` или `[Tooltip]` (если настроено). Рекурсивно обрабатывает <strong>Массивы</strong>, <strong>Списки</strong> и даже <strong>Вложенные Сериализуемые Классы</strong>.",
  "li_content_scanner_details_4": "<strong>Поддержка современного C#:</strong> Полная поддержка синтаксиса C# 9.0+, включая выражения `new()` с целевым типом, неявное создание массивов и интерполированные строки (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Атрибуты для сканирования:</strong> Определите пользовательские атрибуты (например, <code>[Header]</code> или <code>[Tooltip]</code>), которые парсер должен распознавать как локализуемые строковые источники.",
  "li_content_script_rules_bridge_name": "<strong>Имя класса-моста:</strong> Позволяет определить имя генерируемого статического класса.",
  "li_content_script_rules_bridges": "<strong>Генерировать C# мосты:</strong> Автоматически создает статический класс (например, <code>AnkoLoc</code>), обеспечивающий строго типизированный доступ ко всем ключам, исключая «магические строки» и позволяя автодополнение в IDE.",
  "li_context_1": "<strong>Developer Notes:</strong> Комментарии из таблицы переводов передаются AI в качестве контекста.",
  "li_context_2": "<strong>Object Path:</strong> Если комментарий отсутствует, в качестве запасного контекста используется путь к объекту в иерархии (например, <code>MainMenu/Canvas/StartButton</code>).",
  "li_context_3": "<strong>Glossary:</strong> Вы можете загрузить CSV-глоссарий в профиль, чтобы обеспечить принудительное использование определенных переводов для терминов и имен.",
  "li_context_4": "<strong>Описание проекта:</strong> Опишите сеттинг вашей игры и целевую аудиторию, чтобы помочь ИИ понять общий контекст.",
  "li_context_5": "<strong>Тон и стиль:</strong> Определите желаемую персону (например, «Дружелюбный», «Профессиональный», «Пират») и правила форматирования.",
  "li_context_glossary": "<strong>Менеджер словарей:</strong> Взаимодействуйте напрямую со словарем, чтобы «Добавлять», «Редактировать» или «Удалять» термины. Поддерживает чувствительность к регистру и типы «Не переводить».",
  "li_context_optimization": "<strong>Оптимизация токенов:</strong> Система интеллектуально сжимает контекст и повторно использует кеш для минимизации использования токенов и затрат.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Гибкая реализация, которая может взаимодействовать с OpenAI-совместимыми API (включая локальные LLM через Ollama).",
  "li_custom_ai_2": "<strong>Шаблоны и авторизация:</strong> Полностью настраивайте запрос. <ul><li><strong>Авторизация:</strong> Настройте <code>Auth Header Key</code> (например, <code>Authorization</code>) и <code>Format</code> (например, <code>Bearer {0}</code>). Поддерживает ключ API в параметрах запроса.</li><li><strong>Шаблон тела:</strong> Используйте JSON-шаблон с заполнителями, такими как <code>{model}</code> и <code>{prompt}</code> для текста, или <code>{input}</code> и <code>{voice}</code> для аудио.</li><li><strong>Путь ответа:</strong> Определите путь JSON к результату (например, <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Встроенные функции безопасности:</strong> Автоматическое исправление нарушенных тегов форматирования (например, <ph0>), часто возвращаемых моделями AI, обеспечивая надежные и согласованные переводы.",
  "li_custom_parser_1": "Создайте новый C#-скрипт в папке <strong>Editor</strong> вашего проекта.",
  "li_custom_parser_2": "Скопируйте в него шаблон ниже.",
  "li_custom_parser_3": "Измените логику в соответствии с вашим компонентом.",
  "li_custom_provider_manual_reg": "<strong>Ручная регистрация:</strong> Для продвинутых сценариев (например, внедрение DI или ленивая инициализация) вы можете вручную зарегистрировать свой провайдер с помощью <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> во время инициализации.",
  "li_custom_provider_step_1": "<strong>Реализуйте интерфейс:</strong> Создайте новый класс, который реализует <code>IAssetProvider</code>. Вам нужно будет определить, как `Load&lt;T&gt;` (синхронно) и `LoadAsync&lt;T&gt;` (асинхронно) загружать ассеты, используя API вашей системы.",
  "li_custom_provider_step_2": "<strong>Определите жизненный цикл:</strong> Реализуйте <code>Initialize</code>, <code>Dispose</code> и <code>UnloadAll</code>. Эти методы вызываются <code>LocalizationManager</code> при переключении языков или очистке ресурсов.",
  "li_custom_provider_step_3": "<strong>Языковая безопасность:</strong> Метод <code>SetCurrentLanguage</code> вызывается при каждом изменении активного языка. Используйте это для обновления внутренних путей или повторной загрузки метаданных ассетов.",
  "li_custom_provider_step_4": "<strong>Автоматическое обнаружение (рекомендуется):</strong> Декорируйте ваш класс атрибутом <code>[AssetProviderPlugin]</code>. Это сделает ваш провайдер мгновенно видимым в выпадающем списке <strong>Settings Tab -&gt; Asset Loading Strategy</strong>.",
  "li_editor_1": "<strong>Умная группировка:</strong> Ключи для множественного числа и рода (например, <code>apple_count_one</code>, <code>apple_count_few</code>) автоматически объединяются в сворачиваемые группы.",
  "li_editor_2": "<strong>Продвинутое редактирование:</strong> Нажмите на ячейку, чтобы открыть всплывающее окно <strong>MultiLineEditWindow</strong>. Оно показывает исходный текст для сравнения и выполняет проверку заполнителей (placeholders).",
  "li_editor_3": "<strong>Расширенный выбор:</strong> Поддерживает гибкие режимы выбора: отдельные ячейки, целые строки или конкретные столбцы (языки). Используйте <code>Ctrl+Click</code> и <code>Shift+Click</code> для сложных выделений.",
  "li_editor_4": "<strong>Массовые действия:</strong> Выполняйте операции над тысячами ячеек одновременно. Щелкните правой кнопкой мыши по выделенному фрагменту, чтобы: <ul><li><strong>Автоматический перевод:</strong> Заполните отсутствующие переводы, используя активный профиль ИИ.</li><li><strong>Заполнить из источника:</strong> Быстро сбросить переводы.</li><li><strong>Переключить блокировку:</strong> Защитите «идеальные» переводы от случайных перезаписей.</li><li><strong>Сгенерировать аудио:</strong> Пакетная обработка TTS для выбранных фраз.</li></ul>",
  "li_editor_5": "<strong>Высокопроизводительная навигация:</strong> Редактор использует виртуализированный 'MultiColumnListView' для плавной прокрутки с 10 000+ ключами. Поддерживает навигацию с помощью клавиатуры (Стрелки/Tab) и промышленные сочетания клавиш: <code>Ctrl+S</code> (Сохранить), <code>Ctrl+Z/Y</code> (Отменить/Повторить), <code>Ctrl+F</code> (Фокус поиска).",
  "li_editor_6": "<strong>Расширенные предустановки поиска:</strong> Проверьте свой проект, используя специализированные фильтры: <ul><li><strong>Статус:</strong> Непереведенные (Текущий/Любой язык), Идентичные источнику, Заблокированные.</li><li><strong>Содержимое:</strong> Имеет комментарии, Имеет/Отсутствуют заполнители, Имеет проблемы с длиной (Автоматическое определение).</li><li><strong>Структура:</strong> Множественное число, Гендерное или Оба.</li><li><strong>Аудио:</strong> Отсутствует аудио, Устарело (Несоответствие хеша).</li></ul>",
  "li_editor_7": "<strong>Умное управление аудио:</strong> Отслеживает «свежесть» ваших файлов TTS. Если вы редактируете текст перевода, появляется <strong>Желтый индикатор (Устарело)</strong>, указывающий на то, что хеш аудиофайла больше не соответствует тексту. Один клик регенерирует только устаревшие файлы.",
  "li_editor_8": "<strong>Механизм блокировки:</strong> Объяснение: <ul><li><strong>Заблокированные ячейки/строки:</strong> Предотвращает любые изменения с помощью <strong>Автоматического перевода</strong>, <strong>Импорта CSV/Google</strong> или <strong>Заполнения из источника</strong>.</li><li><strong>Применение:</strong> Блокируйте «идеальные» переводы, которые были вручную проверены носителями языка.</li><li><strong>Массовое управление:</strong> Блокируйте целые языки или определенные функции (например, имена персонажей) в рамках всего проекта.</li></ul>",
  "li_editor_layout": "<strong>Динамический многопанельный макет:</strong> Используйте 3-панельную систему, чтобы закрепить «фиксированные» столбцы (например, Keys) с левой стороны, прокручивая более 20 языков в середине. Переключайте видимость столбцов через контекстное меню заголовка.",
  "li_editor_regex": "<strong>Поиск по Regex:</strong> Как главное окно, так и табличный редактор поддерживают <strong>Регулярные выражения</strong>. Если ваш запрос содержит символы, такие как <code>* + ? ^ $ [ ] ( ) { } | .</code>, он автоматически трактуется как Regex (например, <code>^item_.*</code> для поиска всех ключей, начинающихся с 'item_').",
  "li_editor_structure": "<strong>Таблицы и Группы:</strong> Данные организованы в Таблицы (Файлы), отображаемые как Группы (Папки) в редакторе для лучшей навигации.",
  "li_editor_ui_test": "<strong>Встроенное тестирование UI:</strong> <ul><li><strong>Слайдер расширения длины:</strong> Имитируйте расширение текста (0% - 100%), чтобы увидеть, как ваш UI обрабатывает более длинные языки, такие как немецкий или русский, не выходя из редактора.</li><li><strong>Рендерер форматированного текста:</strong> Переключайте рендеринг тегов (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) для проверки стилизации без запуска игры.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Готовый компонент для создания выпадающего списка UI для переключения языка. Он автоматически находит все доступные языки и управляет их переключением.<br><strong>Как использовать:</strong> Просто добавьте компонент <code>LanguageSelector</code> в вашу сцену (например, на пустой GameObject) и укажите ваш <code>TMP_Dropdown</code> в инспекторе.",
  "li_example_components_2": "<strong>Примеры кода:</strong> Для изучения продвинутых техник, таких как работа с <code>[LocalizableField]</code>, функцией <code>_()</code>, множественным числом и родом, изучите файлы <code>StatPurchaseTest.cs</code> и <code>TestLocalization.cs</code>. Они наглядно демонстрируют реализацию всех основных функций инструмента в коде.",
  "li_example_components_new": "<strong>Новое (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Возвращает <code>IEnumerator</code>. Должно быть ожидаемо (yielded).",
  "li_example_components_old": "<strong>Старое:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (синхронный void) - <strong>Устарело</strong>. Используйте версию с Coroutine.",
  "li_feature_1": "<strong>Продвинутый парсинг:</strong> Автоматическое сканирование сцен, префабов, UI Toolkit (UXML) и C#-скриптов, включая поля, отмеченные атрибутом <code>[LocalizableField]</code>, а также вложенные классы и списки.",
  "li_feature_10": "<strong>Менеджер резервных копий:</strong> Встроенный инструмент для создания и восстановления резервных копий.",
  "li_feature_11": "<strong>На базе AI:</strong> Поддержка OpenAI, Anthropic (Claude), Google Gemini и локальных LLM (Ollama) через настраиваемые профили.",
  "li_feature_12": "<strong>Преобразование текста в речь (TTS):</strong> Генерация аудиофайлов для локализованных строк с помощью AI (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Инструменты миграции:</strong> Инструменты для автоматического перехода от плагинов I2 Localization и Unity Localization.",
  "li_feature_14": "<strong>Менеджер шрифтов и глифов:</strong> Инструмент для анализа используемых символов и поиска недостающих глифов в шрифтах.",
  "li_feature_15": "<strong>Визуальная отладка:</strong> Иконки в иерархии и метки в Scene View для быстрой отладки.",
  "li_feature_2": "<strong>Локализация любых активов:</strong> Управление спрайтами, аудио, префабами, материалами и т.д.",
  "li_feature_3": "<strong>Мощный редактор переводов:</strong> Централизованный интерфейс с автосохранением, полной поддержкой Отмены/Повтора, интеллектуальной группировкой ключей и действиями с мультивыделением.",
  "li_feature_4": "<strong>ИИ и машинный перевод:</strong> Система профилей, поддерживающая DeepL, Google, Microsoft и <strong>Пользовательский ИИ (OpenAI, Gemini, Claude, Ollama)</strong> с учетом контекста.",
  "li_feature_5": "<strong>Гибкий Импорт/Экспорт:</strong> Поддержка CSV, XML, YAML, XLIFF и прямой импорт из Google Sheets.",
  "li_feature_6": "<strong>Живой предпросмотр:</strong> Предпросмотр любого языка в окне Scene View или <strong>Prefab Mode</strong> без запуска игры.",
  "li_feature_7": "<strong>Поддержка множественного числа и рода:</strong> Полная поддержка CLDR (v43). Включает правила для <strong>Азиатских</strong> (Нет), <strong>Английских/Германских</strong> (Один, Другой), <strong>Французских</strong> (Один 0-1), <strong>Славянских</strong> (Один, Несколько, Много - RU, UK, PL), <strong>Арабских</strong>, <strong>Кельтских</strong>, <strong>Балтийских</strong> (LT, LV) и других языков.",
  "li_feature_8": "<strong>Полная поддержка RTL:</strong> Корректное отображение языков с письмом справа налево.",
  "li_feature_9": "<strong>Обновления в реальном времени:</strong> Загрузка актуальных переводов с удаленного сервера при запуске игры.",
  "li_feature_tool_translation": "<strong>Полностью переведенный UI:</strong> Интерфейс инструмента локализуем. Вы можете переключить язык редактора, используя выпадающий список в <strong>заголовке главного окна</strong>.",
  "li_font_global": "<strong>Глобальный отчет:</strong> Генерирует отчет обо всех отсутствующих глифах на всех языках.",
  "li_font_glyph_analyze": "Анализирует все переводы и проверяет, поддерживает ли назначенный шрифт (TMP_FontAsset) все используемые символы.",
  "li_font_glyph_copy": "Позволяет копировать все уникальные символы языка для генерации атласа шрифтов. Включает <strong>фильтры для исключения ASCII, чисел и знаков препинания</strong> для оптимизации пространства текстуры.",
  "li_font_glyph_missing": "Показывает список недостающих глифов.",
  "li_font_glyph_workflow": "<strong>Рабочий процесс для TMP:</strong> 1. Запустите сканирование. 2. Выберите язык с недостающими глифами. 3. Нажмите <strong>'Copy Character Set'</strong>. 4. Откройте Window -> TextMeshPro -> Font Asset Creator. 5. Вставьте содержимое буфера обмена в поле 'Character Sequence (Custom Range)', чтобы сгенерировать атлас, содержащий ровно те символы, которые нужны вашей игре.",
  "li_font_unicode": "<strong>Диапазоны Unicode:</strong> Просматривайте конкретные диапазоны Unicode, используемые в ваших переводах (например, Basic Latin, Cyrillic) для оптимизации ресурсов шрифтов.",
  "li_footer_status": "<strong>Статус и прогресс:</strong> Обратная связь в реальном времени по задачам парсинга, импорта или генерации AI.",
  "li_header_lang_selector": "<strong>Язык редактора:</strong> Переключите язык интерфейса инструмента. Пользовательский интерфейс инструмента полностью локализуем.",
  "li_header_preview_btn": "<strong>Переключатель предпросмотра:</strong> Быстро включите или выключите предпросмотр в редакторе. Используйте кнопку 'Вернуть', чтобы восстановить исходные значения сцены.",
  "li_header_toolbar_buttons": "<strong>Глобальная панель инструментов:</strong> Прямой доступ к Документации, Discord, Settings Asset, Dependency Checker и странице обзора.",
  "li_install_1": "<strong>ВАЖНО (Обновление v2.0):</strong> При обновлении с v1.x вы <strong>ОБЯЗАТЕЛЬНО должны удалить</strong> старую папку `Ankonoanko` перед импортом. Версия 2.0 требует чистой установки из-за изменений в пространствах имен.",
  "li_install_2": "Инструмент автоматически проверит наличие необходимых зависимостей. Подтвердите установку в появившемся диалоговом окне.",
  "li_install_3": "Обязательные зависимости (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) необходимы для базовой функциональности.",
  "li_install_4": "Необязательные зависимости (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) включают дополнительные функции.",
  "li_install_5": "Нажмите <strong>Install Selected</strong>, чтобы установить рекомендованные пакеты.",
  "li_install_6": "После установки откройте главное окно инструмента через меню <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Если вы планируете использовать асинхронную загрузку ассетов, установите пакет <strong>Addressables</strong> через Package Manager.",
  "li_live_updates_1": "<strong>Включить:</strong> в настройках установите флажок 'Enable Live Updates'.",
  "li_live_updates_2": "<strong>Источник:</strong> Укажите <code>Live Update URL</code>, возвращающий JSON-словарь, или <code>Google Sheet URL</code>.",
  "li_live_updates_3": "<strong>Кеш:</strong> Переводы кэшируются локально по пути <code>liveUpdateCachePath</code>, чтобы обеспечить работу игры в автономном режиме.",
  "li_live_updates_4": "<strong>Безопасность:</strong> Используйте <strong>Runtime API Key</strong> (зашифрованный), если ваш сервер требует аутентификации.",
  "li_localizedtext_1": "<code>localizationKey</code>: Ключ, используемый для поиска перевода. Может быть сгенерирован автоматически или назначен вручную.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Если <code>true</code>, компонент будет применять только стили (шрифт, RTL), но не будет изменять сам текст. Критично для динамических текстовых элементов (например, текст, обновляемый с помощью вызовов `_()` в скриптах).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Оригинальный текст на базовом языке. Используется как запасной вариант (fallback).",
  "li_localizedtext_key_override": "<strong>Переопределение ключа вручную:</strong> Вы можете нажать значок 'Редактировать' рядом с ключом, чтобы ввести ключ вручную. Используйте 'X', чтобы вернуться к автоматической генерации. Это работает для <code>LocalizedText</code>, <code>LocalizedDropdown</code> (для каждой опции индивидуально) и <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>Поиск в таблице:</strong> Нажмите на значок увеличительного стекла, чтобы мгновенно открыть Таблицу переводов и сфокусироваться на этом конкретном ключе.",
  "li_migration_csv_details_1": "<strong>Умная фильтрация:</strong> Импортер автоматически пропускает строки, которые выглядят как пути к ассетам (например, <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>), чтобы сохранить базу данных текста чистой.",
  "li_migration_csv_details_2": "<strong>Столбец 'Type':</strong> Если столбец 'Type' существует (формат I2), импортируются только строки, помеченные как 'Text' или с пустым типом. Для импорта ассетов используйте Профили миграции, чтобы сопоставить их с <code>LocalizedAsset</code>.",
  "li_migration_csv_req_1": "<strong>Столбец Key:</strong> Должен называться <code>Key</code> (без учета регистра) или быть определен в вашем Профиле миграции.",
  "li_migration_csv_req_2": "<strong>Языковые столбцы:</strong> Любой столбец, не помеченный как игнорируемый, трактуется как код языка (например, 'en', 'ja', 'English'). Инструмент пытается нечетко сопоставить их с языками вашего проекта.",
  "li_migration_csv_req_3": "<strong>Комментарии:</strong> Столбцы с именами <code>Desc</code>, <code>Description</code> или <code>Comment</code> импортируются как заметки разработчика. Этот список настраивается в <strong>Профиле миграции</strong>.",
  "li_migration_custom_1": "Правый клик в окне Project View -> Create -> Anko Localization -> Migration Profile.",
  "li_migration_custom_2": "<strong>Правила:</strong> Определите правила преобразования (если [Исходный компонент] с [Контекстным фильтром], то преобразовать в [Целевой компонент]). Правила поддерживают <strong>Приоритет</strong> (более высокие значения обрабатываются первыми), <strong>Сбор ресурсов</strong> (автоматически извлекает и регистрирует ссылки на ресурсы, такие как Sprites или Audio), и <strong>Контекстную фильтрацию</strong> для различения нескольких компонентов на одном объекте.",
  "li_migration_fallback_keys": "<strong>Поля резервных ключей:</strong> Укажите дополнительные имена полей для проверки при извлечении ключей из устаревших компонентов. Полезно, если ваша старая система использует нестандартные имена свойств для ключей.",
  "li_migration_gs_1": "<strong>Доступ:</strong> Таблица должна быть общедоступной ('Anyone with the link can view') или Опубликована в Интернете.",
  "li_migration_gs_2": "<strong>Вкладки таблицы (GID):</strong> URL должен включать параметр <code>gid=...</code>. Он указывает инструменту, какую именно вкладку читать (например, <code>gid=0</code> обычно является первой вкладкой/листом).",
  "li_migration_ignored_headers": "<strong>Игнорируемые заголовки CSV:</strong> Определите столбцы, которые следует пропускать во время импорта (например, 'Type', 'Description'). Это предотвращает обработку инструментом столбцов метаданных как языковых данных.",
  "li_migration_legacy_components": "<strong>Дополнительные устаревшие компоненты:</strong> Вручную перечислите имена компонентов, которые инструмент должен обнаруживать как 'устаревшие' во время сканирования миграции, даже если прямое правило преобразования не определено.",
  "li_migration_profile_details": "<strong>Расширенные настройки профиля:</strong><ul><li><code>CsvKeyHeader</code>: Имя заголовка для столбца Ключ.</li><li><code>CsvCommentHeaders</code>: Список заголовков, которые следует рассматривать как заметки/комментарии разработчика.</li><li><code>IgnoredCsvHeaders</code>: Столбцы, которые нужно пропустить (метаданные, такие как 'Type' или 'Status'), чтобы они не обрабатывались как языки.</li><li><code>AssetExtensions</code>: Типы файлов, распознаваемые как ресурсы во время сканирования.</li><li><code>FallbackKeyFields</code>: Дополнительные имена полей для проверки, если основное поле ключа пусто.</li></ul>",
  "li_migration_rule_fields": "<strong>Конфигурация правила:</strong><ul><li><code>Priority</code>: Более высокие значения обрабатываются первыми. Используйте это для обработки конкретных случаев перед общими.</li><li><code>Context Filter</code>: Применять правило только в том случае, если на том же объекте присутствует определенный компонент (например, <code>Text</code>).</li><li><code>Harvest Assets</code>: Если включено, извлекает текущий ресурс (например, Sprite) из устаревшего компонента и регистрирует его в таблице ресурсов.</li><li><code>Asset Field Path</code>: Путь к полю, содержащему ссылку на ресурс для сбора.</li><li><code>Additional Data Path</code>: Используется для сложных компонентов, таких как Dropdowns, для сбора нескольких значений/опций.</li></ul>",
  "li_migration_stubs_1": "<strong>Проблема:</strong> Вы удаляете старые ассеты плагина. Unity обнаруживает отсутствующие скрипты (например, отсутствует компонент <code>Localize</code>). Редактор переходит в режим ошибок компиляции.",
  "li_migration_stubs_2": "<strong>Решение:</strong> Функция 'Emergency Stubs' генерирует легковесные, пустые классы с точно такими же именами и пространствами имен, как у старого плагина. Это удовлетворяет компилятор.",
  "li_migration_stubs_3": "<strong>Рабочий процесс:</strong> 1. Нажмите <strong>Включить аварийные заглушки</strong> (это добавляет <code>ANKO_ENABLE_MIGRATION_STUBS</code> в настройки вашего проекта). 2. Удалите старую папку плагина. 3. Unity успешно перекомпилируется, используя поддельные классы. 4. Запустите <strong>Конвертер компонентов</strong>, чтобы заменить заглушки официальными компонентами. 5. Нажмите <strong>Отключить заглушки</strong> после завершения рефакторинга.",
  "li_migration_tool_converter": "<strong>Шаг 2: Конвертер компонентов:</strong> Сканируйте сцены и префабы. Автоматически заменяет старые компоненты (например, <code>Localize</code>) на <code>LocalizedText</code> / <code>LocalizedAsset</code>, перенося ключи.",
  "li_migration_tool_fields": "<strong>Настройки профиля:</strong> Настраиваемый тип 'Source Plugin' и правила 'Asset Mapping' обеспечивают корректную передачу текстур и аудио.",
  "li_migration_tool_import": "<strong>Шаг 1: Импорт данных:</strong> Импортируйте файлы CSV (I2) или XLIFF (Unity Loc) для создания базы данных ключей.",
  "li_migration_tool_profiles": "<strong>Профили миграции:</strong> Создавайте пользовательские профили для сопоставления ассетов и настроек из сторонних плагинов (I2, Unity Loc).",
  "li_migration_tool_safemode": "<strong>Безопасный режим и аварийные заглушки:</strong> Компоненты отключаются, а не удаляются. Включает критически важную функцию <strong>Аварийных заглушек</strong> (активируется через символ определения <code>ANKO_ENABLE_MIGRATION_STUBS</code>): генерирует поддельные классы-заполнители для I2 Localization или Unity Localization, чтобы ваш проект мог быть скомпилирован сразу после удаления этих плагинов. Это предотвращает ошибки \"The type name 'Localize' could not be found\" и дает вам время для правильного рефакторинга кода для использования новой системы. Включение заглушек позволяет исправить ошибки компиляции после удаления старого плагина локализации.",
  "li_migration_tool_setup": "<strong>Шаг 0: Настройка:</strong> Настройте имена компонентов (например, <code>Localize</code> для I2) и поля, где хранится ключ. Доступны пресеты.",
  "li_migration_workflow_1": "<strong>1. Резервное копирование:</strong> Зафиксируйте свой проект в системе контроля версий (Git) или сделайте резервную копию файла перед началом.",
  "li_migration_workflow_2": "<strong>2. Включите Stubs:</strong> Откройте Migration Tool -> вкладка 'Safe Mode'. Нажмите <strong>Enable Emergency Stubs</strong> для вашей целевой системы (I2/UnityLoc). Это создает легковесные фиктивные классы в вашем проекте.",
  "li_migration_workflow_3": "<strong>3. Удалите старый плагин:</strong> Удалите папку старого плагина (например, 'Assets/Plugins/I2'). Unity перекомпилируется. Благодаря Stubs вы <strong>НЕ</strong> получите ошибки 'Type not found', сохраняя все ссылки на компоненты в Prefabs.",
  "li_migration_workflow_4": "<strong>4. Импорт данных:</strong> На вкладке 'Import Data' загрузите исходный CSV/XLIFF. Проверьте предварительный просмотр и нажмите <strong>Import</strong>. Это заполнит таблицы переводов AnKo.",
  "li_migration_workflow_5": "<strong>5. Преобразование компонентов:</strong> На вкладке 'Component Converter' выберите 'Entire Project' и нажмите <strong>Scan & Convert</strong>. Инструмент заменит старые заглушки компонентами 'LocalizedText'/'LocalizedAsset', передавая ключи.",
  "li_migration_workflow_6": "<strong>6. Очистка:</strong> Как только все заработает, нажмите <strong>Disable Stubs</strong> и позвольте Unity перекомпилироваться снова.",
  "li_notes_1": "<strong>Резервные копии:</strong> Всегда создавайте резервную копию через <strong>Translation Table Editor -> Manage Backups</strong> перед внесением серьезных изменений. Резервные копии хранятся в папке <code>LocalizationBackups</code> <strong>в корне проекта (за пределами папки Assets)</strong>, чтобы сохранить ваш Unity-проект чистым и сократить время импорта.",
  "li_notes_2": "<strong>Безопасность API-ключа:</strong> Ключ для работы в редакторе хранится локально на вашей машине (в <code>EditorPrefs</code>) и не попадает в репозиторий. Для ключей, нужных в сборке игры, используйте секцию <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Папка <code>StreamingAssets</code>:</strong> Файлы переводов должны находиться во вложенной папке <code>Assets/StreamingAssets/</code>, чтобы быть включенными в сборку игры.",
  "li_notes_4": "<strong>«Защита от дурака»:</strong> Инструмент автоматически защищает вас от случайного сохранения временных данных из режима предварительного просмотра в сцену или префаб.",
  "li_notes_5": "<strong>Производительность:</strong> Вызов <code>_()</code> выполняется быстро, но в циклах, которые выполняются каждый кадр (например, в <code>Update</code>), старайтесь кэшировать результат в переменной.",
  "li_notes_6": "<strong>Исключение <code>LanguageSelector</code> из парсинга:</strong> Объект с компонентом <code>LanguageSelector</code> и его <code>TMP_Dropdown</code> должен быть добавлен в список <strong>Ignore Specific Objects</strong> на вкладке <strong>Content</strong>. Это необходимо, чтобы парсер не создавал лишние ключи для опций выпадающего списка, поскольку скрипт <code>LanguageSelector</code> заполняет их динамически во время выполнения. Игнорирование предотвращает конфликты и сохраняет файлы переводов чистыми.",
  "li_notes_7": "<strong>Шрифты для <code>LanguageSelector</code>:</strong> Чтобы выбранный язык в <code>TMP_Dropdown</code> корректно обновлял свой шрифт, вручную добавьте пустой компонент <code>LocalizedText</code> на дочерний объект <strong>Label</strong> выпадающего списка и установите флажок <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Код и Addressables:</strong> Если вы переключаетесь на режим <strong>Addressables (Async)</strong>, вы ОБЯЗАНЫ использовать <code>GetLocalizedAssetAsync<T>()</code> в ваших скриптах. Вызов синхронного <code>GetLocalizedAsset<T>()</code> вернет null и выведет предупреждение, чтобы предотвратить зависание основного потока.",
  "li_notes_addressables_sync_warning": "<strong>Синхронный vs. Асинхронный:</strong> Если вы переключаетесь на режим <strong>Addressables (Async)</strong>, вы ОБЯЗАНЫ обновить свой код, чтобы использовать <code>GetLocalizedAssetAsync<T>()</code>. Вызов синхронного метода вернет null и выведет предупреждение, чтобы избежать зависания основного потока.",
  "li_preview_1": "<strong>Как это работает:</strong> Выберите язык из списка, и инструмент мгновенно применит соответствующие переводы, шрифты, настройки RTL и ассеты ко всем локализуемым объектам в активной сцене или открытом префабе.",
  "li_preview_2": "<strong>Заполнители (Placeholders):</strong> Если на вкладке <strong>Settings</strong> выбран стиль заполнителя (например, <strong>Accents</strong> или <strong>Brackets</strong>), в режиме предварительного просмотра будут отображаться эти заполнители вместо фактических переводов. Это идеально подходит для тестирования макета и поиска нелокализованных элементов.",
  "li_preview_3": "<strong>Безопасность:</strong> Все изменения, внесенные в режиме предварительного просмотра, являются временными. Инструмент автоматически вернет все в исходное состояние, когда вы выберете \"<strong>Revert to Original</strong>\", закроете окно, смените сцену или перед сохранением сцены/префаба (благодаря компоненту <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Защита от сбоев:</strong> Система автоматически создает резервную копию состояния сцены в папку <code>Library</code> перед предпросмотром. Если Unity аварийно завершит работу или вы принудительно выйдете во время предпросмотра, инструмент обнаружит файл восстановления при следующем запуске и предложит восстановить исходное состояние сцены.",
  "li_preview_overlay_1": "<strong>Доступ:</strong> Оверлей появляется автоматически в окне Scene View. Вы можете переключать его через меню Unity Overlay (клавиша <code>Space</code> в Scene View).",
  "li_preview_overlay_2": "<strong>Функциональность:</strong> Предоставляет выпадающее меню для быстрого переключения текущего языка предварительного просмотра без открытия основного окна.",
  "li_report_1": "<strong>Категории:</strong> Все ключи, Добавлено, Обновлено (текст изменился), Удалено, Дубликаты, Мигрировано, Пропущено (не изменилось).",
  "li_report_2": "<strong>Продвинутый поиск:</strong> Нажмите кнопку <strong>Find</strong> рядом с любой записью, чтобы мгновенно найти соответствующий объект в проекте. Поиск работает асинхронно, не блокируя редактор, и ищет по всем сценам и префабам.",
  "li_report_all_keys": "<strong>Все ключи:</strong> Список всех ключей локализации, обнаруженных в проекте, с возможностями поиска и фильтрации.",
  "li_report_btn_clear": "<strong>Очистить отчет:</strong> Удаляет все результаты сканирования из памяти текущей сессии.",
  "li_report_btn_copy_all": "<strong>Скопировать все ключи:</strong> Копирует все ключи локализации в текущей категории в системный буфер обмена.",
  "li_report_btn_load_last": "<strong>Загрузить последнее сканирование:</strong> Мгновенно восстанавливает результаты последнего анализа проекта без повторного сканирования.",
  "li_report_btn_save": "<strong>Сохранить отчет:</strong> Экспортирует текущие результаты сканирования в текстовый или CSV файл для внешней документации или аудита.",
  "li_report_source_filter": "<strong>Фильтр источника:</strong> Сужает результаты по их происхождению (например, показывать только ключи, найденные в Scripts, Scenes или Prefabs).",
  "li_safety_global_limit": "<strong>Глобальный месячный лимит:</strong> <code>monthlyCharLimit</code> (по умолчанию: 500,000 символов) действует как предохранитель для всех запросов. Вы можете переключать предупреждения через <code>enableApiLimitWarning</code>.",
  "li_safety_profile_limit": "<strong>Лимиты профиля:</strong> Каждый профиль перевода позволяет устанавливать собственные 'Max Chars Per Request' и 'Batch Size'.",
  "li_settings_1": "<strong>Режим генерации ключей:</strong> Определяет стратегию создания уникальных идентификаторов для вашего текста:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(По умолчанию - Рекомендуется)</strong>: Генерирует ключи на основе имени сцены/Prefab и иерархии объектов (например, <code>scene_Menu_BtnPlay_682412</code>). Лучше всего подходит для больших проектов, так как гарантирует уникальность и невосприимчив к изменениям текста.</li><li><code>UseTextAsKey</code>: Использует сам исходный текст в качестве ключа (например, \"Start Game\" → <code>Start Game</code>). Идеально для быстрого прототипирования, где ключи должны быть удобочитаемыми.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Гибридный)</strong>: Самый гибкий режим. Сначала проверяет, есть ли у компонента уже вручную назначенный ключ или <code>[LocalizableField(key=\"...\")]</code>. Если ключа нет, он генерирует иерархический ключ. <em>Используйте это, чтобы сохранить существующую работу, автоматизируя новый контент.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Гибридный)</strong>: Как и выше, но возвращается к самому тексту, если ручной ключ не найден. Учитывает существующие компоненты и данные.</li><li><code>Manual</code>: Сканер никогда не создает новые ключи. Он только обновляет объекты, которые уже имеют компонент локализации с ключом. Идеально для строгого ручного управления.</li></ul>",
  "li_settings_10": "<strong>Dev Tools:</strong> В нижней части вкладки Settings можно найти служебные кнопки, такие как <strong>Clear Saved Language Pref</strong> (сбрасывает сохраненный язык в PlayerPrefs, чтобы игра снова запускалась с Default language).",
  "li_settings_11": "<strong>Технические опции Dropdown:</strong> Список строковых значений (по умолчанию: 'Option A', 'Option B', 'Option C'), которые парсер будет <strong>игнорировать</strong> при сканировании Dropdown'ов. Это позволяет сохранить вашу таблицу переводов чистой от стандартного UI-текста-заполнителя Unity.",
  "li_settings_2": "<strong>Управление языками:</strong><ul><li><strong>Source Language:</strong> Язык, используемый в ваших Unity-сценах/префабах (язык разработки).</li><li><strong>Default Language:</strong> Язык, выбранный при первом запуске игры, если системный язык пользователя не поддерживается.</li><li><strong>Список:</strong> Управляйте поддерживаемыми языками, назначайте специальные <strong>Font Assets</strong> и включайте поддержку <strong>RTL</strong>.</li></ul>",
  "li_settings_3": "<strong>Общие настройки:</strong> Конфигурация общепроектного поведения:<ul><li><code>Translations Save Path</code>: Корневой каталог для хранения файлов переводов <code>.json</code>. Для доступа в игре он должен находиться внутри <code>Assets/Resources</code> или <code>Assets/StreamingAssets</code>.</li><li><code>Safe Mode</code>: Защитный слой, который блокирует операции (например, автоматический перевод), если обнаружены несоответствия проекта или отсутствующие зависимости.</li><li><code>Remove Missing Keys</code>: Если включено, сканер автоматически удалит записи из базы данных, которые больше не присутствуют ни в одной сцене или Prefab во время обновления проекта.</li><li><code>Parse Inactive Objects</code>: Определяет, должен ли инструмент сканировать и локализовать отключенные или скрытые GameObjects.</li><li><code>Parse All Prefabs</code>: Сканирует каждый Prefab в проекте. Если отключено, обрабатываются только Prefabs в папках, указанных на вкладке <strong>Контент</strong>.</li><li><code>Fill Comments By Paths</code>: Автоматически заполняет поле 'Комментарий' в таблице переводов путем иерархии объекта в сцене/Prefab.</li><li><code>Split Files by Language</code>: Разделяет базу данных переводов на несколько файлов (например, <code>en.json</code>, <code>ja.json</code>). Настоятельно рекомендуется для больших проектов, чтобы уменьшить накладные расходы на память во время выполнения.</li><li><code>Allow Empty Source/Keys</code>: Позволяет инструменту регистрировать и отслеживать объекты, даже если их исходный текст пуст. Полезно для динамического текста, который устанавливается исключительно через код.</li><li><code>Attach to Regex-Ignored Text</code>: Принуждает инструмент добавлять компоненты локализации к объектам, текст которых соответствует исключающему регулярному выражению (например, числам), что позволяет вручную переопределять.</li><li><code>Find Settings Asset</code>: Утилитарная кнопка, которая мгновенно находит и выбирает файл <code>LocalizationSettings.asset</code> в окне вашего проекта.</li></ul>",
  "li_settings_4": "<strong>Отладка и тестирование:</strong><ul><li><code>Placeholder Style</code>: Выберите стиль отображения заполнителей в режиме предварительного просмотра.</li><li><code>Pseudo-Localization</code>: Выберите <strong>'Пользовательский псевдо'</strong>, чтобы отобразить расширенные настройки тестирования макета (Коэффициент расширения, Акценты и Разделители).</li></ul>",
  "li_settings_5": "<strong>Live Updates:</strong> Настройки для загрузки переводов с удаленного сервера.",
  "li_settings_6": "<strong>Ключ API для рантайма:</strong> Надежно хранит ваш ключ API для <strong>Live Updates</strong> (получение новых переводов в игре). Он отличается от ключей Translation Service, используемых в редакторе. Ключ <strong>обфусцируется</strong> (шифруется) в сборке для предотвращения легкого извлечения с помощью поиска по строкам, но помните: ни один клиентский секрет не является на 100% безопасным.",
  "li_settings_7": "<strong>Стратегия загрузки ассетов:</strong> Выбор между <code>Resources (Legacy)</code>, <code>Addressables (Async)</code> и <code>Custom</code>. Внимание: Изменение этого режима требует повторного сканирования проекта. Режим Addressables настоятельно рекомендуется для мобильных устройств и WebGL для снижения потребления памяти.",
  "li_settings_8": "<strong>Автоматический перевод:</strong> Использует систему <strong>Профилей перевода</strong> для локализации на основе AI. Конфигурация включает:<ul><li><code>Text & Audio Profiles</code>: Выберите или создайте профили ScriptableObject для настройки различных сервисов (например, OpenAI, DeepL, Google).</li><li><code>Presets Folder</code>: Каталог, где хранятся ваши предустановки и профили перевода.</li><li><code>Target Languages</code>: Список всех языков проекта со статусом в реальном времени, индикаторами прогресса и количеством символов для выбранного профиля.</li><li><code>Start Auto Translation</code>: Начинает процесс для всех выбранных языков с использованием указанных профилей.</li></ul>",
  "li_settings_9": "<strong>Улучшения отладки:</strong><ul><li><code>Show Hierarchy Icons</code>: Отображает значки состояния (Зеленая галочка / Желтое предупреждение) в иерархии. <strong>Оптимизировано по производительности:</strong> Использует кэширование для обеспечения нулевой задержки даже в больших сценах.</li><li><code>Show Scene View Labels</code>: Визуальная отладка непосредственно в окне сцены. Метки интерактивны: Щелкните правой кнопкой мыши по любой метке сцены, чтобы мгновенно скопировать ключ локализации в буфер обмена.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Правило структуры папок:</strong> Определяет, как структурируются подпапки при генерации локализованных ресурсов (например, <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Имя класса-моста:</strong> Позволяет настроить имя генерируемого статического класса (по умолчанию <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Безопасный режим:</strong> Гарантирует, что критически важные операции не будут выполнены, если они могут привести к несогласованным состояниям проекта.",
  "li_settings_lang_culture_fallback": "<strong>Использовать региональный резерв:</strong> Если конкретный региональный диалект (например, <code>en-AU</code>) отсутствует, инструмент попытается использовать базовый язык (<code>en</code>) перед возвратом к <strong>Языку по умолчанию</strong>.",
  "li_settings_lang_follow_system": "<strong>Следовать системному языку:</strong> Автоматически переключает язык игры в соответствии с языком ОС игрока при первом запуске.",
  "li_settings_live_updates_security": "<strong>Безопасность:</strong> ключи API рантайма шифруются (AES) в сборке для предотвращения случайного извлечения. Всегда используйте HTTPS.",
  "li_settings_pseudo_accents": "<strong>Использовать акценты:</strong> Заменяет стандартные символы на версии с акцентами (например, <code>å</code>, <code>é</code>). Используйте это, чтобы убедиться, что ваши шрифты поддерживают все необходимые глифы.",
  "li_settings_pseudo_brackets": "<strong>Добавить скобки:</strong> Оборачивает текст в <code>[ ]</code> для проверки начала и конца локализованных строк, помогая выявлять проблемы с усечением или конкатенацией текста.",
  "li_settings_pseudo_expand_length": "<strong>Расширить длину:</strong> Имитирует расширение текста, характерное для таких языков, как немецкий или русский, путем добавления конечных символов.",
  "li_settings_pseudo_expansion_factor": "<strong>Коэффициент расширения:</strong> Множитель для симуляции длины текста (например, 2.0 сделает текст в два раза длиннее).",
  "li_settings_pseudo_prefix": "<strong>Пользовательский префикс:</strong> Добавляет определенную строку (например, <code>PSEUDO-</code>) в начало каждого локализованного текста.",
  "li_settings_pseudo_suffix": "<strong>Пользовательский суффикс:</strong> Добавляет определенную строку в конец каждого локализованного текста.",
  "li_settings_return_source": "<strong>Возвращать источник, если отсутствует:</strong> Если включено, система вернет текст на языке источника (или сам ключ), если перевод для текущего языка не найден.",
  "li_settings_tms_timeout": "<strong>Таймаут TMS:</strong> Указывает максимальное время ожидания (в секундах) для сетевых запросов к внешним службам TMS.",
  "li_settings_tool_check_deps": "<strong>Проверить зависимости:</strong> Повторно сканирует проект на наличие необходимых пакетов (например, Newtonsoft) и дополнительных интеграций.",
  "li_settings_tool_cleanup": "<strong>Полная очистка проекта:</strong> Деструктивный инструмент, который удаляет все компоненты и данные Anko Localization из проекта (используйте с осторожностью!).",
  "li_settings_tool_clear_prefs": "<strong>Очистить настройки языка:</strong> Сбрасывает сохраненный язык в PlayerPrefs, принуждая игру использовать язык по умолчанию или системный язык при следующем запуске.",
  "li_settings_tool_font_manager": "<strong>Менеджер шрифтов:</strong> Открывает менеджер шрифтов и глифов для анализа отсутствующих символов и генерации оптимизированных шрифтовых ресурсов.",
  "li_settings_tool_migration": "<strong>Инструмент миграции:</strong> Упрощает перенос данных и компонентов из I2 Localization или Unity Localization.",
  "li_settings_tool_test_center": "<strong>Центр тестирования локализации:</strong> Диагностический инструмент для проверки работоспособности проекта, поиска нарушенных ссылок и обеспечения целостности локализации.",
  "li_setup_1": "<strong>Создание настроек:</strong> При первом открытии инструмент создаст файл <code>LocalizationSettings.asset</code> в папке <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Настройка языков и режима:</strong> На вкладке <strong>Settings</strong> убедитесь, что ваш <strong>Source Language</strong> указан правильно. Также проверьте <strong>Key Generation Mode</strong> (по умолчанию установлен <code>AutoGenerateKeysOnly</code>, что рекомендуется для большинства проектов).",
  "li_setup_3": "<strong>Указание контента для парсинга:</strong> Во вкладке <strong>Content</strong> добавьте все сцены для анализа в список <strong>Scenes to Parse</strong>. Если вы используете префабы с текстом, убедитесь, что их папки добавлены в <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Первый запуск парсера:</strong> Перейдите на вкладку <strong>Actions</strong> и нажмите кнопку <code>Update Keys</code>. Инструмент просканирует ваш проект, создаст файлы переводов и автоматически добавит необходимые компоненты (<code>LocalizedText</code>, <code>LocalizedAsset</code> и т.д.) к игровым объектам.",
  "li_setup_5": "<strong>Настройки и сборки (КРИТИЧЕСКИ ВАЖНО):</strong> Инструмент автоматически добавляет <code>LocalizationSettings.asset</code> в <code>Project Settings -> Player -> Preloaded Assets</code>. <br>⚠️ <strong>Проверка безопасности:</strong> Если настройки отсутствуют в Preloaded Assets и не находятся в папке Resources, инструмент <strong>заблокирует сборку</strong> с помощью <code>BuildFailedException</code>, чтобы предотвратить сбой игры при запуске.",
  "li_sidebar_presets": "<strong>Предустановки поиска:</strong> Предопределенные фильтры для общих задач, таких как поиск непереведенных строк или ключей с отсутствующими заполнителями.",
  "li_sidebar_search": "<strong>Глобальный поиск:</strong> Поиск конкретных ключей или текста по всем таблицам в вашем проекте.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Требует Project ID и API Key. Поддерживает загрузку исходных XLIFF и скачивание переводов в виде ZIP архива. <em>Дополнительно:</em> <code>File Name</code> (целевой путь в Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Требует API Key. Простая и быстрая интеграция для небольших проектов. <em>Дополнительно:</em> <code>Import/Export Params</code> (позволяет добавлять дополнительные флаги Loco API, такие как <code>&tag=v1</code> или <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Управление локализацией корпоративного уровня. <em>Дополнительно:</em> Флаги <code>Update Translations/Descriptions</code> для контроля того, перезаписывает ли Phrase существующие данные при загрузке.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Поддерживает слагоны организации/проекта и аутентификацию по API Token. <em>Дополнительно:</em> <code>Resource Slug</code> (автоматически создает ресурс, если он не существует).",
  "li_tutorials_1": "<strong>Интерактивное обучение:</strong> Руководства выделяют определенные элементы пользовательского интерфейса и ожидают ваших действий.",
  "li_tutorials_2": "<strong>Доступные уроки:</strong>",
  "li_tutorials_editor": "<strong>Редактор переводов:</strong> Расширенные функции редактора в виде электронной таблицы.",
  "li_tutorials_list": "<strong>Список руководств:</strong> Доступ к интерактивным руководствам по основным функциям инструмента.",
  "li_tutorials_migration": "<strong>Миграция:</strong> Как перейти с других систем локализации (I2, Unity Localization).",
  "li_tutorials_quickstart": "<strong>Быстрый старт:</strong> Базовая настройка текста и ассетов.",
  "li_tutorials_size": "<strong>Размер руководства:</strong> Настраивает масштаб пользовательского интерфейса и детализацию интерактивных руководств (от компактного до очень большого). Находится в заголовке вкладки «Руководства».",
  "li_vis_debug_1": "<strong>Иконки иерархии:</strong> Мгновенно выявляйте проблемы (Отсутствует ключ, Отсутствует компонент). Оптимизированы для нулевого влияния на производительность.",
  "li_vis_debug_2": "<strong>Метки в Scene View:</strong> Отображает ключ над каждым локализованным объектом. <strong>Щелкните правой кнопкой мыши</strong> по метке, чтобы 'Copy Key' или 'Select Object'.",
  "li_vis_debug_3": "<strong>Оверлеи:</strong> Используйте оверлей окна сцены (пробел) для мгновенного переключения языков предварительного просмотра.",
  "lightbox_aria_close": "Закрыть просмотрщик изображений",
  "lightbox_image_alt": "Увеличенный вид",
  "mindmap_edge_configure": "1. Настроить",
  "mindmap_edge_creates_components": "Создает компоненты",
  "mindmap_edge_defines_rules": "Определяет правила для",
  "mindmap_edge_edited_in": "Редактируется в",
  "mindmap_edge_enables_reaction": "Включает реакцию через",
  "mindmap_edge_extends": "Расширяет",
  "mindmap_edge_generates": "Генерирует",
  "mindmap_edge_manages_assets": "Управляет активами для",
  "mindmap_edge_opens": "Открывает",
  "mindmap_edge_parse_project": "3. Разобрать проект",
  "mindmap_edge_processed_by": "Обрабатывается",
  "mindmap_edge_recommends_for": "Рекомендует для",
  "mindmap_edge_relates_to": "Относится к",
  "mindmap_edge_reports_on": "Отчитывается о",
  "mindmap_edge_see_faq": "Смотри FAQ",
  "mindmap_edge_specify_content": "2. Указать содержимое",
  "mindmap_edge_warns_about": "Предупреждает о",
  "mindmap_node_ai_ecosystem": "Экосистема ИИ",
  "mindmap_node_async_code": "Асинхронный / Addressables",
  "mindmap_node_dev_tools": "Инструменты и утилиты",
  "mindmap_node_tms_integration": "Интеграция TMS",
  "mindmap_preset_ai": "ИИ и автоматизация",
  "mindmap_preset_dev": "Рабочий процесс разработчика",
  "mindmap_preset_full": "Полный вид",
  "mindmap_preset_quick_start": "Быстрый старт",
  "mindmap_preset_tools": "Инструменты и интеграции",
  "mindmap_preset_translator": "Рабочий процесс переводчика",
  "mindmap_toggle_title": "Показать карту связей",
  "my_notes_title": "Мои примечания",
  "no_notes_message_new": "Наведите на текст, чтобы добавить примечание.",
  "notes_add_title": "Добавить примечание к этому блоку",
  "notes_close_title": "Закрыть",
  "notes_delete_title": "Удалить примечание",
  "notes_edit_text": "Редактировать",
  "notes_edit_title": "Редактировать примечание",
  "notes_goto_title": "Перейти к тексту",
  "notes_placeholder": "Ваше примечание...",
  "on_this_page_title": "На этой странице",
  "p_actions_1": "Основная рабочая вкладка.",
  "p_ai_assistant": "В Редакторе таблицы переводов теперь можно запускать пользовательские команды AI для выбранных ячеек через контекстное меню (Правый клик -> AI: ...).",
  "p_ai_audio_economy": "<strong>Экономия средств:</strong> Инструмент рассчитывает MD5-хеш вашего текста и регенерирует аудиофайлы, только если исходный текст изменился, экономя ваши кредиты API. Если вы измените перевод, система пометит только этот конкретный аудиофайл как 'Outdated'. Используйте 'Generate Missing/Outdated' для регенерации только того, что изменилось, экономя кредиты API. Инструмент хеширует ваш текст и регенерирует аудиофайлы, только если исходный текст изменился, экономя ваши кредиты API благодаря умной пакетной обработке.",
  "p_ai_context": "Для повышения качества перевода AI теперь получает дополнительный контекст:",
  "p_ai_intro": "Инструмент использует систему <strong>профилей перевода</strong> (ScriptableObject). Это позволяет хранить настройки сервиса перевода в отдельных ассетах профилей, что упрощает переключение между конфигурациями.",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code> предоставляет надежный API для управления локализацией во время выполнения. Ниже приведены ключевые методы, которые вы будете использовать в своих скриптах.",
  "p_assets_1": "Эта вкладка полностью посвящена локализации нетекстовых ресурсов.",
  "p_async_api": "При использовании Addressables ресурсы загружаются не мгновенно. Необходимо использовать асинхронный API, чтобы избежать падения кадров.",
  "p_bridge_description": "Инструмент включает генератор статических классов для доступа к ключам, позволяя использовать строго типизированные ссылки вместо «магических строк». Это помогает предотвратить опечатки и включает автодополнение в IDE.",
  "p_bridge_usage_title": "Пример использования:",
  "p_components_intro": "Эти компоненты являются «мостом» между вашими объектами в сцене и базой данных переводов. Они «слушают» изменения языка и автоматически подставляют нужный текст или ассет.",
  "p_content_1": "Здесь вы говорите инструменту, где именно искать текст. Интерфейс был полностью переработан для лучшего удобства использования.",
  "p_custom_ai": "Тип сервиса <strong>Custom AI</strong> позволяет подключить любой LLM через REST API.",
  "p_custom_asset_provider_1": "Разработка пользовательского провайдера позволяет интегрировать вашу собственную систему управления ассетами (например, пользовательский облачный загрузчик, специфическую внутреннюю систему пакетирования или репозиторий ассетов на основе базы данных) непосредственно в рабочий процесс локализации.",
  "p_custom_asset_provider_intro": "Система Asset Provider абстрагирует способ загрузки ассетов (Sprites, Audio, Prefabs и т.д.) во время выполнения. Она использует <strong>реестр плагинов</strong>, который автоматически обнаруживает любую реализацию класса <code>IAssetProvider</code>, помеченную атрибутом <code>[AssetProviderPlugin]</code>. Это позволяет беспрепятственно интегрировать пользовательские системы загрузки (например, облачные загрузчики или внутреннюю упаковку) без изменения основного набора инструментов.",
  "p_custom_attributes_description": "В дополнение к вызовам функций, вы можете пометить любое строковое поле в ваших скриптах как локализуемое с помощью пользовательских атрибутов. По умолчанию инструмент распознает <code>[LocalizableField]</code>, но вы можете добавить любое имя атрибута (например, <code>[Header]</code> или <code>[Tooltip]</code>) в список <strong>Attributes to Scan</strong>.",
  "p_custom_parser_1": "Вы можете легко расширить систему для поддержки пользовательских компонентов, создав свой собственный класс парсера.",
  "p_editor_1": "Открывается через <strong>Tools -> Localization -> Translation Table Editor</strong>. Это основной инструмент для ручного редактирования переводов.",
  "p_example_attribute_1": "Самый мощный способ локализовать переменные скриптов. Он работает с полями <strong>private, protected, and public</strong>. Парсер рекурсивно обрабатывает <strong>Arrays, Lists</strong>, и <strong>Nested Serializable Classes</strong>. Он даже может генерировать ключи для других атрибутов (например <code>[Header]</code> или <code>[Tooltip]</code>), если это настроено в Настройки.",
  "p_example_components_1": "В проект включены готовые к использованию скрипты, которые служат отличными примерами.",
  "p_example_components_updated": "Код был изменен. Загрузка языка (особенно при использовании Addressables) теперь асинхронна.",
  "p_example_function_1": "Используйте функцию <code>_()</code> для динамического текста, который меняется во время игры. Метод, который обновляет UI, должен быть помечен атрибутом <code>[OnLanguageChange]</code>, чтобы он вызывался автоматически при смене языка. Для этой цели к объекту будет автоматически добавлен компонент <code>LocalizedBehaviour</code>.",
  "p_example_plurals_1": "Инструмент теперь использует более точные правила для разных языковых групп.",
  "p_font_glyph_manager_access": "Доступ через <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "Этот инструмент представляет собой комплексное решение для локализации игр и приложений в Unity. Он автоматизирует процесс сбора текста и ассетов, управления переводами через мощный интерфейс, интеграции со службами машинного перевода (включая Custom AI) и динамического обновления локализованного контента в игре.",
  "p_live_updates_guide": "Система Live Updates позволяет вашей игре получать новые переводы с удаленного сервера или Google Sheet во время выполнения, не требуя новой сборки.",
  "p_localizedasset_1": "Используется для подмены активов в зависимости от языка. Автоматически определяет тип компонента. Поддерживает: <ul><li><strong>2D:</strong> Sprites (<code>Image</code>, <code>SpriteRenderer</code>), Textures (<code>RawImage</code>).</li><li><strong>Аудио/Видео:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Анимация:</strong> <code>MeshFilter</code> (Меши), <code>Renderer</code> (Материалы), <code>Animator</code> (Контроллер), <code>PlayableDirector</code> (Timeline).</li></ul>",
  "p_localizedasset_2": "Для компонентов с опцией <strong>Play on Awake</strong> (таких как <code>AudioSource</code>, <code>VideoPlayer</code>) <code>LocalizedAsset</code> корректно перехватывает автозапуск, подменяет ассет, а затем запускает воспроизведение, чтобы избежать проигрывания нелокализованного контента.",
  "p_localizedasset_updated": "Компонент теперь поддерживает асинхронную загрузку. Обратите внимание, что может быть небольшая задержка при смене языков, если ассеты загружаются из облака/с диска (Addressables).",
  "p_localizedbehaviour_1": "Вспомогательный компонент, который позволяет вашим скриптам реагировать на изменения языка. Он автоматически находит и вызывает методы, помеченные атрибутом <code>[OnLanguageChange]</code>.",
  "p_localizeddropdown_1": "Добавляется к <code>Dropdown</code> и <code>TMP_Dropdown</code> для перевода их опций.",
  "p_localizedprefab_1": "Компонент для локализации целых префабов. Работает не деструктивно: он не изменяет оригинальный префаб, а создает экземпляр локализованной версии как дочерний объект, отключая при этом все скрипты (<code>MonoBehaviour</code>), рендереры (<code>Renderer</code>) и коллайдеры (<code>Collider</code>) на оригинальном объекте. Это предотвращает двойное выполнение логики и визуальные артефакты. Для корректной работы в рантайме его порядок выполнения установлен на -100 (<code>[DefaultExecutionOrder(-100)]</code>), чтобы гарантировать его запуск до других скриптов.",
  "p_localizedtext_1": "Основной компонент для отображения переведенного текста. Размещается на объектах с <code>Text</code>, <code>TMP_Text</code> и <code>TextMesh</code>.",
  "p_migration_custom": "Вы можете создавать собственные профили миграции для поддержки пользовательских систем или специфических настроек проекта. Каждый профиль содержит список <strong>Правил</strong>, которые определяют, как должны быть преобразованы компоненты и их поля. Правила проверяются в порядке их <strong>приоритета</strong>.",
  "p_migration_custom_advanced": "Профили миграции предлагают расширенные настройки для точной настройки процесса импорта и обнаружения:",
  "p_migration_google_sheet": "Вы можете импортировать непосредственно из URL-адреса Google Sheet без загрузки файлов.",
  "p_migration_import_csv": "Инструмент поддерживает стандартные CSV-файлы (разделенные запятыми). Первая строка должна быть заголовком.",
  "p_migration_stubs": "Распространенная проблема при миграции заключается в том, что удаление старого плагина (например, I2) нарушает сборку, не позволяя Unity скомпилировать сам инструмент миграции.",
  "p_migration_tool_access": "Доступ через <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Инструмент для перехода с других систем локализации (I2 Localization, Unity Localization).",
  "p_preview_1": "Прямо под заголовком находится выпадающий список <strong>Preview Language</strong>. Эта мощная функция позволяет вам увидеть, как будет выглядеть локализация на любом языке непосредственно в окне <strong>Scene</strong> или <strong>Prefab Mode</strong>, без запуска игры.",
  "p_preview_overlay": "Для еще более быстрой итерации вы можете переключать языки прямо из Scene View, используя специальный <strong>Localization Preview Overlay</strong>.",
  "p_report_1": "После каждого парсинга этот отчет показывает полную картину состояния вашей локализации.",
  "p_safety_caps": "Для предотвращения случайных высоких затрат или больших проверок трафика:",
  "p_script_parsing_rules_description": "Инструмент может быть настроен на распознавание ключей локализации, используемых в пользовательских функциях или даже в конкурирующих системах (таких как I2 Localization), без изменения существующего кода. Это достигается путем определения регулярных выражений, которые сканер использует для извлечения ключей из ваших скриптов.",
  "p_script_parsing_rules_usage": "На вкладке <strong>Content</strong>, в разделе <strong>Script Parsing Rules</strong>, вы можете добавить правила, соответствующие вашим конкретным вызовам функций. Например, для поддержки <code>I2.Loc.Get(\"key\")</code> вы можете добавить правило с шаблоном, который захватывает строку внутри скобок.",
  "p_settings_1": "Ваш центр управления. Здесь вы определяете глобальные правила для всего процесса локализации.",
  "p_tms_intro": "Инструмент теперь поддерживает синхронизацию с популярными системами управления переводами. Вы можете отправлять исходные ключи и получать переводы напрямую в Unity.",
  "p_tms_setup": "1. Перейдите к <strong>Actions -> External Services</strong>.<br>2. Выберите вашего поставщика услуг.<br>3. Введите API-ключи и идентификаторы проектов.<br>4. Используйте кнопки <strong>Push</strong> (Загрузка ключей) и <strong>Pull</strong> (Скачивание переводов) в окне Settings.",
  "p_tutorials_1": "Вкладка «Учебники» предоставляет интерактивные пошаговые руководства, которые помогут вам освоить функции инструмента прямо в редакторе Unity.",
  "p_uitklocalization_1": "Добавляется к объектам с <code>UIDocument</code>. Поддерживает локализацию <strong>Меток, Кнопок, HelpBox, Foldout, ProgressBar (заголовок), TextField (метка и заполнитель), DropdownField (метка и варианты), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), и Подсказок</strong> на любом элементе. Идентификаторы стабильны при переименованиях, если ID установлены в UI Builder.",
  "p_window_footer": "Отображает текущий статус, ход фоновых операций и версию инструмента.",
  "p_window_header": "Верхняя панель обеспечивает глобальный доступ к элементам управления предварительного просмотра и служебным инструментам, которые сохраняются независимо от выбранной вкладки.",
  "p_window_sidebar": "Боковая панель управляет навигацией между различными функциональными вкладками и глобальными инструментами поиска.",
  "page_title": "Документация по Инструменту Локализации Unity",
  "q_faq_addressables_1": "Я включил режим Addressables, но ассеты не загружаются. Что мне нужно проверить?",
  "q_faq_addressables_2": "Как добавить поддержку DeepL/Google?",
  "q_faq_addressables_3": "Мигратор показывает ошибки компиляции после удаления I2/UnityLoc. Как это исправить?",
  "q_faq_audio_smart_update": "Как инструмент экономит кредиты API при регенерации аудиофайлов?",
  "q_faq_components_1": "Компонент LocalizedPrefab отключает MonoBehaviours на исходном объекте. Что, если исходный объект имеет скрипт, который создает другие объекты или подписывается на события в Awake()?",
  "q_faq_components_2": "Если оригинальный префаб (LocalizedPrefab) имеет Rigidbody или другой физический компонент, будет ли он отключен? Повлияет ли это на физику, если локализованный префаб его не имеет?",
  "q_faq_components_3": "Компонент LocalizedAsset хранит имя целевого компонента в виде строки (_targetComponentTypeName). Что произойдет, если я переименую скрипт пользовательского компонента или перемещу его в другую сборку (Assembly Definition)? Перестанет ли LocalizedAsset для него работать?",
  "q_faq_components_4": "Если на одном GameObject есть два компонента Image, как LocalizedAsset узнает, какой из них локализовать? Будет ли он работать с обоими или только с первым найденным?",
  "q_faq_components_5": "В документации указано, что LocalizedPrefab имеет порядок выполнения -100. Что, если у меня есть другой скрипт с порядком выполнения -110, который пытается найти дочерний объект, созданный LocalizedPrefab, в своем Awake()? Успеет ли LocalizedPrefab создать свой экземпляр вовремя?",
  "q_faq_components_6": "Компонент LocalizedText имеет опцию isStyleOnly. Если я ее включу, а затем вызову myLocalizedText.SetFormattedText(\"new_key\") в коде, изменится ли текст или только стиль (шрифт/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour автоматически находит методы с атрибутом [OnLanguageChange]. Будет ли он находить private и protected методы, или они обязательно должны быть public?",
  "q_faq_components_8": "Компонент LocalizedAsset перехватывает Play on Awake. Что произойдет, если другой скрипт на том же объекте попытается получить доступ к ассету (например, audioSource.clip.length) в Awake() или Start() до того, как LocalizedAsset его подменит? Возможна ли ошибка NullReferenceException или использование старого ассета?",
  "q_faq_custom_keys_attribute": "Могу ли я использовать свой собственный атрибут для ключей вместо [LocalizableField]?",
  "q_faq_custom_provider_1": "Почему мой пользовательский провайдер не отображается в выпадающем списке настроек?",
  "q_faq_editor_1": "Что имеет более высокий приоритет для валидации заполнителей: директива @placeholders: в комментарии или заполнители, найденные в тексте исходного языка? Например, если в исходном тексте есть {name}, а комментарий гласит @placeholders: {username}.",
  "q_faq_editor_2": "Если я сделаю опечатку в директиве (например, @placeholder: вместо @placeholders:), будет ли она проигнорирована или инструмент выдаст предупреждение?",
  "q_faq_editor_3": "Система автосохранения создает файлы в папке Backups/AutoSaves. Будут ли эти файлы автоматически удалены после успешного ручного сохранения или закрытия окна?",
  "q_faq_editor_4": "Если я изменю ширину столбцов в редакторе, сохранятся ли эти настройки между сессиями Unity?",
  "q_faq_editor_5": "Поддерживает ли всплывающее окно редактирования текста (MultiLineEditWindow) свой собственный стек Undo/Redo (через Ctrl+Z) для изменений, внесенных внутри него?",
  "q_faq_examples_1": "Что произойдет, если имена свойств в анонимном типе, переданном в функцию _(), не будут совпадать с заполнителями в строке? Например, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Будет ли ошибка, или заполнитель просто не будет заменен?",
  "q_faq_examples_2": "Атрибут [LocalizableField] работает для private полей. Будет ли он работать для static полей?",
  "q_faq_examples_3": "Если я поставлю атрибут [OnLanguageChange] на метод с параметрами (например, void UpdateUI(string newLang)), что произойдет? Будет ли ошибка компиляции или предупреждение во время выполнения?",
  "q_faq_examples_4": "Я использую _(\"apple_count\", count). Если для текущего языка нет ключа apple_count_one (для count = 1), какую форму выберет система? Будет ли она использовать apple_count_other в качестве запасного варианта?",
  "q_faq_examples_5": "Функция _(\"key\", new { username = \"Alex\" }) использует анонимный тип. Не создаст ли это чрезмерную «нагрузку» на сборщик мусора (GC) при частых вызовах в методе Update() по сравнению с передачей предварительно созданного Dictionary<string, object>?",
  "q_faq_examples_6": "Мой метод, помеченный [OnLanguageChange], не вызывается. Почему?",
  "q_faq_extending_1": "Будет ли мой пользовательский парсер вызываться автоматически после каждого Update Keys? Нужно ли его где-то регистрировать, или достаточно просто иметь класс, реализующий ITextComponentParser в проекте?",
  "q_faq_extending_2": "Что если в моем пользовательском парсере произойдет исключение? Прервет ли это весь процесс парсинга, или инструмент безопасно продолжит работу с другими парсерами?",
  "q_faq_installation_1": "Что произойдет, если в моем проекте уже есть пакет com.unity.nuget.newtonsoft-json от другого ассета? Попытается ли установщик зависимостей его обновить или проигнорирует?",
  "q_faq_installation_2": "Я случайно нажал \"Skip for Now\" и установил флажок \"Don't ask again\" для необязательных зависимостей (например, для поддержки CSV). Как я могу снова вызвать окно установщика для их установки?",
  "q_faq_installation_3": "Инструмент не создал LocalizationSettings.asset в Assets/Resources. Почему это могло произойти и могу ли я создать его вручную через меню Assets -> Create?",
  "q_faq_installation_4": "Могу ли я переместить файл LocalizationSettings.asset в другую папку Resources, например, Assets/MyGame/Resources? Найдет ли его инструмент?",
  "q_faq_installation_5": "Установщик зависимостей завис или выдал ошибку. Могу ли я установить зависимости (Newtonsoft Json, Editor Coroutines) вручную через Unity Package Manager?",
  "q_faq_notes_1": "В документации рекомендуется добавить LanguageSelector в список игнорирования. Что именно сломается, если я забуду это сделать? Будут ли созданы лишние ключи для \"Option A, Option B\"?",
  "q_faq_notes_2": "Если я забуду добавить пустой LocalizedText с флажком isStyleOnly на Label внутри TMP_Dropdown, используемого LanguageSelector, не изменится ли шрифт? Почему это необходимо?",
  "q_faq_notes_3": "Вызов _() в методе Update() не рекомендуется. Но что, если мне нужно обновлять текст каждый кадр (например, таймер)? Какой самый производительный способ сделать это, кэшируя только строку формата?",
  "q_faq_tts_voices": "Как мне назначить конкретные голоса персонажам?",
  "q_faq_window_actions_1": "Что произойдет, если во время пакетного автоперевода пропадет интернет-соединение? Будет ли инструмент повторять неудачный пакет в соответствии с Retry Policy, или процесс будет полностью прерван?",
  "q_faq_window_actions_2": "Если я импортирую CSV-файл, содержащий ключи, которые уже существуют в проекте, но с пустыми значениями для некоторых языков, заменят ли эти пустые значения мои существующие переводы или будут проигнорированы?",
  "q_faq_window_actions_3": "Раздел \"Danger Zone\" позволяет удалить все компоненты. Удалит ли он компоненты из префабов, которые находятся в папках, не указанных во Prefab Folders на вкладке Content?",
  "q_faq_window_actions_4": "При импорте из Google Sheets, как мне отформатировать столбец с комментариями, чтобы работала валидация заполнителей с помощью директивы @placeholders:?",
  "q_faq_window_actions_5": "Может ли инструмент импортировать данные из нескольких листов одного документа Google Sheets, или он работает только с одним листом за раз по GID?",
  "q_faq_window_assets_1": "Что если в одной папке сканирования у меня есть два ассета с одинаковым ключом, но разным типом (например, sound_effect_en.mp3 и sound_effect_en.wav)? Какой из них попадет в таблицу ассетов?",
  "q_faq_window_assets_2": "Если я нажму Scan Assets & Analyze Project, и в сцене есть объект Image, для которого уже существует локализованный спрайт, но сам объект Image еще не имеет компонента LocalizedAsset, добавит ли инструмент компонент и автоматически вставит ключ?",
  "q_faq_window_assets_3": "Могу ли я использовать одно и то же Naming Rule для разных категорий ассетов, если у них разные Scan Folders? Вызовет ли это конфликты?",
  "q_faq_window_assets_4": "Если локализуемый ассет (например, button_ok_en.png) находится не в корне Scan Folder, а во вложенной папке, найдет ли его сканер?",
  "q_faq_window_content_1": "Что если я добавлю в Scenes to Parse сцену, которая не включена в Build Settings? Повлияет ли это на что-то, кроме самого процесса парсинга?",
  "q_faq_window_content_2": "Я добавил объект в Ignore Specific Objects (временный список). Если я сделаю из этого объекта префаб, будет ли экземпляр этого префаба тоже игнорироваться?",
  "q_faq_window_content_3": "Если я добавлю компонент TMPro.TMP_Text в Parsing Ignores -> Ignore Component Types, но в сцене есть объект с LocalizedText, который уже ссылается на этот TMP_Text, что произойдет при следующем Update Keys? Будет ли ключ удален?",
  "q_faq_window_content_4": "В документации сказано, что \"Pin\" сохраняет полный путь к объекту и сломается, если он будет переименован. Что если я сделаю префаб из объекта, а затем переименую оригинальный объект — будет ли \"Pin\" продолжать работать для экземпляров префаба?",
  "q_faq_window_content_5": "Если я использую \"Pin\" для дочернего объекта внутри экземпляра префаба, какой путь будет сохранен: относительный к корню префаба или корню сцены? Будет ли он работать в других сценах?",
  "q_faq_window_preview_1": "Я открыл префаб в Prefab Mode, применил In-Editor Preview и нажал Ctrl+S. Сохранятся ли временные данные предпросмотра в ассет префаба? Как LocalizationPreviewProtector обрабатывает этот случай?",
  "q_faq_window_preview_2": "Если я включу In-Editor Preview, а редактор Unity аварийно завершит работу, и файл Temp/localization_preview_recovery.json будет поврежден (например, пустой или недействительный JSON), что произойдет при следующем запуске?",
  "q_faq_window_preview_3": "В режиме In-Editor Preview для LocalizedPrefab создается временный экземпляр. Будут ли на этом экземпляре выполняться методы Awake() и Start()? Может ли это вызвать ошибки, если они не предназначены для запуска в Edit Mode?",
  "q_faq_window_report_1": "Кнопка \"Find\" ищет объект асинхронно. Что если я начну поиск, а затем сразу нажму Update Keys? Будет ли поиск прерван?",
  "q_faq_window_report_2": "Если ключ используется в нескольких местах (например, на двух разных кнопках в разных сценах), как это будет отображено в отчете в категории \"Duplicates\"?",
  "q_faq_window_report_3": "Если я нажму \"Find\" для ключа, который используется только в коде (через функцию _()), что произойдет? Сможет ли инструмент найти и выделить C#-скрипт?",
  "q_faq_window_settings_1": "Я могу изменить Key Generation Mode с UseTextAsKey на AutoGenerateKeysOnly в середине проекта. Что именно произойдет с моими существующими переводами? Будут ли они сопоставлены с новыми ключами?",
  "q_faq_window_settings_2": "Если я добавлю в список Supported Languages язык с кодом, для которого нет правил плюрализации (например, \"kz\" для казахского), какое правило будет использоваться по умолчанию?",
  "q_faq_window_settings_3": "Что если я укажу Translations Path не в StreamingAssets, а в обычной папке, например, Assets/MyTranslations? Будут ли json-файлы включены в сборку игры?",
  "q_faq_window_settings_4": "Ключ API для автоперевода хранится в EditorPrefs. Если я работаю над проектом на двух разных компьютерах, нужно ли мне вводить ключ на каждой машине отдельно?",
  "tip_best_practice": "<strong>Совет профессионала:</strong> Если вам нужно локализовать свойство, создайте резервное поле с <code>[LocalizableField]</code> и предоставьте доступ к свойству отдельно.",
  "toc_search_placeholder": "Поиск по документации...",
  "toc_title": "Оглавление",
  "toggle_notes_title": "Переключить примечания",
  "warning_box_components": "<strong>Важное примечание:</strong> Все описанные ниже компоненты добавляются к игровым объектам автоматически во время парсинга (при нажатии кнопки <code>Update Keys</code>). Вам не нужно добавлять их вручную.",
  "warning_tms_overwrite": "<strong>Внимание:</strong> Получение из TMS перезапишет локальные переводы для совпадающих ключей. Убедитесь, что ваш TMS является единственным источником правды."
}