{
  "page_title": "Документация по инструменту локализации для Unity",
  "toc_title": "Оглавление",
  "toc_search_placeholder": "Поиск по документации...",
  "nav_introduction": "1. Введение",
  "nav_quick_start": "2. Быстрый старт",
  "nav_components": "3. Основные компоненты",
  "nav_loc_tool_window": "4. Окно \"Localization Tool\"",
  "nav_translation_editor": "5. Редактор переводов",
  "nav_ai_profiles": "6. AI и Профили переводов (Новое в v1.1)",
  "nav_usage_examples": "7. Примеры использования",
  "nav_important_notes": "8. Важные нюансы",
  "nav_extending": "9. Расширение функционала",
  "nav_faq": "10. FAQ и Решение проблем",
  "nav_key_features": "Ключевые возможности",
  "nav_installation": "2.1. Установка",
  "nav_initial_setup": "2.2. Первоначальная настройка",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. Контекстное меню",
  "nav_in_editor_preview": "4.1. Предпросмотр в редакторе и в режиме префаба",
  "nav_tab_settings": "4.2. Вкладка \"Settings\"",
  "nav_tab_content": "4.3. Вкладка \"Content\" (Обновлена)",
  "nav_tab_actions": "4.4. Вкладка \"Actions\"",
  "nav_tab_assets": "4.5. Вкладка \"Assets\"",
  "nav_tab_report": "4.6. Вкладка \"Report\"",
  "nav_ai_profiles_overview": "6.1. Профили переводов",
  "nav_custom_ai": "6.2. Кастомный AI и модели",
  "nav_ai_context": "6.3. Контекст и глоссарий",
  "nav_ai_assistant": "6.4. Команды AI-помощника",
  "nav_example_components": "7.1. Готовые компоненты",
  "nav_example_attribute": "7.2. Атрибут [LocalizableField]",
  "nav_example_function": "7.3. Функция _()",
  "nav_example_plurals": "7.4. Множественное число и род",
  "nav_custom_parser": "9.1. Создание парсера",
  "nav_faq_installation": "10.1. Установка и Быстрый старт",
  "nav_faq_components": "10.2. Основные компоненты",
  "nav_faq_window": "10.3. Окно \"Localization Tool\"",
  "nav_faq_window_actions": "10.3. Окно \"Localization Tool\" - Вкладка \"Actions\"",
  "nav_faq_window_assets": "10.3. Окно \"Localization Tool\" - Вкладка \"Assets\"",
  "nav_faq_window_report": "10.3. Окно \"Localization Tool\" - Вкладка \"Report\"",
  "nav_faq_editor": "10.4. Редактор переводов",
  "nav_faq_examples": "10.5. Примеры использования и работа с кодом",
  "nav_faq_notes": "10.6. Важные нюансы и предупреждения",
  "nav_faq_extending": "10.7. Расширение функционала",
  "h1_introduction": "Введение",
  "p_intro_1": "Этот инструмент представляет собой комплексное решение для локализации игр и приложений в Unity. Он позволяет автоматизировать процесс сбора текста и ассетов, управлять переводами через мощный интерфейс, интегрироваться с сервисами машинного перевода (включая Кастомный AI) и динамически обновлять локализованный контент в игре.",
  "h2_key_features": "Ключевые возможности",
  "li_feature_1": "<strong>Продвинутый парсинг:</strong> Автоматическое сканирование сцен, префабов, UI Toolkit (UXML) и C# скриптов, включая поля, отмеченные атрибутом <code>[LocalizableField]</code>, а также вложенные классы и списки.",
  "li_feature_2": "<strong>Локализация любых ассетов:</strong> Управление спрайтами, аудио, префабами, материалами и т.д.",
  "li_feature_3": "<strong>Мощный редактор переводов:</strong> Централизованный интерфейс с автосохранением, полной поддержкой Undo/Redo, умной группировкой ключей и <strong>Новое в v1.1:</strong> действиями с мультивыбором.",
  "li_feature_4": "<strong>AI и Машинный перевод (v1.1):</strong> Новая система Профилей с поддержкой DeepL, Google, Microsoft и <strong>Кастомного AI (OpenAI, Gemini, Claude, Ollama)</strong> с учетом контекста.",
  "li_feature_5": "<strong>Гибкий импорт/экспорт:</strong> Поддержка CSV, XML, YAML, XLIFF и прямой импорт из Google Sheets.",
  "li_feature_6": "<strong>Live Preview:</strong> Предпросмотр любого языка в окне Scene или в <strong>Prefab Mode</strong>, не запуская игру.",
  "li_feature_7": "<strong>Поддержка Plural & Gender:</strong> Корректная обработка форм множественного числа (с правилами для славянских, арабского и других языков) и рода.",
  "li_feature_8": "<strong>Полная поддержка RTL:</strong> Корректное отображение языков с написанием справа налево.",
  "li_feature_9": "<strong>Live Updates:</strong> Загрузка актуальных переводов с удаленного сервера при старте игры.",
  "li_feature_10": "<strong>Менеджер бэкапов:</strong> Встроенный инструмент для создания и восстановления резервных копий.",
  "h1_quick_start": "Быстрый старт и настройка",
  "h2_installation": "2.1. Установка",
  "li_install_1": "Скопируйте ассет в папку вашего проекта Unity.",
  "li_install_2": "Инструмент автоматически проверит наличие необходимых зависимостей. В появившемся диалоговом окне подтвердите установку.",
  "li_install_3": "Обязательные зависимости (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) необходимы для базовой работы.",
  "li_install_4": "Опциональные зависимости (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) включают дополнительные функции.",
  "li_install_5": "Нажмите <strong>Install Selected</strong>, чтобы установить рекомендуемые пакеты.",
  "li_install_6": "После установки откройте главное окно инструмента через меню <strong>Tools -> Localization Tool</strong>.",
  "h2_initial_setup": "2.2. Первоначальная настройка",
  "li_setup_1": "<strong>Создание настроек:</strong> При первом открытии инструмент создаст файл <code>LocalizationSettings.asset</code> в папке <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Настройка языков:</strong> На вкладке <strong>Settings</strong> в секции <strong>Language Management</strong> убедитесь, что ваш основной язык (например, <code>en</code> — английский) выбран как <strong>Source Language</strong>. Включите все языки, которые вы планируете поддерживать.",
  "li_setup_3": "<strong>Указание контента для парсинга:</strong> На вкладке <strong>Content</strong> добавьте все сцены для анализа в список <strong>Scenes to Parse</strong>. Если вы используете префабы с текстом, убедитесь, что папки с ними добавлены в <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Первый запуск парсера:</strong> Перейдите на вкладку <strong>Actions</strong> и нажмите кнопку <code>Update Keys</code>. Инструмент просканирует ваш проект, создаст файлы с переводами и автоматически добавит необходимые компоненты (<code>LocalizedText</code>, <code>LocalizedAsset</code> и т.д.) на игровые объекты.",
  "h1_components": "Основные компоненты (назначаются автоматически)",
  "warning_box_components": "<strong>Важное замечание:</strong> Все описанные ниже компоненты добавляются на игровые объекты автоматически в процессе парсинга (когда вы нажимаете кнопку <code>Update Keys</code>). Вам не нужно добавлять их вручную.",
  "p_components_intro": "Эти компоненты — \"мост\" между вашими объектами в сцене и базой данных переводов. Они \"слушают\" смену языка и автоматически подставляют нужный текст или ассет.",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "Основной компонент для отображения переведенного текста. Устанавливается на объекты с <code>Text</code>, <code>TMP_Text</code> и <code>TextMesh</code>.",
  "li_localizedtext_1": "<code>localizationKey</code>: Ключ, по которому находится перевод. Генерируется автоматически.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Если <code>true</code>, компонент будет применять только стили (шрифт, RTL), но не менять сам текст. Полезно для элементов, текст которых управляется другим скриптом (например, <code>LanguageSelector</code>).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Исходный текст на базовом языке. Используется как резервный вариант.",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "Используется для подмены ассетов (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code> и т.д.). Он автоматически определяет тип целевого компонента на объекте (<code>Image</code>, <code>AudioSource</code>) и подменяет его ресурс.",
  "p_localizedasset_2": "Для компонентов с опцией <strong>Play on Awake</strong> (таких как <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> корректно перехватывает автозапуск, подменяет ассет и затем запускает воспроизведение, чтобы избежать проигрывания нелокализованного контента.",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "Компонент для локализации целых префабов. Он работает неразрушающим образом: не изменяет исходный префаб, а создает экземпляр локализованной версии как дочерний объект, отключая все скрипты (<code>MonoBehaviour</code>), рендереры (<code>Renderer</code>) и коллайдеры (<code>Collider</code>) на оригинальном объекте. Это предотвращает двойное выполнение логики и появление визуальных артефактов. Для корректной работы в рантайме его порядок выполнения установлен на -100 (<code>[DefaultExecutionOrder(-100)]</code>), чтобы он срабатывал раньше других скриптов.",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "Добавляется на объекты с <code>UIDocument</code> и управляет локализацией всех текстовых элементов внутри UI Toolkit документа (UXML).",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "Добавляется на <code>Dropdown</code> и <code>TMP_Dropdown</code> для перевода их вариантов.",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "Служебный компонент, который позволяет вашим скриптам реагировать на смену языка. Он автоматически находит и вызывает методы, помеченные атрибутом <code>[OnLanguageChange]</code>.",
  "h2_context_menu": "3.7. Контекстное меню \"Analyze for Localization\"",
  "p_context_menu_1": "Для быстрого добавления <code>LocalizedAsset</code> на объект, вы можете кликнуть правой кнопкой мыши по нужному компоненту (например, <code>Image</code>, <code>AudioSource</code>) в инспекторе и выбрать <strong>Analyze for Localization</strong>. Инструмент сам добавит и настроит компонент. (Это необязательно, но можно использовать для мануального добавления).",
  "h1_loc_tool_window": "Окно \"Localization Tool\"",
  "h2_in_editor_preview": "4.1. Предпросмотр в редакторе и в режиме префаба",
  "p_preview_1": "Прямо под заголовком находится выпадающий список <strong>Preview Language</strong>. Эта мощная функция позволяет увидеть, как будет выглядеть локализация на любом языке прямо в окне <strong>Scene</strong> или в <strong>Prefab Mode</strong>, не запуская игру.",
  "li_preview_1": "<strong>Как это работает:</strong> Выберите язык из списка, и инструмент мгновенно применит соответствующие переводы, шрифты, RTL-настройки и ассеты ко всем локализуемым объектам на активной сцене или открытом префабе.",
  "li_preview_2": "<strong>Плейсхолдеры:</strong> Если на вкладке <strong>Settings</strong> выбран стиль плейсхолдеров (например, <strong>Accents</strong> или <strong>Brackets</strong>), то в режиме превью вместо реальных переводов будут отображаться эти плейсхолдеры. Это идеально подходит для тестирования верстки и поиска нелокализованных элементов.",
  "li_preview_3": "<strong>Безопасность:</strong> Все изменения, внесенные в режиме превью, являются временными. Инструмент автоматически вернет все в исходное состояние при выборе \"<strong>Revert to Original</strong>\", закрытии окна, смене сцены или перед сохранением сцены/префаба (благодаря компоненту <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Защита от сбоев:</strong> Встроенная система <code>PreviewCrashProtector</code> автоматически восстановит исходное состояние объектов, если редактор Unity закроется аварийно во время активного превью. Теперь также поддерживает восстановление в режиме Prefab Mode.",
  "h2_tab_settings": "4.2. Вкладка \"Settings\" (Настройки)",
  "p_settings_1": "Ваш центр управления. Здесь вы определяете глобальные правила для всего процесса локализации.",
  "li_settings_1": "<strong>Key Generation Mode:</strong> Выберите, как будут создаваться ключи.<ul><li><code>UseTextAsKey</code>: Ключом становится сам текст. Идеально для прототипов. Минус: если изменить исходный текст, ключ изменится, и все его переводы будут потеряны.</li><li><code>AutoGenerateKeysOnly</code>: Ключ генерируется на основе иерархии и имени объекта. Надежно для продакшена. Плюс: переводы не ломаются при изменении текста.</li><li><code>UseTextAsKeyWithCustomPriority</code> и <code>AutoGenerateWithCustomKeys</code>: Гибридные режимы, позволяющие задавать кастомные ключи в коде через атрибут <code>[LocalizableField(\"my_custom_key\")]</code>.</li><li><strong>Безопасная миграция:</strong> Вы можете сменить режим в любой момент. Инструмент автоматически перенесет все существующие переводы на новую систему ключей.</li></ul>",
  "li_settings_2": "<strong>Language Management:</strong> Настройте список языков. Для языков с особыми символами назначьте соответствующий <strong>Font Asset</strong>. Включите опцию <strong>RTL</strong> для языков с письмом справа налево.",
  "li_settings_3": "<strong>General Settings:</strong><ul><li><code>Parse Prefabs</code>: Включает парсинг префабов.</li><li><code>Split files by language</code>: Определяет, как хранить переводы (один большой файл или по файлу на язык).</li><li><code>Translations Path</code>: Путь для хранения файлов <code>.json</code> с переводами. Важно: папка должна находиться внутри <code>Assets/StreamingAssets/</code>.</li></ul>",
  "li_settings_4": "<strong>Debugging & Testing:</strong><ul><li><code>Placeholder Style</code>: Выберите стиль для отображения плейсхолдеров в режиме превью.</li></ul>",
  "li_settings_5": "<strong>Live Updates:</strong> Настройки для загрузки переводов с удаленного сервера.",
  "li_settings_6": "<strong>Runtime API Key:</strong> Секция для безопасного хранения API ключа, который может понадобиться в скомпилированной игре (хранится в зашифрованном виде).",
  "h2_tab_content": "4.3. Вкладка \"Content\" (Контент) (Обновлена в v1.1)",
  "p_content_1": "Здесь вы сообщаете инструменту, где именно искать текст. Интерфейс был полностью переработан для лучшего удобства использования.",
  "li_content_1": "<strong>Scenes to Parse:</strong> Перетащите сюда все сцены для анализа.",
  "li_content_2": "<strong>Prefab Folders:</strong> Укажите папки с префабами. Теперь поддерживает пагинацию и поиск для больших проектов.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Впишите сюда строки, которые создаются исключительно в коде (например, \"Game Over\").",
  "li_content_4": "<strong>Parsing Ignores:</strong> Укажите скрипты, компоненты или объекты для игнорирования.",
  "li_content_5": "<strong>Pin:</strong> Эта функция позволяет \"закрепить\" объект из сцены в списке игнорирования. Вместо временной ссылки на объект, инструмент сохранит его полный путь в иерархии, делая игнорирование постоянным между сессиями.",
  "h2_tab_actions": "4.4. Вкладка \"Actions\" (Действия)",
  "p_actions_1": "Главная рабочая вкладка.",
  "li_actions_1": "<strong>Update Keys:</strong> Запускает парсер, который обновляет ваши файлы переводов.",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Открывает отдельное, более удобное окно для редактирования всех переводов.",
  "li_actions_3": "<strong>Data Management:</strong> Используйте для обмена данными с переводчиками (Export/Import в CSV/XML/YAML/XLIFF, импорт из Google Sheets).",
  "li_actions_4": "<strong>Auto-Translation:</strong> Автоматически заполняет все пустые строки переводов, используя активный <strong>Translation Profile</strong>.",
  "li_actions_5": "<strong>Danger Zone:</strong> Содержит кнопки для полного удаления всех компонентов локализации из проекта. Используйте с осторожностью!",
  "h2_tab_assets": "4.5. Вкладка \"Assets\" (Ассеты)",
  "p_assets_1": "Эта вкладка полностью посвящена локализации нетекстовых ресурсов.",
  "li_assets_1": "<strong>Создайте структуру папок (опционально):</strong> В секции <strong>2. Asset Folder Generation</strong> нажмите <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Настройте категории и правила именования:</strong> В секции <strong>3. Asset Categories & Scanning</strong> убедитесь, что правило <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) соответствует вашим файлам (например, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Разместите ваши ассеты:</strong> Положите локализованные ассеты в папки.",
  "li_assets_4": "<strong>Просканируйте ассеты:</strong> В секции <strong>4. Automation</strong> нажмите <strong>Scan Assets & Update Tables</strong>. Процесс очистки стал безопаснее: теперь удаляются только старые файлы таблиц (<code>.asset</code>), а не вся папка.",
  "li_assets_5": "<strong>Привяжите ассеты к объектам:</strong> Нажмите <strong>Analyze Project & Attach Components</strong>.",
  "h2_tab_report": "4.6. Вкладка \"Report\" (Отчет)",
  "p_report_1": "После каждого парсинга этот отчет показывает полную картину состояния вашей локализации.",
  "li_report_1": "<strong>Категории:</strong> Все ключи (All Keys), Добавленные (Added), Обновленные (Updated - текст изменился), Удаленные (Removed), Дубликаты (Duplicates), Мигрированные (Migrated), Пропущенные (Skipped - неизменные).",
  "li_report_2": "<strong>Продвинутый поиск:</strong> Нажмите кнопку <strong>Find</strong> напротив любой записи, чтобы мгновенно найти соответствующий объект в проекте. Поиск работает асинхронно, не блокируя редактор, и ищет по всем сценам и префабам.",
  "h1_translation_editor": "Редактор таблицы переводов",
  "p_editor_1": "Открывается через <strong>Tools -> Localization -> Translation Table Editor</strong>. Это основной инструмент для ручного редактирования переводов.",
  "li_editor_1": "<strong>Умная группировка:</strong> Ключи для множественного числа и рода (например, <code>apple_count_one</code>, <code>apple_count_few</code>) автоматически объединяются в сворачиваемые группы.",
  "li_editor_2": "<strong>Продвинутое редактирование:</strong> Кликните на ячейку, чтобы открыть всплывающее окно <strong>MultiLineEditWindow</strong>. Оно показывает исходный текст для сравнения и проверяет плейсхолдеры.",
  "li_editor_3": "<strong>Продвинутое выделение (Новое):</strong> Поддерживает выделение отдельных ячеек, строк или целых столбцов (языков).",
  "li_editor_4": "<strong>Массовые действия (Новое):</strong> Кликните правой кнопкой мыши по выделению, чтобы выполнить массовые операции: Автоматически перевести выделенные ячейки, Очистить содержимое или Удалить ключи.",
  "li_editor_5": "<strong>Умная навигация (Новое):</strong> Перемещайтесь по таблице с помощью стрелок на клавиатуре и горячих клавиш (Ctrl+S для сохранения, Ctrl+Z/Y для Undo/Redo).",
  "li_editor_6": "<strong>Проверка длины (Новое):</strong> Используйте фильтр \"Has Length Issues\" (Проблемы с длиной), чтобы выделить переводы, которые значительно длиннее исходного текста (настраиваемый порог).",
  "h1_ai_profiles": "AI и Профили переводов (Новое в v1.1)",
  "h2_ai_profiles_overview": "6.1. Профили переводов",
  "p_ai_intro": "Версия 1.1 представляет новую систему <strong>Профилей переводов</strong> (ScriptableObject). Это позволяет вынести настройки сервисов перевода из глобальных настроек в отдельные ассеты профилей, упрощая переключение конфигураций.",
  "li_ai_1": "<strong>Создание профиля:</strong> Кликните правой кнопкой мыши в окне Project -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Сервисы:</strong> Поддерживаются DeepL, Google Translate, Microsoft Azure и <strong>Кастомный AI</strong>.",
  "li_ai_3": "<strong>Настройки:</strong> Каждый профиль хранит свой API-ключ, лимиты (размер пакета, макс. символов) и настройки модели.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Используйте встроенный генератор для быстрого создания профилей популярных сервисов (OpenAI, Gemini, Claude, Ollama).",
  "h2_custom_ai": "6.2. Кастомный AI и модели",
  "p_custom_ai": "Тип сервиса <strong>Custom AI</strong> позволяет подключить любую LLM через REST API.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Гибкая реализация, которая может взаимодействовать с OpenAI-совместимыми API (включая локальные LLM через Ollama).",
  "li_custom_ai_2": "<strong>Шаблоны:</strong> Настройте JSON-шаблон тела запроса, чтобы он соответствовал требованиям вашего API.",
  "h2_ai_context": "6.3. Контекст и глоссарий",
  "p_ai_context": "Для улучшения качества перевода AI теперь получает дополнительный контекст:",
  "li_context_1": "<strong>Заметки разработчика:</strong> Комментарии из таблицы переводов передаются AI в качестве контекста.",
  "li_context_2": "<strong>Путь к объекту:</strong> Если комментарий отсутствует, в качестве запасного контекста используется путь объекта в иерархии (например, <code>MainMenu/Canvas/StartButton</code>).",
  "li_context_3": "<strong>Глоссарий:</strong> Вы можете загрузить CSV-глоссарий в профиль для обеспечения конкретных переводов для терминов и имен.",
  "h2_ai_assistant": "6.4. Команды AI-помощника",
  "p_ai_assistant": "В Редакторе таблицы переводов теперь можно запускать кастомные AI-команды на выделенных ячейках через контекстное меню (Правый клик -> AI: ...).",
  "li_assistant_1": "<strong>Настраиваемые:</strong> Определите команды в вашем Профиле переводов (например, \"Исправить грамматику\", \"Сделать формальным\", \"Сократить для UI\").",
  "li_assistant_2": "<strong>Пакетная обработка:</strong> Выделите несколько ячеек, чтобы применить команду ко всем им сразу.",
  "h1_usage_examples": "Примеры использования",
  "h2_example_components": "7.1. Готовые компоненты и примеры",
  "p_example_components_1": "Проект содержит готовые к использованию скрипты, которые служат отличными примерами.",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Готовый компонент для создания UI выпадающего списка для смены языка. Он автоматически находит все доступные языки и управляет их переключением.<br><strong>Как использовать:</strong> Просто добавьте компонент <code>LanguageSelector</code> на вашу сцену (например, на пустой GameObject) и укажите в инспекторе ваш <code>TMP_Dropdown</code>.",
  "li_example_components_2": "<strong>Примеры в коде:</strong> Для изучения продвинутых техник, таких как работа с <code>[LocalizableField]</code>, функцией <code>_()</code>, множественным числом и родом, изучите файлы <code>StatPurchaseTest.cs</code> и <code>TestLocalization.cs</code>. Они наглядно демонстрируют реализацию всех основных возможностей инструмента в коде.",
  "h2_example_attribute": "7.2. Атрибут [LocalizableField]",
  "p_example_attribute_1": "Предпочтительный способ для текстов, которые являются частью конфигурации компонента в инспекторе. Парсер теперь умеет работать со строками, списками/массивами строк и даже полями внутри вложенных <code>[System.Serializable]</code> классов.",
  "code_example_attribute": "using Ankonoanko.Localization; // Required for [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // Парсер найдет это поле и создаст для него ключ\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"You have failed the quest.\";\n    \n    // Можно задать собственный ключ\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Are you ready for an adventure?\";\n    \n    // Работает со списками\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Find the treasure\" };\n    \n    // И даже с вложенными классами!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. Функция _() и атрибут [OnLanguageChange]",
  "p_example_function_1": "Используйте функцию <code>_()</code> для динамического текста, который меняется в ходе игры. Метод, обновляющий UI, следует пометить атрибутом <code>[OnLanguageChange]</code>, чтобы он вызывался автоматически при смене языка. Для этого на объект будет автоматически добавлен компонент <code>LocalizedBehaviour</code>.",
  "code_example_function": "// Чтобы использовать короткий вызов _(), добавьте эти строки\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Required for [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Первоначальное обновление\n    }\n    \n    // Этот метод будет вызван автоматически при смене языка\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Индексные плейсхолдеры (как в string.Format)\n        // Ключ: \"score_label\", Текст в файле: \"Score: {0}\"\n        scoreText.text = _(\"score_label\", score); // Результат: \"Score: 100\"\n        \n        // 2. Именованные плейсхолдеры (рекомендуется для читаемости)\n        // Ключ: \"welcome_message\", Текст: \"Welcome, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Для сложных случаев или высокой производительности\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. Множественное число и род",
  "p_example_plurals_1": "Инструмент теперь использует более точные правила для разных языковых групп.",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Ключи: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Тексты: \"{0} яблоко\", \"{0} яблока\", \"{0} яблок\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Автоматически выберет правильную форму\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Ключи: \"user_greeted_male\", \"user_greeted_female\"\n        // Тексты: \"Он пришел.\", \"Она пришла.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "Важные нюансы и предупреждения",
  "li_notes_1": "<strong>Резервные копии:</strong> Перед глобальными операциями (<code>Update Keys</code>, импорт данных) всегда создавайте резервную копию через <strong>Translation Table Editor -> Manage Backups</strong>.",
  "li_notes_2": "<strong>Безопасность API ключей:</strong> Ключ для работы в редакторе хранится локально на вашей машине (в <code>EditorPrefs</code>) и не попадает в репозиторий. Для ключей, которые нужны в билде игры, используйте секцию <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Папка <code>StreamingAssets</code>:</strong> Файлы переводов должны находиться в подпапке <code>Assets/StreamingAssets/</code>, чтобы они были включены в сборку игры.",
  "li_notes_4": "<strong>\"Защита от дурака\":</strong> Инструмент автоматически защищает вас от случайного сохранения временных данных из режима превью в сцену или префаб.",
  "li_notes_5": "<strong>Производительность:</strong> Вызов <code>_()</code> является быстрым, но в циклах, которые выполняются каждый кадр (например, в <code>Update</code>), старайтесь кэшировать результат в переменную.",
  "li_notes_6": "<strong>Исключение <code>LanguageSelector</code> из парсинга:</strong> Объект с компонентом <code>LanguageSelector</code> и его <code>TMP_Dropdown</code> необходимо добавить в список <strong>Ignore Specific Objects</strong> на вкладке <strong>Content</strong>. Это нужно, чтобы парсер не создавал лишние ключи для вариантов в дропдауне, так как скрипт <code>LanguageSelector</code> заполняет их динамически во время выполнения. Игнорирование предотвращает конфликты и сохраняет чистоту в файлах переводов.",
  "li_notes_7": "<strong>Шрифты для <code>LanguageSelector</code>:</strong> Чтобы выбранный язык в <code>TMP_Dropdown</code> корректно обновлял свой шрифт, вручную добавьте на дочерний объект <strong>Label</strong> у Dropdown пустой компонент <code>LocalizedText</code> и включите у него галочку <code>isStyleOnly</code>.",
  "h1_extending": "Расширение функционала",
  "h2_custom_parser": "9.1. Создание кастомного парсера",
  "p_custom_parser_1": "Вы можете легко расширить систему для поддержки кастомных компонентов, создав свой класс-парсер.",
  "li_custom_parser_1": "Создайте новый C# скрипт в папке <strong>Editor</strong> вашего проекта.",
  "li_custom_parser_2": "Скопируйте в него приведенный ниже шаблон.",
  "li_custom_parser_3": "Измените логику, чтобы она соответствовала вашему компоненту.",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// ШАБЛОН для создания парсера для кастомного компонента.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Проверяем, есть ли на объекте нужный нам кастомный компонент.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Выходим, если компонента нет\n        }\n        \n        // 2. Получаем текст из полей кастомного компонента.\n        string titleText = component.Title;\n        \n        // 3. Проверяем, является ли текст валидным для локализации.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Генерируем ключ и источник, используя хелперы из TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Возвращаем результат.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Повторяем для других полей...\n        // (можно добавить суффикс, чтобы ключи были уникальными)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQ и Решение проблем",
  "h2_faq_installation": "10.1. Установка и Быстрый старт",
  "q_faq_installation_1": "Что произойдет, если в моем проекте уже есть пакет com.unity.nuget.newtonsoft-json от другого ассета? Попытается ли установщик зависимостей его обновить или проигнорирует?",
  "a_faq_installation_1": "Установщик проверяет наличие типа Newtonsoft.Json.JsonConvert. Если тип существует, он считает зависимость удовлетворенной и не будет пытаться установить или обновить пакет. Это сделано для предотвращения конфликтов версий.",
  "q_faq_installation_2": "Я случайно нажал \"Skip for Now\" и поставил галочку \"Don't ask again\" для опциональных зависимостей (например, для поддержки CSV). Как мне снова вызвать окно установщика, чтобы их установить?",
  "a_faq_installation_2": "Вы можете в любой момент вызвать проверку зависимостей вручную через меню Tools -> Localization -> Check Dependencies. Это сбросит флаг \"Don't ask again\" и снова покажет окно со всеми недостающими опциональными пакетами.",
  "q_faq_installation_3": "Инструмент не создал LocalizationSettings.asset в Assets/Resources. Почему это могло произойти и могу ли я создать его вручную через меню Assets -> Create?",
  "a_faq_installation_3": "Это может произойти, если у вас нет папки Assets/Resources. Инструмент попытается ее создать, но права доступа к файловой системе могут помешать. Да, вы можете создать ассет вручную: кликните правой кнопкой мыши в папке Resources, выберите Create -> Localization -> Settings. Инструмент автоматически найдет его.",
  "q_faq_installation_4": "Могу ли я переместить файл LocalizationSettings.asset в другую папку Resources, например Assets/MyGame/Resources? Будет ли инструмент его находить?",
  "a_faq_installation_4": "Да. Инструмент использует Resources.Load(), который ищет ассет по имени во всех папках с названием Resources в вашем проекте. Главное, чтобы файл сохранял свое имя LocalizationSettings.asset.",
  "q_faq_installation_5": "Установщик зависимостей завис или выдал ошибку. Могу ли я установить зависимости (Newtonsoft Json, Editor Coroutines) вручную через Unity Package Manager?",
  "a_faq_installation_5": "Да. Вы можете открыть Window -> Package Manager, нажать на \"+\" и выбрать \"Add package by name...\". Введите имена пакетов: com.unity.nuget.newtonsoft-json и com.unity.editorcoroutines.",
  "h2_faq_components": "10.2. Основные компоненты",
  "q_faq_components_1": "Компонент LocalizedPrefab отключает MonoBehaviour на оригинальном объекте. Что если на оригинальном объекте есть скрипт, который в Awake() создает другие объекты или подписывается на события? Будет ли этот код выполнен?",
  "a_faq_components_1": "Нет, не будет. Отключение MonoBehaviour предотвращает вызов всех \"магических\" методов Unity, включая Awake(), OnEnable() и Start(). Это сделано намеренно, чтобы избежать двойного выполнения логики. Вся инициализация должна происходить в скриптах на локализованных версиях префаба.",
  "q_faq_components_2": "Если на оригинальном префабе (LocalizedPrefab) есть компонент Rigidbody или другой физический компонент, будет ли он отключен? Повлияет ли это на физику, если локализованный префаб его не имеет?",
  "a_faq_components_2": "Да, физическое поведение исходного объекта будет нейтрализовано. Компонент LocalizedPrefab находит все компоненты Rigidbody и Rigidbody2D на своем GameObject и устанавливает их свойство isKinematic в true. Это эффективно исключает их из динамических физических расчетов, предотвращая нежелательное поведение, такое как падение невидимого объекта или реакция на столкновения. По-прежнему рекомендуется, чтобы локализованная версия префаба содержала все необходимые физические компоненты для корректной работы.",
  "q_faq_components_3": "Компонент LocalizedAsset хранит имя целевого компонента как строку (_targetComponentTypeName). Что произойдет, если я переименую скрипт кастомного компонента или перемещу его в другую сборку (Assembly Definition)? Перестанет ли LocalizedAsset работать для него?",
  "a_faq_components_3": "Да, перестанет. Компонент хранит полное имя типа, включая пространство имен и сборку. При переименовании скрипта или его перемещении в другой .asmdef это имя изменится, и LocalizedAsset не сможет найти целевой компонент. Вам нужно будет запустить повторный анализ через Analyze Project & Attach Components, чтобы он обновил имя.",
  "q_faq_components_4": "Если на одном GameObject висят два компонента Image, как LocalizedAsset поймет, какой из них нужно локализовать? Будет ли он работать с обоими или только с первым найденным?",
  "a_faq_components_4": "LocalizedAsset создается для конкретного экземпляра компонента. В коде он хранит ссылку на этот компонент. Если вы вручную добавите второй LocalizedAsset и через контекстное меню \"Analyze for Localization\" укажете второй Image, то у вас будет два LocalizedAsset, каждый из которых будет управлять своим Image. Автоматический анализатор создаст компонент только для первого найденного Image с локализуемым ассетом.",
  "q_faq_components_5": "В документации указано, что LocalizedPrefab имеет порядок выполнения -100. Что если у меня есть другой скрипт с порядком выполнения -110, который в Awake() пытается найти дочерний объект, создаваемый LocalizedPrefab? Успеет ли LocalizedPrefab создать свой экземпляр?",
  "a_faq_components_5": "Да, успеет. LocalizedPrefab создает экземпляр локализованного префаба в своем методе OnEnable(). Порядок выполнения Unity гарантирует, что все методы Awake() выполняются до всех методов OnEnable(). Таким образом, ваш скрипт с порядком -110 выполнит свой Awake(), затем LocalizedPrefab с порядком -100 выполнит свой Awake(), и только после этого в порядке выполнения будут вызваны их методы OnEnable(). Ваш скрипт не найдет объект, так как он еще не будет создан.",
  "q_faq_components_6": "Компонент LocalizedText имеет опцию isStyleOnly. Если я включу ее, а затем в коде вызову myLocalizedText.SetFormattedText(\"new_key\"), изменится ли текст или только стиль (шрифт/RTL)?",
  "a_faq_components_6": "Изменится и ключ, и текст. Вызов SetFormattedText программно переопределяет поведение isStyleOnly для этого конкретного обновления. Опция isStyleOnly предназначена для того, чтобы компонент не реагировал на глобальную смену языка, но он всегда будет реагировать на прямое изменение ключа через код.",
  "q_faq_components_7": "LocalizedBehaviour автоматически находит методы с атрибутом [OnLanguageChange]. Будет ли он находить private и protected методы, или они должны быть public?",
  "a_faq_components_7": "Он найдет методы с любым модификатором доступа (public, private, protected, internal). Рефлексия в Unity позволяет обнаруживать все методы экземпляра независимо от их уровня доступа.",
  "q_faq_components_8": "Компонент LocalizedAsset перехватывает Play on Awake. Что произойдет, если на том же объекте есть другой скрипт, который в Awake() или Start() пытается получить доступ к ассету (например, audioSource.clip.length) до того, как LocalizedAsset его подменит? Возможен ли NullReferenceException или использование старого ассета?",
  "a_faq_components_8": "Возможна работа со старым (нелокализованным) ассетом. LocalizedAsset выполняет подмену в своем OnEnable(). Методы Awake() всех скриптов выполняются до OnEnable(). Если ваш скрипт в Awake() обратится к audioSource.clip, он получит исходный клип. Если же он обратится в Start(), то результат будет зависеть от порядка выполнения скриптов. Чтобы гарантировать доступ к локализованному ассету, либо установите вашему скрипту более поздний порядок выполнения, либо получайте доступ к ассету в методе, помеченном [OnLanguageChange].",
  "h2_faq_window": "10.3. Окно \"Localization Tool\"",
  "h3_faq_window_preview": "Предпросмотр в редакторе",
  "q_faq_window_preview_1": "Я открыл префаб в режиме Prefab Mode, применил In-Editor Preview и нажал Ctrl+S. Сохранятся ли временные preview-данные в ассете префаба? Как LocalizationPreviewProtector обрабатывает этот случай?",
  "a_faq_window_preview_1": "Нет, не сохранятся. LocalizationPreviewProtector перехватывает событие сохранения ассета (OnWillSaveAssets) и автоматически вызывает RevertEditorPreview() до того, как Unity запишет изменения на диск. Таким образом, префаб будет сохранен в своем исходном, нелокализованном состоянии.",
  "q_faq_window_preview_2": "Если я включу In-Editor Preview и редактор Unity аварийно завершит работу, а файл Temp/localization_preview_recovery.json окажется поврежден (например, пустой или с некорректным JSON), что произойдет при следующем запуске?",
  "a_faq_window_preview_2": "PreviewCrashProtector обернут в try-catch блок. Если десериализация JSON не удастся, в консоль будет выведена ошибка о невозможности восстановления, и процесс тихо завершится. Ваша сцена останется в том \"сломанном\" состоянии, в котором она была на момент сбоя. В этом случае вам нужно будет вручную выбрать \"Revert to Original\" в окне инструмента, чтобы принудительно откатить изменения.",
  "q_faq_window_preview_3": "В режиме In-Editor Preview для LocalizedPrefab создается временный экземпляр. Будут ли на этом экземпляре выполняться методы Awake() и Start()? Может ли это вызвать ошибки, если они не рассчитаны на работу в Edit Mode?",
  "a_faq_window_preview_3": "Да, будут. PrefabUtility.InstantiatePrefab в Edit Mode вызывает Awake() и OnEnable(). Если в этих методах есть логика, которая не должна выполняться в редакторе (например, доступ к синглтонам, которые существуют только в Play Mode), это может вызвать ошибки. Рекомендуется использовать if (Application.isPlaying) или #if UNITY_EDITOR для защиты такого кода.",
  "h3_faq_window_settings": "Вкладка \"Settings\"",
  "q_faq_window_settings_1": "Я могу сменить Key Generation Mode с UseTextAsKey на AutoGenerateKeysOnly в середине проекта. Что именно произойдет с моими существующими переводами? Они будут сопоставлены с новыми ключами?",
  "a_faq_window_settings_1": "Да, будут. При смене режима инструмент выполняет \"безопасную миграцию\": он заново парсит весь проект, создает новые ключи по новым правилам, но при этом сопоставляет старые и новые ключи через исходный текст. Затем он переносит все ваши существующие переводы и комментарии со старых ключей на новые. Ваши переводы не будут потеряны.",
  "q_faq_window_settings_2": "Если я добавлю в список Supported Languages язык с кодом, для которого нет правил плюрализации (например, \"kz\" для казахского), какое правило будет использоваться по умолчанию?",
  "a_faq_window_settings_2": "Будет использоваться правило DefaultPluralRule, которое подходит для английского и большинства европейских языков (формы для \"один\" и \"другие\").",
  "q_faq_window_settings_3": "Что если я укажу Translations Path не в StreamingAssets, а в обычной папке Assets/MyTranslations? Будут ли файлы json включены в билд игры?",
  "a_faq_window_settings_3": "Нет, не будут. Только ассеты, находящиеся в папке StreamingAssets или Resources, гарантированно включаются в сборку. Если вы укажете другой путь, локализация будет работать в редакторе, но не будет работать в скомпилированной игре, так как файлы переводов не попадут в билд.",
  "q_faq_window_settings_4": "API-ключ для авто-перевода хранится в EditorPrefs. Если я работаю над проектом на двух разных компьютерах, мне нужно вводить ключ на каждой машине отдельно?",
  "a_faq_window_settings_4": "Да. EditorPrefs — это локальное хранилище для каждого компьютера. Вам нужно будет ввести API-ключ на каждой машине, с которой вы планируете использовать функцию авто-перевода.",
  "h3_faq_window_content": "Вкладка \"Content\"",
  "q_faq_window_content_1": "Что если я добавлю в Scenes to Parse сцену, которая не включена в Build Settings? Повлияет ли это на что-то, кроме самого процесса парсинга?",
  "a_faq_window_content_1": "Нет, не повлияет. Список Scenes to Parse используется исключительно для того, чтобы инструмент знал, какие сцены нужно открыть и проанализировать на наличие текста. Это никак не связано со сценами, которые попадут в финальный билд вашей игры.",
  "q_faq_window_content_2": "Я добавил объект в Ignore Specific Objects (временный список). Если я сделаю из этого объекта префаб, будет ли экземпляр этого префаба также игнорироваться?",
  "a_faq_window_content_2": "Нет, не будет. Временный список хранит прямую ссылку на объект в сцене. Когда вы создаете префаб, это новый ассет. Его экземпляры — это другие объекты, и на них правило игнорирования не распространится. Для постоянного игнорирования префабов их нужно добавлять в список игнорирования как ассет префаба.",
  "q_faq_window_content_3": "Если я добавлю в Parsing Ignores -> Ignore Component Types компонент TMPro.TMP_Text, но при этом на сцене есть объект с LocalizedText, который уже ссылается на этот TMP_Text, что произойдет при следующем Update Keys? Ключ будет удален?",
  "a_faq_window_content_3": "Да, будет. При нажатии Update Keys парсер заново сканирует весь проект. Он увидит, что тип TMPro.TMP_Text нужно игнорировать, и не сгенерирует для него ключ. В процессе сверки старых и новых ключей он определит, что старый ключ больше не используется, и пометит его как \"Removed\".",
  "q_faq_window_content_4": "В документации сказано, что \"Pin\" сохраняет полный путь к объекту и сломается при переименовании. А если я сделаю из объекта префаб, а потом переименую исходный объект — \"Pin\" продолжит работать для экземпляров префаба?",
  "a_faq_window_content_4": "Нет, не продолжит. \"Pin\" сохраняет абсолютный путь в иерархии сцены на момент нажатия кнопки (например, Canvas/Panel/Button). Этот путь никак не связан с логикой префабов. Экземпляры префаба будут иметь такой же путь, но если вы переименуете родительский объект в сцене, \"Pin\" перестанет работать как для оригинала, так и для экземпляров.",
  "q_faq_window_content_5": "Если я использую \"Pin\" для дочернего объекта внутри экземпляра префаба, какой путь будет сохранен: относительно корня префаба или корня сцены? Будет ли он работать в других сценах?",
  "a_faq_window_content_5": "Будет сохранен полный путь от корня сцены. Например, MyPrefab(Clone)/Content/Icon. Этот \"закрепленный\" путь будет работать только в той сцене, где вы его создали. В других сценах такой путь, скорее всего, не будет найден.",
  "h3_faq_window_actions": "Вкладка \"Actions\"",
  "h3_faq_window_assets": "Вкладка \"Assets\"",
  "h3_faq_window_report": "Вкладка \"Report\"",
  "h2_faq_editor": "10.4. Редактор переводов",
  "h2_faq_examples": "10.5. Примеры использования и работа с кодом",
  "h2_faq_notes": "10.6. Важные нюансы и предупреждения",
  "h2_faq_extending": "10.7. Расширение функционала",
  "q_faq_window_actions_1": "Что произойдет, если во время пакетного авто-перевода пропадет интернет-соединение? Инструмент попытается повторить неудачный пакет (batch) согласно настройкам Retry Policy или процесс прервется полностью?",
  "a_faq_window_actions_1": "Инструмент попытается повторить отправку именно того пакета, который не удался, согласно настройкам Retry Policy (количество попыток и задержка). Если все попытки для этого пакета закончатся неудачей, процесс перевода для текущего языка прервется, и в консоль будет выведена ошибка. Перевод для следующих языков в очереди не начнется.",
  "q_faq_window_actions_2": "Если я импортирую CSV-файл, в котором есть ключи, уже существующие в проекте, но с пустыми значениями для некоторых языков, эти пустые значения заменят мои существующие переводы или будут проигнорированы?",
  "a_faq_window_actions_2": "Пустые значения заменят существующие переводы. Процесс импорта рассматривает CSV-файл как \"источник правды\". Если для ключа welcome_message в колонке ru стоит пустое значение, то текущий русский перевод для этого ключа будет затерт.",
  "q_faq_window_actions_3": "Секция \"Danger Zone\" позволяет удалить все компоненты. Удалит ли она компоненты с префабов, которые находятся в папках, не указанных в Prefab Folders на вкладке Content?",
  "a_faq_window_actions_3": "Да, удалит. Функции из \"Danger Zone\" сканируют все префабы в проекте (AssetDatabase.FindAssets(\"t:Prefab\")), а не только те, что указаны в списке для парсинга, чтобы обеспечить максимально полную очистку.",
  "q_faq_window_actions_4": "При импорте из Google Sheets, как правильно оформить колонку с комментариями, чтобы работала валидация плейсхолдеров через директиву @placeholders:?",
  "a_faq_window_actions_4": "В вашей таблице Google Sheets колонка должна иметь заголовок Developer Notes. В ячейках этой колонки вы можете писать комментарии как обычно. Чтобы указать плейсхолдеры, просто добавьте строку вида @placeholders: {username}, {score} в текст комментария. Инструмент автоматически распознает эту директиву при импорте.",
  "q_faq_window_actions_5": "Может ли инструмент импортировать данные с нескольких листов (sheets) одного документа Google Sheets, или он работает только с одним листом по GID?",
  "a_faq_window_actions_5": "Инструмент работает только с одним листом за раз. URL для импорта включает параметр gid=..., который однозначно указывает на конкретный лист в документе. Чтобы импортировать данные с другого листа, вам нужно скопировать его URL (с другим gid) и выполнить импорт повторно.",
  "q_faq_window_assets_1": "Что если у меня есть два ассета с одинаковым ключом, но разным типом в одной и той же папке сканирования (например, sound_effect_en.mp3 и sound_effect_en.wav)? Какой из них попадет в таблицу ассетов?",
  "a_faq_window_assets_1": "Сканер ассетов загружает их с указанием ожидаемого типа (AssetDatabase.LoadAssetAtPath(path, expectedType)). Для категории AudioClip он будет искать и загружать только файлы, которые Unity распознает как AudioClip. Если оба файла являются валидными аудиоклипами, то в таблицу попадет тот, который будет обработан последним, фактически перезаписав предыдущий. Рекомендуется избегать таких дубликатов.",
  "q_faq_window_assets_2": "Если я нажму Scan Assets & Analyze Project, а на сцене есть объект Image, для которого уже есть локализованный спрайт, но на самом объекте Image еще нет компонента LocalizedAsset, добавит ли инструмент компонент и автоматически подставит ключ?",
  "a_faq_window_assets_2": "Да, именно так он и работает. \"Analyze Project\" находит компонент Image, смотрит на имя назначенного ему спрайта (например, icon_play_en), извлекает из него ключ (icon_play) и язык (en), а затем добавляет на этот GameObject компонент LocalizedAsset и вписывает в него ключ icon_play.",
  "q_faq_window_assets_3": "Могу ли я использовать одно и то же правило Naming Rule для разных категорий ассетов, если у них разные Scan Folder? Не вызовет ли это конфликтов?",
  "a_faq_window_assets_3": "Да, можете. Конфликтов не будет, так как для каждой категории создается своя таблица ассетов (LocalizedAssetTable). Ключи из категории \"Sprites\" не пересекаются с ключами из категории \"AudioClips\", даже если они называются одинаково.",
  "q_faq_window_assets_4": "Если локализуемый ассет (например, button_ok_en.png) находится не в корне Scan Folder, а во вложенной папке, найдет ли его сканер?",
  "a_faq_window_assets_4": "Да, найдет. Сканер использует опцию SearchOption.AllDirectories, что означает, что он будет рекурсивно проверять все вложенные папки внутри указанной вами Scan Folder.",
  "q_faq_window_report_1": "Кнопка \"Find\" ищет объект асинхронно. Что если я запущу поиск, а затем сразу же нажму Update Keys? Прервется ли поиск?",
  "a_faq_window_report_1": "Да, прервется. Любое новое действие, требующее блокировки UI (как Update Keys), остановит текущую корутину поиска. Появится диалоговое окно, предлагающее остановить текущий поиск, чтобы начать новый.",
  "q_faq_window_report_2": "Если ключ используется в нескольких местах (например, на двух разных кнопках в разных сценах), как это будет отображено в отчете в категории \"Duplicates\"?",
  "a_faq_window_report_2": "В категории \"Duplicates\" будут показаны все источники для данного ключа. Вы увидите одну запись для ключа, а в поле \"Source\" будут перечислены все пути (и в сцене 1, и в сцене 2). Кнопка \"Find\" в этом случае откроет выпадающий список, позволяя вам выбрать, к какому именно объекту перейти.",
  "q_faq_window_report_3": "Если я нажму \"Find\" для ключа, который используется только в коде (через функцию _()), что произойдет? Сможет ли инструмент найти и подсветить C# скрипт?",
  "a_faq_window_report_3": "Да. Система поиска специально обучена распознавать источники вида script MyScript.cs. При нажатии \"Find\" она выполнит поиск ассета MyScript.cs в проекте и подсветит (пропингует) его в окне Project.",
  "q_faq_editor_1": "Что имеет больший приоритет для валидации плейсхолдеров: директива @placeholders: в комментарии или плейсхолдеры, найденные в тексте исходного языка? Например, если в исходном тексте есть {name}, а в комментарии написано @placeholders: {username}.",
  "a_faq_editor_1": "Приоритет имеет директива @placeholders: в комментарии. Она рассматривается как явное указание разработчика и \"источник правды\". В вашем примере редактор будет требовать наличия {username} в переводе и проигнорирует {name} из исходного текста.",
  "q_faq_editor_2": "Если я допущу опечатку в директиве (например, @placeholder: вместо of @placeholders:), будет ли она проигнорирована или инструмент выдаст предупреждение?",
  "a_faq_editor_2": "Она будет просто проигнорирована. Инструмент ищет точное совпадение @placeholders:. Если директива написана с ошибкой, она будет считаться частью обычного комментария, и валидация будет работать по старинке — на основе плейсхолдеров из исходного текста.",
  "q_faq_editor_3": "Система автосохранения создает файлы в папке Backups/AutoSaves. Будут ли эти файлы автоматически удаляться после успешного ручного сохранения или закрытия окна?",
  "a_faq_editor_3": "Да. При успешном ручном сохранении или штатном закрытии окна (когда вы сохраняете изменения) все файлы автосохранения удаляются, чтобы не предлагать восстановление при следующем запуске. Они остаются только в случае аварийного завершения работы редактора.",
  "q_faq_editor_4": "Если я изменю ширину колонок в редакторе, эти настройки сохранятся между сессиями Unity?",
  "a_faq_editor_4": "Да. Ширина колонок сохраняется в EditorPrefs каждый раз, когда вы закрываете окно редактора переводов, и будет восстановлена при следующем открытии.",
  "q_faq_editor_5": "Поддерживает ли всплывающее окно редактирования текста (MultiLineEditWindow) свой собственный стек операций Undo/Redo (через Ctrl+Z) для изменений, сделанных внутри него?",
  "a_faq_editor_5": "Да. MultiLineEditWindow имеет свой собственный, временный стек Undo/Redo, который работает, пока окно открыто. Это позволяет вам отменять и возвращать изменения текста внутри этого окна. Как только вы сохраняете результат (закрывая окно), это изменение записывается как единое действие в глобальный стек Undo/Redo основного редактора.",
  "q_faq_examples_1": "Что произойдет, если имена свойств в анонимном типе, переданном в функцию _(), не совпадут с плейсхолдерами в строке? Например, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Будет ли ошибка или плейсхолдер просто не заменится?",
  "a_faq_examples_1": "Ошибки не будет. Плейсхолдер {username} просто не будет заменен, и в результате вы получите строку \"Hello, {username}\". Замена происходит только при точном совпадении имен.",
  "q_faq_examples_2": "Атрибут [LocalizableField] работает для private полей. Будет ли он работать для static полей?",
  "a_faq_examples_2": "Да, будет. Парсер использует рефлексию для поиска полей с флагами BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, поэтому он найдет и обработает статические поля.",
  "q_faq_examples_3": "Если я повешу атрибут [OnLanguageChange] на метод с параметрами (например, void UpdateUI(string newLang)), что произойдет? Будет ли ошибка компиляции или предупреждение в рантайме?",
  "a_faq_examples_3": "Ошибки компиляции не будет, но в консоли Unity при запуске появится предупреждение от LocalizedBehaviour. Он сообщит, что нашел метод с атрибутом, но проигнорировал его, так как метод имеет параметры. Вызываться такой метод не будет.",
  "q_faq_examples_4": "Я использую _(\"apple_count\", count). Если для текущего языка нет ключа apple_count_one (для count = 1), какую форму выберет система? Будет ли она использовать apple_count_other как запасной вариант?",
  "a_faq_examples_4": "Да. Если конкретная форма (_one, _few и т.д.) не найдена, система в качестве запасного варианта попытается использовать ключ с суффиксом _other. Если и он не найден, будет использован перевод для базового ключа apple_count.",
  "q_faq_examples_5": "Функция _(\"key\", new { username = \"Alex\" }) использует анонимный тип. Не создаст ли это избыточную \"нагрузку\" на сборщик мусора (GC) при частом вызове в методе Update() по сравнению с передачей заранее созданного словаря Dictionary<string, object>?",
  "a_faq_examples_5": "Да, создаст. Каждый вызов new { ... } приводит к выделению памяти в управляемой куче, что создает дополнительную работу для сборщика мусора. Для текста, который обновляется каждый кадр (в Update или LateUpdate), значительно производительнее будет создать Dictionary<string, object> один раз в Start(), а в Update() только обновлять значения в нем и передавать его в функцию _().",
  "q_faq_notes_1": "В документации рекомендуется добавлять LanguageSelector в список игнорирования. Что конкретно сломается, если я забуду это сделать? Будут ли создаваться лишние ключи для опций \"Option A, Option B\"?",
  "a_faq_notes_1": "Да. Если не добавить LanguageSelector в игнор, парсер обработает его TMP_Dropdown как обычный выпадающий список. Он найдет стандартные опции \"Option A, Option B, Option C\", которые Unity создает по умолчанию, и добавит для них ключи в ваши файлы переводов. Это \"замусорит\" ваши файлы ненужными ключами, так как LanguageSelector все равно удалит эти опции в рантайме и создаст свои.",
  "q_faq_notes_2": "Если я забуду добавить пустой LocalizedText с галочкой isStyleOnly на Label внутри TMP_Dropdown, который используется в LanguageSelector, шрифт не будет меняться? Почему это необходимо?",
  "a_faq_notes_2": "Да, шрифт не будет меняться. Это необходимо, потому что LanguageSelector напрямую меняет свойство label.text. Без LocalizedText на этом объекте система локализации не знает, что этому элементу нужно применять стили (шрифт, RTL) при смене языка. Пустой LocalizedText с isStyleOnly служит \"маркером\" для системы, говоря: \"Следи за этим объектом и применяй к нему стили, но не трогай его текст\".",
  "q_faq_notes_3": "Вызов _() в методе Update() не рекомендуется. Но что если мне нужно обновлять текст каждый кадр (например, таймер)? Какой самый производительный способ это сделать, кэшируя только форматную строку?",
  "a_faq_notes_3": "Самый производительный подход — кэшировать форматную строку в Start() или в методе [OnLanguageChange], а в Update() использовать обычный string.Format. Пример: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Это позволяет избежать поиска ключа в словаре каждый кадр, что значительно быстрее.",
  "q_faq_extending_1": "Мой кастомный парсер будет вызываться автоматически после каждого Update Keys? Нужно ли мне где-то его регистрировать, или достаточно просто наличия класса, реализующего ITextComponentParser, в проекте?",
  "a_faq_extending_1": "Достаточно просто наличия класса. При запуске TextParser использует рефлексию, чтобы найти все классы в проекте, которые реализуют интерфейс ITextComponentParser, и автоматически вызывает их метод Parse() для каждого GameObject. Никакой ручной регистрации не требуется.",
  "q_faq_extending_2": "Что если в моем кастомном парсере произойдет исключение (exception)? Прервет ли это весь процесс парсинга или инструмент безопасно продолжит работу с другими парсерами?",
  "a_faq_extending_2": "Исключение в вашем кастомном парсере прервет процесс. Основной цикл парсинга не оборачивает вызовы кастомных парсеров в блок try-catch. Если ваш метод Parse() выбросит необработанное исключение,",
  "toggle_notes_title": "Переключить заметки",
  "mindmap_toggle_title": "Показать интеллект-карту",
  "on_this_page_title": "На этой странице",
  "my_notes_title": "Мои заметки",
  "no_notes_message_new": "Наведите курсор на текст, чтобы добавить заметку.",
  "notes_add_title": "Добавить заметку к этому блоку",
  "notes_placeholder": "Ваша заметка...",
  "notes_close_title": "Закрыть",
  "notes_goto_title": "Перейти к тексту",
  "notes_edit_title": "Редактировать заметку",
  "notes_delete_title": "Удалить заметку",
  "notes_edit_text": "Редактировать",
  "copy_code_copy": "Копировать",
  "copy_code_copied": "Скопировано!",
  "copy_code_error": "Ошибка",
  "error_loading_title": "Ошибка загрузки",
  "error_loading_message": "Пожалуйста, проверьте соединение и обновите страницу.",
  "lightbox_aria_close": "Закрыть просмотрщик изображений",
  "lightbox_image_alt": "Увеличенный вид",
  "mindmap_preset_full": "Полный вид",
  "mindmap_preset_quick_start": "Быстрый старт",
  "mindmap_preset_dev": "Рабочий процесс разработчика",
  "mindmap_preset_translator": "Рабочий процесс переводчика",
  "mindmap_edge_configure": "1. Настроить",
  "mindmap_edge_specify_content": "2. Указать контент",
  "mindmap_edge_parse_project": "3. Проанализировать проект",
  "mindmap_edge_creates_components": "Создает компоненты",
  "mindmap_edge_generates": "Генерирует",
  "mindmap_edge_opens": "Открывает",
  "mindmap_edge_manages_assets": "Управляет ассетами для",
  "mindmap_edge_defines_rules": "Определяет правила для",
  "mindmap_edge_reports_on": "Сообщает о",
  "mindmap_edge_enables_reaction": "Включает реакцию через",
  "mindmap_edge_processed_by": "Обрабатывается",
  "mindmap_edge_edited_in": "Редактируется в",
  "mindmap_edge_extends": "Расширяет",
  "mindmap_edge_warns_about": "Предупреждает о",
  "mindmap_edge_relates_to": "Относится к",
  "mindmap_edge_recommends_for": "Рекомендует для",
  "mindmap_edge_see_faq": "См. FAQ"
}