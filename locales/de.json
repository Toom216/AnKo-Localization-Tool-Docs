{
  "page_title": "Dokumentation zum Unity-Lokalisierungstool",
  "toc_title": "Inhaltsverzeichnis",
  "toc_search_placeholder": "Dokumentation durchsuchen...",
  "nav_introduction": "1. Einleitung",
  "nav_quick_start": "2. Schnellstart",
  "nav_components": "3. Kernkomponenten",
  "nav_loc_tool_window": "4. Fenster \"Localization Tool\"",
  "nav_translation_editor": "5. Übersetzungseditor",
  "nav_ai_profiles": "6. KI & Übersetzungs-Profile (Neu v1.1)",
  "nav_usage_examples": "7. Anwendungsbeispiele",
  "nav_important_notes": "8. Wichtige Hinweise",
  "nav_extending": "9. Funktionalität erweitern",
  "nav_faq": "10. FAQ & Fehlerbehebung",
  "nav_key_features": "Hauptmerkmale",
  "nav_installation": "2.1. Installation",
  "nav_initial_setup": "2.2. Ersteinrichtung",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. Kontextmenü",
  "nav_in_editor_preview": "4.1. Vorschau im Editor & Prefab",
  "nav_tab_settings": "4.2. Registerkarte \"Einstellungen\"",
  "nav_tab_content": "4.3. Registerkarte \"Inhalt\" (Neu gestaltet)",
  "nav_tab_actions": "4.4. Registerkarte \"Aktionen\"",
  "nav_tab_assets": "4.5. Registerkarte \"Assets\"",
  "nav_tab_report": "4.6. Registerkarte \"Bericht\"",
  "nav_ai_profiles_overview": "6.1. Übersetzungs-Profile",
  "nav_custom_ai": "6.2. Benutzerdefinierte KI & Modelle",
  "nav_ai_context": "6.3. Kontext & Glossar",
  "nav_ai_assistant": "6.4. KI-Assistenten-Befehle",
  "nav_example_components": "7.1. Vorgefertigte Komponenten",
  "nav_example_attribute": "7.2. [LocalizableField] Attribut",
  "nav_example_function": "7.3. _() Funktion",
  "nav_example_plurals": "7.4. Plural & Geschlecht",
  "nav_custom_parser": "9.1. Einen Parser erstellen",
  "nav_faq_installation": "10.1. Installation & Schnellstart",
  "nav_faq_components": "10.2. Kernkomponenten",
  "nav_faq_window": "10.3. Fenster \"Localization Tool\"",
  "nav_faq_window_actions": "10.3. Fenster \"Localization Tool\" - Registerkarte \"Aktionen\"",
  "nav_faq_window_assets": "10.3. Fenster \"Localization Tool\" - Registerkarte \"Assets\"",
  "nav_faq_window_report": "10.3. Fenster \"Localization Tool\" - Registerkarte \"Bericht\"",
  "nav_faq_editor": "10.4. Übersetzungseditor",
  "nav_faq_examples": "10.5. Anwendungsbeispiele & Code",
  "nav_faq_notes": "10.6. Wichtige Nuancen & Warnungen",
  "nav_faq_extending": "10.7. Funktionalität erweitern",
  "h1_introduction": "Einleitung",
  "p_intro_1": "Dieses Tool ist eine umfassende Lösung zur Lokalisierung von Spielen und Anwendungen in Unity. Es automatisiert das Sammeln von Texten und Assets, die Verwaltung von Übersetzungen über eine leistungsstarke Benutzeroberfläche, die Integration mit maschinellen Übersetzungsdiensten (einschließlich Benutzerdefinierter KI) und die dynamische Aktualisierung lokalisierter Inhalte im Spiel.",
  "h2_key_features": "Hauptmerkmale",
  "li_feature_1": "<strong>Erweitertes Parsen:</strong> Automatisches Scannen von Szenen, Prefabs, UI Toolkit (UXML) und C#-Skripten, einschließlich Feldern, die mit dem Attribut <code>[LocalizableField]</code> markiert sind, sowie verschachtelten Klassen und Listen.",
  "li_feature_2": "<strong>Lokalisierung beliebiger Assets:</strong> Verwalten von Sprites, Audio, Prefabs, Materialien usw.",
  "li_feature_3": "<strong>Leistungsstarker Übersetzungseditor:</strong> Eine zentralisierte Benutzeroberfläche mit automatischer Speicherung, voller Undo/Redo-Unterstützung, intelligenter Schlüsselgruppierung und <strong>Neu in v1.1:</strong> Aktionen für Mehrfachauswahl.",
  "li_feature_4": "<strong>KI & Maschinelle Übersetzung (v1.1):</strong> Neues Profilsystem mit Unterstützung für DeepL, Google, Microsoft und <strong>Benutzerdefinierte KI (OpenAI, Gemini, Claude, Ollama)</strong> mit Kontextbewusstsein.",
  "li_feature_5": "<strong>Flexibler Import/Export:</strong> Unterstützung für CSV, XML, YAML, XLIFF und direkter Import aus Google Sheets.",
  "li_feature_6": "<strong>Live-Vorschau im Editor:</strong> Vorschau jeder Sprache, ohne das Spiel zu starten.",
  "li_feature_7": "<strong>Plural- & Geschlechtsunterstützung:</strong> Korrekte Handhabung von Pluralformen (mit Regeln für slawische, arabische und andere Sprachen) und Geschlecht.",
  "li_feature_8": "<strong>Volle RTL-Unterstützung:</strong> Korrekte Anzeige von Rechts-nach-Links-Sprachen.",
  "li_feature_9": "<strong>Live-Updates:</strong> Laden Sie aktuelle Übersetzungen von einem Remote-Server beim Spielstart.",
  "li_feature_10": "<strong>Backup-Manager:</strong> Ein integriertes Werkzeug zum Erstellen und Wiederherstellen von Backups.",
  "h1_quick_start": "Schnellstart und Einrichtung",
  "h2_installation": "2.1. Installation",
  "li_install_1": "Kopieren Sie das Asset in Ihren Unity-Projektordner.",
  "li_install_2": "Das Tool prüft automatisch auf notwendige Abhängigkeiten. Bestätigen Sie die Installation im erscheinenden Dialogfeld.",
  "li_install_3": "Erforderliche Abhängigkeiten (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) sind für die Grundfunktionalität notwendig.",
  "li_install_4": "Optionale Abhängigkeiten (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) aktivieren zusätzliche Funktionen.",
  "li_install_5": "Klicken Sie auf <strong>Ausgewählte installieren</strong>, um die empfohlenen Pakete zu installieren.",
  "li_install_6": "Öffnen Sie nach der Installation das Hauptfenster des Tools über das Menü <strong>Tools -> Localization Tool</strong>.",
  "h2_initial_setup": "2.2. Ersteinrichtung",
  "li_setup_1": "<strong>Einstellungen erstellen:</strong> Beim ersten Öffnen erstellt das Tool eine <code>LocalizationSettings.asset</code>-Datei im Ordner <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Sprachen konfigurieren:</strong> Stellen Sie auf der Registerkarte <strong>Einstellungen</strong> unter <strong>Sprachverwaltung</strong> sicher, dass Ihre Hauptsprache (z. B. <code>en</code> für Englisch) als <strong>Quellsprache</strong> ausgewählt ist. Aktivieren Sie alle Sprachen, die Sie unterstützen möchten.",
  "li_setup_3": "<strong>Inhalt zum Parsen angeben:</strong> Fügen Sie auf der Registerkarte <strong>Inhalt</strong> alle zu analysierenden Szenen zur Liste <strong>Zu parsende Szenen</strong> hinzu. Wenn Sie Prefabs mit Text verwenden, stellen Sie sicher, dass deren Ordner zu <strong>Prefab-Ordner</strong> hinzugefügt werden.",
  "li_setup_4": "<strong>Erster Parser-Lauf:</strong> Gehen Sie zur Registerkarte <strong>Aktionen</strong> und klicken Sie auf die Schaltfläche <code>Schlüssel aktualisieren</code>. Das Tool scannt Ihr Projekt, erstellt Übersetzungsdateien und fügt den Spielobjekten automatisch die erforderlichen Komponenten (<code>LocalizedText</code>, <code>LocalizedAsset</code> usw.) hinzu.",
  "h1_components": "Kernkomponenten (werden automatisch zugewiesen)",
  "warning_box_components": "<strong>Wichtiger Hinweis:</strong> Alle unten beschriebenen Komponenten werden während des Parsens (wenn Sie auf die Schaltfläche <code>Schlüssel aktualisieren</code> klicken) automatisch zu Spielobjekten hinzugefügt. Sie müssen sie nicht manuell hinzufügen.",
  "p_components_intro": "Diese Komponenten sind die \"Brücke\" zwischen Ihren Objekten in der Szene und der Übersetzungsdatenbank. Sie \"lauschen\" auf Sprachänderungen und setzen automatisch den richtigen Text oder das richtige Asset ein.",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "Die Hauptkomponente zur Anzeige von übersetztem Text. Sie wird auf Objekten mit <code>Text</code>, <code>TMP_Text</code> und <code>TextMesh</code> platziert.",
  "li_localizedtext_1": "<code>localizationKey</code>: Der Schlüssel, mit dem die Übersetzung gefunden wird. Wird automatisch generiert.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Wenn <code>true</code>, wendet die Komponente nur Stile (Schriftart, RTL) an, ändert aber nicht den Text selbst. Nützlich für Elemente, deren Text von einem anderen Skript verwaltet wird (z. B. <code>LanguageSelector</code>).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Der Originaltext in der Basissprache. Wird als Fallback verwendet.",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "Wird verwendet, um Assets auszutauschen (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code> usw.). Es erkennt automatisch den Zielkomponententyp am Objekt (<code>Image</code>, <code>AudioSource</code>) und ersetzt dessen Ressource.",
  "p_localizedasset_2": "Für Komponenten mit der Option <strong>Play on Awake</strong> (wie <code>AudioSource</code>, <code>VideoPlayer</code>) fängt <code>LocalizedAsset</code> die automatische Wiedergabe korrekt ab, tauscht das Asset aus und startet dann die Wiedergabe, um das Abspielen von nicht lokalisierten Inhalten zu vermeiden.",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "Eine Komponente zur Lokalisierung ganzer Prefabs. Sie arbeitet nicht-destruktiv: Sie modifiziert nicht das ursprüngliche Prefab, sondern erstellt eine Instanz der lokalisierten Version als Kindobjekt und deaktiviert alle Skripte (<code>MonoBehaviour</code>), Renderer (<code>Renderer</code>) und Collider (<code>Collider</code>) am ursprünglichen Objekt. Dies verhindert eine doppelte Logikausführung und visuelle Artefakte. Für einen korrekten Laufzeitbetrieb ist die Ausführungsreihenfolge auf -100 (<code>[DefaultExecutionOrder(-100)]</code>) festgelegt, um sicherzustellen, dass es vor anderen Skripten ausgeführt wird.",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "Wird zu Objekten mit einem <code>UIDocument</code> hinzugefügt und verwaltet die Lokalisierung aller Textelemente innerhalb des UI Toolkit-Dokuments (UXML).",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "Wird zu <code>Dropdown</code> und <code>TMP_Dropdown</code> hinzugefügt, um deren Optionen zu übersetzen.",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "Eine Hilfskomponente, die es Ihren Skripten ermöglicht, auf Sprachänderungen zu reagieren. Sie findet und ruft automatisch Methoden auf, die mit dem Attribut <code>[OnLanguageChange]</code> markiert sind.",
  "h2_context_menu": "3.7. Kontextmenü \"Auf Lokalisierung analysieren\"",
  "p_context_menu_1": "Um einem Objekt schnell ein <code>LocalizedAsset</code> hinzuzufügen, können Sie im Inspektor mit der rechten Maustaste auf die gewünschte Komponente (z. B. <code>Image</code>, <code>AudioSource</code>) klicken und <strong>Auf Lokalisierung analysieren</strong> auswählen. Das Tool fügt die Komponente selbst hinzu und konfiguriert sie. (Dies ist optional, kann aber für manuelles Hinzufügen verwendet werden).",
  "h1_loc_tool_window": "Fenster \"Localization Tool\"",
  "h2_in_editor_preview": "4.1. Vorschau im Editor & Prefab",
  "p_preview_1": "Direkt unter der Überschrift befindet sich die Dropdown-Liste <strong>Vorschau-Sprache</strong>. Mit dieser leistungsstarken Funktion können Sie direkt im <strong>Szenen</strong>-Fenster oder **Prefab-Modus** sehen, wie die Lokalisierung in jeder Sprache aussehen wird, ohne das Spiel zu starten.",
  "li_preview_1": "<strong>Wie es funktioniert:</strong> Wählen Sie eine Sprache aus der Liste, und das Tool wendet sofort die entsprechenden Übersetzungen, Schriftarten, RTL-Einstellungen und Assets auf alle lokalisierbaren Objekte in der aktiven Szene oder dem geöffneten Prefab an.",
  "li_preview_2": "<strong>Platzhalter:</strong> Wenn ein Platzhalterstil (z. B. <strong>Akzente</strong> oder <strong>Klammern</strong>) auf der Registerkarte <strong>Einstellungen</strong> ausgewählt ist, werden diese Platzhalter im Vorschaumodus anstelle von tatsächlichen Übersetzungen angezeigt. Dies ist ideal zum Testen des Layouts und zum Finden nicht lokalisierter Elemente.",
  "li_preview_3": "<strong>Sicherheit:</strong> Alle im Vorschaumodus vorgenommenen Änderungen sind temporär. Das Tool setzt alles automatisch in den ursprünglichen Zustand zurück, wenn Sie \"<strong>Auf Original zurücksetzen</strong>\" auswählen, das Fenster schließen, die Szene wechseln oder **bevor Sie eine Szene/Prefab speichern** (dank der Komponente <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Absturzschutz:</strong> Das integrierte <code>PreviewCrashProtector</code>-System stellt den ursprünglichen Zustand von Objekten automatisch wieder her, wenn der Unity-Editor abstürzt, während eine Vorschau aktiv ist. **Unterstützt jetzt auch die Wiederherstellung im Prefab-Modus.**",
  "h2_tab_settings": "4.2. Registerkarte \"Einstellungen\"",
  "p_settings_1": "Ihre Steuerzentrale. Hier definieren Sie globale Regeln für den gesamten Lokalisierungsprozess.",
  "li_settings_1": "<strong>Schlüssel-Generierungsmodus:</strong> Wählen Sie, wie Schlüssel erstellt werden.<ul><li><code>UseTextAsKey</code>: Der Text selbst wird zum Schlüssel. Ideal für Prototypen. Nachteil: Wenn Sie den Quelltext ändern, ändert sich der Schlüssel und alle seine Übersetzungen gehen verloren.</li><li><code>AutoGenerateKeysOnly</code>: Der Schlüssel wird basierend auf der Hierarchie und dem Namen des Objekts generiert. Zuverlässig für die Produktion. Vorteil: Übersetzungen gehen bei Textänderungen nicht verloren.</li><li><code>UseTextAsKeyWithCustomPriority</code> und <code>AutoGenerateWithCustomKeys</code>: Hybridmodi, mit denen Sie benutzerdefinierte Schlüssel im Code über das Attribut <code>[LocalizableField(\"mein_benutzerdefinierter_schlüssel\")]</code> festlegen können.</li><li><strong>Sichere Migration:</strong> Sie können den Modus jederzeit ändern. Das Tool migriert automatisch alle vorhandenen Übersetzungen in das neue Schlüsselsystem.</li></ul>",
  "li_settings_2": "<strong>Sprachverwaltung:</strong> Konfigurieren Sie die Liste der Sprachen. Weisen Sie für Sprachen mit Sonderzeichen das entsprechende <strong>Font Asset</strong> zu. Aktivieren Sie die Option <strong>RTL</strong> für Rechts-nach-Links-Sprachen.",
  "li_settings_3": "<strong>Allgemeine Einstellungen:</strong><ul><li><code>Parse Prefabs</code>: Aktiviert das Parsen von Prefabs.</li><li><code>Split files by language</code>: Legt fest, wie Übersetzungen gespeichert werden (eine große Datei oder eine Datei pro Sprache).</li><li><code>Translations Path</code>: Der Pfad zum Speichern von <code>.json</code>-Übersetzungsdateien. Wichtig: Der Ordner muss sich in <code>Assets/StreamingAssets/</code> befinden.</li></ul>",
  "li_settings_4": "<strong>Debugging & Testen:</strong><ul><li><code>Placeholder Style</code>: Wählen Sie den Stil für die Anzeige von Platzhaltern im Vorschaumodus.</li></ul>",
  "li_settings_5": "<strong>Live-Updates:</strong> Einstellungen zum Laden von Übersetzungen von einem Remote-Server.",
  "li_settings_6": "<strong>Laufzeit-API-Schlüssel:</strong> Ein Abschnitt zur sicheren Speicherung eines API-Schlüssels, der im kompilierten Spiel benötigt werden könnte (wird verschlüsselt gespeichert).",
  "h2_tab_content": "4.3. Registerkarte \"Inhalt\" (Neu gestaltet in v1.1)",
  "p_content_1": "Hier teilen Sie dem Tool mit, wo genau nach Text gesucht werden soll. **Die Benutzeroberfläche wurde für eine bessere Benutzerfreundlichkeit komplett neu gestaltet.**",
  "li_content_1": "<strong>Zu parsende Szenen:</strong> Ziehen Sie alle zu analysierenden Szenen hierher.",
  "li_content_2": "<strong>Prefab-Ordner:</strong> Geben Sie Ordner mit Prefabs an. **Unterstützt jetzt Paginierung und Suche für große Projekte.**",
  "li_content_3": "<strong>Dynamische Texte:</strong> Geben Sie hier Zeichenfolgen ein, die ausschließlich im Code erstellt werden (z. B. \"Game Over\").",
  "li_content_4": "<strong>Ignorierte Elemente beim Parsen:</strong> Geben Sie Skripte, Komponenten oder Objekte an, die ignoriert werden sollen.",
  "li_content_5": "<strong>Anheften:</strong> Mit dieser Funktion können Sie ein Objekt aus der Szene in der Ignorierliste \"anheften\". Anstelle einer temporären Referenz auf das Objekt speichert das Tool seinen vollständigen Pfad in der Hierarchie, wodurch das Ignorieren zwischen Sitzungen persistent wird.",
  "h2_tab_actions": "4.4. Registerkarte \"Aktionen\"",
  "p_actions_1": "Die Hauptarbeitsregisterkarte.",
  "li_actions_1": "<strong>Schlüssel aktualisieren:</strong> Führt den Parser aus, der Ihre Übersetzungsdateien aktualisiert.",
  "li_actions_2": "<strong>Übersetzungseditor öffnen:</strong> Öffnet ein separates, bequemeres Fenster zum Bearbeiten aller Übersetzungen.",
  "li_actions_3": "<strong>Datenverwaltung:</strong> Zum Austausch von Daten mit Übersetzern (Export/Import nach CSV/XML/YAML/XLIFF, Import aus Google Sheets).",
  "li_actions_4": "<strong>Automatische Übersetzung:</strong> Füllt automatisch alle leeren Übersetzungszeichenfolgen **mithilfe des aktiven Übersetzungs-Profils.**",
  "li_actions_5": "<strong>Gefahrenzone:</strong> Enthält Schaltflächen zum vollständigen Entfernen aller Lokalisierungskomponenten aus dem Projekt. Mit Vorsicht verwenden!",
  "h2_tab_assets": "4.5. Registerkarte \"Assets\"",
  "p_assets_1": "Diese Registerkarte ist vollständig der Lokalisierung von nicht-textuellen Ressourcen gewidmet.",
  "li_assets_1": "<strong>Erstellen Sie eine Ordnerstruktur (optional):</strong> Klicken Sie in Abschnitt <strong>2. Asset-Ordner-Generierung</strong> auf <strong>Asset-Ordner jetzt erstellen</strong>.",
  "li_assets_2": "<strong>Konfigurieren Sie Kategorien und Benennungsregeln:</strong> Stellen Sie in Abschnitt <strong>3. Asset-Kategorien & Scannen</strong> sicher, dass die <strong>Benennungsregel</strong> (<code>{key}_{lang}</code>) mit Ihren Dateien übereinstimmt (z. B. <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Platzieren Sie Ihre Assets:</strong> Legen Sie die lokalisierten Assets in die Ordner.",
  "li_assets_4": "<strong>Assets scannen:</strong> Klicken Sie in Abschnitt <strong>4. Automatisierung</strong> auf <strong>Assets scannen & Tabellen aktualisieren</strong>. Der Bereinigungsprozess ist sicherer geworden: **Jetzt werden nur noch alte Tabellendateien (`.asset`) gelöscht, nicht der gesamte Ordner.**",
  "li_assets_5": "<strong>Assets mit Objekten verknüpfen:</strong> Klicken Sie auf <strong>Projekt analysieren & Komponenten anhängen</strong>.",
  "h2_tab_report": "4.6. Registerkarte \"Bericht\"",
  "p_report_1": "Nach jedem Parsen zeigt dieser Bericht das vollständige Bild Ihres Lokalisierungsstatus.",
  "li_report_1": "<strong>Kategorien:</strong> Alle Schlüssel, Hinzugefügt, Aktualisiert (Text geändert), Entfernt, Duplikate, Migriert, Übersprungen (unverändert).",
  "li_report_2": "<strong>Erweiterte Suche:</strong> Klicken Sie auf die Schaltfläche <strong>Suchen</strong> neben einem Eintrag, um das entsprechende Objekt im Projekt sofort zu finden. Die Suche arbeitet asynchron, blockiert den Editor nicht und **durchsucht alle Szenen und Prefabs.**",
  "h1_translation_editor": "Übersetzungs-Editor",
  "p_editor_1": "Öffnet sich über <strong>Tools -> Localization -> Translation Table Editor</strong>. Dies ist das Hauptwerkzeug zur manuellen Bearbeitung von Übersetzungen.",
  "li_editor_1": "<strong>Intelligente Gruppierung:</strong> Schlüssel für Plural und Geschlecht (z. B. <code>apple_count_one</code>, <code>apple_count_few</code>) werden automatisch zu ausklappbaren Gruppen zusammengefasst.",
  "li_editor_2": "<strong>Erweiterte Bearbeitung:</strong> Klicken Sie auf eine Zelle, um das Popup-Fenster <strong>MultiLineEditWindow</strong> zu öffnen. Es zeigt den Quelltext zum Vergleich an, ermöglicht ein schnelles Kopieren und prüft in Echtzeit auf Platzhalter-Inkonsistenzen (z. B. <code>{username}</code>), wobei fehlende oder zusätzliche hervorgehoben werden.",
  "li_editor_3": "**Erweiterte Auswahl (Neu):** Unterstützt die Auswahl einzelner Zellen, Zeilen oder ganzer Spalten (Sprachen).",
  "li_editor_4": "**Massenaktionen (Neu):** Klicken Sie mit der rechten Maustaste auf eine Auswahl, um Massenoperationen durchzuführen: Ausgewählte Zellen automatisch übersetzen, Inhalt löschen oder Schlüssel löschen.",
  "li_editor_5": "**Intelligente Navigation (Neu):** Navigieren Sie in der Tabelle mit den Tastaturpfeilen und Tastenkombinationen (Strg+S zum Speichern, Strg+Z/Y für Rückgängig/Wiederherstellen).",
  "li_editor_6": "**Längenprüfung (Neu):** Verwenden Sie den Filter „Hat Längenprobleme“, um Übersetzungen hervorzuheben, die signifikant länger als der Quelltext sind (konfigurierbarer Schwellenwert).",
  "h1_ai_profiles": "KI & Übersetzungs-Profile (Neu v1.1)",
  "h2_ai_profiles_overview": "6.1. Übersetzungs-Profile",
  "p_ai_intro": "Version 1.1 führt ein neues **Übersetzungs-Profil**-System (ScriptableObject) ein. Dadurch werden die Einstellungen für Übersetzungsdienste aus den globalen Einstellungen in einzelne Profil-Assets verschoben, was Ihnen einen einfachen Konfigurationswechsel ermöglicht.",
  "li_ai_1": "**Profil erstellen:** Klicken Sie im Projektfenster mit der rechten Maustaste auf -> Erstellen -> Localization -> Translation Profile.",
  "li_ai_2": "**Dienste:** Unterstützt DeepL, Google Translate, Microsoft Azure und **Benutzerdefinierte KI**.",
  "li_ai_3": "**Einstellungen:** Jedes Profil speichert seinen eigenen API-Schlüssel, Limits (Batch-Größe, max. Zeichen) und Modelleinstellungen.",
  "li_ai_4": "**AIPresetsGenerator:** Verwenden Sie den integrierten Generator, um schnell Profile für gängige Dienste (OpenAI, Gemini, Claude, Ollama) zu erstellen.",
  "h2_custom_ai": "6.2. Benutzerdefinierte KI & Modelle",
  "p_custom_ai": "Der Diensttyp **Benutzerdefinierte KI** ermöglicht es Ihnen, jedes LLM über die REST-API zu verbinden.",
  "li_custom_ai_1": "**GenericAIService:** Eine flexible Implementierung, die mit OpenAI-kompatiblen APIs kommunizieren kann (einschließlich lokaler LLMs über Ollama).",
  "li_custom_ai_2": "**Vorlagen:** Passen Sie die JSON-Vorlage für den Anforderungstext an die Anforderungen Ihrer API an.",
  "h2_ai_context": "6.3. Kontext & Glossar",
  "p_ai_context": "Um die Übersetzungsqualität zu verbessern, erhält die KI nun zusätzlichen Kontext:",
  "li_context_1": "**Entwickler-Notizen:** Kommentare aus der Übersetzungstabelle werden als Kontext an die KI übergeben.",
  "li_context_2": "**Objektpfad:** Wenn kein Kommentar existiert, wird der Hierarchiepfad des Objekts (z. B. <code>MainMenu/Canvas/StartButton</code>) als Fallback-Kontext verwendet.",
  "li_context_3": "**Glossar:** Sie können ein CSV-Glossar in das Profil laden, um spezifische Übersetzungen für Begriffe und Namen zu erzwingen.",
  "h2_ai_assistant": "6.4. KI-Assistenten-Befehle",
  "p_ai_assistant": "Im Übersetzungs-Editor können Sie nun benutzerdefinierte KI-Befehle für ausgewählte Zellen über das Kontextmenü ausführen (Rechtsklick -> AI: ...).",
  "li_assistant_1": "**Konfigurierbar:** Definieren Sie Befehle in Ihrem Übersetzungs-Profil (z. B. „Grammatik korrigieren“, „Formalisieren“, „Für UI kürzen“).",
  "li_assistant_2": "**Stapelverarbeitung:** Wählen Sie mehrere Zellen aus, um den Befehl gleichzeitig auf alle anzuwenden.",
  "h1_usage_examples": "Anwendungsbeispiele",
  "h2_example_components": "7.1. Vorgefertigte Komponenten und Beispiele",
  "p_example_components_1": "Das Projekt enthält gebrauchsfertige Skripte, die als hervorragende Beispiele dienen.",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Eine vorgefertigte Komponente zur Erstellung einer UI-Dropdown-Liste für den Sprachwechsel. Sie findet automatisch alle verfügbaren Sprachen und verwaltet deren Umschaltung.<br><strong>Anwendung:</strong> Fügen Sie einfach die Komponente <code>LanguageSelector</code> zu Ihrer Szene hinzu (z. B. auf einem leeren GameObject) und geben Sie im Inspektor Ihr <code>TMP_Dropdown</code> an.",
  "li_example_components_2": "<strong>Codebeispiele:</strong> Um fortgeschrittene Techniken wie die Arbeit mit <code>[LocalizableField]</code>, der Funktion <code>_()</code>, Pluralen und Geschlecht zu erlernen, studieren Sie die Dateien <code>StatPurchaseTest.cs</code> und <code>TestLocalization.cs</code>. Sie demonstrieren anschaulich die Implementierung aller Hauptfunktionen des Tools im Code.",
  "h2_example_attribute": "7.2. [LocalizableField] Attribut",
  "p_example_attribute_1": "Die bevorzugte Methode für Texte, die Teil der Konfiguration einer Komponente im Inspektor sind. Der Parser kann nun mit Zeichenfolgen, Listen/Arrays von Zeichenfolgen und sogar Feldern innerhalb verschachtelter <code>[System.Serializable]</code>-Klassen arbeiten.",
  "code_example_attribute": "using Ankonoanko.Localization; // Erforderlich für [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // Der Parser findet dieses Feld und erstellt einen Schlüssel dafür\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"You have failed the quest.\";\n    \n    // Sie können einen benutzerdefinierten Schlüssel festlegen\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Are you ready for an adventure?\";\n    \n    // Funktioniert mit Listen\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Find the treasure\" };\n    \n    // Und sogar mit verschachtelten Klassen!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. _() Funktion und [OnLanguageChange] Attribut",
  "p_example_function_1": "Verwenden Sie die Funktion <code>_()</code> für dynamischen Text, der sich während des Spiels ändert. Die Methode, die die Benutzeroberfläche aktualisiert, sollte mit dem Attribut <code>[OnLanguageChange]</code> markiert sein, damit sie bei einer Sprachänderung automatisch aufgerufen wird. Zu diesem Zweck wird dem Objekt automatisch eine <code>LocalizedBehaviour</code>-Komponente hinzugefügt.",
  "code_example_function": "// Um den kurzen _()-Aufruf zu verwenden, fügen Sie diese Zeilen hinzu\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Erforderlich für [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Erstmalige Aktualisierung\n    }\n    \n    // Diese Methode wird bei einer Sprachänderung automatisch aufgerufen\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Indexierte Platzhalter (wie in string.Format)\n        // Schlüssel: \"score_label\", Text in Datei: \"Score: {0}\"\n        scoreText.text = _(\"score_label\", score); // Ergebnis: \"Score: 100\"\n        \n        // 2. Benannte Platzhalter (empfohlen für die Lesbarkeit)\n        // Schlüssel: \"welcome_message\", Text: \"Welcome, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Für komplexe Fälle oder hohe Leistung\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. Plural und Geschlecht",
  "p_example_plurals_1": "Das Tool verwendet jetzt genauere Regeln für verschiedene Sprachgruppen.",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Schlüssel: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texte: \"{0} Apfel\", \"{0} Äpfel\", \"{0} Äpfel\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Wählt automatisch die richtige Form aus\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Schlüssel: \"user_greeted_male\", \"user_greeted_female\"\n        // Texte: \"Er ist angekommen.\", \"Sie ist angekommen.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "Wichtige Hinweise und Warnungen",
  "li_notes_1": "<strong>Backups:</strong> Erstellen Sie vor globalen Operationen (<code>Update Keys</code>, Datenimport) immer ein Backup über <strong>Translation Table Editor -> Manage Backups</strong>.",
  "li_notes_2": "<strong>API-Schlüssel-Sicherheit:</strong> Der Schlüssel für die Arbeit im Editor wird lokal auf Ihrem Computer (in <code>EditorPrefs</code>) gespeichert und gelangt nicht in das Repository. Für Schlüssel, die im Spiel-Build benötigt werden, verwenden Sie den Abschnitt <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong><code>StreamingAssets</code>-Ordner:</strong> Übersetzungsdateien müssen sich in einem Unterordner von <code>Assets/StreamingAssets/</code> befinden, damit sie in den Spiel-Build aufgenommen werden.",
  "li_notes_4": "<strong>\"Idiotensicherheit\":</strong> Das Tool schützt Sie automatisch davor, versehentlich temporäre Daten aus dem Vorschaumodus in eine Szene oder ein Prefab zu speichern.",
  "li_notes_5": "<strong>Leistung:</strong> Der Aufruf von <code>_()</code> ist schnell, aber in Schleifen, die jeden Frame ausgeführt werden (z. B. in <code>Update</code>), versuchen Sie, das Ergebnis in einer Variablen zwischenzuspeichern.",
  "li_notes_6": "<strong>Ausschluss von <code>LanguageSelector</code> vom Parsen:</strong> Das Objekt mit der Komponente <code>LanguageSelector</code> und seinem <code>TMP_Dropdown</code> muss der Liste <strong>Spezifische Objekte ignorieren</strong> auf der Registerkarte <strong>Inhalt</strong> hinzugefügt werden. Dies ist notwendig, um zu verhindern, dass der Parser zusätzliche Schlüssel für die Dropdown-Optionen erstellt, da das Skript <code>LanguageSelector</code> diese zur Laufzeit dynamisch füllt. Das Ignorieren verhindert Konflikte und hält die Übersetzungsdateien sauber.",
  "li_notes_7": "<strong>Schriftarten für <code>LanguageSelector</code>:</strong> Damit die ausgewählte Sprache im <code>TMP_Dropdown</code> ihre Schriftart korrekt aktualisiert, fügen Sie manuell eine leere <code>LocalizedText</code>-Komponente zum untergeordneten <strong>Label</strong>-Objekt des Dropdowns hinzu und aktivieren Sie das Kontrollkästchen <code>isStyleOnly</code>.",
  "h1_extending": "Funktionalität erweitern",
  "h2_custom_parser": "9.1. Erstellen eines benutzerdefinierten Parsers",
  "p_custom_parser_1": "Sie können das System leicht erweitern, um benutzerdefinierte Komponenten zu unterstützen, indem Sie Ihre eigene Parser-Klasse erstellen.",
  "li_custom_parser_1": "Erstellen Sie ein neues C#-Skript im <strong>Editor</strong>-Ordner Ihres Projekts.",
  "li_custom_parser_2": "Kopieren Sie die untenstehende Vorlage hinein.",
  "li_custom_parser_3": "Ändern Sie die Logik, um sie an Ihre Komponente anzupassen.",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// VORLAGE zum Erstellen eines Parsers für eine benutzerdefinierte Komponente.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Prüfen, ob das Objekt die benötigte benutzerdefinierte Komponente hat.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Beenden, wenn die Komponente nicht gefunden wird\n        }\n        \n        // 2. Den Text aus den Feldern der benutzerdefinierten Komponente abrufen.\n        string titleText = component.Title;\n        \n        // 3. Prüfen, ob der Text für die Lokalisierung gültig ist.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Den Schlüssel und die Quelle mit Hilfsfunktionen aus TextParser generieren.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Das Ergebnis zurückgeben.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Für andere Felder wiederholen...\n        // (ein Suffix kann hinzugefügt werden, um Schlüssel eindeutig zu machen)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQ & Fehlerbehebung",
  "h2_faq_installation": "10.1. Installation & Schnellstart",
  "q_faq_installation_1": "Was passiert, wenn mein Projekt bereits das Paket com.unity.nuget.newtonsoft-json von einem anderen Asset hat? Wird der Abhängigkeitsinstaller versuchen, es zu aktualisieren oder zu ignorieren?",
  "a_faq_installation_1": "Der Installer prüft auf das Vorhandensein des Typs Newtonsoft.Json.JsonConvert. Wenn der Typ existiert, betrachtet er die Abhängigkeit als erfüllt und wird nicht versuchen, das Paket zu installieren oder zu aktualisieren. Dies geschieht, um Versionskonflikte zu vermeiden.",
  "q_faq_installation_2": "Ich habe versehentlich auf \"Fürs Erste überspringen\" geklickt und \"Nicht erneut fragen\" für optionale Abhängigkeiten (z. B. für CSV-Unterstützung) angekreuzt. Wie kann ich das Installer-Fenster wieder aufrufen, um sie zu installieren?",
  "a_faq_installation_2": "Sie können jederzeit eine manuelle Abhängigkeitsprüfung über das Menü Tools -> Localization -> Check Dependencies auslösen. Dies setzt das \"Nicht erneut fragen\"-Flag zurück und zeigt das Fenster mit allen fehlenden optionalen Paketen erneut an.",
  "q_faq_installation_3": "Das Tool hat LocalizationSettings.asset nicht in Assets/Resources erstellt. Warum könnte das passiert sein, und kann ich es manuell über das Menü Assets -> Create erstellen?",
  "a_faq_installation_3": "Dies kann passieren, wenn Sie keinen Assets/Resources-Ordner haben. Das Tool wird versuchen, ihn zu erstellen, aber Dateisystemberechtigungen könnten dies verhindern. Ja, Sie können das Asset manuell erstellen: Klicken Sie mit der rechten Maustaste in den Resources-Ordner, wählen Sie Create -> Localization -> Settings. Das Tool wird es automatisch finden.",
  "q_faq_installation_4": "Kann ich die Datei LocalizationSettings.asset in einen anderen Resources-Ordner verschieben, zum Beispiel Assets/MyGame/Resources? Wird das Tool sie immer noch finden?",
  "a_faq_installation_4": "Ja. Das Tool verwendet Resources.Load(), das nach einem Asset mit diesem Namen in allen Ordnern namens Resources in Ihrem Projekt sucht. Wichtig ist nur, dass die Datei ihren Namen LocalizationSettings.asset behält.",
  "q_faq_installation_5": "Der Abhängigkeitsinstaller ist eingefroren oder hat einen Fehler ausgegeben. Kann ich die Abhängigkeiten (Newtonsoft Json, Editor Coroutines) manuell über den Unity Package Manager installieren?",
  "a_faq_installation_5": "Ja. Sie können Window -> Package Manager öffnen, auf das \"+\"-Symbol klicken und \"Add package by name...\" auswählen. Geben Sie die Paketnamen ein: com.unity.nuget.newtonsoft-json und com.unity.editorcoroutines.",
  "h2_faq_components": "10.2. Kernkomponenten",
  "q_faq_components_1": "Die Komponente LocalizedPrefab deaktiviert MonoBehaviours auf dem ursprünglichen Objekt. Was ist, wenn das ursprüngliche Objekt ein Skript hat, das in Awake() andere Objekte erstellt oder Ereignisse abonniert? Wird dieser Code ausgeführt?",
  "a_faq_components_1": "Nein, wird er nicht. Das Deaktivieren eines MonoBehaviour verhindert, dass alle \"magischen\" Methoden von Unity aufgerufen werden, einschließlich Awake(), OnEnable() und Start(). Dies ist beabsichtigt, um doppelte Logikausführung zu vermeiden. Alle Initialisierungen sollten in Skripten auf den lokalisierten Versionen des Prefabs erfolgen.",
  "q_faq_components_2": "Wenn das ursprüngliche Prefab (LocalizedPrefab) eine Rigidbody- oder eine andere Physikkomponente hat, wird diese deaktiviert? Beeinflusst dies die Physik, wenn das lokalisierte Prefab sie nicht hat?",
  "a_faq_components_2": "Ja, das physikalische Verhalten des ursprünglichen Objekts wird neutralisiert. Die Komponente LocalizedPrefab findet alle Rigidbody- und Rigidbody2D-Komponenten auf ihrem GameObject und setzt deren Eigenschaft isKinematic auf true. Dies entfernt sie effektiv aus den dynamischen Physikberechnungen und verhindert unerwünschtes Verhalten wie das Fallen eines unsichtbaren Objekts oder Reaktionen auf Kollisionen. Es wird dennoch empfohlen, dass die lokalisierte Version des Prefabs alle notwendigen Physikkomponenten für ein korrektes Verhalten enthält.",
  "q_faq_components_3": "Die Komponente LocalizedAsset speichert den Namen der Zielkomponente als Zeichenfolge (_targetComponentTypeName). Was passiert, wenn ich ein benutzerdefiniertes Komponentenskript umbenenne oder in eine andere Assembly (Assembly Definition) verschiebe? Hört LocalizedAsset dann auf, dafür zu funktionieren?",
  "a_faq_components_3": "Ja, es wird aufhören zu funktionieren. Die Komponente speichert den vollständigen Typnamen, einschließlich Namespace und Assembly. Das Umbenennen des Skripts oder das Verschieben in eine andere .asmdef ändert diesen Namen, und LocalizedAsset kann die Zielkomponente nicht mehr finden. Sie müssen eine erneute Analyse über Analyze Project & Attach Components durchführen, damit der Name aktualisiert wird.",
  "q_faq_components_4": "Wenn sich auf demselben GameObject zwei Image-Komponenten befinden, woher weiß LocalizedAsset, welche davon lokalisiert werden soll? Funktioniert es mit beiden oder nur mit der ersten, die es findet?",
  "a_faq_components_4": "Ein LocalizedAsset wird für eine bestimmte Komponenteninstanz erstellt. Es hält eine Referenz auf diese Komponente im Code. Wenn Sie manuell ein zweites LocalizedAsset hinzufügen und über das Kontextmenü \"Auf Lokalisierung analysieren\" das zweite Image als Ziel festlegen, haben Sie zwei LocalizedAsset-Komponenten, die jeweils ihr eigenes Image verwalten. Der automatische Analysator erstellt nur eine Komponente für das erste gefundene Image mit einem lokalisierbaren Asset.",
  "q_faq_components_5": "Die Dokumentation besagt, dass LocalizedPrefab eine Ausführungsreihenfolge von -100 hat. Was ist, wenn ich ein anderes Skript mit einer Ausführungsreihenfolge von -110 habe, das in seinem Awake() versucht, ein von LocalizedPrefab erstelltes Kindobjekt zu finden? Hat LocalizedPrefab seine Instanz rechtzeitig instanziiert?",
  "a_faq_components_5": "Ja, das hat es. LocalizedPrefab erstellt die Instanz des lokalisierten Prefabs in seiner OnEnable()-Methode. Die Ausführungsreihenfolge von Unity garantiert, dass alle Awake()-Methoden vor allen OnEnable()-Methoden ausgeführt werden. Ihr Skript mit der Reihenfolge -110 wird also sein Awake() ausführen, dann wird LocalizedPrefab mit der Reihenfolge -100 sein Awake() ausführen, und erst danach werden ihre OnEnable()-Methoden in der richtigen Reihenfolge aufgerufen. Ihr Skript wird das Objekt nicht finden, da es noch nicht erstellt wurde.",
  "q_faq_components_6": "Die Komponente LocalizedText hat eine Option isStyleOnly. Wenn ich sie aktiviere und dann im Code myLocalizedText.SetFormattedText(\"new_key\") aufrufe, ändert sich dann der Text oder nur der Stil (Schriftart/RTL)?",
  "a_faq_components_6": "Sowohl der Schlüssel als auch der Text werden sich ändern. Der programmgesteuerte Aufruf von SetFormattedText überschreibt das Verhalten von isStyleOnly für dieses spezifische Update. Die Option isStyleOnly soll verhindern, dass die Komponente auf globale Sprachänderungen reagiert, aber sie wird immer auf eine direkte Schlüsseländerung durch Code reagieren.",
  "q_faq_components_7": "LocalizedBehaviour findet automatisch Methoden mit dem Attribut [OnLanguageChange]. Findet es auch private und protected Methoden, oder müssen sie public sein?",
  "a_faq_components_7": "Es findet Methoden mit jedem Zugriffsmodifikator (public, private, protected, internal). Reflection in Unity ermöglicht die Erkennung aller Instanzmethoden unabhängig von ihrer Zugriffsebene.",
  "q_faq_components_8": "Die Komponente LocalizedAsset fängt Play on Awake ab. Was passiert, wenn ein anderes Skript auf demselben Objekt in Awake() oder Start() versucht, auf das Asset zuzugreifen (z. B. audioSource.clip.length), bevor LocalizedAsset es ausgetauscht hat? Ist eine NullReferenceException oder die Verwendung des alten Assets möglich?",
  "a_faq_components_8": "Die Verwendung des alten (nicht lokalisierten) Assets ist möglich. LocalizedAsset führt den Austausch in seinem OnEnable() durch. Die Awake()-Methoden aller Skripte werden vor OnEnable() ausgeführt. Wenn Ihr Skript in Awake() auf audioSource.clip zugreift, erhält es den ursprünglichen Clip. Wenn es in Start() darauf zugreift, hängt das Ergebnis von der Skriptausführungsreihenfolge ab. Um den Zugriff auf das lokalisierte Asset zu garantieren, setzen Sie entweder eine spätere Ausführungsreihenfolge für Ihr Skript oder greifen Sie in einer mit [OnLanguageChange] markierten Methode auf das Asset zu.",
  "h2_faq_window": "10.3. Fenster \"Localization Tool\"",
  "h3_faq_window_preview": "Vorschau im Editor",
  "q_faq_window_preview_1": "Ich habe ein Prefab im Prefab-Modus geöffnet, die Vorschau im Editor angewendet und Strg+S gedrückt. Werden die temporären Vorschaudaten in der Prefab-Asset-Datei gespeichert? Wie behandelt LocalizationPreviewProtector diesen Fall?",
  "a_faq_window_preview_1": "Nein, sie werden nicht gespeichert. LocalizationPreviewProtector fängt das Ereignis zum Speichern von Assets (OnWillSaveAssets) ab und ruft automatisch RevertEditorPreview() auf, bevor Unity die Änderungen auf die Festplatte schreibt. Das Prefab wird also in seinem ursprünglichen, nicht lokalisierten Zustand gespeichert.",
  "q_faq_window_preview_2": "Wenn ich die Vorschau im Editor aktiviere und der Unity-Editor abstürzt und die Datei Temp/localization_preview_recovery.json beschädigt wird (z. B. leer oder mit ungültigem JSON), was passiert beim nächsten Start?",
  "a_faq_window_preview_2": "PreviewCrashProtector ist in einem try-catch-Block eingeschlossen. Wenn die JSON-Deserialisierung fehlschlägt, wird ein Fehler über die Unfähigkeit zur Wiederherstellung in die Konsole protokolliert und der Prozess wird leise beendet. Ihre Szene bleibt in dem \"kaputten\" Zustand, in dem sie sich zum Zeitpunkt des Absturzes befand. In diesem Fall müssen Sie im Tool-Fenster manuell \"Auf Original zurücksetzen\" auswählen, um ein Zurücksetzen der Änderungen zu erzwingen.",
  "q_faq_window_preview_3": "Im Vorschau-Modus im Editor wird für LocalizedPrefab eine temporäre Instanz erstellt. Werden die Methoden Awake() und Start() auf dieser Instanz ausgeführt? Könnte dies Fehler verursachen, wenn sie nicht für die Ausführung im Bearbeitungsmodus konzipiert sind?",
  "a_faq_window_preview_3": "Ja, werden sie. PrefabUtility.InstantiatePrefab im Bearbeitungsmodus ruft Awake() und OnEnable() auf. Wenn diese Methoden Logik enthalten, die nicht im Editor ausgeführt werden sollte (z. B. Zugriff auf Singletons, die nur im Wiedergabemodus existieren), könnte dies Fehler verursachen. Es wird empfohlen, if (Application.isPlaying) oder #if UNITY_EDITOR zu verwenden, um solchen Code zu schützen.",
  "h3_faq_window_settings": "Registerkarte \"Einstellungen\"",
  "q_faq_window_settings_1": "Ich kann den Schlüssel-Generierungsmodus mitten im Projekt von UseTextAsKey auf AutoGenerateKeysOnly ändern. Was genau passiert mit meinen bestehenden Übersetzungen? Werden sie den neuen Schlüsseln zugeordnet?",
  "a_faq_window_settings_1": "Ja, werden sie. Beim Ändern des Modus führt das Tool eine \"sichere Migration\" durch: Es parst das gesamte Projekt neu, erstellt neue Schlüssel nach den neuen Regeln, ordnet aber die alten und neuen Schlüssel über den Originaltext zu. Anschließend überträgt es alle Ihre bestehenden Übersetzungen und Kommentare von den alten Schlüsseln auf die neuen. Ihre Übersetzungen gehen nicht verloren.",
  "q_faq_window_settings_2": "Wenn ich eine Sprache mit einem Code zur Liste der unterstützten Sprachen hinzufüge, für den keine Pluralisierungsregeln existieren (z. B. \"kz\" für Kasachisch), welche Regel wird dann standardmäßig verwendet?",
  "a_faq_window_settings_2": "Es wird die DefaultPluralRule verwendet, die für Englisch und die meisten europäischen Sprachen geeignet ist (Formen für \"eins\" und \"andere\").",
  "q_faq_window_settings_3": "Was ist, wenn ich den Übersetzungspfad nicht in StreamingAssets, sondern in einem normalen Ordner wie Assets/MyTranslations angebe? Werden die JSON-Dateien in den Spiel-Build aufgenommen?",
  "a_faq_window_settings_3": "Nein, werden sie nicht. Nur Assets, die sich in einem StreamingAssets- oder Resources-Ordner befinden, werden garantiert in den Build aufgenommen. Wenn Sie einen anderen Pfad angeben, funktioniert die Lokalisierung im Editor, aber nicht im kompilierten Spiel, da die Übersetzungsdateien nicht Teil des Builds sind.",
  "q_faq_window_settings_4": "Der API-Schlüssel für die automatische Übersetzung wird in EditorPrefs gespeichert. Wenn ich auf zwei verschiedenen Computern am Projekt arbeite, muss ich den Schlüssel auf jeder Maschine separat eingeben?",
  "a_faq_window_settings_4": "Ja. EditorPrefs ist ein lokaler Speicher für jeden Computer. Sie müssen den API-Schlüssel auf jeder Maschine eingeben, von der aus Sie die automatische Übersetzungsfunktion nutzen möchten.",
  "h3_faq_window_content": "Registerkarte \"Inhalt\"",
  "q_faq_window_content_1": "Was ist, wenn ich eine Szene zu \"Zu parsende Szenen\" hinzufüge, die nicht in den Build-Einstellungen enthalten ist? Beeinflusst dies etwas anderes als den Parsing-Prozess selbst?",
  "a_faq_window_content_1": "Nein, tut es nicht. Die Liste \"Zu parsende Szenen\" wird ausschließlich verwendet, um dem Tool mitzuteilen, welche Szenen geöffnet und auf Text analysiert werden sollen. Sie hat keinerlei Bezug zu den Szenen, die in den endgültigen Build Ihres Spiels gelangen.",
  "q_faq_window_content_2": "Ich habe ein Objekt zu \"Spezifische Objekte ignorieren\" (der temporären Liste) hinzugefügt. Wenn ich aus diesem Objekt ein Prefab erstelle, wird die Instanz dieses Prefabs dann auch ignoriert?",
  "a_faq_window_content_2": "Nein, wird sie nicht. Die temporäre Liste speichert eine direkte Referenz auf das Objekt in der Szene. Wenn Sie ein Prefab erstellen, ist es ein neues Asset. Seine Instanzen sind andere Objekte, und die Ignorierregel gilt nicht für sie. Um Prefabs dauerhaft zu ignorieren, müssen sie als Prefab-Asset zur Ignorierliste hinzugefügt werden.",
  "q_faq_window_content_3": "Wenn ich die Komponente TMPro.TMP_Text zu Parsing Ignores -> Ignore Component Types hinzufüge, aber in der Szene ein Objekt mit einem LocalizedText vorhanden ist, das bereits auf diesen TMP_Text verweist, was passiert beim nächsten Update Keys? Wird der Schlüssel gelöscht?",
  "a_faq_window_content_3": "Ja, wird er. Wenn Sie auf Update Keys klicken, scannt der Parser das gesamte Projekt neu. Er wird sehen, dass der Typ TMPro.TMP_Text ignoriert werden soll und wird keinen Schlüssel dafür generieren. Beim Vergleich von alten und neuen Schlüsseln wird er feststellen, dass der alte Schlüssel nicht mehr verwendet wird und ihn als \"Entfernt\" markieren.",
  "q_faq_window_content_4": "Die Dokumentation besagt, dass \"Anheften\" den vollständigen Pfad zum Objekt speichert und bei einer Umbenennung nicht mehr funktioniert. Was ist, wenn ich aus dem Objekt ein Prefab mache und dann das ursprüngliche Objekt umbenenne – funktioniert \"Anheften\" dann weiterhin für die Prefab-Instanzen?",
  "a_faq_window_content_4": "Nein, wird es nicht. \"Anheften\" speichert den absoluten Pfad in der Szenenhierarchie zum Zeitpunkt des Klickens auf die Schaltfläche (z. B. Canvas/Panel/Button). Dieser Pfad ist nicht mit der Prefab-Logik verbunden. Prefab-Instanzen haben denselben Pfad, aber wenn Sie das übergeordnete Objekt in der Szene umbenennen, funktioniert \"Anheften\" sowohl für das Original als auch für die Instanzen nicht mehr.",
  "q_faq_window_content_5": "Wenn ich \"Anheften\" für ein Kindobjekt innerhalb einer Prefab-Instanz verwende, welcher Pfad wird gespeichert: relativ zum Prefab-Stamm oder zum Szenen-Stamm? Funktioniert es in anderen Szenen?",
  "a_faq_window_content_5": "Der vollständige Pfad vom Szenen-Stamm wird gespeichert. Zum Beispiel MyPrefab(Clone)/Content/Icon. Dieser \"angeheftete\" Pfad funktioniert nur in der Szene, in der Sie ihn erstellt haben. In anderen Szenen wird ein solcher Pfad wahrscheinlich nicht gefunden.",
  "h3_faq_window_actions": "Registerkarte \"Aktionen\"",
  "h3_faq_window_assets": "Registerkarte \"Assets\"",
  "h3_faq_window_report": "Registerkarte \"Bericht\"",
  "h2_faq_editor": "10.4. Übersetzungseditor",
  "h2_faq_examples": "10.5. Anwendungsbeispiele & Code",
  "h2_faq_notes": "10.6. Wichtige Nuancen & Warnungen",
  "h2_faq_extending": "10.7. Funktionalität erweitern",
  "q_faq_window_actions_1": "Was passiert, wenn die Internetverbindung während einer Batch-Auto-Übersetzung unterbrochen wird? Versucht das Tool, den fehlgeschlagenen Batch gemäß der Wiederholungsrichtlinie erneut zu versuchen, oder wird der Prozess vollständig unterbrochen?",
  "a_faq_window_actions_1": "Das Tool wird versuchen, genau den fehlgeschlagenen Batch gemäß den Wiederholungsrichtlinien (Anzahl der Versuche und Verzögerung) erneut zu senden. Wenn alle Versuche für diesen Batch fehlschlagen, wird der Übersetzungsprozess für die aktuelle Sprache unterbrochen und ein Fehler in der Konsole protokolliert. Die Übersetzung für die nächsten Sprachen in der Warteschlange wird nicht gestartet.",
  "q_faq_window_actions_2": "Wenn ich eine CSV-Datei importiere, die Schlüssel enthält, die bereits im Projekt vorhanden sind, aber mit leeren Werten für einige Sprachen, ersetzen diese leeren Werte meine bestehenden Übersetzungen oder werden sie ignoriert?",
  "a_faq_window_actions_2": "Leere Werte ersetzen bestehende Übersetzungen. Der Importprozess betrachtet die CSV-Datei als die \"Quelle der Wahrheit\". Wenn der Wert für den Schlüssel welcome_message in der Spalte ru leer ist, wird die aktuelle russische Übersetzung für diesen Schlüssel überschrieben.",
  "q_faq_window_actions_3": "Der Abschnitt \"Gefahrenzone\" ermöglicht das Löschen aller Komponenten. Werden dabei auch Komponenten von Prefabs entfernt, die sich in Ordnern befinden, die nicht auf der Registerkarte \"Inhalt\" in den Prefab-Ordnern angegeben sind?",
  "a_faq_window_actions_3": "Ja, werden sie. Die Funktionen in der \"Gefahrenzone\" scannen alle Prefabs im Projekt (AssetDatabase.FindAssets(\"t:Prefab\")), nicht nur die in der Parsing-Liste angegebenen, um eine möglichst vollständige Bereinigung zu gewährleisten.",
  "q_faq_window_actions_4": "Wie formatiere ich beim Import aus Google Sheets die Kommentarspalte, damit die Platzhaltervalidierung mit der Direktive @placeholders: funktioniert?",
  "a_faq_window_actions_4": "In Ihrem Google Sheets-Dokument muss die Spalte den Titel \"Developer Notes\" haben. In den Zellen dieser Spalte können Sie Kommentare wie gewohnt schreiben. Um Platzhalter anzugeben, fügen Sie einfach eine Zeile wie @placeholders: {username}, {score} in den Kommentartext ein. Das Tool erkennt diese Direktive beim Import automatisch.",
  "q_faq_window_actions_5": "Kann das Tool Daten von mehreren Blättern eines einzigen Google Sheets-Dokuments importieren oder funktioniert es nur mit einem Blatt pro GID?",
  "a_faq_window_actions_5": "Das Tool arbeitet nur mit einem Blatt gleichzeitig. Die Import-URL enthält einen gid=...-Parameter, der ein bestimmtes Blatt im Dokument eindeutig identifiziert. Um Daten von einem anderen Blatt zu importieren, müssen Sie dessen URL (mit einer anderen gid) kopieren und den Import erneut durchführen.",
  "q_faq_window_assets_1": "Was ist, wenn ich zwei Assets mit demselben Schlüssel, aber unterschiedlichen Typen im selben Scan-Ordner habe (z. B. sound_effect_en.mp3 und sound_effect_en.wav)? Welches davon landet in der Asset-Tabelle?",
  "a_faq_window_assets_1": "Der Asset-Scanner lädt sie unter Angabe des erwarteten Typs (AssetDatabase.LoadAssetAtPath(path, expectedType)). Für die Kategorie AudioClip sucht und lädt er nur Dateien, die Unity als AudioClips erkennt. Wenn beide Dateien gültige Audioclips sind, wird diejenige, die zuletzt verarbeitet wird, in die Tabelle aufgenommen und überschreibt die vorherige. Es wird empfohlen, solche Duplikate zu vermeiden.",
  "q_faq_window_assets_2": "Wenn ich auf \"Assets scannen & Projekt analysieren\" klicke und in der Szene ein Image-Objekt vorhanden ist, für das bereits ein lokalisiertes Sprite existiert, aber das Image-Objekt selbst noch keine LocalizedAsset-Komponente hat, fügt das Tool dann die Komponente hinzu und fügt den Schlüssel automatisch ein?",
  "a_faq_window_assets_2": "Ja, genau so funktioniert es. \"Projekt analysieren\" findet die Image-Komponente, schaut sich den Namen des ihr zugewiesenen Sprites an (z. B. icon_play_en), extrahiert daraus den Schlüssel (icon_play) und die Sprache (en) und fügt dann eine LocalizedAsset-Komponente zu diesem GameObject hinzu und schreibt den Schlüssel icon_play hinein.",
  "q_faq_window_assets_3": "Kann ich dieselbe Benennungsregel für verschiedene Asset-Kategorien verwenden, wenn sie unterschiedliche Scan-Ordner haben? Verursacht das keine Konflikte?",
  "a_faq_window_assets_3": "Ja, das können Sie. Es gibt keine Konflikte, da für jede Kategorie eine separate Asset-Tabelle (LocalizedAssetTable) erstellt wird. Schlüssel aus der Kategorie \"Sprites\" überschneiden sich nicht mit Schlüsseln aus der Kategorie \"AudioClips\", auch wenn sie gleich benannt sind.",
  "q_faq_window_assets_4": "Wenn sich ein lokalisierbares Asset (z. B. button_ok_en.png) nicht im Stammverzeichnis des Scan-Ordners, sondern in einem Unterordner befindet, findet der Scanner es dann?",
  "a_faq_window_assets_4": "Ja, findet er. Der Scanner verwendet die Option SearchOption.AllDirectories, was bedeutet, dass er alle Unterordner innerhalb des von Ihnen angegebenen Scan-Ordners rekursiv überprüft.",
  "q_faq_window_report_1": "Die Schaltfläche \"Suchen\" sucht das Objekt asynchron. Was ist, wenn ich eine Suche starte und dann sofort auf \"Schlüssel aktualisieren\" klicke? Wird die Suche unterbrochen?",
  "a_faq_window_report_1": "Ja, sie wird unterbrochen. Jede neue Aktion, die eine UI-Blockierung erfordert (wie \"Schlüssel aktualisieren\"), stoppt die aktuelle Such-Coroutine. Es erscheint ein Dialogfeld, in dem Sie aufgefordert werden, die aktuelle Suche zu stoppen, um eine neue zu starten.",
  "q_faq_window_report_2": "Wenn ein Schlüssel an mehreren Stellen verwendet wird (z. B. auf zwei verschiedenen Schaltflächen in verschiedenen Szenen), wie wird dies im Bericht unter der Kategorie \"Duplikate\" angezeigt?",
  "a_faq_window_report_2": "Die Kategorie \"Duplikate\" zeigt alle Quellen für diesen Schlüssel an. Sie sehen einen Eintrag für den Schlüssel, und das Feld \"Quelle\" listet alle Pfade auf (in Szene 1 und Szene 2). Die Schaltfläche \"Suchen\" öffnet in diesem Fall eine Dropdown-Liste, mit der Sie auswählen können, zu welchem Objekt Sie navigieren möchten.",
  "q_faq_window_report_3": "Wenn ich auf \"Suchen\" für einen Schlüssel klicke, der nur im Code verwendet wird (über die Funktion _()), was passiert dann? Kann das Tool das C#-Skript finden und hervorheben?",
  "a_faq_window_report_3": "Ja. Das Suchsystem ist speziell darauf trainiert, Quellen wie script MyScript.cs zu erkennen. Wenn Sie auf \"Suchen\" klicken, sucht es nach dem Asset MyScript.cs im Projekt und hebt es im Projektfenster hervor (ping).",
  "q_faq_editor_1": "Was hat eine höhere Priorität für die Platzhaltervalidierung: die Direktive @placeholders: im Kommentar oder die im Quellsprachentext gefundenen Platzhalter? Zum Beispiel, wenn der Quelltext {name} enthält und im Kommentar @placeholders: {username} steht.",
  "a_faq_editor_1": "Die Direktive @placeholders: im Kommentar hat Priorität. Sie wird als explizite Anweisung des Entwicklers und als \"Quelle der Wahrheit\" betrachtet. In Ihrem Beispiel wird der Editor {username} in der Übersetzung verlangen und {name} aus dem Quelltext ignorieren.",
  "q_faq_editor_2": "Wenn ich einen Tippfehler in der Direktive mache (z. B. @placeholder: statt @placeholders:), wird er ignoriert oder gibt das Tool eine Warnung aus?",
  "a_faq_editor_2": "Er wird einfach ignoriert. Das Tool sucht nach einer exakten Übereinstimmung von @placeholders:. Wenn die Direktive falsch geschrieben ist, wird sie als Teil eines normalen Kommentars behandelt und die Validierung funktioniert auf die alte Weise - basierend auf den Platzhaltern aus dem Quelltext.",
  "q_faq_editor_3": "Das Autosave-System erstellt Dateien im Ordner Backups/AutoSaves. Werden diese Dateien nach einem erfolgreichen manuellen Speichern oder Schließen des Fensters automatisch gelöscht?",
  "a_faq_editor_3": "Ja. Bei einem erfolgreichen manuellen Speichern oder normalen Schließen des Fensters (wenn Sie Änderungen speichern) werden alle Autosave-Dateien gelöscht, um beim nächsten Start keine Wiederherstellung anzubieten. Sie bleiben nur im Falle eines Editor-Absturzes erhalten.",
  "q_faq_editor_4": "Wenn ich die Spaltenbreiten im Editor ändere, werden diese Einstellungen zwischen den Unity-Sitzungen gespeichert?",
  "a_faq_editor_4": "Ja. Die Spaltenbreiten werden jedes Mal in EditorPrefs gespeichert, wenn Sie das Übersetzungseditor-Fenster schließen, und werden beim nächsten Öffnen wiederhergestellt.",
  "q_faq_editor_5": "Unterstützt das Popup-Fenster zur Textbearbeitung (MultiLineEditWindow) einen eigenen Undo/Redo-Stapel (über Strg+Z) für darin vorgenommene Änderungen?",
  "a_faq_editor_5": "Ja. Das MultiLineEditWindow hat seinen eigenen temporären Undo/Redo-Stapel, der funktioniert, während das Fenster geöffnet ist. Dies ermöglicht es Ihnen, Textänderungen innerhalb dieses Fensters rückgängig zu machen und wiederherzustellen. Sobald Sie das Ergebnis speichern (indem Sie das Fenster schließen), wird diese Änderung als eine einzige Aktion im globalen Undo/Redo-Stapel des Haupteditors aufgezeichnet.",
  "q_faq_examples_1": "Was passiert, wenn die Eigenschaftsnamen im anonymen Typ, der an die Funktion _() übergeben wird, nicht mit den Platzhaltern in der Zeichenfolge übereinstimmen? Zum Beispiel _(\"Hallo, {username}\", new { user_name = \"Bob\" }). Gibt es einen Fehler oder wird der Platzhalter einfach nicht ersetzt?",
  "a_faq_examples_1": "Es gibt keinen Fehler. Der Platzhalter {username} wird einfach nicht ersetzt, und Sie erhalten als Ergebnis die Zeichenfolge \"Hallo, {username}\". Eine Ersetzung erfolgt nur bei exakter Namensübereinstimmung.",
  "q_faq_examples_2": "Das Attribut [LocalizableField] funktioniert für private Felder. Funktioniert es auch für statische Felder?",
  "a_faq_examples_2": "Ja, tut es. Der Parser verwendet Reflection, um nach Feldern mit den Flags BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static zu suchen, daher findet und verarbeitet er statische Felder.",
  "q_faq_examples_3": "Wenn ich das Attribut [OnLanguageChange] an eine Methode mit Parametern hänge (z. B. void UpdateUI(string newLang)), was passiert dann? Gibt es einen Kompilierfehler oder eine Laufzeitwarnung?",
  "a_faq_examples_3": "Es gibt keinen Kompilierfehler, aber eine Warnung von LocalizedBehaviour erscheint zur Laufzeit in der Unity-Konsole. Sie meldet, dass eine Methode mit dem Attribut gefunden, aber ignoriert wurde, weil die Methode Parameter hat. Eine solche Methode wird nicht aufgerufen.",
  "q_faq_examples_4": "Ich verwende _(\"apple_count\", count). Wenn es für die aktuelle Sprache keinen Schlüssel apple_count_one gibt (für count = 1), welche Form wählt das System? Verwendet es apple_count_other als Fallback?",
  "a_faq_examples_4": "Ja. Wenn eine bestimmte Form (_one, _few, usw.) nicht gefunden wird, versucht das System, den Schlüssel mit dem Suffix _other als Fallback zu verwenden. Wenn auch dieser nicht gefunden wird, wird die Übersetzung für den Basisschlüssel apple_count verwendet.",
  "q_faq_examples_5": "Die Funktion _(\"key\", new { username = \"Alex\" }) verwendet einen anonymen Typ. Erzeugt dies nicht eine übermäßige \"Last\" auf dem Garbage Collector (GC) bei häufigen Aufrufen in einer Update()-Methode im Vergleich zur Übergabe eines vorab erstellten Dictionary<string, object>?",
  "a_faq_examples_5": "Ja, tut es. Jeder Aufruf von new { ... } alloziert Speicher auf dem verwalteten Heap, was zusätzliche Arbeit für den Garbage Collector bedeutet. Für Text, der jeden Frame aktualisiert wird (in Update oder LateUpdate), ist es deutlich performanter, ein Dictionary<string, object> einmal in Start() zu erstellen und in Update() nur dessen Werte zu aktualisieren, bevor es an die Funktion _() übergeben wird.",
  "q_faq_notes_1": "Die Dokumentation empfiehlt, LanguageSelector zur Ignorierliste hinzuzufügen. Was genau geht kaputt, wenn ich das vergesse? Werden zusätzliche Schlüssel für \"Option A, Option B\" erstellt?",
  "a_faq_notes_1": "Ja. Wenn Sie LanguageSelector nicht zur Ignorierliste hinzufügen, behandelt der Parser sein TMP_Dropdown wie ein normales Dropdown. Er findet die Standardoptionen \"Option A, Option B, Option C\", die Unity erstellt, und fügt Schlüssel dafür zu Ihren Übersetzungsdateien hinzu. Dies wird Ihre Dateien mit unnötigen Schlüsseln überladen, da LanguageSelector diese Optionen zur Laufzeit ohnehin entfernt und seine eigenen erstellt.",
  "q_faq_notes_2": "Wenn ich vergesse, ein leeres LocalizedText mit aktiviertem Kontrollkästchen isStyleOnly auf dem Label innerhalb des TMP_Dropdowns hinzuzufügen, das von LanguageSelector verwendet wird, ändert sich die Schriftart dann nicht? Warum ist das notwendig?",
  "a_faq_notes_2": "Ja, die Schriftart ändert sich nicht. Dies ist notwendig, da LanguageSelector die Eigenschaft label.text direkt ändert. Ohne ein LocalizedText auf diesem Objekt weiß das Lokalisierungssystem nicht, dass auf dieses Element Stile (Schriftart, RTL) angewendet werden müssen, wenn die Sprache geändert wird. Ein leeres LocalizedText mit isStyleOnly dient als \"Marker\" für das System und sagt: \"Beobachte dieses Objekt und wende Stile darauf an, aber ändere seinen Text nicht\".",
  "q_faq_notes_3": "Der Aufruf von _() in der Update()-Methode wird nicht empfohlen. Aber was ist, wenn ich Text jeden Frame aktualisieren muss (z. B. einen Timer)? Was ist der performanteste Weg, dies zu tun und nur die Formatzeichenfolge zwischenzuspeichern?",
  "a_faq_notes_3": "Der performanteste Ansatz ist, die Formatzeichenfolge in Start() oder in einer [OnLanguageChange]-Methode zwischenzuspeichern und in Update() reguläres string.Format zu verwenden. Beispiel: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Dies vermeidet das Nachschlagen des Schlüssels im Wörterbuch jeden Frame, was deutlich schneller ist.",
  "q_faq_extending_1": "Wird mein benutzerdefinierter Parser nach jedem Update Keys automatisch aufgerufen? Muss ich ihn irgendwo registrieren oder reicht es aus, einfach eine Klasse zu haben, die ITextComponentParser im Projekt implementiert?",
  "a_faq_extending_1": "Es reicht aus, nur die Klasse zu haben. Wenn TextParser ausgeführt wird, verwendet es Reflection, um alle Klassen im Projekt zu finden, die die Schnittstelle ITextComponentParser implementieren, und ruft automatisch ihre Parse()-Methode für jedes GameObject auf. Es ist keine manuelle Registrierung erforderlich.",
  "q_faq_extending_2": "Was ist, wenn in meinem benutzerdefinierten Parser eine Ausnahme auftritt? Unterbricht das den gesamten Parsing-Prozess oder fährt das Tool sicher mit anderen Parsern fort?",
  "a_faq_extending_2": "Eine Ausnahme in Ihrem benutzerdefinierten Parser unterbricht den Prozess. Die Haupt-Parsing-Schleife umschließt Aufrufe an benutzerdefinierte Parser nicht in einem try-catch-Block. Wenn Ihre Parse()-Methode eine unbehandelte Ausnahme auslöst, wird der Parsing-Prozess gestoppt.",
  "toggle_notes_title": "Notizen umschalten",
  "mindmap_toggle_title": "Mindmap anzeigen",
  "on_this_page_title": "Auf dieser Seite",
  "my_notes_title": "Meine Notizen",
  "no_notes_message_new": "Fahren Sie mit der Maus über den Text, um eine Notiz hinzuzufügen.",
  "notes_add_title": "Eine Notiz zu diesem Block hinzufügen",
  "notes_placeholder": "Ihre Notiz...",
  "notes_close_title": "Schließen",
  "notes_goto_title": "Zum Text gehen",
  "notes_edit_title": "Notiz bearbeiten",
  "notes_delete_title": "Notiz löschen",
  "notes_edit_text": "Bearbeiten",
  "copy_code_copy": "Kopieren",
  "copy_code_copied": "Kopiert!",
  "copy_code_error": "Fehler",
  "error_loading_title": "Ladefehler",
  "error_loading_message": "Bitte überprüfen Sie Ihre Verbindung und aktualisieren Sie die Seite.",
  "lightbox_aria_close": "Bildbetrachter schließen",
  "lightbox_image_alt": "Vergrößerte Ansicht",
  "mindmap_preset_full": "Vollansicht",
  "mindmap_preset_quick_start": "Schnellstart",
  "mindmap_preset_dev": "Entwickler-Workflow",
  "mindmap_preset_translator": "Übersetzer-Workflow",
  "mindmap_edge_configure": "1. Konfigurieren",
  "mindmap_edge_specify_content": "2. Inhalt angeben",
  "mindmap_edge_parse_project": "3. Projekt parsen",
  "mindmap_edge_creates_components": "Erstellt Komponenten",
  "mindmap_edge_generates": "Generiert",
  "mindmap_edge_opens": "Öffnet",
  "mindmap_edge_manages_assets": "Verwaltet Assets für",
  "mindmap_edge_defines_rules": "Definiert Regeln für",
  "mindmap_edge_reports_on": "Berichtet über",
  "mindmap_edge_enables_reaction": "Ermöglicht Reaktion über",
  "mindmap_edge_processed_by": "Verarbeitet von",
  "mindmap_edge_edited_in": "Bearbeitet in",
  "mindmap_edge_extends": "Erweitert",
  "mindmap_edge_warns_about": "Warnt vor",
  "mindmap_edge_relates_to": "Bezieht sich auf",
  "mindmap_edge_recommends_for": "Empfiehlt für",
  "mindmap_edge_see_faq": "Siehe FAQ"
}