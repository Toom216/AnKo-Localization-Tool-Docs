{
  "a_faq_addressables_1": "Stellen Sie sicher, dass das Addressables-Paket installiert und Einstellungen erstellt wurden und Sie auf \"Scan Assets & Generate Tables\" geklickt haben, um Schlüssel in Gruppen zu registrieren.",
  "a_faq_addressables_2": "Erstellen Sie ein <code>Translation Profile</code> im Assets-Ordner, wählen Sie den Diensttyp aus, geben Sie den API-Schlüssel ein und weisen Sie dieses Profil im <code>Settings</code>-Fenster zu.",
  "a_faq_addressables_3": "Im Migrationsfenster (Registerkarten Komponenten / Import) gibt es einen \"Enable Stubs\"-Button, der die Notfall‑Stubs‑Funktion aktiviert. Dadurch werden gefälschte Platzhalterklassen für I2 Localization oder Unity Localization erstellt, sodass Ihr Projekt sofort nach dem Entfernen dieser Plugins kompiliert werden kann. Die Funktion arbeitet, indem das Define‑Symbol ANKO_ENABLE_MIGRATION_STUBS umgeschaltet wird. Dies verhindert Fehler wie \"The type name 'Localize' could not be found\" und gibt Ihnen Zeit, Ihren Code korrekt zu refaktorisieren, um das neue System zu nutzen. Enable Stubs ermöglicht es, Kompilierungsfehler nach dem Löschen des alten Lokalisierungs‑Plugins zu beheben. In v2.0 wurde das Migrationssystem mit <strong>Migrationsprofilen</strong> erweitert, die robustere Übergangsregeln von anderen Plugins erlauben.",
  "a_faq_audio_smart_update": "Das Tool verwendet intelligentes Batching mit MD5-Hashing, um Audiodateien nur dann neu zu generieren, wenn sich der Quelltext geändert hat. Es berechnet einen MD5-Hash Ihres Textinhalts und vergleicht ihn mit zuvor generierten Audiodateien. Wenn sich der Text nicht geändert hat, wird die Regenerierung übersprungen, wodurch Ihre API-Gutschriften gespart werden. Dies verhindert unnötige API-Aufrufe und reduziert Kosten beim Regenerieren von Audio. Das Tool hashiert Ihren Text und generiert Audiodateien nur neu, wenn sich der Quelltext geändert hat, wodurch Ihre API-Gutschriften gespart werden.",
  "a_faq_components_1": "Nein, das wird er nicht. Das Deaktivieren eines MonoBehaviour verhindert, dass alle \"magischen\" Methoden von Unity aufgerufen werden, einschließlich Awake(), OnEnable() und Start(). Dies ist beabsichtigt, um doppelte Logikausführung zu vermeiden. Die gesamte Initialisierung sollte in Skripten auf den lokalisierten Versionen des Prefabs erfolgen.",
  "a_faq_components_2": "Ja, das Physikverhalten des Originalobjekts wird neutralisiert. Die Komponente LocalizedPrefab findet alle Rigidbody- und Rigidbody2D-Komponenten auf seinem GameObject und setzt deren isKinematic-Eigenschaft auf true. Dies entfernt sie effektiv aus dynamischen Physikberechnungen und verhindert unerwünschtes Verhalten wie ein unsichtbares Objekt, das fällt oder auf Kollisionen reagiert. Es wird weiterhin empfohlen, dass die lokalisierte Version des Prefabs alle notwendigen Physikkomponenten für das korrekte Verhalten enthält.",
  "a_faq_components_3": "Ja, das wird. Die Komponente speichert den vollständigen Typnamen, einschließlich Namespace und Assembly. Das Umbenennen des Skripts oder das Verschieben in ein anderes .asmdef ändert diesen Namen, und LocalizedAsset kann die Zielkomponente nicht mehr finden. Sie müssen eine weitere Analyse über \"Projekt analysieren & Komponenten anhängen\" ausführen, damit der Name aktualisiert wird.",
  "a_faq_components_4": "Ein LocalizedAsset wird für eine bestimmte Komponenteninstanz erstellt. Es enthält eine Referenz auf diese Komponente im Code. Wenn Sie manuell ein zweites LocalizedAsset hinzufügen und das Kontextmenü \"Analyze for Localization\" verwenden, um auf das zweite Image abzuzielen, haben Sie zwei LocalizedAsset-Komponenten, die jeweils ihr eigenes Image verwalten. Der automatische Analysator erstellt nur eine Komponente für das erste Image mit einem lokalisierbaren Asset, das er findet.",
  "a_faq_components_5": "Ja, das wird es. LocalizedPrefab erstellt die Instanz des lokalisierten Prefabs in seiner OnEnable()-Methode. Unitys Ausführungsreihenfolge garantiert, dass alle Awake()-Methoden vor allen OnEnable()-Methoden ausgeführt werden. Ihr Skript mit der Reihenfolge -110 führt also sein Awake() aus, dann führt LocalizedPrefab mit der Reihenfolge -100 sein Awake() aus, und erst danach werden ihre OnEnable()-Methoden in der Reihenfolge aufgerufen. Ihr Skript findet das Objekt nicht, da es noch nicht erstellt wurde.",
  "a_faq_components_6": "Sowohl der Schlüssel als auch der Text ändern sich. Der programmatische Aufruf von SetFormattedText überschreibt das isStyleOnly-Verhalten für dieses spezifische Update. Die Option isStyleOnly soll verhindern, dass die Komponente auf globale Sprachänderungen reagiert, aber sie reagiert immer auf eine direkte Schlüsseländerung durch Code.",
  "a_faq_components_7": "Es findet Methoden mit jedem Zugriffsmodifikator (public, private, protected, internal). Reflection in Unity ermöglicht die Erkennung aller Instanzmethoden, unabhängig von ihrer Zugriffsebene.",
  "a_faq_components_8": "Die Verwendung des alten (nicht lokalisierten) Assets ist möglich. LocalizedAsset führt den Austausch in seiner OnEnable() durch. Die Awake()-Methoden aller Skripte werden vor OnEnable() ausgeführt. Wenn Ihr Skript in Awake() auf audioSource.clip zugreift, erhält es den ursprünglichen Clip. Wenn es in Start() darauf zugreift, hängt das Ergebnis von der Skript-Ausführungsreihenfolge ab. Um den Zugriff auf das lokalisierte Asset zu gewährleisten, legen Sie entweder eine spätere Ausführungsreihenfolge für Ihr Skript fest oder greifen Sie in einer Methode, die mit [OnLanguageChange] markiert ist, auf das Asset zu.",
  "a_faq_custom_keys_attribute": "Ja. Im <strong>Content Tab</strong> unter 'Attributes to Scan' können Sie jeden Attributnamen hinzufügen (z. B. <code>[Header]</code>, <code>[TermsPopup]</code>). Der Parser behandelt jedes Zeichenkettenfeld mit diesem Attribut als lokalisierbar.",
  "a_faq_custom_provider_1": "Stellen Sie sicher, dass Ihre Klasse <code>IAssetProvider</code> implementiert, NICHT abstrakt ist und mit dem Attribut <code>[AssetProviderPlugin]</code> markiert ist. Überprüfen Sie außerdem die Konsole auf reflexionsbezogene Fehler beim Start, da das Tool alle Assemblies nach Providern durchsucht.",
  "a_faq_editor_1": "Die Direktive @placeholders: im Kommentar hat Priorität. Sie wird als explizite Anweisung des Entwicklers und als \"Wahrheitsquelle\" betrachtet. In Ihrem Beispiel erfordert der Editor {username} in der Übersetzung und ignoriert {name} aus dem Quelltext.",
  "a_faq_editor_2": "Er wird einfach ignoriert. Das Tool sucht nach einer exakten Übereinstimmung von @placeholders:. Wenn die Direktive falsch geschrieben ist, wird sie als Teil eines regulären Kommentars behandelt, und die Validierung funktioniert auf die alte Weise - basierend auf den Platzhaltern aus dem Quelltext.",
  "a_faq_editor_3": "Ja. Nach einem erfolgreichen manuellen Speichern oder normalem Schließen des Fensters (wenn Sie Änderungen speichern) werden alle Auto-Speicher-Dateien gelöscht, um eine Wiederherstellungsaufforderung beim nächsten Start zu vermeiden. Sie bleiben nur im Falle eines Editor-Absturzes erhalten.",
  "a_faq_editor_4": "Ja. Die Spaltenbreiten werden jedes Mal, wenn Sie das Übersetzungseditor-Fenster schließen, in EditorPrefs gespeichert und beim nächsten Öffnen wiederhergestellt.",
  "a_faq_editor_5": "Ja. Das MultiLineEditWindow verfügt über einen eigenen temporären Rückgängig/Wiederherstellen-Stapel, der funktioniert, während das Fenster geöffnet ist. Dadurch können Sie Textänderungen innerhalb dieses Fensters rückgängig machen und wiederherstellen. Sobald Sie das Ergebnis speichern (durch Schließen des Fensters), wird diese Änderung als einzelne Aktion im globalen Rückgängig/Wiederherstellen-Stapel des Haupteditors aufgezeichnet.",
  "a_faq_examples_1": "Es wird keinen Fehler geben. Der Platzhalter {username} wird einfach nicht ersetzt, und Sie erhalten die Zeichenkette \"Hello, {username}\" als Ergebnis. Die Ersetzung erfolgt nur bei einer exakten Namensübereinstimmung.",
  "a_faq_examples_2": "Ja, das wird es. Der Parser verwendet Reflection, um Felder mit den Flags BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static zu finden, sodass er statische Felder findet und verarbeitet.",
  "a_faq_examples_3": "Es gibt keinen Kompilierungsfehler, aber eine Warnung von LocalizedBehaviour wird zur Laufzeit in der Unity-Konsole angezeigt. Sie meldet, dass sie eine Methode mit dem Attribut gefunden, diese aber ignoriert hat, weil die Methode Parameter hat. Eine solche Methode wird nicht aufgerufen.",
  "a_faq_examples_4": "Ja. Wenn eine bestimmte Form (_one, _few usw.) nicht gefunden wird, versucht das System, den Schlüssel mit dem Suffix _other als Fallback zu verwenden. Wenn auch dieser nicht gefunden wird, wird die Übersetzung für den Basisschlüssel apple_count verwendet.",
  "a_faq_examples_5": "Ja, das wird es. Jeder Aufruf von new { ... } reserviert Speicher auf dem verwalteten Heap, was zusätzliche Arbeit für den Garbage Collector bedeutet. Für Text, der in jedem Frame aktualisiert wird (in Update oder LateUpdate), ist es deutlich performanter, ein Dictionary<string, object> einmal in Start() zu erstellen und in Update() nur seine Werte zu aktualisieren, bevor es an die _()-Funktion übergeben wird.",
  "a_faq_examples_6": "Prüfen Sie, ob Ihre Methode Parameter hat. Das Attribut <code>[OnLanguageChange]</code> funktioniert nur bei Methoden **ohne Parameter** (z. B. <code>void UpdateUI()</code>). Wenn Ihre Methode Argumente erfordert, umschließen Sie sie in einer parameterlosen Methode.",
  "a_faq_extending_1": "Es reicht aus, die Klasse zu haben. Wenn TextParser ausgeführt wird, verwendet es Reflection, um alle Klassen im Projekt zu finden, die die Schnittstelle ITextComponentParser implementieren, und ruft automatisch deren Parse()-Methode für jedes GameObject auf. Es ist keine manuelle Registrierung erforderlich.",
  "a_faq_extending_2": "Eine Ausnahme in Ihrem benutzerdefinierten Parser unterbricht den Prozess. Die Haupt-Parsing-Schleife umschließt Aufrufe an benutzerdefinierte Parser nicht in einem try-catch-Block. Wenn Ihre Parse()-Methode eine unbehandelte Ausnahme auslöst,",
  "a_faq_installation_1": "Der Installer prüft auf das Vorhandensein des Typs Newtonsoft.Json.JsonConvert. Wenn der Typ existiert, betrachtet er die Abhängigkeit als erfüllt und versucht nicht, das Paket zu installieren oder zu aktualisieren. Dies geschieht, um Versionskonflikte zu vermeiden.",
  "a_faq_installation_2": "Sie können jederzeit manuell eine Abhängigkeitsprüfung über das Menü Tools -> Localization -> Check Dependencies auslösen. Dadurch wird das Flag \"Don't ask again\" zurückgesetzt und das Fenster mit allen fehlenden optionalen Paketen erneut angezeigt.",
  "a_faq_installation_3": "Dies kann passieren, wenn Sie keinen Ordner Assets/Resources haben. Das Tool versucht, ihn zu erstellen, aber Dateisystemberechtigungen könnten dies verhindern. Ja, Sie können das Asset manuell erstellen: Rechtsklick im Resources-Ordner, wählen Sie Create -> Localization -> Settings. Das Tool findet es automatisch.",
  "a_faq_installation_4": "Ja. Das Tool verwendet Resources.Load(), das in allen Ordnern mit dem Namen Resources in Ihrem Projekt nach einem Asset anhand des Namens sucht. Wichtig ist, dass die Datei ihren Namen LocalizationSettings.asset behält.",
  "a_faq_installation_5": "Ja. Sie können Window -> Package Manager öffnen, auf das \"+\"-Symbol klicken und \"Add package by name...\" auswählen. Geben Sie die Paketnamen ein: com.unity.nuget.newtonsoft-json und com.unity.editorcoroutines.",
  "a_faq_notes_1": "Ja. Wenn Sie LanguageSelector nicht zur Ignorierliste hinzufügen, behandelt der Parser seinen TMP_Dropdown als reguläres Dropdown. Er findet die Standardwerte \"Option A, Option B, Option C\", die Unity erstellt, und fügt Schlüssel dafür zu Ihren Übersetzungsdateien hinzu. Dies überfrachtet Ihre Dateien mit unnötigen Schlüsseln, da LanguageSelector diese Optionen zur Laufzeit sowieso entfernt und seine eigenen erstellt.",
  "a_faq_notes_2": "Ja, die Schriftart ändert sich nicht. Dies ist notwendig, weil LanguageSelector die Eigenschaft label.text direkt ändert. Ohne ein LocalizedText auf diesem Objekt weiß das Lokalisierungssystem nicht, dass dieses Element beim Sprachwechsel Stile (Schriftart, RTL) erhalten muss. Ein leeres LocalizedText mit isStyleOnly dient als \"Marker\" für das System, der besagt: \"Beobachte dieses Objekt und wende Stile darauf an, aber berühre seinen Text nicht\".",
  "a_faq_notes_3": "Der performanteste Ansatz besteht darin, die Formatzeichenkette in Start() oder in einer [OnLanguageChange]-Methode zwischenzuspeichern und in Update() das reguläre string.Format zu verwenden. Beispiel: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Dadurch wird vermieden, dass der Schlüssel in jedem Frame im Wörterbuch nachgeschlagen wird, was erheblich schneller ist.",
  "a_faq_runtime_api_key_distinction": "<strong>F: Was ist der Unterschied zwischen 'Translation Service Keys' und 'Runtime API Key'?</strong><br>A: <strong>Translation Service Keys</strong> (OpenAI, DeepL) werden im <strong>Unity Editor</strong> verwendet, um Übersetzungen zu erzeugen. Sie werden im Registrierungsbereich Ihres Computers (EditorPrefs) gespeichert und sind NICHT im Build enthalten.<br>Der <strong>Runtime API Key</strong> wird vom <strong>Game Build</strong> verwendet, um Live‑Updates abzurufen. Er ist IM Build enthalten (verschlüsselt).",
  "a_faq_tts_voices": "Verwenden Sie in Ihrem <strong>Translation Profile</strong> (Inspektor) die Liste 'Voice Mappings'. Sie können ein Regex-Muster (z. B. <code>^hero_.*</code>) einer bestimmten Voice-ID zuordnen. Der Generator wählt automatisch die korrekte Stimme basierend auf dem Schlüsselnamen aus.",
  "a_faq_window_actions_1": "Das Tool versucht, den exakten fehlgeschlagenen Stapel gemäß den Einstellungen der Wiederholungsrichtlinie (Anzahl der Versuche und Verzögerung) erneut zu senden. Wenn alle Versuche für diesen Stapel fehlschlagen, wird der Übersetzungsprozess für die aktuelle Sprache unterbrochen, und ein Fehler wird in der Konsole protokolliert. Die Übersetzung für die nächsten Sprachen in der Warteschlange wird nicht gestartet.",
  "a_faq_window_actions_2": "Leere Werte ersetzen vorhandene Übersetzungen. Der Importprozess betrachtet die CSV-Datei als \"Wahrheitsquelle\". Wenn der Wert für den Schlüssel welcome_message in der Spalte ru leer ist, wird die aktuelle russische Übersetzung für diesen Schlüssel überschrieben.",
  "a_faq_window_actions_3": "Ja, das werden sie. Die Funktionen in der \"Danger Zone\" scannen alle Prefabs im Projekt (AssetDatabase.FindAssets(\"t:Prefab\")), nicht nur die in der Parsing-Liste angegebenen, um die größtmögliche Bereinigung zu gewährleisten.",
  "a_faq_window_actions_4": "In Ihrem Google Sheets-Dokument muss die Spalte den Titel \"Developer Notes\" tragen. In den Zellen dieser Spalte können Sie wie gewohnt Kommentare schreiben. Um Platzhalter anzugeben, fügen Sie einfach eine Zeile wie @placeholders: {username}, {score} in den Kommentartext ein. Das Tool erkennt diese Direktive beim Import automatisch.",
  "a_faq_window_actions_5": "Das Tool funktioniert nur mit einem Blatt gleichzeitig. Die Import-URL enthält einen Parameter gid=..., der ein bestimmtes Blatt im Dokument eindeutig identifiziert. Um Daten aus einem anderen Blatt zu importieren, müssen Sie dessen URL (mit einer anderen gid) kopieren und den Import erneut durchführen.",
  "a_faq_window_assets_1": "Der Asset-Scanner lädt sie unter Angabe des erwarteten Typs (AssetDatabase.LoadAssetAtPath(path, expectedType)). Für die Kategorie AudioClip sucht und lädt er nur Dateien, die Unity als AudioClips erkennt. Wenn beide Dateien gültige Audioclips sind, wird diejenige in die Tabelle aufgenommen, die zuletzt verarbeitet wird, wodurch die vorherige effektiv überschrieben wird. Es wird empfohlen, solche Duplikate zu vermeiden.",
  "a_faq_window_assets_2": "Ja, genau so funktioniert es. \"Analyze Project\" findet die Image-Komponente, betrachtet den Namen des ihr zugewiesenen Sprites (z. B. icon_play_en), extrahiert daraus den Schlüssel (icon_play) und die Sprache (en) und fügt dann dem GameObject eine LocalizedAsset-Komponente hinzu und schreibt den Schlüssel icon_play hinein.",
  "a_faq_window_assets_3": "Ja, das können Sie. Es wird keine Konflikte geben, da für jede Kategorie eine separate Asset-Tabelle (LocalizedAssetTable) erstellt wird. Schlüssel aus der Kategorie \"Sprites\" überschneiden sich nicht mit Schlüsseln aus der Kategorie \"AudioClips\", selbst wenn sie denselben Namen haben.",
  "a_faq_window_assets_4": "Ja, das wird er. Der Scanner verwendet die Option SearchOption.AllDirectories, was bedeutet, dass er alle Unterordner innerhalb des von Ihnen angegebenen Scan Folders rekursiv überprüft.",
  "a_faq_window_content_1": "Nein, das wird es nicht. Die Liste Scenes to Parse wird ausschließlich verwendet, um das Tool darüber zu informieren, welche Szenen geöffnet und auf Text analysiert werden sollen. Sie steht in keiner Weise in Bezug zu den Szenen, die letztendlich im finalen Build Ihres Spiels landen.",
  "a_faq_window_content_2": "Nein, das wird sie nicht. Die temporäre Liste speichert eine direkte Referenz auf das Objekt in der Szene. Wenn Sie ein Prefab erstellen, handelt es sich um ein neues Asset. Seine Instanzen sind andere Objekte, und die Ignorierregel gilt nicht für sie. Um Prefabs dauerhaft zu ignorieren, müssen sie als Prefab-Asset zur Ignorierliste hinzugefügt werden.",
  "a_faq_window_content_3": "Ja, das wird er. Wenn Sie auf Update Keys klicken, scannt der Parser das gesamte Projekt erneut. Er wird sehen, dass der Typ TMPro.TMP_Text ignoriert werden soll, und generiert keinen Schlüssel dafür. Während des Vergleichs alter und neuer Schlüssel wird er feststellen, dass der alte Schlüssel nicht mehr verwendet wird, und ihn als \"Removed\" markieren.",
  "a_faq_window_content_4": "Nein, das wird es nicht. \"Pin\" speichert den absoluten Pfad in der Szenenhierarchie in dem Moment, in dem auf die Schaltfläche geklickt wird (z. B. Canvas/Panel/Button). Dieser Pfad steht in keinem Zusammenhang mit der Prefab-Logik. Prefab-Instanzen haben denselben Pfad, aber wenn Sie das übergeordnete Objekt in der Szene umbenennen, funktioniert \"Pin\" sowohl für das Original als auch für die Instanzen nicht mehr.",
  "a_faq_window_content_5": "Der vollständige Pfad von der Szenen-Wurzel wird gespeichert. Zum Beispiel MyPrefab(Clone)/Content/Icon. Dieser \"angeheftete\" Pfad funktioniert nur in der Szene, in der Sie ihn erstellt haben. In anderen Szenen ist es unwahrscheinlich, dass ein solcher Pfad gefunden wird.",
  "a_faq_window_preview_1": "Nein, es wird nicht gespeichert. PreviewSafetyBridge fängt das Asset‑Speicherevent (OnWillSaveAssets) ab und ruft automatisch RevertEditorPreview() auf, bevor Unity die Änderungen auf die Festplatte schreibt. Dadurch wird das Prefab im ursprünglichen, nicht lokalisieren Zustand gespeichert.",
  "a_faq_window_preview_2": "PreviewRecoveryService übernimmt die Wiederherstellung nach Abstürzen. Wenn Unity abstürzt, erkennt der Dienst beim nächsten Start die Sicherungsdatei und versucht, den Szenenzustand wiederherzustellen. Wenn die automatische Wiederherstellung fehlschlägt, müssen Sie möglicherweise manuell \"Revert to Original\" im Werkzeugfenster auswählen.",
  "a_faq_window_preview_3": "Ja, das werden sie. PrefabUtility.InstantiatePrefab im Edit-Modus ruft Awake() und OnEnable() auf. Wenn diese Methoden Logik enthalten, die nicht im Editor ausgeführt werden sollte (z. B. Zugriff auf Singletons, die nur im Play-Modus existieren), könnte dies Fehler verursachen. Es wird empfohlen, if (Application.isPlaying) oder #if UNITY_EDITOR zu verwenden, um solchen Code zu schützen.",
  "a_faq_window_report_1": "Ja, sie wird unterbrochen. Jede neue Aktion, die eine UI-Blockierung erfordert (wie Update Keys), stoppt die aktuelle Such-Coroutine. Es erscheint ein Dialogfeld, in dem Sie aufgefordert werden, die aktuelle Suche zu beenden, um eine neue zu starten.",
  "a_faq_window_report_2": "Die Kategorie \"Duplicates\" zeigt alle Quellen für diesen Schlüssel an. Sie sehen einen Eintrag für den Schlüssel, und das Feld \"Source\" listet alle Pfade (in Szene 1 und Szene 2) auf. Die Schaltfläche \"Find\" öffnet in diesem Fall eine Dropdown-Liste, in der Sie auswählen können, zu welchem Objekt navigiert werden soll.",
  "a_faq_window_report_3": "Ja. Das Suchsystem ist speziell darauf trainiert, Quellen wie Skript MyScript.cs zu erkennen. Wenn Sie auf \"Find\" klicken, sucht es nach dem Asset MyScript.cs im Projekt und hebt es im Projektfenster hervor (ping).",
  "a_faq_window_settings_1": "Ja, das werden sie. Beim Ändern des Modus führt das Tool eine \"sichere Migration\" durch: Es parst das gesamte Projekt erneut, erstellt neue Schlüssel gemäß den neuen Regeln, ordnet die alten und neuen Schlüssel jedoch über den Originaltext zu. Anschließend überträgt es alle Ihre vorhandenen Übersetzungen und Kommentare von den alten auf die neuen Schlüssel. Ihre Übersetzungen gehen nicht verloren.",
  "a_faq_window_settings_2": "Die DefaultPluralRule wird verwendet, die für Englisch und die meisten europäischen Sprachen geeignet ist (Formen für „one“ und „other“).",
  "a_faq_window_settings_3": "Nein, das werden sie nicht. Nur Assets, die sich in einem StreamingAssets- oder Resources-Ordner befinden, werden garantiert in den Build aufgenommen. Wenn Sie einen anderen Pfad angeben, funktioniert die Lokalisierung im Editor, aber nicht im kompilierten Spiel, da die Übersetzungsdateien nicht Teil des Builds sind.",
  "a_faq_window_settings_4": "Ja. EditorPrefs ist lokaler Speicher für jeden Computer. Sie müssen den <strong>Translation Service API Key</strong> (für die Nutzung im Editor wie OpenAI/DeepL) auf jedem Rechner eingeben. Der <strong>Runtime API Key</strong> (in Builds verwendet) wird jedoch in den Projekteinstellungen gespeichert und über die Versionskontrolle (verschlüsselt) geteilt.",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "Kopiert!",
  "copy_code_copy": "Kopieren",
  "copy_code_error": "Fehler",
  "error_loading_message": "Bitte überprüfen Sie Ihre Verbindung und aktualisieren Sie die Seite.",
  "error_loading_title": "Ladefehler",
  "h1_ai_audio": "KI Audio / Text-to-Speech",
  "h1_ai_profiles": "KI & Übersetzungsprofile",
  "h1_api_snippets": "API & Code‑Snippets",
  "h1_components": "Kernkomponenten (automatisch zugewiesen)",
  "h1_extending": "Erweiterung der Funktionalität",
  "h1_faq": "FAQ & Fehlerbehebung",
  "h1_font_glyph_manager": "Font & Glyph Manager",
  "h1_important_notes": "Wichtige Hinweise und Warnungen",
  "h1_introduction": "Einführung",
  "h1_loc_tool_window": "Das „Localization Tool“-Fenster",
  "h1_migration_tool": "Migrationstool",
  "h1_quick_start": "Schnellstart und Setup",
  "h1_tms": "Externe TMS-Integration (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Übersetzungstabellen-Editor",
  "h1_usage_examples": "Anwendungsbeispiele",
  "h2_ai_assistant": "KI-Assistent Befehle",
  "h2_ai_audio_setup": "Setup",
  "h2_ai_audio_usage": "Anwendung",
  "h2_ai_context": "Kontext & Glossar",
  "h2_ai_profiles_overview": "Übersetzungsprofile",
  "h2_async_api": "Asynchrone API (Addressables)",
  "h2_backup_manager": "Backup‑Manager",
  "h2_bridge_generation": "C#-Brücken generieren (stark typisierter Zugriff)",
  "h2_custom_ai": "Benutzerdefinierte KI & Modelle",
  "h2_custom_asset_provider": "Erstellen eines benutzerdefinierten Asset‑Providers",
  "h2_custom_attributes": "Scannen benutzerdefinierter Attribute",
  "h2_custom_parser": "Erstellen eines benutzerdefinierten Parsers",
  "h2_example_attribute": "[LocalizableField] Attribut",
  "h2_example_components": "Fertige Komponenten und Beispiele",
  "h2_example_components_updated": "Aktualisierte LanguageSelector.cs",
  "h2_example_function": "_() Funktion und [OnLanguageChange] Attribut",
  "h2_example_plurals": "Pluralformen und Geschlecht",
  "h2_faq_addressables": "Addressables & Migration",
  "h2_faq_audio": "KI Audio / Text-to-Speech",
  "h2_faq_components": "Kernkomponenten",
  "h2_faq_editor": "Übersetzungseditor",
  "h2_faq_examples": "Anwendungsbeispiele & Code",
  "h2_faq_extending": "Funktionalität erweitern",
  "h2_faq_installation": "Installation & Schnellstart",
  "h2_faq_notes": "Wichtige Nuancen & Warnungen",
  "h2_faq_window": "\"Lokalisierungswerkzeug\" Fenster",
  "h2_font_glyph_manager_features": "Merkmale",
  "h2_in_editor_preview": "Im Editor & Prefab-Vorschau",
  "h2_initial_setup": "Erste Einrichtung",
  "h2_installation": "Installation",
  "h2_key_features": "Schlüsselmerkmale",
  "h2_live_updates_guide": "Leitfaden für Live‑Updates",
  "h2_localizedasset": "Lokalisierte Asset",
  "h2_localizedasset_updated": "Asynchrone Ladung von LocalizedAsset",
  "h2_localizedbehaviour": "Lokalisierter Behaviour",
  "h2_localizeddropdown": "Lokalisierter Dropdown",
  "h2_localizedprefab": "Lokalisierter Prefab",
  "h2_localizedtext": "Lokalisierter Text",
  "h2_migration_custom": "Erstellen benutzerdefinierter Profile",
  "h2_migration_google_sheets": "Google‑Sheets‑Schlüssel",
  "h2_migration_import_formats": "Importformate (CSV & Google Sheets)",
  "h2_migration_stubs": "Sichere Migration & Notfall‑Stubs",
  "h2_migration_tool_features": "Merkmale",
  "h2_migration_workflow": "Leitfaden zum Migrations‑Workflow",
  "h2_preview_overlay": "Szenenansicht‑Overlay",
  "h2_safety_caps": "Grenzwerte & Sicherheitsquoten",
  "h2_script_parsing_rules": "Skript-Parsing-Regeln (Kompatibilität)",
  "h2_tab_actions": "\"Aktionen\" Tab",
  "h2_tab_assets": "\"Assets\" Tab",
  "h2_tab_content": "\"Content\"‑Tab",
  "h2_tab_report": "\"Bericht\" Tab",
  "h2_tab_settings": "\"Einstellungen\" Tab",
  "h2_tab_tutorials": "\"Tutorials\" Registerkarte",
  "h2_tms_setup": "Einrichtung & Nutzung",
  "h2_tms_supported": "Unterstützte Dienste",
  "h2_uitklocalization": "UITK-Lokalisierung",
  "h2_visual_debugging_guide": "Visuelles Debugging",
  "h2_window_footer": "Fensterfußzeile (Statusleiste)",
  "h2_window_header": "Fensterkopfzeile & Symbolleiste",
  "h2_window_sidebar": "Hauptmenü (Seitenleiste)",
  "h3_actions_autotranslate": "Auto‑Übersetzung",
  "h3_actions_danger": "Gefahrenzone",
  "h3_actions_data": "Datenverwaltung",
  "h3_actions_editor": "Übersetzungseditor",
  "h3_actions_parsing": "Parsing",
  "h3_actions_tms_integration": "Externe Dienste (TMS)",
  "h3_assets_automation": "Automatisierung",
  "h3_assets_categories": "Asset‑Kategorien",
  "h3_assets_folder_gen": "Ordnererstellung",
  "h3_assets_loading": "Lade‑Strategie",
  "h3_assets_storage": "Speicherkonfiguration",
  "h3_attribute_cheat_sheet": "Kurzübersicht: Was funktioniert und was nicht",
  "h3_attribute_features": "Unterstützte Typen & Funktionen",
  "h3_attribute_limitations": "Einschränkungen",
  "h3_content_components_ignore": "Komponententypen zum Ignorieren",
  "h3_content_dynamic_keys": "Dynamische Schlüsselpräfixe",
  "h3_content_dynamic_texts": "Dynamische Texte",
  "h3_content_objects_ignore": "Zu ignorierende Objekte",
  "h3_content_prefabs": "Prefab‑Ordner",
  "h3_content_regex": "Ignorierte Regex‑Muster",
  "h3_content_scenes": "Zu parsende Szenen",
  "h3_content_script_rules": "Regeln für das Skript‑Parsing",
  "h3_content_scripts_ignore": "Zu ignorierende Skripte",
  "h3_custom_provider_steps": "Implementierungsschritte",
  "h3_faq_window_actions": "Tab „Aktionen“",
  "h3_faq_window_assets": "Tab „Assets“",
  "h3_faq_window_content": "Tab „Inhalt“",
  "h3_faq_window_preview": "In-Editor-Vorschau",
  "h3_faq_window_report": "Tab „Bericht“",
  "h3_faq_window_settings": "Tab „Einstellungen“",
  "h3_mode_auto": "AutoGenerateKeysOnly (Standard)",
  "h3_mode_hybrid": "Hybrid-Modi (benutzerdefinierte Priorität)",
  "h3_mode_text": "UseTextAsKey (Vereinfacht)",
  "h3_report_all_keys": "Alle Schlüssel",
  "h3_settings_debugging": "Debugging",
  "h3_settings_general": "Allgemeine Einstellungen",
  "h3_settings_keygen": "Schlüsselgenerierung",
  "h3_settings_languages": "Sprachverwaltung",
  "h3_settings_liveupdates": "Live‑Updates",
  "h3_settings_pseudo": "Einstellungen für Pseudo‑Lokalisierung",
  "h3_settings_runtimeapi": "Runtime‑API",
  "h3_settings_tools": "Allgemeine & Dev‑Tools",
  "h3_tutorials_list": "Tutorial‑Liste",
  "lbl_not_supported": "NICHT unterstützt",
  "lbl_supported": "Vollständig unterstützt",
  "li_actions_1": "<strong>Parsing:</strong><ul><li><strong>Update Keys:</strong> Vollständiger Projekt-Scan, definiert durch die Einstellungen des Tabs 'Content'.</li><li><strong>Scan Selected Assets:</strong> Scannt **NUR** die Dateien/Ordner, die aktuell in der Projektansicht ausgewählt sind. Sicherer für Teilaktualisierungen, da 'Remove Missing Keys' automatisch deaktiviert wird.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Öffnet ein separates, bequemeres Fenster zum Bearbeiten aller Übersetzungen.",
  "li_actions_3": "<strong>Datenverwaltung:</strong> Verwenden Sie es zum Austausch von Daten mit Übersetzern (Export/Import nach CSV/XML/YAML/XLIFF, Import von Google Sheets). <strong>Google Sheets:</strong> Unterstützt sowohl 'Edit'-Links als auch 'Publish to Web'-URLs (prüfen Sie den GID‑Parameter).",
  "li_actions_4": "<strong>Auto-Translation:</strong> Füllt alle leeren Übersetzungszeichenketten automatisch mithilfe des aktiven <strong>Translation Profile</strong>.",
  "li_actions_5": "<strong>Danger Zone:</strong> Enthält Schaltflächen zum vollständigen Entfernen aller Lokalisierungskomponenten aus dem Projekt. Mit Vorsicht verwenden!",
  "li_ai_1": "<strong>Profil erstellen:</strong> Rechtsklick in der Projektansicht -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Dienste:</strong> Unterstützt DeepL, Google Translate, Microsoft Azure und <strong>Custom AI</strong>.",
  "li_ai_3": "<strong>Einstellungen:</strong> Jedes Profil speichert seinen eigenen API-Schlüssel, Limits (Batch-Größe, maximale Zeichen) und Modelleinstellungen.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Verwenden Sie den integrierten Generator, um schnell Profile für gängige Dienste (OpenAI, Gemini, Claude, Ollama) zu erstellen.",
  "li_ai_audio_generate": "Wählen Sie im <strong>Translation Table Editor</strong> Zeilen/Zellen aus -> Rechtsklick -> <strong>Generate Audio</strong>.",
  "li_ai_audio_hash": "<strong>Smart Update & Hashing:</strong> Das Tool berechnet einen MD5-Hash Ihres Textinhalts und generiert Audiodateien nur neu, wenn sich der Quelltext geändert hat, wodurch Ihre API-Gutschriften gespart werden. Es erkennt, ob sich die Übersetzung seit der letzten Audio-Generierung geändert hat. Der Editor hebt diese Zeilen mit einem 'Outdated'-Symbol (gelb) hervor, sodass Sie NUR geänderte Zeilen aktualisieren können. Diese intelligente Stapelverarbeitungsfunktion verhindert unnötige API-Aufrufe und reduziert Kosten beim Regenerieren von Audio. Das Tool hashiert Ihren Text und generiert Audiodateien nur neu, wenn sich der Quelltext geändert hat, wodurch Ihre API-Gutschriften gespart werden.",
  "li_ai_audio_profile": "Wählen Sie in den <strong>Settings</strong> das <strong>Active Audio Profile</strong> aus (z. B. OpenAI TTS oder ElevenLabs).",
  "li_ai_audio_save": "Dateien werden in dem im Profil angegebenen Ordner gespeichert.",
  "li_ai_audio_voice_mapping": "<strong>Voice Mapping (Multi-Speaker):</strong> Unterschiedliche KI-Stimmen automatisch verschiedenen Charakteren zuweisen. Verwenden Sie die <strong>Voice Mappings</strong>-Liste, um Regex‑Muster (z. B. <code>^hero_.*</code>) mit bestimmten Voice‑IDs zu verknüpfen. Das Tool wählt automatisch die richtige Stimme basierend auf dem Schlüsselnamen während der Audioerstellung aus.",
  "li_ai_provider_settings": "<strong>Provider‑Einstellungen:</strong> Jeder Dienst ermöglicht die Konfiguration von API‑Schlüsseln, Modellen (z. B. GPT-4o, Sonnet) und sprachspezifischen Parametern (Stabilität, Ähnlichkeit).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Verwenden Sie dies, um Addressables‑Assets asynchron zu laden. Es gibt ein <code>Task&lt;T&gt;</code> zurück.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) liefert eine geschlechtsspezifische Übersetzung.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> gibt die korrekte Pluralform basierend auf sprachspezifischen Regeln zurück.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> Eine Coroutine (<code>IEnumerator</code>) zum Ändern der Sprache. Verwenden Sie stets <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Erstellen Sie eine Ordnerstruktur (optional):</strong> Klicken Sie in Abschnitt <strong>2. Asset Folder Generation</strong> auf <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Kategorien und Benennungsregeln konfigurieren:</strong> Stellen Sie in Abschnitt <strong>3. Asset Categories & Scanning</strong> sicher, dass die <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) mit Ihren Dateien übereinstimmt (z. B. <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Platzieren Sie Ihre Assets:</strong> Legen Sie die lokalisierten Assets in die Ordner.",
  "li_assets_4": "<strong>Assets scannen:</strong> Klicken Sie in Abschnitt <strong>4. Automation</strong> auf <strong>Scan Assets & Update Tables</strong>. Der Bereinigungsprozess ist sicherer geworden: Jetzt werden nur alte Tabellendateien (<code>.asset</code>) gelöscht, nicht der gesamte Ordner.",
  "li_assets_5": "<strong>Assets mit Objekten verknüpfen:</strong> Klicken Sie auf <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Addressables-Integration:</strong> Wenn der <strong>Addressables</strong>-Modus aktiviert ist, werden Assets während des Scannens automatisch in Addressables-Gruppen mit Adressen in der Form <code>{Category}/{Language}/{Key}</code> registriert.",
  "li_assets_addressables_naming": "<strong>Namenskonvention:</strong> Beim Scannen setzt das Tool die Addressable Adressen automatisch auf das Format <code>{Category}/{Language}/{Key}</code>. **Benennen Sie** diese Adressen nicht manuell um, da der LocalizationManager auf dieses spezifische Format angewiesen ist, um Assets zur Laufzeit zu laden.",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> Wenn aktiviert, erstellt das Tool automatisch die erforderliche Verzeichnisstruktur für alle unterstützten Sprachen während der ersten Asset‑Lokalisierung.",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> Erstellt automatisch die Ordnerstruktur für lokalisierte Assets gemäß Ihren Regeln.",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> Definieren Sie das Stammverzeichnis für alle lokalisierten Assets (Sprites, Audio usw.). Verwenden Sie die Variable <code>{lang}</code>, um festzulegen, wie die pro‑Sprach‑Ordner strukturiert sind.",
  "li_assistant_1": "<strong>Konfigurierbar:</strong> Definieren Sie Befehle in Ihrem Übersetzungsprofil (z. B. „Fix Grammar“, „Make Formal“, „Shorten for UI“).",
  "li_assistant_2": "<strong>Stapelverarbeitung:</strong> Wählen Sie mehrere Zellen aus, um den Befehl auf alle gleichzeitig anzuwenden.",
  "li_assistant_3": "<strong>Custom Commands:</strong> Definieren Sie eigene Eingabeaufforderungen im Inspektor <strong>Translation Profile</strong> (Liste von <code>AIAssistantCommand</code>). Jeder Befehl hat ein <strong>Label</strong> (erscheint im Kontextmenü) und ein <strong>Prompt</strong> (die an die KI gesendeten Anweisungen, z. B. 'Rewrite in pirate style').",
  "li_attr_feat_1": "<strong>Sammlungen:</strong> Unterstützt <code>List&lt;string&gt;</code> und <code>string[]</code>. Schlüssel werden mit Suffixen wie <code>_0</code>, <code>_1</code> usw. generiert. Sie können sogar einen benutzerdefinierten Schlüssel auf das Listenfeld selbst anwenden, um alle Elemente zu präfixen.",
  "li_attr_feat_2": "<strong>Zugriffsmodifikatoren:</strong> Funktioniert mit <code>private</code>, <code>protected</code>, <code>internal</code> und <code>public</code> Feldern.",
  "li_attr_feat_3": "<strong>Benutzerdefinierte Attribute:</strong> In den Einstellungen des <em>Content Tabs</em> können Sie <code>HeaderAttribute</code>, <code>TooltipAttribute</code> oder jeden beliebigen benutzerdefinierten Attributnamen hinzufügen. Der Parser behandelt Felder mit diesen Attributen (z.B. <code>[Header(\"Text\")]</code>) dann als lokalisierbare Zeichenketten!",
  "li_attr_feat_4": "<strong>Verschachtelte Objekte:</strong> Rekursives Scannen von Feldern innerhalb von Klassen oder Strukturen, die mit <code>[System.Serializable]</code> markiert sind. Dies umfasst einzelne Instanzen und Listen von verschachtelten Objekten.",
  "li_attr_feat_5": "<strong>Formatierte Zeichenketten:</strong> Unterstützt interpolierte Zeichenketten (<code>$\"Text {0}\"</code>), wörtliche Zeichenketten (<code>@\"Text\"</code>) und Verkettung (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Properties werden unterstützt:</strong> Der Parser scannt sowohl <code>Fields</code> als auch <code>Properties</code>. Ein Getter ist erforderlich.",
  "li_attr_limit_2": "<strong>Wörterbücher:</strong> <code>Dictionary&lt;T, string&gt;</code> wird nicht direkt für das Parsing unterstützt.",
  "li_attr_limit_3": "<strong>Statische Felder:</strong> Unterstützt durch statische Analyse (Regex) in Codedateien, aber im Allgemeinen wird empfohlen, Instanzfelder für eine robuste Erkennung auf GameObjects zu verwenden.",
  "li_backup_desc": "Verfolgen Sie Änderungen und stellen Sie frühere Versionen Ihrer Übersetzungen wieder her.",
  "li_backup_rollback": "<strong>Rollback:</strong> Setzt ausgewählte Schlüssel oder die gesamte Tabelle sofort in einen vorherigen Zustand zurück.",
  "li_backup_snapshots": "<strong>Snapshots:</strong> Erstellt benannte Wiederherstellungspunkte vor Massenoperationen.",
  "li_cheat_base_private": "<strong>Base Private Fields:</strong> Unterstützt (Scanner liest Basis‑Klassen‑Dateien direkt)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> Arrays",
  "li_cheat_concatenation": "<strong>String Concatenation:</strong> <code>\"A\" + \"B\"</code> (Unterstützt)",
  "li_cheat_constructor_args": "<strong>Komplexe Konstruktor-Argumente:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>Wörterbücher</strong> (Nicht von Unitys Inspector serialisierbar)",
  "li_cheat_headers": "Attribute wie <code>[Header(\"...\")]</code> (Vollständig unterstützt)",
  "li_cheat_nested_lists": "<strong>Listen verschachtelter Objekte</strong> (z.B. <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Variablen & Konstanten:</strong> <code>const string s = \"Value\";</code> oder <code>static string</code> (Unterstützt, Roslyn löst Werte aus derselben Datei auf)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> Felder (Unterstützt)",
  "li_cheat_properties": "<strong>Properties:</strong> <code>{ get; set; }</code> (Auto‑Properties & Full‑Properties unterstützt)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Unterstützt, wenn referenziert)",
  "li_cheat_serializable": "Verschachtelte <code>[Serializable] class</code> (Inventargegenstände, Dialogknoten)",
  "li_cheat_static": "<strong>Static Fields:</strong> <code>public static string</code> (Vollständig unterstützt)",
  "li_cheat_structs": "<strong>Structs & Records:</strong> Unterstützt (Rekursives Scannen)",
  "li_cheat_ternary": "<strong>Logik/Ternär:</strong> <code>cond ? \"A\" : \"B\"</code> (Der Parser kann den Wert nicht bestimmen)",
  "li_cheat_unattached": "<strong>Unattached Scripts:</strong> Unterstützt (Scanner liest alle .cs‑Dateien im Projekt)",
  "li_content_1": "<strong>Scenes to Parse:</strong> Ziehen Sie alle Szenen zur Analyse hierher.",
  "li_content_2": "<strong>Prefab Folders:</strong> Geben Sie Ordner mit Prefabs an. Unterstützt jetzt Paginierung und Suche für große Projekte.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Geben Sie hier Zeichenketten ein, die ausschließlich im Code erstellt werden (z. B. „Game Over“).",
  "li_content_4": "<strong>Component Types to Ignore:</strong> Geben Sie Unity‑Komponententypen an, die beim Scannen übersprungen werden sollen.",
  "li_content_5": "<strong>Pin to Ignore:</strong> Diese Funktion ermöglicht es Ihnen, ein Objekt aus der Szene dauerhaft zur Ignorierliste zu \"pinnen\".",
  "li_content_6": "<strong>Scripts to Ignore:</strong> Fügen Sie bestimmte C#‑Skripte ODER ganze Ordner hinzu, um sie vom Parsen auszuschließen.",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> Liste von Präfixen für Schlüssel (z. B. <code>Item_</code>), die beim Aufräumen nicht gelöscht werden.",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> Definieren Sie Präfixe (z. B. <code>quest_item_</code>), die als potenziell dynamisch erkannt werden sollen. Dies hilft dem Tool, zwischen statischen UI‑Beschriftungen und datengetriebenen Schlüsseln zu unterscheiden.",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> Konfigurieren Sie Muster für Text, der dynamisch per Code aktualisiert wird. Dies verhindert, dass der Scanner redundante Schlüssel für Text erstellt, der zur Laufzeit geändert wird.",
  "li_content_regex_example": "<strong>Beispiel für benutzerdefinierten Wrapper:</strong> Wenn Sie eine benutzerdefinierte Funktion wie <code>MyGame.Loc(\"KEY\")</code>, fügen Sie eine Skript‑Parsing‑Regel mit dem Regex hinzu: <code>\\\\bMyGame\\.Loc\\s*\\(\\s*\"([^\\\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Ignorierte Regex‑Muster:</strong> Klicken Sie auf <strong>'Gemeinsames Muster hinzufügen'</strong> um schnell dynamische Inhalte wie URLs, E‑Mails usw. auszuschließen.",
  "li_content_scanner": "<strong>Roslyn Code Scanner:</strong> Eine tiefgehende statische Analyse‑Engine, die C#‑Syntaxbäume versteht, um eine robuste Schlüsselerkennung zu ermöglichen.",
  "li_content_scanner_details_1": "<strong>Smart Call Detection:</strong> findet automatisch Aufrufe von <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> und <code>GetTranslation(\"Text\")</code>. Sie erzwingt den <strong>Text‑Als‑Key</strong>-Modus für diese Aufrufe, um sicherzustellen, dass Laufzeit‑Funktionen wie Pluralisierung und Geschlecht korrekt funktionieren.",
  "li_content_scanner_details_2": "<strong>Constant Resolution:</strong> Der Scanner ist intelligent genug, `const`‑ oder `static readonly`‑String‑Variablen aufzulösen. Wenn Sie <code>_ (MyConst)</code> verwenden, findet er den Wert von `MyConst` (falls in derselben Klasse definiert) und nutzt ihn als Quelltext.",
  "li_content_scanner_details_3": "<strong>Attribute & Metadaten:</strong> Es scannt jedes Feld oder jede Eigenschaft mit `[LocalizableField]`, `[Header]` oder `[Tooltip]` (falls konfiguriert). Es verarbeitet <strong>Arrays</strong>, <strong>Listen</strong> und sogar <strong>Verschachtelte serialisierbare Klassen</strong> rekursiv.",
  "li_content_scanner_details_4": "<strong>Moderne C# Unterstützung:</strong> Vollständige Unterstützung für C# 9.0+ Syntax, einschließlich target-typed <code>new()</code>-Ausdrücken, impliziter Array-Erstellung und interpolierter Zeichenketten (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Zu scannende Attribute:</strong> Definieren Sie benutzerdefinierte Attribute (wie <code>[Header]</code> oder <code>[Tooltip]</code>), die der Parser als lokalisierbare Zeichenkettenquellen erkennen soll.",
  "li_content_script_rules_bridge_name": "<strong>Bridge‑Klassenname:</strong> Ermöglicht es Ihnen, den Namen der generierten statischen Klasse festzulegen.",
  "li_content_script_rules_bridges": "<strong>C#‑Brücken generieren:</strong> Erstellt automatisch eine statische Klasse (z. B. <code>AnkoLoc</code>), die typgesicherten Zugriff auf alle Schlüssel bietet, magische Zeichenketten eliminiert und die IDE‑Autovervollständigung ermöglicht.",
  "li_context_1": "<strong>Entwicklerhinweise:</strong> Kommentare aus der Übersetzungstabelle werden als Kontext an die KI weitergegeben.",
  "li_context_2": "<strong>Objektpfad:</strong> Wenn kein Kommentar existiert, wird der Hierarchiepfad des Objekts (z. B. <code>MainMenu/Canvas/StartButton</code>) als Fallback-Kontext verwendet.",
  "li_context_3": "<strong>Glossar:</strong> Sie können ein CSV-Glossar in das Profil laden, um spezifische Übersetzungen für Begriffe und Namen zu erzwingen.",
  "li_context_4": "<strong>Projektbeschreibung:</strong> Beschreibe das Setting und die Zielgruppe deines Spiels, um der KI den allgemeinen Kontext zu vermitteln.",
  "li_context_5": "<strong>Ton & Stil:</strong> Definiere die gewünschte Persona (z. B. 'Freundlich', 'Professionell', 'Piraten') und Formatierungsregeln.",
  "li_context_glossary": "<strong>Wörterbuch-Manager:</strong> Interagiere direkt mit dem Glossar, um Begriffe 'Hinzufügen', 'Bearbeiten' oder 'Entfernen' zu verwalten. Unterstützt Groß-/Kleinschreibung und 'Nicht übersetzen'-Typen.",
  "li_context_optimization": "<strong>Token-Optimierung:</strong> Das System komprimiert den Kontext intelligent und nutzt den Cache wieder, um den Tokenverbrauch und die Kosten zu minimieren.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Eine flexible Implementierung, die mit OpenAI-kompatiblen APIs (einschließlich lokaler LLMs über Ollama) kommunizieren kann.",
  "li_custom_ai_2": "<strong>Vorlagen & Authentifizierung:</strong> Passen Sie die Anfrage vollständig an. <ul><li><strong>Authentifizierung:</strong> Konfigurieren Sie <code>Auth Header Key</code> (z. B. <code>Authorization</code>) und <code>Format</code> (z. B. <code>Bearer {0}</code>). Unterstützt API‑Schlüssel in Abfrageparametern.</li><li><strong>Body‑Vorlage:</strong> Verwenden Sie eine JSON‑Vorlage mit Platzhaltern wie <code>{model}</code> und <code>{prompt}</code> für Text oder <code>{input}</code> und <code>{voice}</code> für Audio.</li><li><strong>Antwortpfad:</strong> Definieren Sie den JSON‑Pfad zum Ergebnis (z. B. <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Integrierte Sicherheitsfunktionen:</strong> Repariert automatisch fehlerhafte Formatierungs-Tags (wie <ph0>), die häufig von KI-Modellen zurückgegeben werden, um zuverlässige und konsistente Übersetzungen zu gewährleisten.",
  "li_custom_parser_1": "Erstellen Sie ein neues C#-Skript im Ordner <strong>Editor</strong> Ihres Projekts.",
  "li_custom_parser_2": "Kopieren Sie die folgende Vorlage hinein.",
  "li_custom_parser_3": "Passen Sie die Logik an Ihre Komponente an.",
  "li_custom_provider_manual_reg": "<strong>Manuelle Registrierung:</strong> Für erweiterte Szenarien (wie DI-Injektion oder Lazy-Init) kannst du deinen Provider manuell über <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> während der Initialisierung registrieren.",
  "li_custom_provider_step_1": "<strong>Implementiere das Interface:</strong> Erstelle eine neue Klasse, die <code>IAssetProvider</code> implementiert. Du musst definieren, wie du Assets mit <code>Load&lt;T&gt;</code> (synchron) und <code>LoadAsync&lt;T&gt;</code> (asynchron) über die API deines Systems lädst.",
  "li_custom_provider_step_2": "<strong>Definiere den Lebenszyklus:</strong> Implementiere <code>Initialize</code>, <code>Dispose</code> und <code>UnloadAll</code>. Diese Methoden werden vom <code>LocalizationManager</code> aufgerufen, wenn die Sprache gewechselt oder Ressourcen bereinigt werden.",
  "li_custom_provider_step_3": "<strong>Sprachsicherheit:</strong> Die Methode <code>SetCurrentLanguage</code> wird aufgerufen, sobald sich die aktive Sprache ändert. Verwende sie, um interne Pfade zu aktualisieren oder Asset-Metadaten erneut abzurufen.",
  "li_custom_provider_step_4": "<strong>Auto-Discovery (Empfohlen):</strong> Dekoriere deine Klasse mit dem Attribut <code>[AssetProviderPlugin]</code>. Dadurch wird dein Provider sofort im Dropdown <strong>Einstellungen-Tab → Asset Loading Strategy</strong> sichtbar.",
  "li_editor_1": "<strong>Intelligente Gruppierung:</strong> Schlüssel für Plurale und Geschlecht (z. B. <code>apple_count_one</code>, <code>apple_count_few</code>) werden automatisch zu einklappbaren Gruppen zusammengefasst.",
  "li_editor_2": "<strong>Erweiterte Bearbeitung:</strong> Klicken Sie auf eine Zelle, um das Popup <strong>MultiLineEditWindow</strong> zu öffnen. Es zeigt den Quelltext zum Vergleich an und validiert Platzhalter.",
  "li_editor_3": "<strong>Erweiterte Auswahl:</strong> Unterstützt flexible Auswahlmodi: einzelne Zellen, ganze Zeilen oder bestimmte Spalten (Sprachen). Verwende <code>Ctrl+Click</code> und <code>Shift+Click</code> für komplexe Auswahlen.",
  "li_editor_4": "<strong>Massenaktionen:</strong> Führe Vorgänge gleichzeitig auf Tausenden von Zellen aus. Rechtsklicke deine Auswahl, um: <ul><li><strong>Auto-Übersetzen:</strong> Fehlende Übersetzungen mit dem aktiven KI-Profil ausfüllen.</li><li><strong>Von Quelle füllen:</strong> Übersetzungen schnell zurücksetzen.</li><li><strong>Sperre umschalten:</strong> 'Perfekte' Übersetzungen vor versehentlichen Überschreibungen schützen.</li><li><strong>Audio generieren:</strong> Stapelverarbeitung von TTS für ausgewählte Phrasen.</li></ul>",
  "li_editor_5": "<strong>Hochleistungs-Navigation:</strong> Der Editor verwendet ein virtualisiertes 'MultiColumnListView' für flüssiges Scrollen mit über 10 k Schlüsseln. Unterstützt Tastaturnavigation (Pfeile/Tab) und leistungsstarke Shortcuts: <code>Ctrl+S</code> (Speichern), <code>Ctrl+Z/Y</code> (Rückgängig/Wiederherstellen), <code>Ctrl+F</code> (Suche fokussieren).",
  "li_editor_6": "<strong>Erweiterte Suchvorgaben:</strong> Prüfe dein Projekt mit spezialisierten Filtern: <ul><li><strong>Status:</strong> Unübersetzt (Aktuell/Jede Sprache), Identisch zur Quelle, Gesperrt.</li><li><strong>Inhalt:</strong> Hat Kommentare, Hat/Fehlende Platzhalter, Hat Längenprobleme (automatisch erkannt).</li><li><strong>Struktur:</strong> Pluralisiert, Geschlechtsspezifisch oder beides.</li><li><strong>Audio:</strong> Fehlendes Audio, Veraltet (Hash‑Mismatch).</li></ul>",
  "li_editor_7": "<strong>Intelligentes Audio-Management:</strong> Verfolgt die 'Frische' deiner TTS-Dateien. Wenn du den Übersetzungstext bearbeitest, erscheint ein <strong>Gelber Indikator (Veraltet)</strong>, der anzeigt, dass der Audio-Datei‑Hash nicht mehr zum Text passt. Ein Klick regeneriert nur die veralteten Dateien.",
  "li_editor_8": "<strong>Sperrmechanismus:</strong> Erklärung: <ul><li><strong>Gesperrte Zellen/Zeilen:</strong> Verhindert jede Änderung durch <strong>Auto-Übersetzen</strong>, <strong>CSV/Google-Import</strong> oder <strong>Von Quelle füllen</strong>.</li><li><strong>Anwendungsfall:</strong> Sperre 'Goldene' Übersetzungen, die manuell von Muttersprachlern verifiziert wurden.</li><li><strong>Massenkontrolle:</strong> Sperre gesamte Sprachen oder bestimmte Features (wie Charakternamen) projektweit.</li></ul>",
  "li_editor_layout": "<strong>Dynamisches Multi-Pane-Layout:</strong> Verwende das 3‑Paneel‑System, um 'feste' Spalten (wie Schlüssel) links zu fixieren, während du in der Mitte durch 20+ Sprachen scrollst. Schalte die Sichtbarkeit von Spalten über das Kontextmenü der Kopfzeile um.",
  "li_editor_regex": "<strong>Regex-Suche:</strong> Sowohl das Hauptfenster als auch der Tabelleneditor unterstützen <strong>reguläre Ausdrücke</strong>. Wenn deine Anfrage Symbole wie <code>* + ? ^ $ [ ] ( ) { } | .</code> enthält, wird sie automatisch als Regex behandelt (z. B. <code>^item_.*</code>, um alle Schlüssel zu finden, die mit 'item_' beginnen).",
  "li_editor_structure": "<strong>Tabellen & Gruppen:</strong> Daten werden in Tabellen (Dateien) organisiert und im Editor als Gruppen (Ordner) angezeigt, um die Navigation zu verbessern.",
  "li_editor_ui_test": "<strong>Eingebauter UI-Test:</strong> <ul><li><strong>Längen‑Erweiterungs‑Slider:</strong> Simuliere Textexpansion (0 % - 100 %), um zu sehen, wie deine UI längere Sprachen wie Deutsch oder Russisch ohne Verlassen des Editors handhabt.</li><li><strong>Rich‑Text‑Renderer:</strong> Schalte die Darstellung von Tags (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) um, um das Styling zu überprüfen, ohne das Spiel zu starten.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Eine vorgefertigte Komponente zum Erstellen einer UI-Dropdown-Liste für den Sprachwechsel. Sie findet automatisch alle verfügbaren Sprachen und verwaltet deren Umschaltung.<br><strong>Anwendung:</strong> Fügen Sie die Komponente <code>LanguageSelector</code> einfach Ihrer Szene hinzu (z. B. auf einem leeren GameObject) und geben Sie Ihre <code>TMP_Dropdown</code> im Inspektor an.",
  "li_example_components_2": "<strong>Code-Beispiele:</strong> Um erweiterte Techniken wie die Arbeit mit <code>[LocalizableField]</code>, der <code>_()</code>-Funktion, Pluralen und Geschlecht zu erlernen, studieren Sie die Dateien <code>StatPurchaseTest.cs</code> und <code>TestLocalization.cs</code>. Sie demonstrieren klar die Implementierung aller Hauptfunktionen des Tools im Code.",
  "li_example_components_new": "<strong>Neu (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Gibt <code>IEnumerator</code> zurück. Muss gewartet werden.",
  "li_example_components_old": "<strong>Alt:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (synchroner void) - <strong>Veraltet</strong>. Verwende die Coroutine-Version.",
  "li_feature_1": "<strong>Erweitertes Parsing:</strong> Automatisches Scannen von Szenen, Prefabs, UI Toolkit (UXML) und C#-Skripten, einschließlich Feldern, die mit dem Attribut <code>[LocalizableField]</code> markiert sind, sowie verschachtelten Klassen und Listen.",
  "li_feature_10": "<strong>Backup-Manager:</strong> Ein integriertes Tool zum Erstellen und Wiederherstellen von Backups.",
  "li_feature_11": "<strong>KI-gestützt:</strong> Unterstützung für OpenAI, Anthropic (Claude), Google Gemini und lokale LLMs (Ollama) über anpassbare Profile.",
  "li_feature_12": "<strong>Text-to-Speech (TTS):</strong> Generierung von Audiodateien für lokalisierte Zeichenketten mithilfe von KI (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Migrationstools:</strong> Tools für den automatischen Übergang von I2 Localization- und Unity Localization-Plugins.",
  "li_feature_14": "<strong>Font & Glyph Manager:</strong> Tool zur Analyse verwendeter Zeichen und zum Auffinden fehlender Glyphen in Schriftarten.",
  "li_feature_15": "<strong>Visuelles Debugging:</strong> Symbole in der Hierarchie und Beschriftungen in der Szenenansicht zur schnellen Fehlerbehebung.",
  "li_feature_2": "<strong>Lokalisierung beliebiger Assets:</strong> Verwalten Sie Sprites, Audio, Prefabs, Materialien usw.",
  "li_feature_3": "<strong>Leistungsstarker Übersetzungseditor:</strong> Eine zentrale Oberfläche mit automatischem Speichern, voller Undo/Redo-Unterstützung, intelligenter Schlüsselgruppierung und Mehrfachauswahl-Aktionen.",
  "li_feature_4": "<strong>KI & Maschinelle Übersetzung:</strong> Profilsystem, das DeepL, Google, Microsoft und <strong>benutzerdefinierte KI (OpenAI, Gemini, Claude, Ollama)</strong> mit Kontextbewusstsein unterstützt.",
  "li_feature_5": "<strong>Flexibler Import/Export:</strong> Unterstützung für CSV, XML, YAML, XLIFF und direkten Import aus Google Sheets.",
  "li_feature_6": "<strong>Live-Vorschau:</strong> Zeigen Sie jede Sprache in der Szenenansicht oder im <strong>Prefab-Modus</strong> an, ohne das Spiel zu starten.",
  "li_feature_7": "<strong>Plural‑ und Geschlechtsunterstützung:</strong> Vollständige CLDR‑Unterstützung (v43). Enthält Regeln für <strong>Asiatisch</strong> (Keine), <strong>Englisch/Germanisch</strong> (Einzahl, Mehrzahl), <strong>Französisch</strong> (Einzahl 0‑1), <strong>Slawisch</strong> (Einzahl, Wenige, Viele – RU, UK, PL), <strong>Arabisch</strong>, <strong>Keltisch</strong>, <strong>Baltisch</strong> (LT, LV) und mehr.",
  "li_feature_8": "<strong>Volle RTL-Unterstützung:</strong> Korrekte Anzeige von Sprachen, die von rechts nach links geschrieben werden.",
  "li_feature_9": "<strong>Live-Updates:</strong> Laden Sie aktuelle Übersetzungen von einem Remote-Server beim Spielstart.",
  "li_feature_tool_translation": "<strong>Vollständig übersetzte UI:</strong> Die Oberfläche des Tools ist lokalisierbar. Du kannst die Editor‑Sprache über das Dropdown im <strong>Kopfbereich des Hauptfensters</strong> umschalten.",
  "li_font_global": "<strong>Globaler Bericht:</strong> Erstellt einen Bericht über alle fehlenden Glyphen in allen Sprachen.",
  "li_font_glyph_analyze": "Analysiert alle Übersetzungen und prüft, ob die zugewiesene Schriftart (TMP_FontAsset) alle verwendeten Zeichen unterstützt.",
  "li_font_glyph_copy": "Ermöglicht das Kopieren aller eindeutigen Sprachzeichen für die Font‑Atlas‑Erstellung. Enthält <strong>Filter zum Ausschließen von ASCII, Zahlen und Satzzeichen</strong>, um Texturplatz zu optimieren.",
  "li_font_glyph_missing": "Zeigt eine Liste fehlender Glyphen an.",
  "li_font_glyph_workflow": "<strong>Workflow für TMP:</strong> 1. Scan ausführen. 2. Eine Sprache mit fehlenden Glyphen auswählen. 3. Auf <strong>'Copy Character Set'</strong> klicken. 4. Window -> TextMeshPro -> Font Asset Creator öffnen. 5. Den Inhalt der Zwischenablage in das Feld 'Character Sequence (Custom Range)' einfügen, um einen Atlas zu generieren, der genau die Zeichen enthält, die Ihr Spiel benötigt.",
  "li_font_unicode": "<strong>Unicode‑Bereiche:</strong> Zeige die spezifischen Unicode‑Bereiche, die in deinen Übersetzungen verwendet werden (z. B. Basic Latin, Kyrillisch), um Font‑Assets zu optimieren.",
  "li_footer_status": "<strong>Status & Fortschritt:</strong> Echtzeit‑Feedback zu Parsing‑, Import‑ oder KI‑Generierungsaufgaben.",
  "li_header_lang_selector": "<strong>Editor‑Sprache:</strong> Wechseln Sie die Sprache der Werkzeugoberfläche. Die Werkzeug‑UI ist vollständig lokalisierbar.",
  "li_header_preview_btn": "<strong>Vorschau‑Umschalter:</strong> Aktivieren oder deaktivieren Sie schnell die Vorschau im Editor. Verwenden Sie die Schaltfläche 'Zurücksetzen', um die ursprünglichen Szenenwerte wiederherzustellen.",
  "li_header_toolbar_buttons": "<strong>Globale Symbolleiste:</strong> Direkter Zugriff auf Dokumentation, Discord, Einstellungs‑Asset, Abhängigkeits‑Checker und Bewertungsseite.",
  "li_install_1": "<strong>WICHTIG (v2.0 Update):</strong> Beim Upgrade von v1.x musst du den alten `Ankonoanko`‑Ordner <strong>löschen</strong> bevor du importierst. Version 2.0 erfordert eine saubere Installation wegen Namensraum‑Änderungen.",
  "li_install_2": "Das Tool überprüft automatisch die notwendigen Abhängigkeiten. Bestätigen Sie die Installation in dem erscheinenden Dialogfeld.",
  "li_install_3": "Erforderliche Abhängigkeiten (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) sind für die grundlegende Funktionalität notwendig.",
  "li_install_4": "Optionale Abhängigkeiten (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) ermöglichen zusätzliche Funktionen.",
  "li_install_5": "Klicken Sie auf <strong>Install Selected</strong>, um die empfohlenen Pakete zu installieren.",
  "li_install_6": "Öffnen Sie nach der Installation das Haupttool-Fenster über das Menü <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Wenn Sie die asynchrone Asset-Ladung verwenden möchten, installieren Sie das <strong>Addressables</strong>-Paket über den Paket-Manager.",
  "li_live_updates_1": "<strong>Aktivieren:</strong> In den Einstellungen das Häkchen bei 'Live‑Updates aktivieren' setzen.",
  "li_live_updates_2": "<strong>Quelle:</strong> Gib eine <code>Live Update URL</code> an, die ein JSON‑Wörterbuch zurückgibt, oder eine <code>Google‑Sheet‑URL</code>.",
  "li_live_updates_3": "<strong>Cache:</strong> Übersetzungen werden lokal unter <code>liveUpdateCachePath</code> zwischengespeichert, um sicherzustellen, dass das Spiel offline funktioniert.",
  "li_live_updates_4": "<strong>Sicherheit:</strong> Verwende den <strong>Runtime‑API‑Schlüssel</strong> (verschlüsselt), falls dein Server Authentifizierung benötigt.",
  "li_localizedtext_1": "<code>localizationKey</code>: Der Schlüssel, der verwendet wird, um die Übersetzung zu finden. Kann automatisch generiert oder manuell zugewiesen werden.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Wenn <code>true</code>, wendet die Komponente nur Stile (Schrift, RTL) an, ändert jedoch nicht den eigentlichen Text. Kritisch für dynamische Textelemente (z. B. Text, der über `_()`‑Aufrufe in Skripten aktualisiert wird).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Der Originaltext in der Basissprache. Wird als Fallback verwendet.",
  "li_localizedtext_key_override": "<strong>Manuelle Schlüssel‑Überschreibung:</strong> Sie können das 'Bearbeiten'-Symbol neben dem Schlüssel anklicken, um manuell einen Schlüssel einzugeben. Verwenden Sie 'X', um zur automatischen Generierung zurückzukehren. Dies funktioniert für <code>LocalizedText</code>, <code>LocalizedDropdown</code> (für jede Option einzeln) und <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>In Tabelle suchen:</strong> Klicke das Lupen‑Symbol, um sofort die Übersetzungstabelle zu öffnen und auf diesen spezifischen Schlüssel zu fokussieren.",
  "li_migration_csv_details_1": "<strong>Intelligente Filterung:</strong> Der Importer überspringt automatisch Zeilen, die wie Asset‑Pfade aussehen (z. B. <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>), um deine Textdatenbank sauber zu halten.",
  "li_migration_csv_details_2": "<strong>'Typ'-Spalte:</strong> Wenn eine 'Typ'-Spalte existiert (I2‑Format), werden nur Zeilen, die als 'Text' markiert sind oder keinen Typ haben, importiert. Um Assets zu importieren, verwende die Migrationsprofile, um sie auf <code>LocalizedAsset</code> zuzuordnen.",
  "li_migration_csv_req_1": "<strong>Schlüssel‑Spalte:</strong> Muss <code>Key</code> (Groß-/Kleinschreibung ignorierend) heißen oder in deinem Migrationsprofil definiert sein.",
  "li_migration_csv_req_2": "<strong>Sprachspalten:</strong> Jede Spalte, die nicht als ignoriert markiert ist, wird als Sprachcode behandelt (z. B. 'en', 'ja', 'English'). Das Tool versucht, diese unscharf mit den Sprachen deines Projekts abzugleichen.",
  "li_migration_csv_req_3": "<strong>Kommentare:</strong> Spalten mit den Namen <code>Desc</code>, <code>Description</code> oder <code>Comment</code> werden als Entwickler‑Notizen importiert. Diese Liste ist im <strong>Migrationsprofil</strong> konfigurierbar.",
  "li_migration_custom_1": "Rechtsklick im Projekt‑View → Erstellen → Anko Localization → Migrationsprofil.",
  "li_migration_custom_2": "<strong>Regeln:</strong> Definieren Sie Konvertierungsregeln (wenn [Quell‑Komponente] mit [Kontext‑Filter], dann konvertiere zu [Ziel‑Komponente]). Regeln unterstützen <strong>Priorität</strong> (höhere Zahlen werden zuerst verarbeitet), <strong>Assets ernten</strong> (referenzierte Assets wie Sprites oder Audio automatisch extrahieren und registrieren) und <strong>Kontext‑Filterung</strong>, um zwischen mehreren Komponenten am selben Objekt zu unterscheiden.",
  "li_migration_fallback_keys": "<strong>Fallback‑Schlüsselfelder:</strong> Zusätzliche Feldnamen angeben, die beim Extrahieren von Schlüsseln aus Legacy‑Komponenten geprüft werden sollen. Nützlich, wenn Ihr altes System nicht‑standardisierte Eigenschaftsnamen für Schlüssel verwendet.",
  "li_migration_gs_1": "<strong>Zugriff:</strong> Das Blatt muss geteilt sein ('Jeder mit dem Link kann es ansehen') oder im Web veröffentlicht werden.",
  "li_migration_gs_2": "<strong>Tab‑Blätter (GID):</strong> Die URL muss den Parameter <code>gid=...</code> enthalten. Das teilt dem Tool genau mit, welches Tab gelesen werden soll (z. B. <code>gid=0</code> ist normalerweise das erste Tab/Blatt).",
  "li_migration_ignored_headers": "<strong>Ignorierte CSV‑Header:</strong> Spalten definieren, die beim Import übersprungen werden sollen (z. B. 'Type', 'Description'). Dadurch wird verhindert, dass das Tool Metadaten‑Spalten als Sprachdaten behandelt.",
  "li_migration_legacy_components": "<strong>Zusätzliche Legacy‑Komponenten:</strong> Komponenten‑Namen manuell auflisten, die das Tool während des Migrations‑Scans als 'legacy' erkennen soll, selbst wenn keine direkte Konvertierungsregel definiert ist.",
  "li_migration_profile_details": "<strong>Erweiterte Profileinstellungen:</strong><ul><li><code>CsvKeyHeader</code>: Der Header‑Name für die Schlüsselspalte.</li><li><code>CsvCommentHeaders</code>: Liste von Headern, die als Entwickler‑Notizen/Kommentare behandelt werden.</li><li><code>IgnoredCsvHeaders</code>: Spalten, die übersprungen werden (Metadaten wie 'Type' oder 'Status'), um zu verhindern, dass sie als Sprachen behandelt werden.</li><li><code>AssetExtensions</code>: Dateitypen, die beim Scannen als Assets erkannt werden.</li><li><code>FallbackKeyFields</code>: Zusätzliche Feldnamen, die geprüft werden, wenn das primäre Schlüssel‑Feld leer ist.</li></ul>",
  "li_migration_rule_fields": "<strong>Regelkonfiguration:</strong><ul><li><code>Priority</code>: Höhere Werte werden zuerst verarbeitet. Verwenden Sie dies, um spezifische Fälle vor generischen zu behandeln.</li><li><code>Context Filter</code>: Wenden Sie die Regel nur an, wenn eine bestimmte Komponente (z. B. <code>Text</code>) am selben Objekt vorhanden ist.</li><li><code>Harvest Assets</code>: Wenn aktiviert, extrahiert das aktuelle Asset (z. B. Sprite) aus der alten Komponente und registriert es in der Asset‑Tabelle.</li><li><code>Asset Field Path</code>: Pfad zum Feld, das die Asset‑Referenz für das Ernten enthält.</li><li><code>Additional Data Path</code>: Wird für komplexe Komponenten wie Dropdowns verwendet, um mehrere Werte/Optionen zu ernten.</li></ul>",
  "li_migration_stubs_1": "<strong>Problem:</strong> Du löschst die alten Plugin‑Assets. Unity erkennt fehlende Skripte (z. B. fehlende <code>Localize</code>-Komponente). Der Editor wechselt in den Kompilierungs‑Fehlermodus.",
  "li_migration_stubs_2": "<strong>Lösung:</strong> Die 'Emergency Stubs'-Funktion erzeugt leichte, leere Klassen mit exakt denselben Namen und Namespaces wie das alte Plugin. Das erfüllt den Compiler.",
  "li_migration_stubs_3": "<strong>Ablauf:</strong> 1. Klicken Sie auf <strong>Notfall‑Stubs aktivieren</strong> (dies fügt <code>ANKO_ENABLE_MIGRATION_STUBS</code> zu Ihren Projekteinstellungen hinzu). 2. Löschen Sie den alten Plugin‑Ordner. 3. Unity kompiliert erfolgreich neu unter Verwendung von Dummy‑Klassen. 4. Führen Sie den <strong>Component Converter</strong> aus, um Stubs durch offizielle Komponenten zu ersetzen. 5. Klicken Sie auf <strong>Stubs deaktivieren</strong>, sobald die Refaktorierung abgeschlossen ist.",
  "li_migration_tool_converter": "<strong>Schritt 2: Komponentenkonverter:</strong> Scannen Sie Szenen und Prefabs. Ersetzt automatisch alte Komponenten (z. B. <code>Localize</code>) durch <code>LocalizedText</code> / <code>LocalizedAsset</code> und überträgt Schlüssel.",
  "li_migration_tool_fields": "<strong>Profileinstellungen:</strong> Konfigurierbare 'Source Plugin'-Typen und 'Asset Mapping'-Regeln gewährleisten die korrekte Übertragung von Texturen und Audio.",
  "li_migration_tool_import": "<strong>Schritt 1: Datenimport:</strong> Importieren Sie CSV (I2) oder XLIFF (Unity Loc) Dateien, um eine Schlüsseldatenbank zu erstellen.",
  "li_migration_tool_profiles": "<strong>Migrationsprofile:</strong> Erstelle benutzerdefinierte Profile, um Assets und Einstellungen von Drittanbieter-Plugins (I2, Unity Loc) zuzuordnen.",
  "li_migration_tool_safemode": "<strong>Sicherer Modus & Notfall‑Stubs:</strong> Komponenten werden deaktiviert statt gelöscht. Enthält die kritische Notfall‑Stubs‑Funktion (aktiviert über das <code>ANKO_ENABLE_MIGRATION_STUBS</code>-Define‑Symbol): erzeugt gefälschte Platzhalterklassen für I2 Localization oder Unity Localization, sodass Ihr Projekt sofort nach dem Entfernen dieser Plugins kompiliert. Dies verhindert Fehler wie \"Der Typname 'Localize' konnte nicht gefunden werden\" und gibt Ihnen Zeit, Ihren Code korrekt zu refaktorisieren, um das neue System zu nutzen. „Stubs aktivieren“ ermöglicht es Ihnen, Kompilierungsfehler nach dem Löschen des alten Lokalisierungs‑Plugins zu beheben.",
  "li_migration_tool_setup": "<strong>Schritt 0: Setup:</strong> Konfigurieren Sie Komponentennamen (z. B. <code>Localize</code> für I2) und Felder, in denen der Schlüssel gespeichert ist. Presets sind verfügbar.",
  "li_migration_workflow_1": "<strong>1. Sicherung:</strong> Committe dein Projekt in die Versionskontrolle (Git) oder erstelle ein Dateibackup, bevor du beginnst.",
  "li_migration_workflow_2": "<strong>2. Stubs aktivieren:</strong> Öffne das Migration Tool → Reiter 'Safe Mode'. Klicke <strong>Enable Emergency Stubs</strong> für dein Zielsystem (I2/UnityLoc). Dies erzeugt leichte Fake-Klassen in deinem Projekt.",
  "li_migration_workflow_3": "<strong>3. Altes Plugin entfernen:</strong> Lösche den alten Plugin-Ordner (z.B. 'Assets/Plugins/I2'). Unity kompiliert neu. Dank der Stubs bekommst du <strong>NICHT</strong> den Fehler 'Typ nicht gefunden', wodurch alle Komponentenreferenzen auf Prefabs erhalten bleiben.",
  "li_migration_workflow_4": "<strong>4. Daten importieren:</strong> Im Reiter 'Import Data' lade deine Quell-CSV/XLIFF. Überprüfe die Vorschau und klicke <strong>Import</strong>. Dies füllt die AnKo-Übersetzungstabellen.",
  "li_migration_workflow_5": "<strong>5. Komponenten konvertieren:</strong> Im Reiter 'Component Converter' wähle 'Entire Project' und klicke <strong>Scan & Convert</strong>. Das Tool ersetzt alte Stubs durch 'LocalizedText'/'LocalizedAsset'-Komponenten und überträgt die Schlüssel.",
  "li_migration_workflow_6": "<strong>6. Aufräumen:</strong> Wenn alles funktioniert, klicke <strong>Disable Stubs</strong> und lasse Unity erneut kompilieren.",
  "li_notes_1": "<strong>Backups:</strong> Erstellen Sie immer ein Backup über <strong>Translation Table Editor -> Manage Backups</strong>, bevor Sie größere Änderungen vornehmen. Backups werden im Ordner <code>LocalizationBackups</code> **im Projektstammverzeichnis (außerhalb des Assets-Ordners)** gespeichert, um Ihr Unity-Projekt sauber zu halten und die Importzeiten zu reduzieren.",
  "li_notes_2": "<strong>API-Schlüsselsicherheit:</strong> Der Schlüssel für die Arbeit im Editor wird lokal auf Ihrem Computer gespeichert (in <code>EditorPrefs</code>) und gelangt nicht in das Repository. Für Schlüssel, die im Spiel-Build benötigt werden, verwenden Sie den Abschnitt <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong><code>StreamingAssets</code> Ordner:</strong> Übersetzungsdateien müssen sich in einem Unterordner von <code>Assets/StreamingAssets/</code> befinden, um in den Spiel-Build aufgenommen zu werden.",
  "li_notes_4": "<strong>„Idiotensicherheit“:</strong> Das Tool schützt Sie automatisch davor, temporäre Daten aus dem Vorschaumodus versehentlich in einer Szene oder einem Prefab zu speichern.",
  "li_notes_5": "<strong>Leistung:</strong> Der <code>_()</code>-Aufruf ist schnell, aber in Schleifen, die in jedem Frame ausgeführt werden (z. B. in <code>Update</code>), versuchen Sie, das Ergebnis in einer Variablen zwischenzuspeichern.",
  "li_notes_6": "<strong>Ausschließen von <code>LanguageSelector</code> vom Parsing:</strong> Das Objekt mit der Komponente <code>LanguageSelector</code> und sein <code>TMP_Dropdown</code> müssen zur Liste <strong>Ignore Specific Objects</strong> im Tab <strong>Content</strong> hinzugefügt werden. Dies ist notwendig, um zu verhindern, dass der Parser zusätzliche Schlüssel für die Dropdown-Optionen erstellt, da das <code>LanguageSelector</code>-Skript diese zur Laufzeit dynamisch füllt. Das Ignorieren verhindert Konflikte und hält die Übersetzungsdateien sauber.",
  "li_notes_7": "<strong>Schriftarten für <code>LanguageSelector</code>:</strong> Damit die ausgewählte Sprache im <code>TMP_Dropdown</code> ihre Schriftart korrekt aktualisiert, fügen Sie dem untergeordneten <strong>Label</strong>-Objekt des Dropdown manuell eine leere <code>LocalizedText</code>-Komponente hinzu und aktivieren Sie das Kontrollkästchen <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Code & Addressables:</strong> Wenn Sie in den Modus <strong>Addressables (Async)</strong> wechseln, **MÜSSEN** Sie <code>GetLocalizedAssetAsync<T>()</code> in Ihren Skripten verwenden. Der Aufruf des synchronen <code>GetLocalizedAsset<T>()</code> gibt null zurück und protokolliert eine Warnung, um das Einfrieren des Hauptthreads zu verhindern.",
  "li_notes_addressables_sync_warning": "<strong>Sync vs Async:</strong> Wenn Sie in den Modus <strong>Addressables (Async)</strong> wechseln, **MÜSSEN** Sie Ihren Code aktualisieren, um <code>GetLocalizedAssetAsync<T>()</code> zu verwenden. Der Aufruf der synchronen Methode gibt null zurück und protokolliert eine Warnung, um das Einfrieren des Hauptthreads zu vermeiden.",
  "li_preview_1": "<strong>Funktionsweise:</strong> Wählen Sie eine Sprache aus der Liste, und das Tool wendet sofort die entsprechenden Übersetzungen, Schriftarten, RTL-Einstellungen und Assets auf alle lokalisierbaren Objekte in der aktiven Szene oder dem geöffneten Prefab an.",
  "li_preview_2": "<strong>Platzhalter:</strong> Wenn im Tab <strong>Settings</strong> ein Platzhalterstil (z. B. <strong>Accents</strong> oder <strong>Brackets</strong>) ausgewählt ist, werden diese Platzhalter im Vorschaumodus anstelle der tatsächlichen Übersetzungen angezeigt. Dies ist ideal zum Testen des Layouts und zum Auffinden nicht lokalisierter Elemente.",
  "li_preview_3": "<strong>Sicherheit:</strong> Alle im Vorschaumodus vorgenommenen Änderungen sind temporär. Das Tool setzt automatisch alles in den Originalzustand zurück, wenn Sie „<strong>Revert to Original</strong>“ auswählen, das Fenster schließen, die Szene wechseln oder bevor eine Szene/ein Prefab gespeichert wird (dank der Komponente <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Absturzsicherung:</strong> Das System sichert den Szenenzustand automatisch im Ordner <code>Library</code>, bevor eine Vorschau angezeigt wird. Wenn Unity abstürzt oder Sie es während der Vorschau zwangsweise beenden, erkennt das Tool die Wiederherstellungsdatei beim nächsten Start und bietet an, den ursprünglichen Szenenzustand wiederherzustellen.",
  "li_preview_overlay_1": "<strong>Zugriff:</strong> Das Overlay erscheint automatisch in der Szenenansicht. Du kannst es über das Unity Overlay-Menü (<code>Space</code>-Taste in der Szenenansicht) umschalten.",
  "li_preview_overlay_2": "<strong>Funktionalität:</strong> Bietet ein Dropdown, um die aktuelle Vorsprache-Sprache schnell zu wechseln, ohne das Hauptfenster zu öffnen.",
  "li_report_1": "<strong>Kategorien:</strong> Alle Schlüssel, Hinzugefügt, Aktualisiert (Text geändert), Entfernt, Duplikate, Migriert, Übersprungen (unverändert).",
  "li_report_2": "<strong>Erweiterte Suche:</strong> Klicken Sie neben einem beliebigen Eintrag auf die Schaltfläche <strong>Find</strong>, um das entsprechende Objekt im Projekt sofort zu finden. Die Suche funktioniert asynchron, blockiert den Editor nicht und durchsucht alle Szenen und Prefabs.",
  "li_report_all_keys": "<strong>Alle Schlüssel:</strong> Eine Liste aller im Projekt erkannten Lokalisierungsschlüssel mit Such‑ und Filteroptionen.",
  "li_report_btn_clear": "<strong>Bericht löschen:</strong> Entfernt alle Scan‑Ergebnisse aus dem Speicher der aktuellen Sitzung.",
  "li_report_btn_copy_all": "<strong>Alle Schlüssel kopieren:</strong> Kopiert alle Lokalisierungsschlüssel der aktuellen Kategorie in die System‑Zwischenablage.",
  "li_report_btn_load_last": "<strong>Letzten Scan laden:</strong> Stellt sofort die Ergebnisse der letzten Projektanalyse wieder her, ohne erneut zu scannen.",
  "li_report_btn_save": "<strong>Bericht speichern:</strong> Exportiert die aktuellen Scan‑Ergebnisse in eine Text- oder CSV-Datei für externe Dokumentation oder Audits.",
  "li_report_source_filter": "<strong>Quell‑Filter:</strong> Eingrenzen der Ergebnisse nach ihrer Herkunft (z. B. nur Schlüssel anzeigen, die in Skripten, Szenen oder Prefabs gefunden wurden).",
  "li_safety_global_limit": "<strong>Globales monatliches Limit:</strong> Der <code>monthlyCharLimit</code> (Standard: 500.000 Zeichen) fungiert als Sicherungsmechanismus für alle Anfragen. Warnungen können über <code>enableApiLimitWarning</code> ein- bzw. ausgeschaltet werden.",
  "li_safety_profile_limit": "<strong>Profilgrenzen:</strong> Jedes Übersetzungsprofil ermöglicht das Festlegen von eigenem 'Max Chars Per Request' und 'Batch Size'.",
  "li_settings_1": "<strong>Schlüssel‑Generierungsmodus:</strong><ul><li><code>AutoGenerateKeysOnly</code> <strong>(Standard – Empfohlen)</strong>: Generiert Schlüssel basierend auf Szenen‑/Prefab‑Name und Objekt‑Hierarchie (z. B. <code>scene_Menu_BtnPlay_682412</code>). Ideal für große Projekte, da es Eindeutigkeit garantiert und gegenüber Textänderungen immun ist.</li><li><code>UseTextAsKey</code>: Verwendet den Quelltext selbst als Schlüssel (z. B. \"Start Game\" → <code>Start Game</code>). Ideal für schnelles Prototyping, bei dem Schlüssel lesbar sein sollen.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Hybrid)</strong>: Der flexibelste Modus. Er prüft zuerst, ob eine Komponente bereits einen manuell zugewiesenen Schlüssel oder ein <code>[LocalizableField(key=\"...\")]</code> hat. Wenn kein Schlüssel vorhanden ist, wird ein hierarchischer Schlüssel generiert. <em>Verwenden Sie dies, um bestehende Arbeit zu erhalten und gleichzeitig neue Inhalte zu automatisieren.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Hybrid)</strong>: Wie oben, fällt jedoch auf den Text zurück, wenn kein manueller Schlüssel gefunden wird. Respektiert bestehende Komponenten und Daten.</li><li><code>Manual</code>: Der Scanner erstellt niemals neue Schlüssel. Er aktualisiert nur Objekte, die bereits eine Lokalisierungskomponente mit einem Schlüssel besitzen. Perfekt für strenge manuelle Kontrolle.</li></ul>",
  "li_settings_10": "<strong>Dev Tools:</strong> Am unteren Rand des Settings-Tabs finden Sie Dienstprogramm-Schaltflächen wie <strong>Clear Saved Language Pref</strong> (setzt die gespeicherte Sprache in PlayerPrefs zurück, sodass das Spiel wieder mit der Standardsprache startet).",
  "li_settings_11": "<strong>Technische Dropdown-Optionen:</strong> Eine Liste von Zeichenkettenwerten (Standard: 'Option A', 'Option B', 'Option C'), die der Parser beim Scannen von Dropdowns **ignoriert**. Dadurch bleibt Ihre Übersetzungstabelle frei von Unitys Standard-UI-Platzhaltertext.",
  "li_settings_2": "<strong>Language Management:</strong><ul><li><strong>Source Language:</strong> Die Sprache, die in Ihren Unity-Szenen/Prefabs verwendet wird (Entwicklungssprache).</li><li><strong>Default Language:</strong> Die Sprache, die beim ersten Spielstart ausgewählt wird, wenn die Systemsprache des Benutzers nicht unterstützt wird.</li><li><strong>Liste:</strong> Verwalten Sie unterstützte Sprachen, weisen Sie spezifische <strong>Font Assets</strong> zu und aktivieren Sie die <strong>RTL</strong>-Unterstützung.</li></ul>",
  "li_settings_3": "<strong>Allgemeine Einstellungen:</strong><ul><li><code>Translations Save Path</code>: Das Stammverzeichnis zum Speichern von <code>.json</code>-Übersetzungsdateien. Für den Zugriff im Spiel muss es sich innerhalb von <code>Assets/Resources</code> oder <code>Assets/StreamingAssets</code> befinden.</li><li><code>Safe Mode</code>: Eine Schutzschicht, die Vorgänge (wie Auto‑Translate) blockiert, wenn Projektinkonsistenzen oder fehlende Abhängigkeiten erkannt werden.</li><li><code>Remove Missing Keys</code>: Wenn aktiviert, löscht der Scanner automatisch Einträge aus der Datenbank, die in keiner Szene oder keinem Prefab mehr vorhanden sind, während das Projekt aktualisiert wird.</li><li><code>Parse Inactive Objects</code>: Bestimmt, ob das Werkzeug deaktivierte oder versteckte <code>GameObject</code>s scannen und lokalisieren soll.</li><li><code>Parse All Prefabs</code>: Scannt jedes Prefab im Projekt. Wenn deaktiviert, werden nur Prefabs in den im Reiter <strong>Content</strong> angegebenen Ordnern verarbeitet.</li><li><code>Fill Comments By Paths</code>: Füllt das Feld 'Comment' in der Übersetzungstabelle automatisch mit dem Szenen‑/Prefab‑Hierarchiepfad des Objekts.</li><li><code>Split Files by Language</code>: Teilt die Übersetzungsdatenbank in mehrere Dateien (z. B. <code>en.json</code>, <code>ja.json</code>). Sehr empfehlenswert für große Projekte, um den Laufzeit‑Speicherverbrauch zu reduzieren.</li><li><code>Allow Empty Source/Keys</code>: Erlaubt dem Werkzeug, Objekte zu registrieren und zu verfolgen, selbst wenn ihr Quelltext leer ist. Nützlich für dynamischen Text, der ausschließlich per Code gesetzt wird.</li><li><code>Attach to Regex-Ignored Text</code>: Zwingt das Werkzeug, Lokalisierungskomponenten zu Objekten hinzuzufügen, deren Text einem Ausschluss‑Regex (z. B. Zahlen) entspricht, um manuelle Überschreibung zu ermöglichen.</li><li><code>Find Settings Asset</code>: Eine Hilfsschaltfläche, die sofort die Datei <code>LocalizationSettings.asset</code> im Projektfenster anpingt und auswählt.</li></ul>",
  "li_settings_4": "<strong>Debugging & Testen:</strong><ul><li><code>Placeholder Style</code>: Wählen Sie den Stil für die Anzeige von Platzhaltern im Vorschaumodus.</li><li><code>Pseudo-Localization</code>: Wählen Sie <strong>'Custom Pseudo'</strong>, um erweiterte Layout‑Testeinstellungen (Expansionsfaktor, Akzente und Trennzeichen) anzuzeigen.</li></ul>",
  "li_settings_5": "<strong>Live Updates:</strong> Einstellungen zum Laden von Übersetzungen von einem Remote-Server.",
  "li_settings_6": "<strong>Runtime-API-Schlüssel:</strong> Speichert deinen API-Schlüssel für <strong>Live Updates</strong> (Abrufen neuer Übersetzungen im Spiel) sicher. Dies unterscheidet sich von den Übersetzungsservice‑Schlüsseln, die im Editor verwendet werden. Der Schlüssel ist im Build <strong>obfuskiert</strong> (verschlüsselt), um eine einfache Extraktion per String‑Suche zu verhindern, aber denke daran: kein clientseitiges Geheimnis ist zu 100 % sicher.",
  "li_settings_7": "<strong>Asset‑Lade‑Strategie:</strong> Wahl zwischen <code>Resources (Legacy)</code>, <code>Addressables (Async)</code> und <code>Custom</code>. Warnung: Das Ändern dieses Modus erfordert einen Projekt‑Neuscan. Der Addressables‑Modus wird für Mobile und WebGL dringend empfohlen, um den Speicherverbrauch zu reduzieren.",
  "li_settings_8": "<strong>Auto‑Übersetzung:</strong><ul><li><code>Text & Audio Profiles</code>: Wählen oder erstellen Sie ScriptableObject‑Profile, um verschiedene Dienste (z. B. OpenAI, DeepL, Google) zu konfigurieren.</li><li><code>Presets Folder</code>: Das Verzeichnis, in dem Ihre Übersetzungsvorlagen und -profile gespeichert werden.</li><li><code>Target Languages</code>: Eine Liste aller Projektsprachen mit Echtzeit‑Status, Fortschrittsbalken und Zeichenanzahl für das ausgewählte Profil.</li><li><code>Start Auto Translation</code>: Startet den Vorgang für alle ausgewählten Sprachen unter Verwendung der angegebenen Profile.</li></ul>",
  "li_settings_9": "<strong>Debugging‑Erweiterungen:</strong><ul><li><code>Show Hierarchy Icons</code>: Zeigt Status‑Icons (grüner Haken / gelbe Warnung) in der Hierarchie an. <strong>Performance‑optimiert:</strong> Nutzt Caching, um selbst in großen Szenen keinerlei Verzögerung zu verursachen.</li><li><code>Show Scene View Labels</code>: Visuelles Debugging direkt in der Szenenansicht. Labels sind interaktiv: Rechtsklicken Sie auf ein beliebiges Szenen‑Label, um den Lokalisierungsschlüssel sofort in die Zwischenablage zu kopieren.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Ordnerstruktur‑Regel:</strong> Definiert, wie Unterordner beim Generieren lokalisierter Assets strukturiert werden (z. B. <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Bridge‑Klassenname:</strong> Ermöglicht es Ihnen, den Namen der generierten statischen Klasse anzupassen (Standard ist <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Sicherer Modus:</strong> Stellt sicher, dass kritische Vorgänge nicht ausgeführt werden, wenn sie zu inkonsistenten Projektzuständen führen könnten.",
  "li_settings_icons_legend": "<strong>Legende der Hierarchie-Symbole:</strong><br>🟢 (Grüner Haken): Lokalisiert & Schlüssel gesetzt.<br>🔴 (Roter Fehler): Lokalisierte Komponente vorhanden, aber <strong>Schlüssel fehlt</strong>.<br>🟡 (Gelbe Warnung): Text-/Bildkomponente gefunden, aber <strong>keine Lokalisierungskomponente</strong> angehängt.<br>🐛 (Bug): Objekt wird von den Einstellungen <strong>ignoriert</strong>.",
  "li_settings_lang_culture_fallback": "<strong>Kulturelles Fallback verwenden:</strong> Wenn ein spezifischer regionaler Dialekt (z. B. <code>en-AU</code>) fehlt, versucht das Werkzeug, zuerst die Basissprache (<code>en</code>) zu verwenden, bevor es auf die <strong>Standard‑Sprache</strong> zurückfällt.",
  "li_settings_lang_follow_system": "<strong>Systemsprache folgen:</strong> Schaltet die Spielsprache beim ersten Start automatisch auf die Betriebssystemsprache des Spielers um.",
  "li_settings_live_updates_security": "<strong>Sicherheit:</strong> Runtime‑API‑Schlüssel werden im Build mit AES verschlüsselt, um eine beiläufige Extraktion zu verhindern. Verwende stets HTTPS.",
  "li_settings_pseudo_accents": "<strong>Akzente verwenden:</strong> Ersetzt Standardzeichen durch akzentuierte Varianten (z. B. <code>å</code>, <code>é</code>). Verwenden Sie dies, um sicherzustellen, dass Ihre Schriftarten alle benötigten Glyphen unterstützen.",
  "li_settings_pseudo_brackets": "<strong>Klammern hinzufügen:</strong> Umhüllt den Text mit <code>[ ]</code>, um den Anfang und das Ende lokalisierter Zeichenketten zu überprüfen und hilft, Abschneide‑ oder Verkettungsprobleme zu erkennen.",
  "li_settings_pseudo_expand_length": "<strong>Länge erweitern:</strong> Simuliert die Textexpansion, die in Sprachen wie Deutsch oder Russisch üblich ist, indem nachfolgende Zeichen angehängt werden.",
  "li_settings_pseudo_expansion_factor": "<strong>Expansionsfaktor:</strong> Multiplikator für die Simulation der Textlänge (z. B. 2,0 macht den Text doppelt so lang).",
  "li_settings_pseudo_prefix": "<strong>Benutzerdefiniertes Präfix:</strong> Fügt jedem lokalisierten Text einen bestimmten String (z. B. <code>PSEUDO-</code>) am Anfang hinzu.",
  "li_settings_pseudo_suffix": "<strong>Benutzerdefiniertes Suffix:</strong> Fügt jedem lokalisierten Text einen bestimmten String am Ende hinzu.",
  "li_settings_return_source": "<strong>Quelltext zurückgeben, falls fehlt:</strong> Wenn aktiviert, gibt das System den Text in der Ausgangssprache (oder den Schlüssel selbst) zurück, falls für die aktuelle Sprache keine Übersetzung gefunden wird.",
  "li_settings_tms_timeout": "<strong>TMS‑Timeout:</strong> Gibt die maximale Wartezeit (in Sekunden) für Netzwerk‑Anfragen an externe TMS‑Dienste an.",
  "li_settings_tool_check_deps": "<strong>Abhängigkeiten prüfen:</strong> Durchsucht das Projekt erneut nach erforderlichen Paketen (wie Newtonsoft) und optionalen Integrationen.",
  "li_settings_tool_cleanup": "<strong>Vollständige Projektbereinigung:</strong> Ein destruktives Werkzeug, das alle Anko Localization‑Komponenten und -Daten aus dem Projekt entfernt (mit Vorsicht verwenden!).",
  "li_settings_tool_clear_prefs": "<strong>Sprach‑Einstellungen löschen:</strong> Setzt die in PlayerPrefs gespeicherte Sprache zurück und zwingt das Spiel, beim nächsten Start die Standard‑ oder System‑Sprache zu verwenden.",
  "li_settings_tool_font_manager": "<strong>Schrift‑Manager:</strong> Öffnet den Schrift‑ & Glyph‑Manager, um fehlende Zeichen zu analysieren und optimierte Schrift‑Assets zu erzeugen.",
  "li_settings_tool_migration": "<strong>Migrations‑Tool:</strong> Erleichtert das Verschieben von Daten und Komponenten von I2 Localization oder Unity Localization.",
  "li_settings_tool_test_center": "<strong>Lokalisierungs‑Testzentrum:</strong> Ein Diagnose‑Tool zur Überprüfung der Projekt‑Gesundheit, zum Aufspüren defekter Referenzen und zur Sicherstellung der Lokalisierungs‑Integrität.",
  "li_setup_1": "<strong>Einstellungen erstellen:</strong> Beim ersten Öffnen erstellt das Tool eine Datei <code>LocalizationSettings.asset</code> im Ordner <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Sprachen & Modus konfigurieren:</strong> Im <strong>Einstellungen</strong>-Tab sicherstellen, dass Ihre <strong>Quellsprache</strong> korrekt ist. Außerdem den <strong>Schlüsselgenerierungsmodus</strong> überprüfen (Standard ist <code>AutoGenerateKeysOnly</code>, empfohlen für die meisten Projekte).",
  "li_setup_3": "<strong>Inhalt für das Parsing angeben:</strong> Fügen Sie im Tab <strong>Content</strong> alle Szenen zur Analyse zur Liste <strong>Scenes to Parse</strong> hinzu. Wenn Sie Prefabs mit Text verwenden, stellen Sie sicher, dass deren Ordner zu <strong>Prefab Folders</strong> hinzugefügt werden.",
  "li_setup_4": "<strong>Erster Parser-Lauf:</strong> Gehen Sie zum Tab <strong>Actions</strong> und klicken Sie auf die Schaltfläche <code>Update Keys</code>. Das Tool scannt Ihr Projekt, erstellt Übersetzungsdateien und fügt automatisch die notwendigen Komponenten (<code>LocalizedText</code>, <code>LocalizedAsset</code> usw.) zu Spielobjekten hinzu.",
  "li_setup_5": "<strong>Einstellungen & Builds (KRITISCH):</strong> Das Tool fügt <code>LocalizationSettings.asset</code> automatisch zu <code>Project Settings -> Player -> Preloaded Assets</code> hinzu. <br>⚠️ <strong>Sicherheitsprüfung:</strong> Wenn die Einstellungen bei Preloaded Assets fehlen und sich nicht in einem Resources-Ordner befinden, **blockiert** das Tool den Build mit einer <code>BuildFailedException</code>, um zu verhindern, dass das Spiel beim Start abstürzt.",
  "li_sidebar_presets": "<strong>Such‑Vorgaben:</strong> Vordefinierte Filter für gängige Aufgaben wie das Finden von nicht übersetzten Zeichenketten oder Schlüsseln mit fehlenden Platzhaltern.",
  "li_sidebar_search": "<strong>Globale Suche:</strong> Suchen Sie nach bestimmten Schlüsseln oder Texten in allen Tabellen Ihres Projekts.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Erfordert Projekt-ID und API-Schlüssel. Unterstützt das Hochladen von Quell‑XLIFF und das Herunterladen von Übersetzungen als ZIP‑Archiv. <em>Erweitert:</em> <code>File Name</code> (der Zielpfad in Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Erfordert API-Schlüssel. Einfache und schnelle Integration für kleinere Projekte. <em>Erweitert:</em> <code>Import/Export Params</code> (ermöglicht das Hinzufügen zusätzlicher Loco-API-Flags wie <code>&tag=v1</code> oder <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Unternehmensgerechte Lokalisierungsverwaltung. <em>Erweitert:</em> <code>Update Translations/Descriptions</code>-Flags, um zu steuern, ob Phrase beim Hochladen vorhandene Daten überschreibt.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Unterstützt Organisations-/Projekt‑Slugs und API‑Token-Authentifizierung. <em>Erweitert:</em> <code>Resource Slug</code> (erstellt die Ressource automatisch, falls sie nicht existiert).",
  "li_tutorials_1": "<strong>Interaktives Lernen:</strong> Anleitungen heben bestimmte UI‑Elemente hervor und warten auf Ihre Aktionen.",
  "li_tutorials_2": "<strong>Verfügbare Lektionen:</strong>",
  "li_tutorials_editor": "<strong>Übersetzungs‑Editor:</strong> Erweiterte Funktionen des tabellenähnlichen Editors.",
  "li_tutorials_list": "<strong>Tutorial-Liste:</strong> Zugriff auf interaktive Anleitungen zu den Hauptfunktionen des Tools.",
  "li_tutorials_migration": "<strong>Migration:</strong> Wie man von anderen Lokalisierungssystemen (I2, Unity Localization) migriert.",
  "li_tutorials_quickstart": "<strong>Quick Start:</strong> Grundlegende Einrichtung für Texte und Assets.",
  "li_tutorials_size": "<strong>Tutorial-Größe:</strong> Passt die UI-Skalierung und den Detailgrad der interaktiven Anleitungen an (Komprimiert bis Extra Groß). Befindet sich im Header des Tutorials‑Tabs.",
  "li_vis_debug_1": "<strong>Hierarchie‑Icons:</strong> Probleme sofort erkennen (Missing Key, Missing Component). Optimiert für null Performance‑Einfluss.",
  "li_vis_debug_2": "<strong>Szenenansichts‑Labels:</strong> Zeigt den Schlüssel über jedem lokalisierten Objekt an. <strong>Rechtsklick</strong> auf ein Label, um 'Copy Key' oder 'Select Object' auszuführen.",
  "li_vis_debug_3": "<strong>Overlays:</strong> Verwende das Szenenansichts‑Overlay (Leertaste), um Vorsprache‑Sprachen sofort zu wechseln.",
  "lightbox_aria_close": "Bildbetrachter schließen",
  "lightbox_image_alt": "Vergrößerte Ansicht",
  "mindmap_edge_configure": "1. Konfigurieren",
  "mindmap_edge_creates_components": "Erstellt Komponenten",
  "mindmap_edge_defines_rules": "Definiert Regeln für",
  "mindmap_edge_edited_in": "Bearbeitet in",
  "mindmap_edge_enables_reaction": "Ermöglicht Reaktion über",
  "mindmap_edge_extends": "Erweitert",
  "mindmap_edge_generates": "Generiert",
  "mindmap_edge_manages_assets": "Verwaltet Assets für",
  "mindmap_edge_opens": "Öffnet",
  "mindmap_edge_parse_project": "3. Projekt parsen",
  "mindmap_edge_processed_by": "Verarbeitet durch",
  "mindmap_edge_recommends_for": "Empfiehlt für",
  "mindmap_edge_relates_to": "Bezieht sich auf",
  "mindmap_edge_reports_on": "Berichtet über",
  "mindmap_edge_see_faq": "Siehe FAQ",
  "mindmap_edge_specify_content": "2. Inhalt angeben",
  "mindmap_edge_warns_about": "Warnt vor",
  "mindmap_node_ai_ecosystem": "KI-Ökosystem",
  "mindmap_node_async_code": "Async / Addressables",
  "mindmap_node_dev_tools": "Werkzeuge & Dienstprogramme",
  "mindmap_node_tms_integration": "TMS-Integration",
  "mindmap_preset_ai": "KI & Automatisierung",
  "mindmap_preset_dev": "Entwickler-Workflow",
  "mindmap_preset_full": "Vollansicht",
  "mindmap_preset_quick_start": "Schnellstart",
  "mindmap_preset_tools": "Werkzeuge & Integrationen",
  "mindmap_preset_translator": "Übersetzer-Workflow",
  "mindmap_toggle_title": "Mind Map anzeigen",
  "my_notes_title": "Meine Notizen",
  "no_notes_message_new": "Fahren Sie mit der Maus über den Text, um eine Notiz hinzuzufügen.",
  "notes_add_title": "Eine Notiz zu diesem Block hinzufügen",
  "notes_close_title": "Schließen",
  "notes_delete_title": "Notiz löschen",
  "notes_edit_text": "Bearbeiten",
  "notes_edit_title": "Notiz bearbeiten",
  "notes_goto_title": "Zum Text gehen",
  "notes_placeholder": "Ihre Notiz...",
  "on_this_page_title": "Auf dieser Seite",
  "p_actions_1": "Der Haupt-Arbeits-Tab.",
  "p_ai_assistant": "Im Übersetzungstabellen-Editor können Sie jetzt benutzerdefinierte KI-Befehle für ausgewählte Zellen über das Kontextmenü ausführen (Rechtsklick -> AI: ...).",
  "p_ai_audio_economy": "<strong>Kostenersparnis:</strong> Das Tool berechnet einen MD5-Hash Ihres Textes und generiert Audiodateien nur neu, wenn sich der Quelltext geändert hat, wodurch Ihre API-Gutschriften gespart werden. Wenn Sie eine Übersetzung ändern, markiert das System nur diese spezifische Audiodatei als 'Veraltet'. Verwenden Sie 'Generate Missing/Outdated', um nur das zu regenerieren, was sich geändert hat, wodurch API-Gutschriften gespart werden. Das Tool hashiert Ihren Text und generiert Audiodateien nur neu, wenn sich der Quelltext geändert hat, wodurch Ihre API-Gutschriften durch intelligentes Batching gespart werden.",
  "p_ai_context": "Um die Übersetzungsqualität zu verbessern, erhält die KI nun zusätzlichen Kontext:",
  "p_ai_intro": "Das Tool verwendet ein <strong>Translation Profile</strong>-System (ScriptableObject). Damit werden die Einstellungen des Übersetzungsdienstes in einzelnen Profil‑Assets gespeichert, sodass du Konfigurationen einfach wechseln kannst.",
  "p_api_snippets_intro": "Die <code>LocalizationManager.cs</code> bietet eine robuste API für die Laufzeit‑Lokalisierungsverwaltung. Nachfolgend die wichtigsten Methoden, die Sie in Ihren Skripten verwenden werden.",
  "p_assets_1": "Dieser Tab ist vollständig der Lokalisierung von Nicht-Text-Ressourcen gewidmet.",
  "p_async_api": "Beim Einsatz von Addressables werden Assets nicht sofort geladen. Sie müssen die asynchrone API verwenden, um Frame-Drops zu vermeiden.",
  "p_bridge_description": "Das Tool enthält einen Generator für statische Klassen zum Schlüsselzugriff, sodass Sie stark typisierte Referenzen anstelle von magischen Zeichenketten verwenden können. Das hilft Tippfehler zu vermeiden und ermöglicht die Autovervollständigung in der IDE.",
  "p_bridge_usage_title": "Verwendungsbeispiel:",
  "p_components_intro": "Diese Komponenten sind die „Brücke“ zwischen Ihren Objekten in der Szene und der Übersetzungsdatenbank. Sie „lauschen“ auf Sprachänderungen und ersetzen automatisch den korrekten Text oder das korrekte Asset.",
  "p_content_1": "Hier teilen Sie dem Tool mit, wo genau nach Text gesucht werden soll. Die Benutzeroberfläche wurde für eine bessere Benutzerfreundlichkeit komplett überarbeitet.",
  "p_custom_ai": "Der Diensttyp <strong>Custom AI</strong> ermöglicht es Ihnen, jedes LLM über die REST-API zu verbinden.",
  "p_custom_asset_provider_1": "Die Entwicklung eines benutzerdefinierten Providers ermöglicht es Ihnen, Ihr eigenes Asset‑Verwaltungssystem (z. B. einen benutzerdefinierten Cloud‑Loader, ein spezifisches internes Bundling‑System oder ein datenbankbasiertes Asset‑Repository) direkt in den Lokalisierungs‑Workflow zu integrieren.",
  "p_custom_asset_provider_intro": "Das Asset‑Provider‑System abstrahiert, wie Assets (Sprites, Audio, Prefabs usw.) zur Laufzeit geladen werden. Es verwendet ein <strong>Plugin‑Registry</strong>, das automatisch jede Klassenimplementierung von <code>IAssetProvider</code> entdeckt, die mit dem Attribut <code>[AssetProviderPlugin]</code> markiert ist. Dadurch wird eine nahtlose Integration benutzerdefinierter Ladesysteme (wie Cloud‑Loader oder internes Bundling) ermöglicht, ohne das Kern‑Toolkit zu ändern.",
  "p_custom_attributes_description": "Zusätzlich zu Funktionsaufrufen können Sie jedes String‑Feld in Ihren Skripten mit benutzerdefinierten Attributen als lokalisierbar markieren. Standardmäßig erkennt das Tool <code>[LocalizableField]</code>, Sie können jedoch jeden Attributnamen (wie <code>[Header]</code> oder <code>[Tooltip]</code>) zur Liste <strong>Zu scannende Attribute</strong> hinzufügen.",
  "p_custom_parser_1": "Sie können das System ganz einfach erweitern, um benutzerdefinierte Komponenten zu unterstützen, indem Sie Ihre eigene Parser-Klasse erstellen.",
  "p_editor_1": "Wird über <strong>Tools -> Localization -> Translation Table Editor</strong> geöffnet. Dies ist das Hauptwerkzeug zum manuellen Bearbeiten von Übersetzungen.",
  "p_example_attribute_1": "Die leistungsstärkste Methode, Skriptvariablen zu lokalisieren. Sie funktioniert mit <strong>private, protected und public</strong> Feldern. Der Parser verarbeitet rekursiv <strong>Arrays, Listen</strong> und <strong>verschachtelte serialisierbare Klassen</strong>. Er kann sogar Schlüssel für andere Attribute (wie <code>[Header]</code> oder <code>[Tooltip]</code>) generieren, wenn dies in den Einstellungen konfiguriert ist.",
  "p_example_components_1": "Das Projekt enthält vorgefertigte Skripte, die als ausgezeichnete Beispiele dienen.",
  "p_example_components_updated": "Der Code hat sich geändert. Das Laden der Sprache (insbesondere bei Verwendung von Addressables) ist jetzt asynchron.",
  "p_example_function_1": "Verwenden Sie die Funktion <code>_()</code> für dynamischen Text, der sich während des Spiels ändert. Die Methode, die die Benutzeroberfläche aktualisiert, sollte mit dem Attribut <code>[OnLanguageChange]</code> markiert werden, damit sie beim Wechsel der Sprache automatisch aufgerufen wird. Zu diesem Zweck wird dem Objekt automatisch eine Komponente <code>LocalizedBehaviour</code> hinzugefügt.",
  "p_example_plurals_1": "Das Tool verwendet jetzt genauere Regeln für verschiedene Sprachgruppen.",
  "p_font_glyph_manager_access": "Zugriff über <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "Dieses Tool ist eine umfassende Lösung zur Lokalisierung von Spielen und Anwendungen in Unity. Es automatisiert den Prozess der Sammlung von Text und Assets, der Verwaltung von Übersetzungen über eine leistungsstarke Benutzeroberfläche, der Integration mit maschinellen Übersetzungsdiensten (einschließlich Custom AI) und der dynamischen Aktualisierung lokalisierter Inhalte im Spiel.",
  "p_live_updates_guide": "Das Live‑Updates‑System ermöglicht es Ihrem Spiel, zur Laufzeit neue Übersetzungen von einem Remote‑Server oder Google‑Sheet abzurufen, ohne dass ein neuer Build erforderlich ist.",
  "p_localizedasset_1": "Wird verwendet, um Assets basierend auf der Sprache auszutauschen. Erkennt den Komponententyp automatisch. Unterstützt: <ul><li><strong>2D:</strong> Sprites (<code>Image</code>, <code>SpriteRenderer</code>), Texturen (<code>RawImage</code>).</li><li><strong>Audio/Video:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Animation:</strong> <code>MeshFilter</code> (Meshes), <code>Renderer</code> (Materialien), <code>Animator</code> (Controller), <code>PlayableDirector</code> (Timeline).</li></ul>",
  "p_localizedasset_2": "Bei Komponenten mit der Option <strong>Play on Awake</strong> (wie <code>AudioSource</code>, <code>VideoPlayer</code>) fängt <code>LocalizedAsset</code> das Auto-Play korrekt ab, tauscht das Asset aus und startet dann die Wiedergabe, um die Wiedergabe nicht lokalisierter Inhalte zu vermeiden.",
  "p_localizedasset_updated": "Die Komponente unterstützt jetzt die asynchrone Ladung. Beachten Sie, dass beim Wechsel der Sprache eine leichte Verzögerung auftreten kann, wenn Assets von Cloud/Disk geladen werden (Addressables).",
  "p_localizedbehaviour_1": "Eine Dienstprogrammkomponente, die es Ihren Skripten ermöglicht, auf Sprachänderungen zu reagieren. Sie findet und ruft automatisch Methoden auf, die mit dem Attribut <code>[OnLanguageChange]</code> markiert sind.",
  "p_localizeddropdown_1": "Wird zu <code>Dropdown</code> und <code>TMP_Dropdown</code> hinzugefügt, um deren Optionen zu übersetzen.",
  "p_localizedprefab_1": "Eine Komponente zur Lokalisierung ganzer Prefabs. Sie funktioniert nicht-destruktiv: Sie ändert das Original-Prefab nicht, sondern erstellt eine Instanz der lokalisierten Version als Kindobjekt und deaktiviert alle Skripte (<code>MonoBehaviour</code>), Renderer (<code>Renderer</code>) und Collider (<code>Collider</code>) auf dem Originalobjekt. Dies verhindert doppelte Logikausführung und visuelle Artefakte. Für den korrekten Betrieb zur Laufzeit ist ihre Ausführungsreihenfolge auf -100 (<code>[DefaultExecutionOrder(-100)]</code>) eingestellt, um sicherzustellen, dass sie vor anderen Skripten ausgeführt wird.",
  "p_localizedtext_1": "Die Hauptkomponente zur Anzeige von übersetztem Text. Sie wird auf Objekten mit <code>Text</code>, <code>TMP_Text</code> und <code>TextMesh</code> platziert.",
  "p_migration_custom": "Sie können eigene Migrationsprofile erstellen, um benutzerdefinierte Systeme oder spezifische Projekt‑Setups zu unterstützen. Jedes Profil enthält eine Liste von <strong>Regeln</strong>, die festlegen, wie Komponenten und deren Felder konvertiert werden sollen. Regeln werden in der Reihenfolge ihrer <strong>Priorität</strong> geprüft.",
  "p_migration_custom_advanced": "Migrationsprofile bieten erweiterte Einstellungen zur Feinabstimmung des Import‑ und Erkennungsprozesses:",
  "p_migration_google_sheet": "Sie können direkt von einer Google‑Sheet‑URL importieren, ohne Dateien herunterzuladen.",
  "p_migration_import_csv": "Das Tool unterstützt standardmäßige CSV‑Dateien (kommagetrennt). Die erste Zeile muss die Kopfzeile sein.",
  "p_migration_stubs": "Ein häufiges Problem bei der Migration ist, dass das Löschen des alten Plugins (z. B. I2) den Build beschädigt und Unity daran hindert, das Migrations‑Tool selbst zu kompilieren.",
  "p_migration_tool_access": "Zugriff über <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Tool für den Übergang von anderen Lokalisierungssystemen (I2 Localization, Unity Localization).",
  "p_preview_1": "Direkt unterhalb des Headers befindet sich die Dropdown-Liste <strong>Preview Language</strong>. Diese leistungsstarke Funktion ermöglicht es Ihnen, zu sehen, wie die Lokalisierung in jeder Sprache direkt im <strong>Scene</strong>-Fenster oder im <strong>Prefab-Modus</strong> aussehen wird, ohne das Spiel zu starten.",
  "p_preview_overlay": "Für noch schnellere Iterationen können Sie die Sprache direkt im Szenen‑View mithilfe des dedizierten <strong>Localization Preview Overlay</strong> umschalten.",
  "p_report_1": "Nach jedem Parsing zeigt dieser Bericht das vollständige Bild Ihres Lokalisierungsstatus.",
  "p_safety_caps": "Um versehentliche hohe Kosten oder umfangreiche Traffic‑Prüfungen zu verhindern:",
  "p_script_parsing_rules_description": "Das Tool kann so konfiguriert werden, dass es Lokalisierungsschlüssel erkennt, die in benutzerdefinierten Funktionen oder sogar Konkurrenzsystemen (wie I2 Localization) verwendet werden, ohne Ihren bestehenden Code zu ändern. Dies wird erreicht, indem Regex‑Muster definiert werden, die der Scanner zum Extrahieren von Schlüsseln aus Ihren Skripten verwendet.",
  "p_script_parsing_rules_usage": "Im Tab <strong>Inhalt</strong>, unter <strong>Skript‑Parsing‑Regeln</strong>, können Sie Regeln hinzufügen, die Ihre spezifischen Funktionsaufrufe abdecken. Zum Beispiel, um <code>I2.Loc.Get(\\\"key\\\")</code> zu unterstützen, können Sie eine Regel mit einem Muster hinzufügen, das die Zeichenkette innerhalb der Klammern erfasst.",
  "p_settings_1": "Ihr Kontrollzentrum. Hier definieren Sie globale Regeln für den gesamten Lokalisierungsprozess.",
  "p_tms_intro": "Das Tool unterstützt jetzt die Synchronisation mit beliebten Translation Management Systemen. Sie können Quellschlüssel hochladen und Übersetzungen direkt in Unity abrufen.",
  "p_tms_setup": "1. Gehen Sie zu <strong>Settings -> TMS Integration</strong>.<br>2. Wählen Sie Ihren Dienstanbieter aus.<br>3. Geben Sie die API-Schlüssel und Projekt-IDs ein.<br>4. Verwenden Sie die Schaltflächen <strong>Push</strong> (Schlüssel hochladen) und <strong>Pull</strong> (Übersetzungen herunterladen) im Einstellungsfenster.",
  "p_tutorials_1": "Der Tab „Tutorials“ bietet interaktive Schritt‑für‑Schritt‑Anleitungen, um Ihnen zu helfen, die Funktionen des Tools direkt im Unity‑Editor zu meistern.",
  "p_uitklocalization_1": "Wird zu Objekten mit einem <code>UIDocument</code> hinzugefügt. Unterstützt die Lokalisierung von <strong>Labels, Buttons, HelpBox, Foldout, ProgressBar (Titel), TextField (Label & Platzhalter), DropdownField (Label & Auswahlmöglichkeiten), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), und Tooltips</strong> auf jedem Element. Bezeichner bleiben über Umbenennungen hinweg stabil, wenn IDs im UI Builder gesetzt sind.",
  "p_window_footer": "Zeigt den aktuellen Status, den Fortschritt von Hintergrundvorgängen und die Tool‑Version an.",
  "p_window_header": "Die obere Leiste bietet globalen Zugriff auf Vorschausteuerungen und Dienstprogramme, die unabhängig vom ausgewählten Tab bestehen bleiben.",
  "p_window_sidebar": "Die Seitenleiste steuert die Navigation zwischen verschiedenen Funktions‑Tabs und globalen Suchwerkzeugen.",
  "page_title": "Unity Localization Tool Dokumentation",
  "q_faq_addressables_1": "Ich habe den Addressables-Modus aktiviert, aber Assets werden nicht geladen. Was soll ich überprüfen?",
  "q_faq_addressables_2": "Wie füge ich Unterstützung für DeepL/Google hinzu?",
  "q_faq_addressables_3": "Der Migrator zeigt Kompilierungsfehler an, nachdem I2/UnityLoc entfernt wurde. Wie kann ich das beheben?",
  "q_faq_audio_smart_update": "Wie spart das Tool API-Gutschriften beim Regenerieren von Audiodateien?",
  "q_faq_components_1": "Die LocalizedPrefab‑Komponente deaktiviert MonoBehaviours am Originalobjekt. Was ist, wenn das Originalobjekt ein Skript hat, das in Awake() andere Objekte erstellt oder sich zu Ereignissen anmeldet?",
  "q_faq_components_2": "Wenn das Original-Prefab (LocalizedPrefab) ein Rigidbody oder eine andere Physikkomponente hat, wird diese deaktiviert? Wirkt sich dies auf die Physik aus, wenn das lokalisierte Prefab diese nicht hat?",
  "q_faq_components_3": "Die Komponente LocalizedAsset speichert den Zielkomponentennamen als Zeichenkette (_targetComponentTypeName). Was passiert, wenn ich ein benutzerdefiniertes Komponentenskript umbenenne oder in eine andere Assembly (Assembly Definition) verschiebe? Funktioniert LocalizedAsset dafür nicht mehr?",
  "q_faq_components_4": "Wenn sich zwei Image-Komponenten auf demselben GameObject befinden, woher weiß LocalizedAsset, welche es lokalisieren soll? Funktioniert es mit beiden oder nur mit der ersten, die es findet?",
  "q_faq_components_5": "Die Dokumentation besagt, dass LocalizedPrefab eine Ausführungsreihenfolge von -100 hat. Was passiert, wenn ich ein anderes Skript mit einer Ausführungsreihenfolge von -110 habe, das versucht, in seinem Awake() ein von LocalizedPrefab erstelltes Kindobjekt zu finden? Wird LocalizedPrefab seine Instanz rechtzeitig instanziiert haben?",
  "q_faq_components_6": "Die Komponente LocalizedText hat eine Option isStyleOnly. Wenn ich sie aktiviere und dann myLocalizedText.SetFormattedText(\"new_key\") im Code aufrufe, ändert sich der Text oder nur der Stil (Schriftart/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour findet automatisch Methoden mit dem Attribut [OnLanguageChange]. Findet es private und geschützte Methoden, oder müssen diese öffentlich sein?",
  "q_faq_components_8": "Die Komponente LocalizedAsset fängt Play on Awake ab. Was passiert, wenn ein anderes Skript auf demselben Objekt versucht, in Awake() oder Start() auf das Asset zuzugreifen (z. B. audioSource.clip.length), bevor LocalizedAsset es ausgetauscht hat? Ist eine NullReferenceException oder die Verwendung des alten Assets möglich?",
  "q_faq_custom_keys_attribute": "Kann ich mein eigenes Attribut für Schlüssel anstelle von [LocalizableField] verwenden?",
  "q_faq_custom_provider_1": "Warum wird mein benutzerdefinierter Provider nicht im Settings‑Dropdown angezeigt?",
  "q_faq_editor_1": "Was hat eine höhere Priorität für die Platzhaltervalidierung: die Direktive @placeholders: im Kommentar oder die im Quellsprachentext gefundenen Platzhalter? Zum Beispiel, wenn der Quelltext {name} und der Kommentar @placeholders: {username} enthält.",
  "q_faq_editor_2": "Wenn ich einen Tippfehler in der Direktive mache (z. B. @placeholder: anstelle von @placeholders:), wird dieser ignoriert oder gibt das Tool eine Warnung aus?",
  "q_faq_editor_3": "Das Auto-Speicher-System erstellt Dateien im Ordner Backups/AutoSaves. Werden diese Dateien nach einem erfolgreichen manuellen Speichern oder Schließen des Fensters automatisch gelöscht?",
  "q_faq_editor_4": "Wenn ich die Spaltenbreiten im Editor ändere, werden diese Einstellungen zwischen den Unity-Sitzungen gespeichert?",
  "q_faq_editor_5": "Unterstützt das Textbearbeitungs-Popup-Fenster (MultiLineEditWindow) einen eigenen Rückgängig/Wiederherstellen-Stapel (über Strg+Z) für darin vorgenommene Änderungen?",
  "q_faq_examples_1": "Was passiert, wenn die Eigenschaftsnamen im an die _()-Funktion übergebenen anonymen Typ nicht mit den Platzhaltern in der Zeichenkette übereinstimmen? Zum Beispiel _(\"Hello, {username}\", new { user_name = \"Bob\" }). Gibt es einen Fehler, oder wird der Platzhalter einfach nicht ersetzt?",
  "q_faq_examples_2": "Das Attribut [LocalizableField] funktioniert für private Felder. Funktioniert es für statische Felder?",
  "q_faq_examples_3": "Wenn ich das Attribut [OnLanguageChange] auf eine Methode mit Parametern setze (z. B. void UpdateUI(string newLang)), was passiert dann? Gibt es einen Kompilierungsfehler oder eine Laufzeitwarnung?",
  "q_faq_examples_4": "Ich verwende _(\"apple_count\", count). Wenn für die aktuelle Sprache (für count = 1) kein Schlüssel apple_count_one vorhanden ist, welche Form wählt das System? Wird es apple_count_other als Fallback verwenden?",
  "q_faq_examples_5": "Die Funktion _(\"key\", new { username = \"Alex\" }) verwendet einen anonymen Typ. Erzeugt dies nicht eine übermäßige \"Belastung\" für den Garbage Collector (GC) bei häufigen Aufrufen in einer Update()-Methode im Vergleich zur Übergabe eines vorab erstellten Dictionary<string, object>?",
  "q_faq_examples_6": "Meine mit [OnLanguageChange] markierte Methode wird nicht aufgerufen. Warum?",
  "q_faq_extending_1": "Wird mein benutzerdefinierter Parser nach jedem Update Keys automatisch aufgerufen? Muss ich ihn irgendwo registrieren, oder reicht es aus, einfach eine Klasse zu haben, die ITextComponentParser im Projekt implementiert?",
  "q_faq_extending_2": "Was passiert, wenn in meinem benutzerdefinierten Parser eine Ausnahme auftritt? Wird der gesamte Parsing-Prozess unterbrochen, oder fährt das Tool sicher mit anderen Parsern fort?",
  "q_faq_installation_1": "Was passiert, wenn mein Projekt das Paket com.unity.nuget.newtonsoft-json bereits von einem anderen Asset enthält? Versucht der Abhängigkeits-Installer, es zu aktualisieren oder zu ignorieren?",
  "q_faq_installation_2": "Ich habe versehentlich auf \"Skip for Now\" geklickt und \"Don't ask again\" für optionale Abhängigkeiten (z. B. für CSV-Unterstützung) aktiviert. Wie kann ich das Installer-Fenster erneut aufrufen, um sie zu installieren?",
  "q_faq_installation_3": "Das Tool hat LocalizationSettings.asset nicht in Assets/Resources erstellt. Warum könnte das passiert sein, und kann ich es manuell über das Menü Assets -> Create erstellen?",
  "q_faq_installation_4": "Kann ich die Datei LocalizationSettings.asset in einen anderen Resources-Ordner verschieben, z. B. Assets/MyGame/Resources? Wird das Tool sie trotzdem finden?",
  "q_faq_installation_5": "Der Abhängigkeits-Installer ist eingefroren oder hat einen Fehler ausgegeben. Kann ich die Abhängigkeiten (Newtonsoft Json, Editor Coroutines) manuell über den Unity Package Manager installieren?",
  "q_faq_notes_1": "Die Dokumentation empfiehlt, LanguageSelector zur Ignorierliste hinzuzufügen. Was genau wird kaputt gehen, wenn ich das vergesse? Werden zusätzliche Schlüssel für \"Option A, Option B\" erstellt?",
  "q_faq_notes_2": "Wenn ich vergesse, ein leeres LocalizedText mit aktiviertem isStyleOnly-Kontrollkästchen auf dem Label innerhalb des von LanguageSelector verwendeten TMP_Dropdown hinzuzufügen, ändert sich die Schriftart dann nicht? Warum ist das notwendig?",
  "q_faq_notes_3": "Der Aufruf von _() in der Update()-Methode wird nicht empfohlen. Aber was ist, wenn ich Text in jedem Frame aktualisieren muss (z. B. einen Timer)? Was ist der performanteste Weg dafür, wobei nur die Formatzeichenkette zwischengespeichert wird?",
  "q_faq_tts_voices": "Wie weise ich bestimmten Charakteren bestimmte Stimmen zu?",
  "q_faq_window_actions_1": "Was passiert, wenn die Internetverbindung während einer automatischen Stapelübersetzung unterbrochen wird? Versucht das Tool, den fehlgeschlagenen Stapel gemäß der Wiederholungsrichtlinie erneut zu senden, oder wird der Prozess vollständig unterbrochen?",
  "q_faq_window_actions_2": "Wenn ich eine CSV-Datei importiere, die Schlüssel enthält, die bereits im Projekt existieren, aber mit leeren Werten für einige Sprachen, werden diese leeren Werte meine vorhandenen Übersetzungen ersetzen oder ignoriert?",
  "q_faq_window_actions_3": "Der Abschnitt \"Danger Zone\" ermöglicht das Löschen aller Komponenten. Werden Komponenten aus Prefabs entfernt, die sich in Ordnern befinden, die nicht in den Prefab Folders im Content-Tab angegeben sind?",
  "q_faq_window_actions_4": "Wie soll ich beim Import aus Google Sheets die Kommentarspalte formatieren, damit die Platzhaltervalidierung mithilfe der Direktive @placeholders: funktioniert?",
  "q_faq_window_actions_5": "Kann das Tool Daten aus mehreren Blättern eines einzigen Google Sheets-Dokuments importieren, oder funktioniert es nur mit einem Blatt pro GID?",
  "q_faq_window_assets_1": "Was passiert, wenn ich zwei Assets mit demselben Schlüssel, aber unterschiedlichen Typen im selben Scan-Ordner habe (z. B. sound_effect_en.mp3 und sound_effect_en.wav)? Welches landet in der Asset-Tabelle?",
  "q_faq_window_assets_2": "Wenn ich Scan Assets & Analyze Project klicke und ein Image-Objekt in der Szene vorhanden ist, für das bereits ein lokalisiertes Sprite existiert, das Image-Objekt selbst aber noch keine LocalizedAsset-Komponente hat, wird das Tool die Komponente hinzufügen und den Schlüssel automatisch einfügen?",
  "q_faq_window_assets_3": "Kann ich dieselbe Naming Rule für verschiedene Asset-Kategorien verwenden, wenn diese unterschiedliche Scan Folders haben? Verursacht dies Konflikte?",
  "q_faq_window_assets_4": "Wenn sich ein lokalisierbares Asset (z. B. button_ok_en.png) nicht im Stammverzeichnis des Scan Folders, sondern in einem Unterordner befindet, wird der Scanner es finden?",
  "q_faq_window_content_1": "Was passiert, wenn ich eine Szene zu Scenes to Parse hinzufüge, die nicht in den Build Settings enthalten ist? Wirkt sich dies auf etwas anderes als den Parsing-Prozess selbst aus?",
  "q_faq_window_content_2": "Ich habe ein Objekt zu Ignore Specific Objects (der temporären Liste) hinzugefügt. Wenn ich aus diesem Objekt ein Prefab erstelle, wird die Instanz dieses Prefabs ebenfalls ignoriert?",
  "q_faq_window_content_3": "Wenn ich die Komponente TMPro.TMP_Text zu Parsing Ignores -> Ignore Component Types hinzufüge, aber ein Objekt in der Szene mit einem LocalizedText vorhanden ist, der bereits auf diesen TMP_Text verweist, was passiert beim nächsten Update Keys? Wird der Schlüssel gelöscht?",
  "q_faq_window_content_4": "Die Dokumentation besagt, dass \"Pin\" den vollständigen Pfad zum Objekt speichert und unterbrochen wird, wenn es umbenannt wird. Was passiert, wenn ich aus dem Objekt ein Prefab erstelle und dann das Originalobjekt umbenenne - funktioniert \"Pin\" weiterhin für die Prefab-Instanzen?",
  "q_faq_window_content_5": "Wenn ich \"Pin\" für ein Kindobjekt innerhalb einer Prefab-Instanz verwende, welcher Pfad wird gespeichert: relativ zur Prefab-Wurzel oder zur Szenen-Wurzel? Funktioniert es in anderen Szenen?",
  "q_faq_window_preview_1": "Ich habe ein Prefab im Prefab-Modus geöffnet, die In-Editor-Vorschau angewendet und Strg+S gedrückt. Werden die temporären Vorschaudaten im Prefab-Asset gespeichert? Wie handhabt LocalizationPreviewProtector diesen Fall?",
  "q_faq_window_preview_2": "Wenn ich die In-Editor-Vorschau aktiviere und der Unity-Editor abstürzt und die Datei Temp/localization_preview_recovery.json beschädigt wird (z. B. leer oder ungültiges JSON), was passiert beim nächsten Start?",
  "q_faq_window_preview_3": "Im In-Editor-Vorschaumodus für LocalizedPrefab wird eine temporäre Instanz erstellt. Werden die Awake()- und Start()-Methoden auf dieser Instanz ausgeführt? Könnte dies Fehler verursachen, wenn sie nicht für die Ausführung im Edit-Modus konzipiert sind?",
  "q_faq_window_report_1": "Die Schaltfläche \"Find\" sucht das Objekt asynchron. Was passiert, wenn ich eine Suche starte und dann sofort Update Keys klicke? Wird die Suche unterbrochen?",
  "q_faq_window_report_2": "Wenn ein Schlüssel an mehreren Stellen verwendet wird (z. B. auf zwei verschiedenen Schaltflächen in verschiedenen Szenen), wie wird dies im Bericht unter der Kategorie \"Duplicates\" angezeigt?",
  "q_faq_window_report_3": "Wenn ich auf \"Find\" für einen Schlüssel klicke, der nur im Code verwendet wird (über die _()-Funktion), was passiert dann? Kann das Tool das C#-Skript finden und hervorheben?",
  "q_faq_window_settings_1": "Ich kann den Key Generation Mode mitten im Projekt von UseTextAsKey auf AutoGenerateKeysOnly ändern. Was genau passiert mit meinen vorhandenen Übersetzungen? Werden sie auf die neuen Schlüssel abgebildet?",
  "q_faq_window_settings_2": "Wenn ich eine Sprache mit einem Code, der keine Pluralisierungsregeln hat (z. B. \"kz\" für Kasachisch), zur Liste der Supported Languages hinzufüge, welche Regel wird standardmäßig verwendet?",
  "q_faq_window_settings_3": "Was passiert, wenn ich den Translations Path nicht in StreamingAssets, sondern in einem regulären Ordner wie Assets/MyTranslations angebe? Werden die json-Dateien in den Spiel-Build aufgenommen?",
  "q_faq_window_settings_4": "Der Auto-Übersetzungs-API-Schlüssel wird in EditorPrefs gespeichert. Wenn ich an dem Projekt auf zwei verschiedenen Computern arbeite, muss ich den Schlüssel auf jedem Computer separat eingeben?",
  "tip_best_practice": "<strong>Profi-Tipp:</strong> Wenn Sie eine Eigenschaft lokalisieren müssen, erstellen Sie ein Sicherungsfeld mit <code>[LocalizableField]</code> und machen Sie die Eigenschaft separat zugänglich.",
  "toc_search_placeholder": "Dokumentation durchsuchen...",
  "toc_title": "Inhaltsverzeichnis",
  "toggle_notes_title": "Hinweise umschalten",
  "warning_box_components": "<strong>Wichtiger Hinweis:</strong> Alle unten beschriebenen Komponenten werden Spielobjekten automatisch während des Parsings hinzugefügt (wenn Sie auf die Schaltfläche <code>Update Keys</code> klicken). Sie müssen sie nicht manuell hinzufügen.",
  "warning_tms_overwrite": "<strong>Warning:</strong> Das Abrufen aus dem TMS überschreibt lokale Übersetzungen für die entsprechenden Schlüssel. Stellen Sie sicher, dass Ihr TMS die einzige Wahrheitsquelle ist."
}