{
  "page_title": "Documentación de la Herramienta de Localización de Unity",
  "toc_title": "Tabla de Contenidos",
  "toc_search_placeholder": "Buscar en la documentación...",
  "nav_introduction": "1. Introducción",
  "nav_quick_start": "2. Inicio Rápido",
  "nav_components": "3. Componentes Principales",
  "nav_loc_tool_window": "4. Ventana \"Localization Tool\"",
  "nav_translation_editor": "5. Editor de Traducciones",
  "nav_ai_profiles": "6. Perfiles de IA y Traducción (Nuevo v1.1)",
  "nav_usage_examples": "7. Ejemplos de Uso",
  "nav_important_notes": "8. Notas Importantes",
  "nav_extending": "9. Ampliar Funcionalidad",
  "nav_faq": "10. FAQ y Solución de Problemas",
  "nav_key_features": "Características Clave",
  "nav_installation": "2.1. Instalación",
  "nav_initial_setup": "2.2. Configuración Inicial",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. Menú Contextual",
  "nav_in_editor_preview": "4.1. Vista Previa en el Editor y en Prefabs",
  "nav_tab_settings": "4.2. Pestaña \"Configuración\"",
  "nav_tab_content": "4.3. Pestaña \"Contenido\" (Rediseñada)",
  "nav_tab_actions": "4.4. Pestaña \"Acciones\"",
  "nav_tab_assets": "4.5. Pestaña \"Assets\"",
  "nav_tab_report": "4.6. Pestaña \"Informe\"",
  "nav_ai_profiles_overview": "6.1. Perfiles de Traducción",
  "nav_custom_ai": "6.2. IA y Modelos Personalizados",
  "nav_ai_context": "6.3. Contexto y Glosario",
  "nav_ai_assistant": "6.4. Comandos del Asistente de IA",
  "nav_example_components": "7.1. Componentes Listos para Usar",
  "nav_example_attribute": "7.2. Atributo [LocalizableField]",
  "nav_example_function": "7.3. Función _()",
  "nav_example_plurals": "7.4. Plurales y Género",
  "nav_custom_parser": "9.1. Creando un Parser",
  "nav_faq_installation": "10.1. Instalación e Inicio Rápido",
  "nav_faq_components": "10.2. Componentes Principales",
  "nav_faq_window": "10.3. Ventana \"Localization Tool\"",
  "nav_faq_window_actions": "10.3. Ventana \"Localization Tool\" - Pestaña \"Acciones\"",
  "nav_faq_window_assets": "10.3. Ventana \"Localization Tool\" - Pestaña \"Assets\"",
  "nav_faq_window_report": "10.3. Ventana \"Localization Tool\" - Pestaña \"Informe\"",
  "nav_faq_editor": "10.4. Editor de Traducciones",
  "nav_faq_examples": "10.5. Ejemplos de Uso y Código",
  "nav_faq_notes": "10.6. Matices y Advertencias Importantes",
  "nav_faq_extending": "10.7. Ampliar Funcionalidad",
  "h1_introduction": "Introducción",
  "p_intro_1": "Esta herramienta es una solución integral para localizar juegos y aplicaciones en Unity. Automatiza el proceso de recopilación de texto y assets, gestiona las traducciones a través de una potente interfaz, se integra con servicios de traducción automática (incluyendo IA Personalizada) y actualiza dinámicamente el contenido localizado en el juego.",
  "h2_key_features": "Características Clave",
  "li_feature_1": "<strong>Análisis Avanzado:</strong> Escaneo automático de escenas, prefabs, UI Toolkit (UXML) y scripts de C#, incluyendo campos marcados con el atributo <code>[LocalizableField]</code>, así como clases anidadas y listas.",
  "li_feature_2": "<strong>Localización de Cualquier Asset:</strong> Gestiona sprites, audio, prefabs, materiales, etc.",
  "li_feature_3": "<strong>Potente Editor de Traducciones:</strong> Una interfaz centralizada con guardado automático, soporte completo de Deshacer/Rehacer, agrupación inteligente de claves y <strong>Nuevo en v1.1:</strong> acciones de selección múltiple.",
  "li_feature_4": "<strong>IA y Traducción Automática (v1.1):</strong> Nuevo sistema de Perfiles compatible con DeepL, Google, Microsoft e <strong>IA Personalizada (OpenAI, Gemini, Claude, Ollama)</strong> con conciencia de contexto.",
  "li_feature_5": "<strong>Importación/Exportación Flexible:</strong> Soporte para CSV, XML, YAML, XLIFF e importación directa desde Google Sheets.",
  "li_feature_6": "<strong>Vista Previa en Vivo:</strong> Previsualiza cualquier idioma en la Vista de Escena o en el <strong>Modo Prefab</strong> sin ejecutar el juego.",
  "li_feature_7": "<strong>Soporte para Plural y Género:</strong> Manejo correcto de las formas plurales (con reglas para idiomas eslavos, árabe y otros) y de género.",
  "li_feature_8": "<strong>Soporte Completo para RTL:</strong> Visualización correcta de idiomas de escritura de derecha a izquierda.",
  "li_feature_9": "<strong>Actualizaciones en Vivo:</strong> Carga traducciones actualizadas desde un servidor remoto al iniciar el juego.",
  "li_feature_10": "<strong>Gestor de Copias de Seguridad:</strong> Una herramienta integrada para crear y restaurar copias de seguridad.",
  "h1_quick_start": "Inicio Rápido y Configuración",
  "h2_installation": "2.1. Instalación",
  "li_install_1": "Copia el asset en la carpeta de tu proyecto de Unity.",
  "li_install_2": "La herramienta comprobará automáticamente las dependencias necesarias. Confirma la instalación en el cuadro de diálogo que aparece.",
  "li_install_3": "Las dependencias requeridas (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) son necesarias para la funcionalidad básica.",
  "li_install_4": "Las dependencias opcionales (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) habilitan características adicionales.",
  "li_install_5": "Haz clic en <strong>Install Selected</strong> para instalar los paquetes recomendados.",
  "li_install_6": "Después de la instalación, abre la ventana principal de la herramienta a través del menú <strong>Tools -> Localization Tool</strong>.",
  "h2_initial_setup": "2.2. Configuración Inicial",
  "li_setup_1": "<strong>Crear Configuración:</strong> La primera vez que se abra, la herramienta creará un archivo <code>LocalizationSettings.asset</code> en la carpeta <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Configurar Idiomas:</strong> En la pestaña <strong>Settings</strong>, en <strong>Language Management</strong>, asegúrate de que tu idioma principal (por ejemplo, <code>en</code> para inglés) esté seleccionado como <strong>Source Language</strong>. Habilita todos los idiomas que planeas soportar.",
  "li_setup_3": "<strong>Especificar Contenido para Analizar:</strong> En la pestaña <strong>Content</strong>, añade todas las escenas para analizar a la lista <strong>Scenes to Parse</strong>. Si usas prefabs con texto, asegúrate de que sus carpetas estén añadidas a <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Primera Ejecución del Analizador:</strong> Ve a la pestaña <strong>Actions</strong> y haz clic en el botón <code>Update Keys</code>. La herramienta escaneará tu proyecto, creará archivos de traducción y añadirá automáticamente los componentes necesarios (<code>LocalizedText</code>, <code>LocalizedAsset</code>, etc.) a los objetos del juego.",
  "h1_components": "Componentes Principales (asignados automáticamente)",
  "warning_box_components": "<strong>Nota Importante:</strong> Todos los componentes descritos a continuación se añaden a los objetos del juego automáticamente durante el análisis (cuando haces clic en el botón <code>Update Keys</code>). No necesitas añadirlos manualmente.",
  "p_components_intro": "Estos componentes son el \"puente\" entre tus objetos en la escena y la base de datos de traducciones. \"Escuchan\" los cambios de idioma y sustituyen automáticamente el texto o asset correcto.",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "El componente principal para mostrar texto traducido. Se coloca en objetos con <code>Text</code>, <code>TMP_Text</code> y <code>TextMesh</code>.",
  "li_localizedtext_1": "<code>localizationKey</code>: La clave utilizada para encontrar la traducción. Se genera automáticamente.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Si es <code>true</code>, el componente solo aplicará estilos (fuente, RTL) pero no cambiará el texto en sí. Útil para elementos cuyo texto es gestionado por otro script (por ejemplo, <code>LanguageSelector</code>).",
  "li_localizedtext_3": "<code>originalSourceText</code>: El texto original en el idioma base. Se utiliza como respaldo.",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "Se utiliza para intercambiar assets (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code>, etc.). Detecta automáticamente el tipo de componente de destino en el objeto (<code>Image</code>, <code>AudioSource</code>) y reemplaza su recurso.",
  "p_localizedasset_2": "Para componentes con la opción <strong>Play on Awake</strong> (como <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> intercepta correctamente la reproducción automática, intercambia el asset y luego inicia la reproducción para evitar reproducir contenido no localizado.",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "Un componente para localizar prefabs enteros. Funciona de forma no destructiva: no modifica el prefab original, sino que crea una instancia de la versión localizada como un objeto hijo, deshabilitando todos los scripts (<code>MonoBehaviour</code>), renderizadores (<code>Renderer</code>) y colisores (<code>Collider</code>) en el objeto original. Esto evita la ejecución de lógica duplicada y artefactos visuales. Para un funcionamiento correcto en tiempo de ejecución, su orden de ejecución se establece en -100 (<code>[DefaultExecutionOrder(-100)]</code>) para garantizar que se ejecute antes que otros scripts.",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "Se añade a objetos con un <code>UIDocument</code> y gestiona la localización de todos los elementos de texto dentro del documento de UI Toolkit (UXML).",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "Se añade a <code>Dropdown</code> y <code>TMP_Dropdown</code> para traducir sus opciones.",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "Un componente de utilidad que permite a tus scripts reaccionar a los cambios de idioma. Encuentra y llama automáticamente a los métodos marcados con el atributo <code>[OnLanguageChange]</code>.",
  "h2_context_menu": "3.7. Menú Contextual \"Analyze for Localization\"",
  "p_context_menu_1": "Para añadir rápidamente un <code>LocalizedAsset</code> a un objeto, puedes hacer clic con el botón derecho en el componente deseado (por ejemplo, <code>Image</code>, <code>AudioSource</code>) en el inspector y seleccionar <strong>Analyze for Localization</strong>. La herramienta añadirá y configurará el componente por sí misma. (Esto es opcional pero puede usarse para adición manual).",
  "h1_loc_tool_window": "Ventana \"Localization Tool\"",
  "h2_in_editor_preview": "4.1. Vista Previa en el Editor y en Prefabs",
  "p_preview_1": "Justo debajo del encabezado se encuentra la lista desplegable <strong>Preview Language</strong>. Esta potente función te permite ver cómo se verá la localización en cualquier idioma directamente en la ventana <strong>Scene</strong> o en el <strong>Modo Prefab</strong>, sin necesidad de ejecutar el juego.",
  "li_preview_1": "<strong>Cómo funciona:</strong> Selecciona un idioma de la lista y la herramienta aplicará instantáneamente las traducciones, fuentes, configuraciones RTL y assets correspondientes a todos los objetos localizables en la escena activa o el prefab abierto.",
  "li_preview_2": "<strong>Marcadores de posición:</strong> Si se selecciona un estilo de marcador de posición (por ejemplo, <strong>Accents</strong> o <strong>Brackets</strong>) en la pestaña <strong>Settings</strong>, estos marcadores se mostrarán en modo de vista previa en lugar de las traducciones reales. Esto es ideal para probar el diseño y encontrar elementos no localizados.",
  "li_preview_3": "<strong>Seguridad:</strong> Todos los cambios realizados en el modo de vista previa son temporales. La herramienta revertirá automáticamente todo a su estado original cuando selecciones \"<strong>Revert to Original</strong>\", cierres la ventana, cambies de escena o antes de guardar una escena/prefab (gracias al componente <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Protección contra Cierres Inesperados:</strong> El sistema integrado <code>PreviewCrashProtector</code> restaurará automáticamente el estado original de los objetos si el editor de Unity se cierra inesperadamente mientras una vista previa está activa. Ahora también es compatible con la restauración en Modo Prefab.",
  "h2_tab_settings": "4.2. Pestaña \"Configuración\"",
  "p_settings_1": "Tu centro de control. Aquí defines las reglas globales para todo el proceso de localización.",
  "li_settings_1": "<strong>Key Generation Mode:</strong> Elige cómo se crearán las claves.<ul><li><code>UseTextAsKey</code>: El propio texto se convierte en la clave. Ideal para prototipos. Desventaja: si cambias el texto fuente, la clave cambia y todas sus traducciones se perderán.</li><li><code>AutoGenerateKeysOnly</code>: La clave se genera en función de la jerarquía y el nombre del objeto. Fiable para producción. Ventaja: las traducciones no se rompen cuando se cambia el texto.</li><li><code>UseTextAsKeyWithCustomPriority</code> y <code>AutoGenerateWithCustomKeys</code>: Modos híbridos que te permiten establecer claves personalizadas en el código mediante el atributo <code>[LocalizableField(\"mi_clave_personalizada\")]</code>.</li><li><strong>Migración Segura:</strong> Puedes cambiar el modo en cualquier momento. La herramienta migrará automáticamente todas las traducciones existentes al nuevo sistema de claves.</li></ul>",
  "li_settings_2": "<strong>Language Management:</strong> Configura la lista de idiomas. Para idiomas con caracteres especiales, asigna el <strong>Font Asset</strong> apropiado. Habilita la opción <strong>RTL</strong> para idiomas de derecha a izquierda.",
  "li_settings_3": "<strong>General Settings:</strong><ul><li><code>Parse Prefabs</code>: Habilita el análisis de prefabs.</li><li><code>Split files by language</code>: Determina cómo almacenar las traducciones (un archivo grande o un archivo por idioma).</li><li><code>Translations Path</code>: La ruta para almacenar los archivos de traducción <code>.json</code>. Importante: la carpeta debe estar dentro de <code>Assets/StreamingAssets/</code>.</li></ul>",
  "li_settings_4": "<strong>Debugging & Testing:</strong><ul><li><code>Placeholder Style</code>: Elige el estilo para mostrar los marcadores de posición en el modo de vista previa.</li></ul>",
  "li_settings_5": "<strong>Live Updates:</strong> Configuración para cargar traducciones desde un servidor remoto.",
  "li_settings_6": "<strong>Runtime API Key:</strong> Una sección para almacenar de forma segura una clave de API que pueda ser necesaria en el juego compilado (se almacena de forma encriptada).",
  "h2_tab_content": "4.3. Pestaña \"Contenido\" (Rediseñada en v1.1)",
  "p_content_1": "Aquí le dices a la herramienta dónde buscar exactamente el texto. La interfaz ha sido completamente rediseñada para una mejor usabilidad.",
  "li_content_1": "<strong>Scenes to Parse:</strong> Arrastra y suelta aquí todas las escenas para analizar.",
  "li_content_2": "<strong>Prefab Folders:</strong> Especifica las carpetas con prefabs. Ahora es compatible con paginación y búsqueda para proyectos grandes.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Introduce aquí las cadenas que se crean exclusivamente en el código (por ejemplo, \"Game Over\").",
  "li_content_4": "<strong>Parsing Ignores:</strong> Especifica scripts, componentes u objetos a ignorar.",
  "li_content_5": "<strong>Pin:</strong> Esta función te permite \"fijar\" un objeto de la escena a la lista de ignorados. En lugar de una referencia temporal al objeto, la herramienta guardará su ruta completa en la jerarquía, haciendo que la exclusión sea persistente entre sesiones.",
  "h2_tab_actions": "4.4. Pestaña \"Acciones\"",
  "p_actions_1": "La pestaña de trabajo principal.",
  "li_actions_1": "<strong>Update Keys:</strong> Ejecuta el analizador, que actualiza tus archivos de traducción.",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Abre una ventana separada y más conveniente para editar todas las traducciones.",
  "li_actions_3": "<strong>Data Management:</strong> Úsalo para intercambiar datos con los traductores (Exportar/Importar a CSV/XML/YAML/XLIFF, importar desde Google Sheets).",
  "li_actions_4": "<strong>Auto-Translation:</strong> Rellena automáticamente todas las cadenas de traducción vacías utilizando el <strong>Perfil de Traducción</strong> activo.",
  "li_actions_5": "<strong>Danger Zone:</strong> Contiene botones para eliminar por completo todos los componentes de localización del proyecto. ¡Úsalo con precaución!",
  "h2_tab_assets": "4.5. Pestaña \"Assets\"",
  "p_assets_1": "Esta pestaña está dedicada por completo a la localización de recursos no textuales.",
  "li_assets_1": "<strong>Crea una estructura de carpetas (opcional):</strong> En la sección <strong>2. Asset Folder Generation</strong>, haz clic en <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Configura categorías y reglas de nomenclatura:</strong> En la sección <strong>3. Asset Categories & Scanning</strong>, asegúrate de que la <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) coincida con tus archivos (por ejemplo, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Coloca tus assets:</strong> Pon los assets localizados en las carpetas.",
  "li_assets_4": "<strong>Escanea los assets:</strong> En la sección <strong>4. Automation</strong>, haz clic en <strong>Scan Assets & Update Tables</strong>. El proceso de limpieza se ha vuelto más seguro: ahora solo se eliminan los archivos de tabla antiguos (<code>.asset</code>), no toda la carpeta.",
  "li_assets_5": "<strong>Vincula los assets a los objetos:</strong> Haz clic en <strong>Analyze Project & Attach Components</strong>.",
  "h2_tab_report": "4.6. Pestaña \"Informe\"",
  "p_report_1": "Después de cada análisis, este informe muestra una imagen completa del estado de tu localización.",
  "li_report_1": "<strong>Categorías:</strong> Todas las Claves, Añadidas, Actualizadas (texto cambiado), Eliminadas, Duplicadas, Migradas, Omitidas (sin cambios).",
  "li_report_2": "<strong>Búsqueda Avanzada:</strong> Haz clic en el botón <strong>Find</strong> junto a cualquier entrada para encontrar instantáneamente el objeto correspondiente en el proyecto. La búsqueda funciona de forma asíncrona, sin bloquear el editor, y busca en todas las escenas y prefabs.",
  "h1_translation_editor": "Editor de Tablas de Traducción",
  "p_editor_1": "Se abre a través de <strong>Tools -> Localization -> Translation Table Editor</strong>. Esta es la herramienta principal para editar manualmente las traducciones.",
  "li_editor_1": "<strong>Agrupación Inteligente:</strong> Las claves para plurales y género (por ejemplo, <code>apple_count_one</code>, <code>apple_count_few</code>) se combinan automáticamente en grupos plegables.",
  "li_editor_2": "<strong>Edición Avanzada:</strong> Haz clic en una celda para abrir la ventana emergente <strong>MultiLineEditWindow</strong>. Muestra el texto fuente para comparar y valida los marcadores de posición.",
  "li_editor_3": "<strong>Selección Avanzada (Nuevo):</strong> Admite la selección de celdas individuales, filas o columnas enteras (idiomas).",
  "li_editor_4": "<strong>Acciones Masivas (Nuevo):</strong> Haz clic con el botón derecho en una selección para realizar operaciones masivas: Traducción Automática de celdas seleccionadas, Borrar contenido o Eliminar claves.",
  "li_editor_5": "<strong>Navegación Inteligente (Nuevo):</strong> Navega por la tabla usando las flechas del teclado y atajos (Ctrl+S para guardar, Ctrl+Z/Y para Deshacer/Rehacer).",
  "li_editor_6": "<strong>Comprobación de Longitud (Nuevo):</strong> Utiliza el filtro \"Has Length Issues\" para resaltar las traducciones que son significativamente más largas que el texto de origen (umbral configurable).",
  "h1_ai_profiles": "Perfiles de IA y Traducción (Nuevo v1.1)",
  "h2_ai_profiles_overview": "6.1. Perfiles de Traducción",
  "p_ai_intro": "La versión 1.1 introduce un nuevo sistema de <strong>Perfiles de Traducción</strong> (ScriptableObject). Esto mueve la configuración del servicio de traducción fuera de la configuración global a assets de perfil individuales, lo que le permite cambiar de configuración fácilmente.",
  "li_ai_1": "<strong>Crear Perfil:</strong> Clic derecho en la vista Proyecto -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Servicios:</strong> Compatible con DeepL, Google Translate, Microsoft Azure e <strong>IA Personalizada</strong>.",
  "li_ai_3": "<strong>Configuración:</strong> Cada perfil almacena su propia clave de API, límites (tamaño de lote, caracteres máximos) y configuración del modelo.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Utilice el generador integrado para crear rápidamente perfiles para servicios populares (OpenAI, Gemini, Claude, Ollama).",
  "h2_custom_ai": "6.2. IA y Modelos Personalizados",
  "p_custom_ai": "El tipo de servicio <strong>Custom AI</strong> le permite conectar cualquier LLM a través de la API REST.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Una implementación flexible que puede comunicarse con API compatibles con OpenAI (incluidos LLM locales a través de Ollama).",
  "li_custom_ai_2": "<strong>Plantillas:</strong> Personalice la plantilla JSON del cuerpo de la solicitud para que coincida con los requisitos de su API.",
  "h2_ai_context": "6.3. Contexto y Glosario",
  "p_ai_context": "Para mejorar la calidad de la traducción, la IA ahora recibe contexto adicional:",
  "li_context_1": "<strong>Notas del Desarrollador:</strong> Los comentarios de la tabla de traducción se pasan a la IA como contexto.",
  "li_context_2": "<strong>Ruta del Objeto:</strong> Si no existe ningún comentario, la ruta de jerarquía del objeto (por ejemplo, <code>MainMenu/Canvas/StartButton</code>) se utiliza como contexto de reserva.",
  "li_context_3": "<strong>Glosario:</strong> Puede cargar un glosario CSV en el perfil para forzar traducciones específicas para términos y nombres.",
  "h2_ai_assistant": "6.4. Comandos del Asistente de IA",
  "p_ai_assistant": "En el Editor de Tablas de Traducción, ahora puede ejecutar comandos de IA personalizados en las celdas seleccionadas a través del menú contextual (Clic derecho -> AI: ...).",
  "li_assistant_1": "<strong>Configurable:</strong> Defina comandos en su Perfil de Traducción (por ejemplo, \"Corregir Gramática\", \"Hacer Formal\", \"Acortar para UI\").",
  "li_assistant_2": "<strong>Procesamiento por Lotes:</strong> Seleccione varias celdas para aplicar el comando a todas ellas a la vez.",
  "h1_usage_examples": "Ejemplos de Uso",
  "h2_example_components": "7.1. Componentes y Ejemplos Listos para Usar",
  "p_example_components_1": "El proyecto incluye scripts listos para usar que sirven como excelentes ejemplos.",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Un componente listo para usar para crear una lista desplegable de interfaz de usuario para cambiar de idioma. Encuentra automáticamente todos los idiomas disponibles y gestiona su cambio.<br><strong>Cómo usarlo:</strong> Simplemente añade el componente <code>LanguageSelector</code> a tu escena (por ejemplo, en un GameObject vacío) y especifica tu <code>TMP_Dropdown</code> en el inspector.",
  "li_example_components_2": "<strong>Ejemplos de Código:</strong> Para aprender técnicas avanzadas como trabajar con <code>[LocalizableField]</code>, la función <code>_()</code>, plurales y género, estudia los archivos <code>StatPurchaseTest.cs</code> y <code>TestLocalization.cs</code>. Demuestran claramente la implementación de todas las características principales de la herramienta en el código.",
  "h2_example_attribute": "7.2. Atributo [LocalizableField]",
  "p_example_attribute_1": "El método preferido para los textos que forman parte de la configuración de un componente en el inspector. El analizador ahora puede trabajar con cadenas, listas/arrays de cadenas, e incluso campos dentro de clases <code>[System.Serializable]</code> anidadas.",
  "code_example_attribute": "using Ankonoanko.Localization; // Requerido para [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // El analizador encontrará este campo y creará una clave para él\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"You have failed the quest.\";\n    \n    // Puedes establecer una clave personalizada\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Are you ready for an adventure?\";\n    \n    // Funciona con listas\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Find the treasure\" };\n    \n    // ¡E incluso con clases anidadas!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. Función _() y Atributo [OnLanguageChange]",
  "p_example_function_1": "Usa la función <code>_()</code> para el texto dinámico que cambia durante el juego. El método que actualiza la interfaz de usuario debe marcarse con el atributo <code>[OnLanguageChange]</code> para que se llame automáticamente cuando se cambie el idioma. Se añadirá automáticamente un componente <code>LocalizedBehaviour</code> al objeto para este propósito.",
  "code_example_function": "// Para usar la llamada corta _(), añade estas líneas\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Requerido para [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Actualización inicial\n    }\n    \n    // Este método se llamará automáticamente cuando cambie el idioma\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Marcadores de posición indexados (como en string.Format)\n        // Clave: \"score_label\", Texto en el archivo: \"Score: {0}\"\n        scoreText.text = _(\"score_label\", score); // Resultado: \"Score: 100\"\n        \n        // 2. Marcadores de posición con nombre (recomendado para legibilidad)\n        // Clave: \"welcome_message\", Texto: \"Welcome, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Para casos complejos o alto rendimiento\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. Plurales y Género",
  "p_example_plurals_1": "La herramienta ahora utiliza reglas más precisas para diferentes grupos de idiomas.",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Claves: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Textos: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Selecciona automáticamente la forma correcta\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Claves: \"user_greeted_male\", \"user_greeted_female\"\n        // Textos: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "Notas y Advertencias Importantes",
  "li_notes_1": "<strong>Copias de Seguridad:</strong> Antes de operaciones globales (<code>Update Keys</code>, importación de datos), siempre crea una copia de seguridad a través de <strong>Translation Table Editor -> Manage Backups</strong>.",
  "li_notes_2": "<strong>Seguridad de la Clave de API:</strong> La clave para trabajar en el editor se almacena localmente en tu máquina (en <code>EditorPrefs</code>) y no entra en el repositorio. Para las claves necesarias en la compilación del juego, utiliza la sección <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Carpeta <code>StreamingAssets</code>:</strong> Los archivos de traducción deben estar en una subcarpeta de <code>Assets/StreamingAssets/</code> para ser incluidos en la compilación del juego.",
  "li_notes_4": "<strong>\"A prueba de tontos\":</strong> La herramienta te protege automáticamente de guardar accidentalmente datos temporales del modo de vista previa en una escena o prefab.",
  "li_notes_5": "<strong>Rendimiento:</strong> La llamada a <code>_()</code> es rápida, pero en bucles que se ejecutan en cada fotograma (por ejemplo, en <code>Update</code>), intenta almacenar en caché el resultado en una variable.",
  "li_notes_6": "<strong>Excluir <code>LanguageSelector</code> del análisis:</strong> El objeto con el componente <code>LanguageSelector</code> y su <code>TMP_Dropdown</code> debe añadirse a la lista <strong>Ignore Specific Objects</strong> en la pestaña <strong>Content</strong>. Esto es necesario para evitar que el analizador cree claves adicionales para las opciones del desplegable, ya que el script <code>LanguageSelector</code> las rellena dinámicamente en tiempo de ejecución. Ignorarlo evita conflictos y mantiene limpios los archivos de traducción.",
  "li_notes_7": "<strong>Fuentes para <code>LanguageSelector</code>:</strong> Para que el idioma seleccionado en el <code>TMP_Dropdown</code> actualice correctamente su fuente, añade manualmente un componente <code>LocalizedText</code> vacío al objeto hijo <strong>Label</strong> del Dropdown y marca la casilla <code>isStyleOnly</code>.",
  "h1_extending": "Ampliar Funcionalidad",
  "h2_custom_parser": "9.1. Crear un Analizador Personalizado",
  "p_custom_parser_1": "Puedes ampliar fácilmente el sistema para admitir componentes personalizados creando tu propia clase de analizador.",
  "li_custom_parser_1": "Crea un nuevo script de C# en la carpeta <strong>Editor</strong> de tu proyecto.",
  "li_custom_parser_2": "Copia la plantilla de abajo en él.",
  "li_custom_parser_3": "Modifica la lógica para que coincida con tu componente.",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// PLANTILLA para crear un analizador para un componente personalizado.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Comprueba si el objeto tiene el componente personalizado que necesitamos.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Sal si no se encuentra el componente\n        }\n        \n        // 2. Obtén el texto de los campos del componente personalizado.\n        string titleText = component.Title;\n        \n        // 3. Comprueba si el texto es válido para la localización.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Genera la clave y la fuente usando los ayudantes de TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Devuelve el resultado.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repite para otros campos...\n        // (se puede añadir un sufijo para que las claves sean únicas)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQ y Solución de Problemas",
  "h2_faq_installation": "10.1. Instalación e Inicio Rápido",
  "q_faq_installation_1": "¿Qué sucede si mi proyecto ya tiene el paquete com.unity.nuget.newtonsoft-json de otro asset? ¿Intentará el instalador de dependencias actualizarlo o lo ignorará?",
  "a_faq_installation_1": "El instalador comprueba la existencia del tipo Newtonsoft.Json.JsonConvert. Si el tipo existe, considera que la dependencia está satisfecha y no intentará instalar o actualizar el paquete. Esto se hace para evitar conflictos de versiones.",
  "q_faq_installation_2": "Accidentalmente hice clic en \"Omitir por ahora\" y marqué \"No volver a preguntar\" para las dependencias opcionales (por ejemplo, para el soporte de CSV). ¿Cómo puedo volver a abrir la ventana del instalador para instalarlas?",
  "a_faq_installation_2": "Puedes activar manualmente una comprobación de dependencias en cualquier momento a través del menú Tools -> Localization -> Check Dependencies. Esto restablecerá la bandera \"No volver a preguntar\" y volverá a mostrar la ventana con todos los paquetes opcionales que falten.",
  "q_faq_installation_3": "La herramienta no creó LocalizationSettings.asset en Assets/Resources. ¿Por qué podría haber sucedido esto y puedo crearlo manualmente a través del menú Assets -> Create?",
  "a_faq_installation_3": "Esto puede suceder si no tienes una carpeta Assets/Resources. La herramienta intentará crearla, pero los permisos del sistema de archivos podrían impedirlo. Sí, puedes crear el asset manualmente: haz clic con el botón derecho en la carpeta Resources, selecciona Create -> Localization -> Settings. La herramienta lo encontrará automáticamente.",
  "q_faq_installation_4": "¿Puedo mover el archivo LocalizationSettings.asset a otra carpeta Resources, por ejemplo, Assets/MyGame/Resources? ¿La herramienta lo seguirá encontrando?",
  "a_faq_installation_4": "Sí. La herramienta utiliza Resources.Load(), que busca un asset por nombre en todas las carpetas llamadas Resources de tu proyecto. Lo importante es que el archivo conserve su nombre LocalizationSettings.asset.",
  "q_faq_installation_5": "El instalador de dependencias se congeló o dio un error. ¿Puedo instalar las dependencias (Newtonsoft Json, Editor Coroutines) manualmente a través del Unity Package Manager?",
  "a_faq_installation_5": "Sí. Puedes abrir Window -> Package Manager, hacer clic en el icono \"+\", y seleccionar \"Add package by name...\". Introduce los nombres de los paquetes: com.unity.nuget.newtonsoft-json y com.unity.editorcoroutines.",
  "h2_faq_components": "10.2. Componentes Principales",
  "q_faq_components_1": "El componente LocalizedPrefab deshabilita los MonoBehaviours en el objeto original. ¿Qué pasa si el objeto original tiene un script que crea otros objetos o se suscribe a eventos en Awake()? ¿Se ejecutará este código?",
  "a_faq_components_1": "No, no lo hará. Deshabilitar un MonoBehaviour evita que se llamen todos los métodos \"mágicos\" de Unity, incluidos Awake(), OnEnable() y Start(). Esto es intencional para evitar la ejecución de lógica duplicada. Toda la inicialización debe ocurrir en scripts en las versiones localizadas del prefab.",
  "q_faq_components_2": "Si el prefab original (LocalizedPrefab) tiene un Rigidbody u otro componente de física, ¿será deshabilitado? ¿Afectará esto a la física si el prefab localizado no lo tiene?",
  "a_faq_components_2": "Sí, el comportamiento físico del objeto original será neutralizado. El componente LocalizedPrefab encuentra todos los componentes Rigidbody y Rigidbody2D en su GameObject y establece su propiedad isKinematic en verdadero. Esto los elimina eficazmente de los cálculos de física dinámica, previniendo comportamientos no deseados como un objeto invisible que cae o reacciona a colisiones. Todavía se recomienda que la versión localizada del prefab contenga todos los componentes de física necesarios para un comportamiento correcto.",
  "q_faq_components_3": "El componente LocalizedAsset almacena el nombre del componente de destino como una cadena (_targetComponentTypeName). ¿Qué sucede si renombro un script de componente personalizado o lo muevo a otro ensamblado (Assembly Definition)? ¿Dejará de funcionar LocalizedAsset para él?",
  "a_faq_components_3": "Sí, dejará de funcionar. El componente almacena el nombre completo del tipo, incluido el espacio de nombres y el ensamblado. Renombrar el script o moverlo a otro .asmdef cambiará este nombre, y LocalizedAsset no podrá encontrar el componente de destino. Necesitarás ejecutar otro análisis a través de Analyze Project & Attach Components para que actualice el nombre.",
  "q_faq_components_4": "Si hay dos componentes Image en el mismo GameObject, ¿cómo sabe LocalizedAsset cuál localizar? ¿Funcionará con ambos o solo con el primero que encuentre?",
  "a_faq_components_4": "Un LocalizedAsset se crea para una instancia de componente específica. Mantiene una referencia a ese componente en el código. Si añades manualmente un segundo LocalizedAsset y utilizas el menú contextual \"Analyze for Localization\" para apuntar a la segunda Image, tendrás dos componentes LocalizedAsset, cada uno gestionando su propia Image. El analizador automático solo creará un componente para la primera Image con un asset localizable que encuentre.",
  "q_faq_components_5": "La documentación indica que LocalizedPrefab tiene un orden de ejecución de -100. ¿Qué pasa si tengo otro script con un orden de ejecución de -110 que intenta encontrar un objeto hijo creado por LocalizedPrefab en su Awake()? ¿Habrá instanciado LocalizedPrefab su instancia a tiempo?",
  "a_faq_components_5": "Sí, lo hará. LocalizedPrefab crea la instancia del prefab localizado en su método OnEnable(). El orden de ejecución de Unity garantiza que todos los métodos Awake() se ejecutan antes que todos los métodos OnEnable(). Por lo tanto, tu script con orden -110 ejecutará su Awake(), luego LocalizedPrefab con orden -100 ejecutará su Awake(), y solo después de eso se llamarán sus métodos OnEnable() en orden. Tu script no encontrará el objeto porque aún no se habrá creado.",
  "q_faq_components_6": "El componente LocalizedText tiene una opción isStyleOnly. Si la habilito y luego llamo a myLocalizedText.SetFormattedText(\"new_key\") en el código, ¿cambiará el texto o solo el estilo (fuente/RTL)?",
  "a_faq_components_6": "Tanto la clave como el texto cambiarán. Llamar a SetFormattedText programáticamente anula el comportamiento de isStyleOnly para esa actualización específica. La opción isStyleOnly está destinada a evitar que el componente reaccione a los cambios globales de idioma, pero siempre reaccionará a un cambio de clave directo a través del código.",
  "q_faq_components_7": "LocalizedBehaviour encuentra automáticamente métodos con el atributo [OnLanguageChange]. ¿Encontrará métodos privados y protegidos, o deben ser públicos?",
  "a_faq_components_7": "Encontrará métodos con cualquier modificador de acceso (público, privado, protegido, interno). La reflexión en Unity permite el descubrimiento de todos los métodos de instancia independientemente de su nivel de acceso.",
  "q_faq_components_8": "El componente LocalizedAsset intercepta Play on Awake. ¿Qué sucede si otro script en el mismo objeto intenta acceder al asset (por ejemplo, audioSource.clip.length) en Awake() o Start() antes de que LocalizedAsset lo haya intercambiado? ¿Es posible una NullReferenceException o el uso del asset antiguo?",
  "a_faq_components_8": "Es posible el uso del asset antiguo (no localizado). LocalizedAsset realiza el intercambio en su OnEnable(). Los métodos Awake() de todos los scripts se ejecutan antes de OnEnable(). Si tu script accede a audioSource.clip en Awake(), obtendrá el clip original. Si accede a él en Start(), el resultado dependerá del orden de ejecución del script. Para garantizar el acceso al asset localizado, establece un orden de ejecución posterior para tu script o accede al asset en un método marcado con [OnLanguageChange].",
  "h2_faq_window": "10.3. Ventana \"Localization Tool\"",
  "h3_faq_window_preview": "Vista Previa en el Editor",
  "q_faq_window_preview_1": "Abrí un prefab en Modo Prefab, apliqué la Vista Previa en el Editor y presioné Ctrl+S. ¿Se guardarán los datos de vista previa temporales en el asset del prefab? ¿Cómo maneja LocalizationPreviewProtector este caso?",
  "a_faq_window_preview_1": "No, no se guardará. LocalizationPreviewProtector intercepta el evento de guardado del asset (OnWillSaveAssets) y llama automáticamente a RevertEditorPreview() antes de que Unity escriba los cambios en el disco. Por lo tanto, el prefab se guardará en su estado original y no localizado.",
  "q_faq_window_preview_2": "Si habilito la Vista Previa en el Editor y el editor de Unity se cierra inesperadamente, y el archivo Temp/localization_preview_recovery.json se corrompe (por ejemplo, vacío o con JSON no válido), ¿qué sucederá en el próximo inicio?",
  "a_faq_window_preview_2": "PreviewCrashProtector está envuelto en un bloque try-catch. Si la deserialización de JSON falla, se registrará un error en la consola sobre la imposibilidad de recuperar, y el proceso terminará silenciosamente. Tu escena permanecerá en el estado \"roto\" en el que estaba en el momento del cierre. En este caso, deberás seleccionar manualmente \"Revert to Original\" en la ventana de la herramienta para forzar una reversión de los cambios.",
  "q_faq_window_preview_3": "En el modo de Vista Previa en el Editor para LocalizedPrefab, se crea una instancia temporal. ¿Se ejecutarán los métodos Awake() y Start() en esta instancia? ¿Podría esto causar errores si no están diseñados para ejecutarse en Modo Edición?",
  "a_faq_window_preview_3": "Sí, lo harán. PrefabUtility.InstantiatePrefab en Modo Edición llama a Awake() y OnEnable(). Si estos métodos contienen lógica que no debería ejecutarse en el editor (por ejemplo, acceder a singletons que solo existen en Modo Juego), podría causar errores. Se recomienda usar if (Application.isPlaying) o #if UNITY_EDITOR para proteger dicho código.",
  "h3_faq_window_settings": "Pestaña \"Configuración\"",
  "q_faq_window_settings_1": "Puedo cambiar el Key Generation Mode de UseTextAsKey a AutoGenerateKeysOnly a mitad del proyecto. ¿Qué pasará exactamente con mis traducciones existentes? ¿Se asignarán a las nuevas claves?",
  "a_faq_window_settings_1": "Sí, lo harán. Al cambiar el modo, la herramienta realiza una \"migración segura\": vuelve a analizar todo el proyecto, crea nuevas claves según las nuevas reglas, pero mapea las claves antiguas y nuevas a través del texto original. Luego transfiere todas tus traducciones y comentarios existentes de las claves antiguas a las nuevas. Tus traducciones no se perderán.",
  "q_faq_window_settings_2": "Si añado un idioma con un código que no tiene reglas de pluralización (por ejemplo, \"kz\" para kazajo) a la lista de Idiomas Soportados, ¿qué regla se usará por defecto?",
  "a_faq_window_settings_2": "Se utilizará la DefaultPluralRule, que es adecuada para el inglés y la mayoría de los idiomas europeos (formas para \"one\" y \"other\").",
  "q_faq_window_settings_3": "¿Qué pasa si especifico la Translations Path no en StreamingAssets, sino en una carpeta normal como Assets/MyTranslations? ¿Se incluirán los archivos json en la compilación del juego?",
  "a_faq_window_settings_3": "No, no lo harán. Solo los assets ubicados en una carpeta StreamingAssets o Resources tienen garantizada su inclusión en la compilación. Si especificas una ruta diferente, la localización funcionará en el editor pero no en el juego compilado, ya que los archivos de traducción no formarán parte de la compilación.",
  "q_faq_window_settings_4": "La clave de API de traducción automática se almacena en EditorPrefs. Si estoy trabajando en el proyecto en dos ordenadores diferentes, ¿necesito introducir la clave en cada máquina por separado?",
  "a_faq_window_settings_4": "Sí. EditorPrefs es un almacenamiento local para cada ordenador. Necesitarás introducir la clave de API en cada máquina desde la que planees usar la función de traducción automática.",
  "h3_faq_window_content": "Pestaña \"Contenido\"",
  "q_faq_window_content_1": "¿Qué pasa si añado una escena a Scenes to Parse que no está incluida en los Build Settings? ¿Afectará esto a algo más que al propio proceso de análisis?",
  "a_faq_window_content_1": "No, no lo hará. La lista Scenes to Parse se utiliza exclusivamente para que la herramienta sepa qué escenas abrir y analizar en busca de texto. No tiene ninguna relación con las escenas que terminarán en la compilación final de tu juego.",
  "q_faq_window_content_2": "Añadí un objeto a Ignore Specific Objects (la lista temporal). Si hago un prefab de este objeto, ¿se ignorará también la instancia de este prefab?",
  "a_faq_window_content_2": "No, no lo hará. La lista temporal almacena una referencia directa al objeto en la escena. Cuando creas un prefab, es un nuevo asset. Sus instancias son objetos diferentes, y la regla de ignorar no se aplicará a ellos. Para ignorar permanentemente los prefabs, deben añadirse a la lista de ignorados como un asset de prefab.",
  "q_faq_window_content_3": "Si añado el componente TMPro.TMP_Text a Parsing Ignores -> Ignore Component Types, pero hay un objeto en la escena con un LocalizedText que ya hace referencia a este TMP_Text, ¿qué pasará en el próximo Update Keys? ¿Se eliminará la clave?",
  "a_faq_window_content_3": "Sí, se eliminará. Cuando haces clic en Update Keys, el analizador vuelve a escanear todo el proyecto. Verá que el tipo TMPro.TMP_Text debe ser ignorado y no generará una clave para él. Durante el proceso de comparación de claves antiguas y nuevas, determinará que la clave antigua ya no se utiliza y la marcará como \"Eliminada\".",
  "q_faq_window_content_4": "La documentación dice que \"Pin\" guarda la ruta completa al objeto y se romperá si se le cambia el nombre. ¿Qué pasa si hago un prefab del objeto y luego renombro el objeto original? ¿\"Pin\" seguirá funcionando para las instancias del prefab?",
  "a_faq_window_content_4": "No, no lo hará. \"Pin\" guarda la ruta absoluta en la jerarquía de la escena en el momento en que se pulsa el botón (por ejemplo, Canvas/Panel/Button). Esta ruta no está relacionada con la lógica de los prefabs. Las instancias de prefabs tendrán la misma ruta, pero si cambias el nombre del objeto padre en la escena, \"Pin\" dejará de funcionar tanto para el original como para las instancias.",
  "q_faq_window_content_5": "Si uso \"Pin\" para un objeto hijo dentro de una instancia de prefab, ¿qué ruta se guardará: relativa a la raíz del prefab o a la raíz de la escena? ¿Funcionará en otras escenas?",
  "a_faq_window_content_5": "Se guardará la ruta completa desde la raíz de la escena. Por ejemplo, MyPrefab(Clone)/Content/Icon. Esta ruta \"fijada\" solo funcionará en la escena donde la creaste. En otras escenas, es poco probable que se encuentre dicha ruta.",
  "h3_faq_window_actions": "Pestaña \"Acciones\"",
  "h3_faq_window_assets": "Pestaña \"Assets\"",
  "h3_faq_window_report": "Pestaña \"Informe\"",
  "h2_faq_editor": "10.4. Editor de Traducciones",
  "h2_faq_examples": "10.5. Ejemplos de Uso y Código",
  "h2_faq_notes": "10.6. Matices y Advertencias Importantes",
  "h2_faq_extending": "10.7. Ampliar Funcionalidad",
  "q_faq_window_actions_1": "¿Qué sucede si se pierde la conexión a internet durante una traducción automática por lotes? ¿Intentará la herramienta reintentar el lote fallido según la Política de Reintentos, o se interrumpirá por completo el proceso?",
  "a_faq_window_actions_1": "La herramienta intentará reenviar el lote exacto que falló, según la configuración de la Política de Reintentos (número de intentos y retraso). Si todos los intentos para este lote fallan, el proceso de traducción para el idioma actual se interrumpirá y se registrará un error en la consola. La traducción para los siguientes idiomas en la cola no comenzará.",
  "q_faq_window_actions_2": "Si importo un archivo CSV que contiene claves que ya existen en el proyecto pero con valores vacíos para algunos idiomas, ¿reemplazarán estos valores vacíos mis traducciones existentes o serán ignorados?",
  "a_faq_window_actions_2": "Los valores vacíos reemplazarán las traducciones existentes. El proceso de importación considera el archivo CSV como la \"fuente de la verdad\". Si el valor para la clave welcome_message en la columna ru está vacío, la traducción actual al ruso para esta clave será sobrescrita.",
  "q_faq_window_actions_3": "La sección \"Danger Zone\" permite eliminar todos los componentes. ¿Eliminará componentes de prefabs que están en carpetas no especificadas en las Carpetas de Prefabs en la pestaña Contenido?",
  "a_faq_window_actions_3": "Sí, lo hará. Las funciones de la \"Danger Zone\" escanean todos los prefabs del proyecto (AssetDatabase.FindAssets(\"t:Prefab\")), no solo los especificados en la lista de análisis, para garantizar la limpieza más completa posible.",
  "q_faq_window_actions_4": "Al importar desde Google Sheets, ¿cómo debo formatear la columna de comentarios para que funcione la validación de marcadores de posición usando la directiva @placeholders:?",
  "a_faq_window_actions_4": "En tu documento de Google Sheets, la columna debe titularse \"Developer Notes\". En las celdas de esta columna, puedes escribir comentarios como de costumbre. Para especificar marcadores de posición, simplemente añade una línea como @placeholders: {username}, {score} en el texto del comentario. La herramienta reconocerá automáticamente esta directiva al importar.",
  "q_faq_window_actions_5": "¿Puede la herramienta importar datos de varias hojas de un solo documento de Google Sheets, o solo funciona con una hoja por GID?",
  "a_faq_window_actions_5": "La herramienta solo funciona con una hoja a la vez. La URL de importación incluye un parámetro gid=..., que identifica de forma única una hoja específica en el documento. Para importar datos de otra hoja, necesitas copiar su URL (con un gid diferente) y volver a realizar la importación.",
  "q_faq_window_assets_1": "¿Qué pasa si tengo dos assets con la misma clave pero de diferente tipo en la misma carpeta de escaneo (por ejemplo, sound_effect_en.mp3 y sound_effect_en.wav)? ¿Cuál de ellos terminará en la tabla de assets?",
  "a_faq_window_assets_1": "El escáner de assets los carga especificando el tipo esperado (AssetDatabase.LoadAssetAtPath(path, expectedType)). Para la categoría AudioClip, solo buscará y cargará archivos que Unity reconozca como AudioClips. Si ambos archivos son clips de audio válidos, el que se procese en último lugar se incluirá en la tabla, sobrescribiendo efectivamente el anterior. Se recomienda evitar tales duplicados.",
  "q_faq_window_assets_2": "Si hago clic en Scan Assets & Analyze Project, y hay un objeto Image en la escena para el cual ya existe un sprite localizado, pero el objeto Image en sí aún no tiene un componente LocalizedAsset, ¿añadirá la herramienta el componente e insertará automáticamente la clave?",
  "a_faq_window_assets_2": "Sí, así es exactamente como funciona. \"Analyze Project\" encuentra el componente Image, mira el nombre del sprite que tiene asignado (por ejemplo, icon_play_en), extrae la clave (icon_play) y el idioma (en) de él, y luego añade un componente LocalizedAsset a ese GameObject y escribe la clave icon_play en él.",
  "q_faq_window_assets_3": "¿Puedo usar la misma Regla de Nomenclatura para diferentes categorías de assets si tienen diferentes Carpetas de Escaneo? ¿Causará esto conflictos?",
  "a_faq_window_assets_3": "Sí, puedes. No habrá conflictos, ya que se crea una tabla de assets separada (LocalizedAssetTable) para cada categoría. Las claves de la categoría \"Sprites\" no se superponen con las claves de la categoría \"AudioClips\", incluso si se nombran igual.",
  "q_faq_window_assets_4": "Si un asset localizable (por ejemplo, button_ok_en.png) no está en la raíz de la Carpeta de Escaneo, sino en una subcarpeta, ¿lo encontrará el escáner?",
  "a_faq_window_assets_4": "Sí, lo hará. El escáner utiliza la opción SearchOption.AllDirectories, lo que significa que comprobará recursivamente todas las subcarpetas dentro de la Carpeta de Escaneo que especifiques.",
  "q_faq_window_report_1": "El botón \"Buscar\" busca el objeto de forma asíncrona. ¿Qué pasa si inicio una búsqueda y luego hago clic inmediatamente en Update Keys? ¿Se interrumpirá la búsqueda?",
  "a_faq_window_report_1": "Sí, se interrumpirá. Cualquier nueva acción que requiera el bloqueo de la interfaz de usuario (como Update Keys) detendrá la corrutina de búsqueda actual. Aparecerá un cuadro de diálogo que te pedirá que detengas la búsqueda actual para iniciar una nueva.",
  "q_faq_window_report_2": "Si una clave se utiliza en varios lugares (por ejemplo, en dos botones diferentes en escenas distintas), ¿cómo se mostrará esto en el informe en la categoría \"Duplicados\"?",
  "a_faq_window_report_2": "La categoría \"Duplicados\" mostrará todas las fuentes para esa clave. Verás una entrada para la clave, y el campo \"Source\" listará todas las rutas (en la escena 1 y en la escena 2). El botón \"Buscar\" en este caso abrirá una lista desplegable, permitiéndote elegir a qué objeto navegar.",
  "q_faq_window_report_3": "Si hago clic en \"Buscar\" para una clave que solo se usa en el código (a través de la función _()), ¿qué sucederá? ¿Podrá la herramienta encontrar y resaltar el script de C#?",
  "a_faq_window_report_3": "Sí. El sistema de búsqueda está específicamente entrenado para reconocer fuentes como script MyScript.cs. Cuando hagas clic en \"Buscar\", buscará el asset MyScript.cs en el proyecto y lo resaltará (hará ping) en la ventana del Proyecto.",
  "q_faq_editor_1": "¿Qué tiene mayor prioridad para la validación de marcadores de posición: la directiva @placeholders: en el comentario o los marcadores de posición encontrados en el texto del idioma de origen? Por ejemplo, si el texto de origen tiene {name} y el comentario dice @placeholders: {username}.",
  "a_faq_editor_1": "La directiva @placeholders: en el comentario tiene prioridad. Se considera una instrucción explícita del desarrollador y la \"fuente de la verdad\". En tu ejemplo, el editor requerirá {username} en la traducción e ignorará {name} del texto de origen.",
  "q_faq_editor_2": "Si cometo un error tipográfico en la directiva (por ejemplo, @placeholder: en lugar de @placeholders:), ¿será ignorado o la herramienta emitirá una advertencia?",
  "a_faq_editor_2": "Simplemente será ignorado. La herramienta busca una coincidencia exacta de @placeholders:. Si la directiva está mal escrita, se tratará como parte de un comentario regular, y la validación funcionará a la antigua, basándose en los marcadores de posición del texto de origen.",
  "q_faq_editor_3": "El sistema de autoguardado crea archivos en la carpeta Backups/AutoSaves. ¿Se eliminarán estos archivos automáticamente después de un guardado manual exitoso o al cerrar la ventana?",
  "a_faq_editor_3": "Sí. Tras un guardado manual exitoso o el cierre normal de la ventana (cuando guardas los cambios), todos los archivos de autoguardado se eliminan para evitar solicitar una recuperación en el próximo inicio. Solo permanecen en caso de un cierre inesperado del editor.",
  "q_faq_editor_4": "Si cambio el ancho de las columnas en el editor, ¿se guardarán estas configuraciones entre sesiones de Unity?",
  "a_faq_editor_4": "Sí. El ancho de las columnas se guarda en EditorPrefs cada vez que cierras la ventana del editor de traducciones y se restaurará la próxima vez que la abras.",
  "q_faq_editor_5": "¿La ventana emergente de edición de texto (MultiLineEditWindow) admite su propia pila de Deshacer/Rehacer (a través de Ctrl+Z) para los cambios realizados dentro de ella?",
  "a_faq_editor_5": "Sí. La MultiLineEditWindow tiene su propia pila temporal de Deshacer/Rehacer que funciona mientras la ventana está abierta. Esto te permite deshacer y rehacer cambios de texto dentro de esa ventana. Una vez que guardas el resultado (cerrando la ventana), este cambio se registra como una sola acción en la pila global de Deshacer/Rehacer del editor principal.",
  "q_faq_examples_1": "¿Qué sucede si los nombres de las propiedades en el tipo anónimo pasado a la función _() no coinciden con los marcadores de posición en la cadena? Por ejemplo, _(\"Hola, {username}\", new { user_name = \"Bob\" }). ¿Habrá un error o el marcador de posición simplemente no se reemplazará?",
  "a_faq_examples_1": "No habrá ningún error. El marcador de posición {username} simplemente no será reemplazado, y obtendrás la cadena \"Hola, {username}\" como resultado. El reemplazo solo ocurre con una coincidencia exacta de nombres.",
  "q_faq_examples_2": "El atributo [LocalizableField] funciona para campos privados. ¿Funcionará para campos estáticos?",
  "a_faq_examples_2": "Sí, lo hará. El analizador utiliza la reflexión para encontrar campos con las banderas BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, por lo que encontrará y procesará campos estáticos.",
  "q_faq_examples_3": "Si pongo el atributo [OnLanguageChange] en un método con parámetros (por ejemplo, void UpdateUI(string newLang)), ¿qué sucederá? ¿Habrá un error de compilación o una advertencia en tiempo de ejecución?",
  "a_faq_examples_3": "No habrá ningún error de compilación, pero aparecerá una advertencia de LocalizedBehaviour en la consola de Unity en tiempo de ejecución. Informará que encontró un método con el atributo pero lo ignoró porque el método tiene parámetros. Dicho método no será llamado.",
  "q_faq_examples_4": "Estoy usando _(\"apple_count\", count). Si no hay una clave apple_count_one para el idioma actual (para count = 1), ¿qué forma elegirá el sistema? ¿Usará apple_count_other como alternativa?",
  "a_faq_examples_4": "Sí. Si no se encuentra una forma específica (_one, _few, etc.), el sistema intentará usar la clave con el sufijo _other como alternativa. Si tampoco se encuentra, se utilizará la traducción para la clave base apple_count.",
  "q_faq_examples_5": "La función _(\"key\", new { username = \"Alex\" }) utiliza un tipo anónimo. ¿No creará esto una \"carga\" excesiva en el recolector de basura (GC) con llamadas frecuentes en un método Update() en comparación con pasar un Dictionary<string, object> pre-creado?",
  "a_faq_examples_5": "Sí, lo hará. Cada llamada a new { ... } asigna memoria en el montón administrado, lo que crea trabajo extra para el recolector de basura. Para el texto que se actualiza en cada fotograma (en Update o LateUpdate), es significativamente más eficiente crear un Dictionary<string, object> una vez en Start(), y solo actualizar sus valores en Update() antes de pasarlo a la función _().",
  "q_faq_notes_1": "La documentación recomienda añadir LanguageSelector a la lista de ignorados. ¿Qué se romperá concretamente si me olvido de hacerlo? ¿Se crearán claves adicionales para \"Opción A, Opción B\"?",
  "a_faq_notes_1": "Sí. Si no añades LanguageSelector a la lista de ignorados, el analizador tratará su TMP_Dropdown como un desplegable normal. Encontrará las opciones predeterminadas \"Opción A, Opción B, Opción C\" que Unity crea y añadirá claves para ellas a tus archivos de traducción. Esto llenará tus archivos de claves innecesarias, ya que LanguageSelector eliminará estas opciones en tiempo de ejecución y creará las suyas de todos modos.",
  "q_faq_notes_2": "Si me olvido de añadir un LocalizedText vacío con la casilla isStyleOnly marcada en la Etiqueta dentro del TMP_Dropdown utilizado por LanguageSelector, ¿no cambiará la fuente? ¿Por qué es esto necesario?",
  "a_faq_notes_2": "Sí, la fuente no cambiará. Esto es necesario porque LanguageSelector cambia directamente la propiedad label.text. Sin un LocalizedText en este objeto, el sistema de localización no sabe que a este elemento se le deben aplicar estilos (fuente, RTL) cuando cambia el idioma. Un LocalizedText vacío con isStyleOnly sirve como un \"marcador\" para el sistema, diciendo: \"Vigila este objeto y aplícale estilos, pero no toques su texto\".",
  "q_faq_notes_3": "No se recomienda llamar a _() en el método Update(). Pero, ¿qué pasa si necesito actualizar el texto en cada fotograma (por ejemplo, un temporizador)? ¿Cuál es la forma más eficiente de hacerlo, almacenando en caché solo la cadena de formato?",
  "a_faq_notes_3": "El enfoque más eficiente es almacenar en caché la cadena de formato en Start() o en un método [OnLanguageChange], y usar string.Format normal en Update(). Ejemplo: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Esto evita buscar la clave en el diccionario en cada fotograma, lo cual es significativamente más rápido.",
  "q_faq_extending_1": "¿Se llamará mi analizador personalizado automáticamente después de cada Update Keys? ¿Necesito registrarlo en algún lugar, o es suficiente con tener una clase que implemente ITextComponentParser en el proyecto?",
  "a_faq_extending_1": "Solo tener la clase es suficiente. Cuando se ejecuta TextParser, utiliza la reflexión para encontrar todas las clases del proyecto que implementan la interfaz ITextComponentParser y llama automáticamente a su método Parse() para cada GameObject. No se requiere ningún registro manual.",
  "q_faq_extending_2": "¿Qué pasa si ocurre una excepción en mi analizador personalizado? ¿Interrumpirá todo el proceso de análisis, o la herramienta continuará de forma segura con otros analizadores?",
  "a_faq_extending_2": "Una excepción en tu analizador personalizado interrumpirá el proceso. El bucle de análisis principal no envuelve las llamadas a los analizadores personalizados en un bloque try-catch. Si tu método Parse() lanza una excepción no controlada, el proceso de análisis se detendrá.",
  "toggle_notes_title": "Alternar Notas",
  "mindmap_toggle_title": "Mostrar Mapa Mental",
  "on_this_page_title": "En Esta Página",
  "my_notes_title": "Mis Notas",
  "no_notes_message_new": "Pasa el cursor sobre el texto para añadir una nota.",
  "notes_add_title": "Añadir una nota a este bloque",
  "notes_placeholder": "Tu nota...",
  "notes_close_title": "Cerrar",
  "notes_goto_title": "Ir al texto",
  "notes_edit_title": "Editar nota",
  "notes_delete_title": "Eliminar nota",
  "notes_edit_text": "Editar",
  "copy_code_copy": "Copiar",
  "copy_code_copied": "¡Copiado!",
  "copy_code_error": "Error",
  "error_loading_title": "Error de Carga",
  "error_loading_message": "Por favor, comprueba tu conexión y actualiza.",
  "lightbox_aria_close": "Cerrar visor de imágenes",
  "lightbox_image_alt": "Vista ampliada",
  "mindmap_preset_full": "Vista Completa",
  "mindmap_preset_quick_start": "Inicio Rápido",
  "mindmap_preset_dev": "Flujo de Trabajo del Desarrollador",
  "mindmap_preset_translator": "Flujo de Trabajo del Traductor",
  "mindmap_edge_configure": "1. Configurar",
  "mindmap_edge_specify_content": "2. Especificar Contenido",
  "mindmap_edge_parse_project": "3. Analizar Proyecto",
  "mindmap_edge_creates_components": "Crea Componentes",
  "mindmap_edge_generates": "Genera",
  "mindmap_edge_opens": "Abre",
  "mindmap_edge_manages_assets": "Gestiona assets para",
  "mindmap_edge_defines_rules": "Define reglas para",
  "mindmap_edge_reports_on": "Informa sobre",
  "mindmap_edge_enables_reaction": "Permite reaccionar a través de",
  "mindmap_edge_processed_by": "Procesado por",
  "mindmap_edge_edited_in": "Editado en",
  "mindmap_edge_extends": "Extiende",
  "mindmap_edge_warns_about": "Advierte sobre",
  "mindmap_edge_relates_to": "Se relaciona con",
  "mindmap_edge_recommends_for": "Recomienda para",
  "mindmap_edge_see_faq": "Ver FAQ"
}