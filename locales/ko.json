{
  "page_title": "Unity Localization Tool 문서",
  "toc_title": "목차",
  "toc_search_placeholder": "문서 검색...",
  "nav_introduction": "1. 소개",
  "nav_quick_start": "2. 빠른 시작",
  "nav_components": "3. 핵심 구성 요소",
  "nav_loc_tool_window": "4. \"로컬라이제이션 도구\" 창",
  "nav_translation_editor": "5. 번역 편집기",
  "nav_ai_profiles": "6. AI 및 번역 프로필 (New v1.1)",
  "nav_usage_examples": "7. 사용 예시",
  "nav_important_notes": "8. 중요 참고 사항",
  "nav_extending": "9. 기능 확장",
  "nav_faq": "10. FAQ 및 문제 해결",
  "nav_migration_tool": "11. 마이그레이션 도구",
  "nav_font_glyph_manager": "12. 폰트 및 글리프 관리자",
  "nav_pseudo_tool": "13. 의사(Pseudo)-로컬라이제이션 도구",
  "nav_ai_audio": "14. AI 오디오 / 텍스트 음성 변환 (Text-to-Speech)",
  "nav_key_features": "주요 기능",
  "nav_installation": "2.1. 설치",
  "nav_initial_setup": "2.2. 초기 설정",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. 상황별 메뉴",
  "nav_in_editor_preview": "4.1. 에디터 내 및 프리팹 미리보기",
  "nav_tab_settings": "4.2. \"설정\" 탭",
  "nav_tab_content": "4.3. \"콘텐츠\" 탭 (재설계됨)",
  "nav_tab_actions": "4.4. \"액션\" 탭",
  "nav_tab_assets": "4.5. \"자산\" 탭",
  "nav_tab_report": "4.6. \"보고서\" 탭",
  "nav_ai_profiles_overview": "6.1. 번역 프로필",
  "nav_custom_ai": "6.2. 사용자 지정 AI 및 모델",
  "nav_ai_context": "6.3. 컨텍스트 및 용어집",
  "nav_ai_assistant": "6.4. AI 도우미 명령",
  "nav_example_components": "7.1. 미리 만들어진 구성 요소",
  "nav_example_attribute": "7.2. [LocalizableField] 속성",
  "nav_example_function": "7.3. _() 함수",
  "nav_example_plurals": "7.4. 복수형 및 성별",
  "nav_custom_parser": "9.1. 파서 생성",
  "nav_faq_installation": "10.1. 설치 및 빠른 시작",
  "nav_faq_components": "10.2. 핵심 구성 요소",
  "nav_faq_window": "10.3. \"로컬라이제이션 도구\" 창",
  "nav_faq_window_actions": "10.3. \"로컬라이제이션 도구\" 창 - \"액션\" 탭",
  "nav_faq_window_assets": "10.3. \"로컬라이제이션 도구\" 창 - \"자산\" 탭",
  "nav_faq_window_report": "10.3. \"로컬라이제이션 도구\" 창 - \"보고서\" 탭",
  "nav_faq_editor": "10.4. 번역 편집기",
  "nav_faq_examples": "10.5. 사용 예시 및 코드",
  "nav_faq_notes": "10.6. 중요한 뉘앙스 및 경고",
  "nav_faq_extending": "10.7. 기능 확장",
  "h1_introduction": "소개",
  "p_intro_1": "이 도구는 Unity에서 게임 및 응용 프로그램을 로컬라이즈하기 위한 포괄적인 솔루션입니다. 텍스트 및 자산 수집 프로세스를 자동화하고, 강력한 인터페이스를 통해 번역을 관리하며, 기계 번역 서비스(사용자 지정 AI 포함)와 통합하고, 게임에서 로컬라이즈된 콘텐츠를 동적으로 업데이트합니다.",
  "h2_key_features": "주요 기능",
  "li_feature_1": "<strong>고급 구문 분석(Advanced Parsing):</strong> 씬, 프리팹, UI 툴킷(UXML), C# 스크립트(<code>[LocalizableField]</code> 속성으로 표시된 필드, 중첩 클래스 및 목록 포함)의 자동 스캔.",
  "li_feature_2": "<strong>모든 자산의 로컬라이제이션:</strong> 스프라이트, 오디오, 프리팹, 재질 등 관리.",
  "li_feature_3": "<strong>강력한 번역 편집기:</strong> 자동 저장, 전체 실행 취소/다시 실행 지원, 스마트 키 그룹화, **v1.1의 새로운 기능:** 다중 선택 액션을 갖춘 중앙 집중식 인터페이스.",
  "li_feature_4": "<strong>AI 및 기계 번역 (v1.1):</strong> DeepL, Google, Microsoft, **사용자 지정 AI (OpenAI, Gemini, Claude, Ollama)**를 컨텍스트 인식과 함께 지원하는 새로운 프로필 시스템.",
  "li_feature_5": "<strong>유연한 가져오기/내보내기:</strong> CSV, XML, YAML, XLIFF 및 Google Sheets에서 직접 가져오기 지원.",
  "li_feature_6": "<strong>실시간 미리보기:</strong> 게임을 실행하지 않고 Scene View 또는 **프리팹 모드**에서 모든 언어를 미리 봅니다.",
  "li_feature_7": "<strong>복수형 및 성별 지원:</strong> 복수형(슬라브어, 아랍어 및 기타 언어 규칙 포함) 및 성별의 올바른 처리.",
  "li_feature_8": "<strong>전체 RTL 지원:</strong> 오른쪽에서 왼쪽으로 쓰는 언어의 올바른 표시.",
  "li_feature_9": "<strong>실시간 업데이트:</strong> 게임 시작 시 원격 서버에서 최신 번역을 로드합니다.",
  "li_feature_10": "<strong>백업 관리자:</strong> 백업 생성 및 복원을 위한 내장 도구.",
  "li_feature_11": "<strong>AI 기반:</strong> 사용자 지정 가능한 프로필을 통해 OpenAI, Anthropic (Claude), Google Gemini 및 로컬 LLM (Ollama) 지원.",
  "li_feature_12": "<strong>텍스트 음성 변환 (TTS):</strong> AI (OpenAI, ElevenLabs)를 사용하여 로컬라이즈된 문자열에 대한 오디오 파일 생성.",
  "li_feature_13": "<strong>마이그레이션 도구:</strong> I2 Localization 및 Unity Localization 플러그인에서 자동 전환을 위한 도구.",
  "li_feature_14": "<strong>폰트 및 글리프 관리자:</strong> 사용된 문자 분석 및 폰트에서 누락된 글리프 찾기 도구.",
  "li_feature_15": "<strong>시각적 디버깅:</strong> 빠른 디버깅을 위한 계층 구조의 아이콘 및 Scene View의 레이블.",
  "h1_quick_start": "빠른 시작 및 설정",
  "h2_installation": "2.1. 설치",
  "li_install_1": "자산을 Unity 프로젝트 폴더에 복사합니다.",
  "li_install_2": "도구가 필요한 종속성을 자동으로 확인합니다. 나타나는 대화 상자에서 설치를 확인합니다.",
  "li_install_3": "필수 종속성(<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>)은 기본 기능에 필요합니다.",
  "li_install_4": "선택적 종속성(<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>)은 추가 기능을 활성화합니다.",
  "li_install_5": "권장 패키지를 설치하려면 **선택 항목 설치**를 클릭합니다.",
  "li_install_6": "설치 후 **Tools -> Localization Tool** 메뉴를 통해 기본 도구 창을 엽니다.",
  "li_install_7": "비동기식 자산 로딩을 사용하려면 패키지 관리자를 통해 **Addressables** 패키지를 설치합니다.",
  "h2_initial_setup": "2.2. 초기 설정",
  "li_setup_1": "<strong>설정 생성:</strong> 처음 열 때, 도구는 <code>Assets/Resources</code> 폴더에 <code>LocalizationSettings.asset</code> 파일을 생성합니다.",
  "li_setup_2": "<strong>언어 구성:</strong> **Settings** 탭의 **Language Management**에서 기본 언어(예: 영어의 경우 <code>en</code>)가 **Source Language**로 선택되었는지 확인합니다. 지원하려는 모든 언어를 활성화합니다.",
  "li_setup_3": "<strong>구문 분석할 콘텐츠 지정:</strong> **Content** 탭에서 분석할 모든 씬을 **Scenes to Parse** 목록에 추가합니다. 텍스트가 있는 프리팹을 사용하는 경우 해당 폴더가 **Prefab Folders**에 추가되었는지 확인합니다.",
  "li_setup_4": "<strong>첫 번째 파서 실행:</strong> **Actions** 탭으로 이동하여 <code>Update Keys</code> 버튼을 클릭합니다. 도구는 프로젝트를 스캔하고, 번역 파일을 생성하며, 필요한 구성 요소(<code>LocalizedText</code>, <code>LocalizedAsset</code> 등)를 게임 개체에 자동으로 추가합니다.",
  "li_setup_5": "<strong>설정 및 빌드 (중요):</strong> 도구는 <code>LocalizationSettings.asset</code>을 <code>Project Settings -> Player -> Preloaded Assets</code>에 자동으로 추가합니다. <br>⚠️ <strong>안전 점검:</strong> 설정이 Preloaded Assets에 없거나 Resources 폴더에 없으면, 도구는 게임이 시작할 때 충돌하는 것을 방지하기 위해 <code>BuildFailedException</code>으로 **빌드를 차단**합니다.",
  "h1_components": "핵심 구성 요소 (자동으로 할당됨)",
  "warning_box_components": "<strong>중요 참고:</strong> 아래에 설명된 모든 구성 요소는 구문 분석(<code>Update Keys</code> 버튼 클릭 시) 중에 게임 개체에 자동으로 추가됩니다. 수동으로 추가할 필요가 없습니다.",
  "p_components_intro": "이 구성 요소는 씬의 개체와 번역 데이터베이스 간의 \"다리\"입니다. 언어 변경을 \"수신\"하고 올바른 텍스트 또는 자산을 자동으로 대체합니다.",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "번역된 텍스트를 표시하는 기본 구성 요소입니다. <code>Text</code>, <code>TMP_Text</code> 및 <code>TextMesh</code>가 있는 개체에 배치됩니다.",
  "li_localizedtext_1": "<code>localizationKey</code>: 번역을 찾는 데 사용되는 키입니다. 자동으로 생성됩니다.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code>이면 구성 요소는 스타일(폰트, RTL)만 적용하고 텍스트 자체는 변경하지 않습니다. 텍스트가 다른 스크립트(예: <code>LanguageSelector</code>)에 의해 관리되는 요소에 유용합니다.",
  "li_localizedtext_3": "<code>originalSourceText</code>: 기본 언어의 원본 텍스트입니다. 대체(fallback)로 사용됩니다.",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "언어에 따라 자산을 교체하는 데 사용됩니다. 구성 요소 유형을 자동으로 감지합니다. 지원: <ul><li><strong>2D:</strong> 스프라이트 (<code>Image</code>, <code>SpriteRenderer</code>), 텍스처 (<code>RawImage</code>).</li><li><strong>오디오/비디오:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/애니메이션:</strong> <code>MeshFilter</code> (메시), <code>Renderer</code> (재질), <code>Animator</code> (컨트롤러), <code>PlayableDirector</code> (타임라인).</li></ul>",
  "p_localizedasset_2": "<strong>Play on Awake</strong> 옵션이 있는 구성 요소(<code>AudioSource</code>, <code>VideoPlayer</code> 등)의 경우, <code>LocalizedAsset</code>은 자동 재생을 올바르게 가로채고, 자산을 교체한 다음, 로컬라이즈되지 않은 콘텐츠가 재생되는 것을 방지하기 위해 재생을 시작합니다.",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "전체 프리팹을 로컬라이즈하기 위한 구성 요소입니다. 비파괴적으로 작동합니다. 원본 프리팹을 수정하지 않고, 로컬라이즈된 버전의 인스턴스를 자식 개체로 생성하고, 원본 개체의 모든 스크립트(<code>MonoBehaviour</code>), 렌더러(<code>Renderer</code>) 및 충돌체(<code>Collider</code>)를 비활성화합니다. 이는 이중 로직 실행 및 시각적 아티팩트를 방지합니다. 올바른 런타임 작동을 위해 실행 순서가 -100 (<code>[DefaultExecutionOrder(-100)]</code>)으로 설정되어 다른 스크립트보다 먼저 실행되도록 합니다.",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "<code>UIDocument</code>가 있는 개체에 추가됩니다. 레이블, 버튼, **TextField Placeholders, DropdownField choices, RadioButtonGroup 및 ToggleButtonGroup options**의 로컬라이제이션을 지원합니다. UI Builder에서 ID가 설정된 경우 이름 변경 전반에 걸쳐 식별자가 안정적입니다.",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "옵션을 번역하기 위해 <code>Dropdown</code> 및 <code>TMP_Dropdown</code>에 추가됩니다.",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "스크립트가 언어 변경에 반응할 수 있도록 하는 유틸리티 구성 요소입니다. <code>[OnLanguageChange]</code> 속성으로 표시된 메서드를 자동으로 찾아 호출합니다.",
  "h2_context_menu": "3.7. \"로컬라이제이션 분석\" 상황별 메뉴",
  "p_context_menu_1": "개체에 <code>LocalizedAsset</code>을 빠르게 추가하려면 인스펙터에서 원하는 구성 요소(예: <code>Image</code>, <code>AudioSource</code>)를 마우스 오른쪽 버튼으로 클릭하고 **Analyze for Localization**을 선택할 수 있습니다. 도구는 구성 요소 자체를 추가하고 구성합니다. (이는 선택 사항이지만 수동 추가에 사용할 수 있습니다).",
  "h1_loc_tool_window": "\"로컬라이제이션 도구\" 창",
  "h2_in_editor_preview": "4.1. 에디터 내 및 프리팹 미리보기",
  "p_preview_1": "헤더 바로 아래에는 **Preview Language** 드롭다운 목록이 있습니다. 이 강력한 기능을 사용하면 게임을 실행하지 않고 **Scene** 창 또는 **Prefab Mode**에서 로컬라이제이션이 모든 언어에서 어떻게 보일지 직접 확인할 수 있습니다.",
  "li_preview_1": "<strong>작동 방식:</strong> 목록에서 언어를 선택하면 도구가 활성 씬 또는 열린 프리팹의 모든 로컬라이즈 가능한 개체에 해당 번역, 폰트, RTL 설정 및 자산을 즉시 적용합니다.",
  "li_preview_2": "<strong>자리 표시자:</strong> **Settings** 탭에서 자리 표시자 스타일(예: **Accents** 또는 **Brackets**)이 선택된 경우 실제 번역 대신 미리보기 모드에서 이러한 자리 표시자가 표시됩니다. 이는 레이아웃을 테스트하고 로컬라이즈되지 않은 요소를 찾는 데 이상적입니다.",
  "li_preview_3": "<strong>안전:</strong> 미리보기 모드에서 이루어진 모든 변경 사항은 임시적입니다. 도구는 \"<strong>Revert to Original</strong>\"을 선택하거나, 창을 닫거나, 씬을 변경하거나, 씬/프리팹을 저장하기 전에(<code>LocalizationPreviewProtector</code> 구성 요소 덕분에) 모든 것을 자동으로 원래 상태로 되돌립니다.",
  "li_preview_4": "<strong>충돌 방지:</strong> 시스템은 미리보기 전에 씬 상태를 <code>Library</code> 폴더에 자동으로 백업합니다. 미리보기 중에 Unity가 충돌하거나 강제 종료하는 경우, 도구는 다음 실행 시 복구 파일을 감지하고 원본 씬 상태를 복원하도록 제안합니다.",
  "h2_tab_settings": "4.2. \"설정\" 탭",
  "p_settings_1": "제어 센터입니다. 여기에서 전체 로컬라이제이션 프로세스에 대한 전역 규칙을 정의합니다.",
  "li_settings_1": "<strong>키 생성 모드:</strong> 키 생성 방식을 선택합니다.<ul><li><code>UseTextAsKey</code>: 텍스트 자체가 키가 됩니다. 프로토타입에 이상적입니다.</li><li><code>AutoGenerateKeysOnly</code>: 개체의 계층 구조 및 이름을 기반으로 키가 생성됩니다. 프로덕션에 신뢰할 수 있습니다.</li><li><code>Manual</code>: 파서가 키를 자동으로 생성하지 않습니다. 이미 키가 할당된 개체만 업데이트합니다.</li><li><code>UseTextAsKeyWithCustomPriority</code> / <code>AutoGenerateWithCustomKeys</code>: 코드 속성을 통해 사용자 지정 키를 허용하는 하이브리드 모드.</li><li><strong>안전한 마이그레이션:</strong> 언제든지 모드를 변경할 수 있으며, 도구는 기존 번역을 마이그레이션하려고 시도합니다.</li></ul>",
  "li_settings_2": "<strong>언어 관리:</strong><ul><li><strong>Source Language:</strong> Unity 씬/프리팹에서 사용되는 언어(개발 언어).</li><li><strong>Default Language:</strong> 사용자의 시스템 언어가 지원되지 않는 경우 첫 번째 게임 실행 시 선택되는 언어.</li><li><strong>List:</strong> 지원되는 언어를 관리하고, 특정 **Font Assets**을 할당하고, **RTL** 지원을 활성화합니다.</li></ul>",
  "li_settings_3": "<strong>일반 설정:</strong><ul><li><code>Parse Prefabs</code>: 프리팹 구문 분석을 활성화합니다.</li><li><code>Split files by language</code>: 번역을 저장하는 방법(하나의 큰 파일 또는 언어당 하나의 파일)을 결정합니다.</li><li><code>Translations Path</code>: <code>.json</code> 번역 파일을 저장할 경로입니다. 중요: 폴더는 <code>Assets/StreamingAssets/</code> 내에 있어야 합니다.</li></ul>",
  "li_settings_4": "<strong>디버깅 및 테스트:</strong><ul><li><code>Placeholder Style</code>: 미리보기 모드에서 자리 표시자를 표시할 스타일을 선택합니다.</li></ul>",
  "li_settings_5": "<strong>실시간 업데이트:</strong> 원격 서버에서 번역을 로드하기 위한 설정.",
  "li_settings_6": "<strong>런타임 API 키:</strong> 게임 내 자동 번역을 위한 API 키를 안전하게 저장합니다. 키는 문자열 검색을 통한 쉬운 추출을 방지하기 위해 빌드에서 **난독화**됩니다(암호화). 그러나 클라이언트 측 비밀은 100% 안전하지 않음을 기억하십시오.",
  "li_settings_7": "<strong>자산 로딩 전략:</strong> <code>Resources (Legacy)</code> (동기식 로딩, 이전 방법)와 <code>Addressables (Async)</code> (비동기식 로딩, 대규모 프로젝트에 권장) 중에서 선택.",
  "li_settings_8": "<strong>자동 번역:</strong> 이제 **Translation Profiles** 시스템을 사용합니다. 프로필 자산(마우스 오른쪽 버튼 클릭 -> 만들기 -> Localization -> Translation Profile)을 생성하거나 <code>Localization/Presets</code> 폴더에서 사전 설정을 선택해야 합니다. 프로필은 Google Translate, DeepL, Microsoft, OpenAI, Claude, Gemini, Ollama를 지원합니다. 설정에서 **Active Text Profile** (텍스트용) 및 **Active Audio Profile** (TTS용)을 선택합니다.",
  "li_settings_9": "<strong>디버깅 향상:</strong><ul><li><code>Show Hierarchy Icons</code>: 계층 구조에 상태 아이콘(녹색 체크/노란색 경고)을 표시합니다. **성능 최적화:** 대규모 씬에서도 지연이 없도록 캐싱을 사용합니다.</li><li><code>Show Scene View Labels</code>: Scene View에서 직접 시각적 디버깅. 레이블은 대화형입니다. Scene View 레이블을 마우스 오른쪽 버튼으로 클릭하여 로컬라이제이션 키를 클립보드에 즉시 복사합니다.</li><li><code>Pseudo-Localization</code>: 번역 없이 UI 레이아웃 확장을 테스트합니다.</li></ul>",
  "li_settings_10": "<strong>개발자 도구:</strong> 설정 탭 하단에서 **Clear Saved Language Pref** (저장된 언어를 PlayerPrefs에서 재설정하여 게임이 기본 언어로 다시 시작되도록 함)와 같은 유틸리티 버튼을 찾을 수 있습니다.",
  "li_settings_11": "<strong>기술 드롭다운 옵션:</strong> 파서가 드롭다운을 스캔할 때 **무시**할 문자열 값 목록(기본값: 'Option A', 'Option B', 'Option C')입니다. 이는 Unity의 기본 UI 자리 표시자 텍스트로부터 번역 테이블을 깨끗하게 유지합니다.",
  "li_assistant_3": "<strong>사용자 지정 명령:</strong> 사전 설정에 국한되지 않습니다! **Translation Profile** 자산 인스펙터를 열어 자신만의 프롬프트(예: '해적 스타일로 다시 작성', '맞춤법 검사')를 추가하십시오. 이는 편집기 상황별 메뉴에 자동으로 나타납니다.",
  "li_font_glyph_workflow": "<strong>TMP용 워크플로:</strong> 1. 스캔 실행. 2. 누락된 글리프가 있는 언어 선택. 3. **'Copy Character Set'** 클릭. 4. Window -> TextMeshPro -> Font Asset Creator 열기. 5. 클립보드를 'Character Sequence (Custom Range)' 필드에 붙여넣어 게임에 정확히 필요한 문자가 포함된 아틀라스를 생성합니다.",
  "li_assets_addressables_naming": "<strong>명명 규칙:</strong> 스캔 시 도구는 Addressable 주소를 자동으로 <code>{Category}/{Language}/{Key}</code> 형식으로 설정합니다. LocalizationManager가 런타임에 자산을 로드하기 위해 이 특정 형식에 의존하므로 이 주소를 수동으로 **이름을 바꾸지 마십시오**.",
  "p_ai_audio_economy": "<strong>비용 절감:</strong> 도구는 텍스트의 MD5 해시를 계산하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다. 번역을 변경하면 시스템은 해당 특정 오디오 파일만 'Outdated'로 플래그를 지정합니다. 변경된 항목만 다시 생성하려면 'Generate Missing/Outdated'를 사용하여 API 크레딧을 절약하십시오. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 스마트 배치 처리를 통해 API 크레딧을 절약합니다.",
  "li_content_regex_example": "<strong>사용자 지정 래퍼 예시:</strong> <code>MyGame.Loc(\"KEY\")</code>와 같은 사용자 지정 함수를 사용하는 경우, 정규식 <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>를 사용하여 스크립트 구문 분석 규칙을 추가합니다. 이제 파서가 사용자 지정 코드에서 키를 캡처합니다.",
  "li_settings_icons_legend": "<strong>계층 구조 아이콘 범례:</strong><br>🟢 (녹색 체크): 로컬라이즈됨 및 키 설정됨.<br>🔴 (빨간색 오류): 로컬라이즈된 구성 요소가 있지만 **키가 누락됨**.<br>🟡 (노란색 경고): 텍스트/이미지 구성 요소는 있지만 **로컬라이제이션 구성 요소가 첨부되지 않음**.<br>🐛 (버그): 개체가 설정에 의해 **무시됨**.",
  "h2_tab_content": "4.3. \"콘텐츠\" 탭 (v1.1에서 재설계됨)",
  "p_content_1": "여기에서 도구에게 텍스트를 정확히 어디에서 찾아야 하는지 알려줍니다. 인터페이스는 더 나은 사용성을 위해 완전히 재설계되었습니다.",
  "li_content_1": "<strong>Scenes to Parse:</strong> 분석할 모든 씬을 여기에 끌어다 놓습니다.",
  "li_content_2": "<strong>Prefab Folders:</strong> 프리팹이 있는 폴더를 지정합니다. 이제 대규모 프로젝트를 위한 페이지 매김 및 검색을 지원합니다.",
  "li_content_3": "<strong>Dynamic Texts:</strong> 코드에서만 생성되는 문자열(예: \"Game Over\")을 여기에 입력합니다.",
  "li_content_4": "<strong>구문 분석 구성:</strong> 무시할 스크립트/개체를 지정합니다. **Attributes to Scan** 아래에서 사용자 지정 속성 이름(예: <code>[Header]</code>, <code>[TermsPopup]</code>)을 추가하여 파서가 해당 필드를 로컬라이즈 가능한 텍스트로 처리하도록 할 수 있습니다.",
  "li_content_5": "<strong>고정(Pin):</strong> 이 기능을 사용하면 씬의 개체를 무시 목록에 \"고정\"할 수 있습니다. 개체에 대한 임시 참조 대신, 도구는 계층 구조의 전체 경로를 저장하여 무시가 세션 간에 지속되도록 합니다.",
  "li_content_6": "<strong>스크립트 구문 분석 규칙:</strong> 코드에서 키를 찾기 위한 사용자 지정 정규식 규칙을 정의합니다. <br>🔥 **새로운 기능:** **'Add Preset'** 버튼을 사용하여 타사 자산(I2 Localization, Unity Localization) 또는 표준 래퍼에 대한 규칙을 즉시 추가합니다.",
  "li_content_7": "<strong>동적 키 접두사:</strong> 파서가 씬에서 찾지 못한 경우에도 정리(Remove Missing Keys) 중에 삭제되지 않을 키 접두사 목록(예: <code>Item_</code>).",
  "h2_tab_actions": "4.4. \"액션\" 탭",
  "p_actions_1": "주요 작업 탭입니다.",
  "li_actions_1": "<strong>구문 분석:</strong><ul><li><strong>Update Keys:</strong> 'Content' 탭 설정에 정의된 전체 프로젝트 스캔.</li><li><strong>Scan Selected Assets:</strong> Project View에서 현재 선택된 파일/폴더**만** 스캔합니다. 'Remove Missing Keys'를 자동으로 비활성화하므로 부분 업데이트에 더 안전합니다.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> 모든 번역을 편집하기 위한 별도의 더 편리한 창을 엽니다.",
  "li_actions_3": "<strong>데이터 관리:</strong> 번역가와 데이터를 교환하는 데 사용합니다(CSV/XML/YAML/XLIFF로 내보내기/가져오기, Google Sheets에서 가져오기).",
  "li_actions_4": "<strong>자동 번역:</strong> 활성 **Translation Profile**을 사용하여 모든 빈 번역 문자열을 자동으로 채웁니다.",
  "li_actions_5": "<strong>위험 영역:</strong> 프로젝트에서 모든 로컬라이제이션 구성 요소를 완전히 제거하기 위한 버튼이 포함되어 있습니다. 주의해서 사용하십시오!",
  "h2_tab_assets": "4.5. \"자산\" 탭",
  "p_assets_1": "이 탭은 텍스트가 아닌 리소스를 로컬라이즈하는 데 전적으로 전념합니다.",
  "li_assets_1": "<strong>폴더 구조 생성 (선택 사항):</strong> **2. Asset Folder Generation** 섹션에서 **Create Asset Folders Now**를 클릭합니다.",
  "li_assets_2": "<strong>범주 및 명명 규칙 구성:</strong> **3. Asset Categories & Scanning** 섹션에서 **Naming Rule** (<code>{key}_{lang}</code>)이 파일(예: <code>button_ok_en.png</code>)과 일치하는지 확인합니다.",
  "li_assets_3": "<strong>자산 배치:</strong> 로컬라이즈된 자산을 폴더에 넣습니다.",
  "li_assets_4": "<strong>자산 스캔:</strong> **4. Automation** 섹션에서 **Scan Assets & Update Tables**를 클릭합니다. 정리 프로세스가 더 안전해졌습니다. 이제 전체 폴더가 아닌 오래된 테이블 파일(<code>.asset</code>)만 삭제됩니다.",
  "li_assets_5": "<strong>개체에 자산 연결:</strong> **Analyze Project & Attach Components**를 클릭합니다.",
  "li_assets_6": "<strong>Addressables 통합:</strong> **Addressables** 모드가 활성화된 경우, 스캔 중에 자산이 <code>{Category}/{Language}/{Key}</code> 형식의 주소로 Addressables 그룹에 자동으로 등록됩니다.",
  "h2_tab_report": "4.6. \"보고서\" 탭",
  "p_report_1": "각 구문 분석 후, 이 보고서는 로컬라이제이션 상태의 전체 그림을 보여줍니다.",
  "li_report_1": "<strong>범주:</strong> All Keys, Added, Updated (텍스트 변경됨), Removed, Duplicates, Migrated, Skipped (변경되지 않음).",
  "li_report_2": "<strong>고급 찾기:</strong> 항목 옆의 **Find** 버튼을 클릭하면 프로젝트에서 해당 개체를 즉시 찾을 수 있습니다. 검색은 비동기적으로 작동하며 편집기를 차단하지 않고 모든 씬과 프리팹을 검색합니다.",
  "h1_translation_editor": "번역 테이블 편집기",
  "p_editor_1": "**Tools -> Localization -> Translation Table Editor**를 통해 열립니다. 수동으로 번역을 편집하기 위한 주요 도구입니다.",
  "li_editor_1": "<strong>스마트 그룹화:</strong> 복수형 및 성별에 대한 키(예: <code>apple_count_one</code>, <code>apple_count_few</code>)가 자동으로 접을 수 있는 그룹으로 결합됩니다.",
  "li_editor_2": "<strong>고급 편집:</strong> 셀을 클릭하여 **MultiLineEditWindow** 팝업을 엽니다. 비교를 위한 원본 텍스트를 표시하고 자리 표시자를 검증합니다.",
  "li_editor_3": "<strong>고급 선택 (새로운 기능):</strong> 개별 셀, 행 또는 전체 열(언어) 선택을 지원합니다.",
  "li_editor_4": "<strong>대량 액션 (새로운 기능):</strong> 선택 항목을 마우스 오른쪽 버튼으로 클릭하여 대량 작업 수행: 선택한 셀 자동 번역, 콘텐츠 지우기 또는 키 삭제.",
  "li_editor_5": "<strong>스마트 탐색 (새로운 기능):</strong> 키보드 화살표 및 단축키(Ctrl+S 저장, Ctrl+Z/Y 실행 취소/다시 실행)를 사용하여 테이블 탐색.",
  "li_editor_6": "<strong>유효성 검사 필터:</strong> 프로젝트를 감사하기 위한 고급 필터 사용: <ul><li><strong>Has Length Issues:</strong> 번역이 소스보다 상당히 긴 경우 경고(+X%).</li><li><strong>Outdated Audio:</strong> 텍스트가 변경되었지만 오디오가 다시 생성되지 않은 키를 표시합니다.</li><li><strong>Missing Placeholders:</strong> {0}이 소스에는 있지만 번역에는 없는 경우 감지.</li></ul>",
  "li_editor_7": "<strong>오디오 상태:</strong> 이제 테이블에 오디오 파일의 상태가 표시됩니다. 텍스트가 변경되었지만 오디오 파일이 이전 상태인 경우(해시 불일치), 경고(노란색 아이콘)가 나타납니다.",
  "li_editor_8": "<strong>향상된 상황별 메뉴:</strong> 명령 추가: **Generate Audio** (선택한 셀에 대한 보이스오버 생성) 및 **AI Assistant** (선택한 AI 프로필을 사용하여 \"문법 수정\" 또는 \"줄이기\"와 같은 명령 실행).",
  "h1_ai_profiles": "AI 및 번역 프로필 (New v1.1)",
  "h2_ai_profiles_overview": "6.1. 번역 프로필",
  "p_ai_intro": "버전 1.1은 새로운 **Translation Profile** 시스템(ScriptableObject)을 도입합니다. 이는 번역 서비스 설정을 전역 설정에서 개별 프로필 자산으로 이동하여 구성을 쉽게 전환할 수 있도록 합니다.",
  "li_ai_1": "<strong>프로필 생성:</strong> Project 뷰에서 마우스 오른쪽 버튼 클릭 -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>서비스:</strong> DeepL, Google Translate, Microsoft Azure 및 **Custom AI**를 지원합니다.",
  "li_ai_3": "<strong>설정:</strong> 각 프로필은 자체 API 키, 제한(배치 크기, 최대 문자) 및 모델 설정을 저장합니다.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> 내장된 생성기를 사용하여 인기 있는 서비스(OpenAI, Gemini, Claude, Ollama)에 대한 프로필을 빠르게 생성합니다.",
  "h2_custom_ai": "6.2. 사용자 지정 AI 및 모델",
  "p_custom_ai": "<strong>Custom AI</strong> 서비스 유형을 사용하면 REST API를 통해 모든 LLM을 연결할 수 있습니다.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> OpenAI 호환 API(Ollama를 통한 로컬 LLM 포함)와 통신할 수 있는 유연한 구현.",
  "li_custom_ai_2": "<strong>템플릿:</strong> API 요구 사항과 일치하도록 요청 본문 JSON 템플릿을 사용자 지정합니다.",
  "li_custom_ai_3": "<strong>내장 안전 기능:</strong> AI 모델에서 자주 반환되는 손상된 형식 지정 태그(예: <ph0>)를 자동으로 복구하여 안정적이고 일관된 번역을 보장합니다.",
  "h2_ai_context": "6.3. 컨텍스트 및 용어집",
  "p_ai_context": "번역 품질을 개선하기 위해 AI는 이제 추가 컨텍스트를 받습니다.",
  "li_context_1": "<strong>개발자 참고 사항:</strong> 번역 테이블의 주석이 AI에 컨텍스트로 전달됩니다.",
  "li_context_2": "<strong>개체 경로:</strong> 주석이 없으면 개체의 계층 구조 경로(예: <code>MainMenu/Canvas/StartButton</code>)가 대체 컨텍스트로 사용됩니다.",
  "li_context_3": "<strong>용어집:</strong> 특정 용어 및 이름에 대한 특정 번역을 적용하도록 CSV 용어집을 프로필에 로드할 수 있습니다.",
  "h2_ai_assistant": "6.4. AI 도우미 명령",
  "p_ai_assistant": "번역 테이블 편집기에서 상황별 메뉴(마우스 오른쪽 버튼 클릭 -> AI: ...)를 통해 선택한 셀에서 사용자 지정 AI 명령을 실행할 수 있습니다.",
  "li_assistant_1": "<strong>구성 가능:</strong> Translation Profile에서 명령 정의(예: \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\").",
  "li_assistant_2": "<strong>일괄 처리:</strong> 여러 셀을 선택하여 명령을 한 번에 모두 적용합니다.",
  "h1_usage_examples": "사용 예시",
  "h2_example_components": "7.1. 미리 만들어진 구성 요소 및 예시",
  "p_example_components_1": "프로젝트에는 훌륭한 예시 역할을 하는 즉시 사용 가능한 스크립트가 포함되어 있습니다.",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 언어 전환을 위한 UI 드롭다운 목록을 만들기 위한 미리 만들어진 구성 요소입니다. 사용 가능한 모든 언어를 자동으로 찾고 전환을 관리합니다.<br><strong>사용 방법:</strong> <code>LanguageSelector</code> 구성 요소를 씬에 추가하고(예: 빈 GameObject에) 인스펙터에서 <code>TMP_Dropdown</code>을 지정하기만 하면 됩니다.",
  "li_example_components_2": "<strong>코드 예시:</strong> <code>[LocalizableField]</code> 작업, <code>_()</code> 함수, 복수형 및 성별과 같은 고급 기술을 배우려면 <code>StatPurchaseTest.cs</code> 및 <code>TestLocalization.cs</code> 파일을 연구하십시오. 이들은 코드에서 도구의 모든 주요 기능 구현을 명확하게 보여줍니다.",
  "h2_example_attribute": "7.2. [LocalizableField] 속성",
  "p_example_attribute_1": "The most powerful way to localize script variables. It works with <strong>private, protected, and public</strong> fields. The parser recursively handles <strong>Arrays, Lists</strong>, and <strong>Nested Serializable Classes</strong>. It can even generate keys for other attributes (like <code>[Header]</code> or <code>[Tooltip]</code>) if configured in Settings.",
  "code_example_attribute": "using Ankonoanko.Localization;\nusing UnityEngine;\nusing System.Collections.Generic;\n\npublic class HeroDialog : MonoBehaviour\n{\n    // 1. Private fields work perfectly\n    [LocalizableField]\n    private string secretWhisper = \"It's a secret to everybody.\";\n\n    // 2. Custom Key Override\n    [LocalizableField(\"hero_greeting_main\")]\n    public string greeting = \"Welcome, traveler!\";\n\n    // 3. Lists and Arrays (Keys become: inventory_header_0, inventory_header_1...)\n    [LocalizableField]\n    public string[] inventoryHeaders = new string[] { \"Weapons\", \"Potions\", \"Armor\" };\n\n    // 4. Nested Serializable Classes (Recursion supported)\n    [System.Serializable]\n    public class BossInfo\n    {\n        [LocalizableField] public string name;\n        [LocalizableField] public string title;\n    }\n    public BossInfo currentBoss; // Parser drills down into this\n\n    // 5. List of Nested Objects\n    [LocalizableField]\n    public List<BossInfo> bossList = new List<BossInfo>();\n\n    // 6. Custom Key on List (Keys: dungeon_hints_list_0, dungeon_hints_list_1...)\n    [LocalizableField(\"dungeon_hints_list\")]\n    public List<string> dungeonHints = new List<string>\n    {\n        \"Beware of traps.\",\n        \"Use fire against trolls.\"\n    };\n\n    // 7. Interpolated Strings (Parser reads the raw format string)\n    [LocalizableField(\"fire_sword_name\")]\n    public string ItemName1 = $\"Fire Sword {0}\";\n}",
  "h2_example_function": "7.3. _() 함수 및 [OnLanguageChange] 속성",
  "p_example_function_1": "게임 플레이 중에 변경되는 동적 텍스트에 <code>_()</code> 함수를 사용합니다. UI를 업데이트하는 메서드는 언어가 변경될 때 자동으로 호출되도록 <code>[OnLanguageChange]</code> 속성으로 표시해야 합니다. 이를 위해 <code>LocalizedBehaviour</code> 구성 요소가 개체에 자동으로 추가됩니다.",
  "code_example_function": "// 짧은 _() 호출을 사용하려면 이 줄을 추가하십시오.\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange]에 필요\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // 초기 업데이트\n    }\n    \n    // 이 메서드는 언어가 변경될 때 자동으로 호출됩니다.\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. 인덱싱된 자리 표시자 (string.Format과 유사)\n        // 키: \"score_label\", 파일의 텍스트: \"Score: {0}\"\n        scoreText.text = _(\"score_label\", score); // 결과: \"Score: 100\"\n        \n        // 2. 명명된 자리 표시자 (가독성을 위해 권장)\n        // 키: \"welcome_message\", 텍스트: \"Welcome, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // 복잡한 경우 또는 고성능을 위해\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. 복수형 및 성별",
  "p_example_plurals_1": "이제 이 도구는 다른 언어 그룹에 대해 더 정확한 규칙을 사용합니다.",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // 키: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // 텍스트: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // 올바른 형태를 자동으로 선택\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // 키: \"user_greeted_male\", \"user_greeted_female\"\n        // 텍스트: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "중요 참고 사항 및 경고",
  "li_notes_1": "<strong>백업:</strong> 주요 변경 전에 항상 **Translation Table Editor -> Manage Backups**를 통해 백업을 생성하십시오. 백업은 Unity 프로젝트를 깨끗하게 유지하고 가져오기 시간을 줄이기 위해 **프로젝트 루트(Assets 폴더 외부)**의 <code>LocalizationBackups</code> 폴더에 저장됩니다.",
  "li_notes_2": "<strong>API 키 보안:</strong> 에디터에서 작업하기 위한 키는 사용자 컴퓨터에 로컬로 저장되며(<code>EditorPrefs</code>에) 리포지토리에 들어가지 않습니다. 게임 빌드에 필요한 키의 경우 **Runtime API Key** 섹션을 사용하십시오.",
  "li_notes_3": "<strong><code>StreamingAssets</code> 폴더:</strong> 번역 파일은 게임 빌드에 포함되려면 <code>Assets/StreamingAssets/</code>의 하위 폴더에 있어야 합니다.",
  "li_notes_4": "<strong>\"바보 방지\":</strong> 도구는 실수로 미리보기 모드의 임시 데이터를 씬 또는 프리팹에 저장하는 것으로부터 사용자를 자동으로 보호합니다.",
  "li_notes_5": "<strong>성능:</strong> <code>_()</code> 호출은 빠르지만, 모든 프레임에서 실행되는 루프(예: <code>Update</code>에서)에서는 결과를 변수에 캐시하려고 시도하십시오.",
  "li_notes_6": "<strong><code>LanguageSelector</code>를 구문 분석에서 제외:</strong> <code>LanguageSelector</code> 구성 요소와 해당 <code>TMP_Dropdown</code>이 있는 개체는 **Content** 탭의 **Ignore Specific Objects** 목록에 추가해야 합니다. 이는 <code>LanguageSelector</code> 스크립트가 런타임에 드롭다운 옵션을 동적으로 채우기 때문에 파서가 드롭다운 옵션에 대한 추가 키를 생성하는 것을 방지하는 데 필요합니다. 무시하면 충돌을 방지하고 번역 파일을 깨끗하게 유지합니다.",
  "li_notes_7": "<strong><code>LanguageSelector</code>용 폰트:</strong> <code>TMP_Dropdown</code>에서 선택한 언어가 해당 폰트를 올바르게 업데이트하려면 드롭다운의 자식 **Label** 개체에 빈 <code>LocalizedText</code> 구성 요소를 수동으로 추가하고 <code>isStyleOnly</code> 상자를 확인하십시오.",
  "li_notes_addressables_code": "<strong>코드 및 Addressables:</strong> **Addressables (Async)** 모드로 전환하는 경우 스크립트에서 <code>GetLocalizedAssetAsync<T>()</code>를 **사용해야 합니다**. 동기식 <code>GetLocalizedAsset<T>()</code>를 호출하면 null이 반환되고 기본 스레드 정지를 방지하기 위해 경고가 기록됩니다.",
  "li_content_regex_presets": "<strong>무시된 정규식 패턴:</strong> **'Add Common Pattern'**을 클릭하여 정규식을 수동으로 작성하지 않고도 <em>URL, 이메일, 날짜, 가격 및 UUID</em>와 같은 동적 콘텐츠를 번역에서 빠르게 제외합니다.",
  "li_notes_addressables_sync_warning": "<strong>동기식 vs 비동기식:</strong> **Addressables (Async)** 모드로 전환하는 경우 코드를 업데이트하여 <code>GetLocalizedAssetAsync<T>()</code>를 **사용해야 합니다**. 동기식 메서드를 호출하면 null이 반환되고 기본 스레드가 멈추는 것을 방지하기 위해 경고가 기록됩니다.",
  "q_faq_custom_keys_attribute": "[LocalizableField] 대신 사용자 지정 키에 내 자신의 속성을 사용할 수 있습니까?",
  "a_faq_custom_keys_attribute": "예. **Content Tab**의 'Attributes to Scan' 아래에 모든 속성 이름(예: <code>[Header]</code>, <code>[TermsPopup]</code>)을 추가할 수 있습니다. 파서는 해당 속성이 있는 모든 문자열 필드를 로컬라이즈 가능한 것으로 처리합니다.",
  "q_faq_tts_voices": "특정 캐릭터에 특정 음성을 할당하려면 어떻게 해야 합니까?",
  "a_faq_tts_voices": "**Translation Profile** (인스펙터)에서 'Voice Mappings' 목록을 사용하십시오. 정규식 패턴(예: <code>^hero_.*</code>)을 특정 Voice ID에 매핑할 수 있습니다. 생성기는 키 이름을 기반으로 올바른 음성을 자동으로 선택합니다.",
  "h1_extending": "기능 확장",
  "h2_custom_parser": "9.1. 사용자 지정 파서 생성",
  "p_custom_parser_1": "자체 파서 클래스를 생성하여 사용자 지정 구성 요소를 지원하도록 시스템을 쉽게 확장할 수 있습니다.",
  "li_custom_parser_1": "프로젝트의 **Editor** 폴더에 새 C# 스크립트를 생성합니다.",
  "li_custom_parser_2": "아래 템플릿을 복사하여 붙여넣습니다.",
  "li_custom_parser_3": "구성 요소와 일치하도록 논리를 수정합니다.",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// 사용자 지정 구성 요소를 위한 파서를 생성하기 위한 템플릿입니다.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. 개체에 필요한 사용자 지정 구성 요소가 있는지 확인합니다.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // 구성 요소를 찾을 수 없으면 종료\n        }\n        \n        // 2. 사용자 지정 구성 요소의 필드에서 텍스트를 가져옵니다.\n        string titleText = component.Title;\n        \n        // 3. 텍스트가 로컬라이제이션에 유효한지 확인합니다.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. TextParser의 도우미를 사용하여 키와 소스를 생성합니다.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. 결과를 반환합니다.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. 다른 필드에 대해 반복합니다...\n        // (키를 고유하게 만들기 위해 접미사를 추가할 수 있습니다)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQ 및 문제 해결",
  "h1_migration_tool": "마이그레이션 도구",
  "p_migration_tool_desc": "다른 로컬라이제이션 시스템(I2 Localization, Unity Localization)에서 전환하기 위한 도구.",
  "p_migration_tool_access": "**Tools -> Anko Localization Tool -> Migration Tool**을 통해 액세스.",
  "h2_migration_tool_features": "기능",
  "li_migration_tool_setup": "<strong>단계 0: 설정:</strong> 구성 요소 이름(예: I2의 경우 <code>Localize</code>)과 키가 저장되는 필드를 구성합니다. 사전 설정이 제공됩니다.",
  "li_migration_tool_import": "<strong>단계 1: 데이터 가져오기:</strong> CSV (I2) 또는 XLIFF (Unity Loc) 파일을 가져와 키 데이터베이스를 생성합니다.",
  "li_migration_tool_converter": "<strong>단계 2: 구성 요소 변환기:</strong> 씬 및 프리팹 스캔. 이전 구성 요소(예: <code>Localize</code>)를 <code>LocalizedText</code> / <code>LocalizedAsset</code>으로 자동 교체하고 키를 전송합니다.",
  "li_migration_tool_safemode": "<strong>안전 모드 및 비상 스텁:</strong> 구성 요소는 삭제되지 않고 비활성화됩니다. **Emergency Stubs** 기능(ANKO_ENABLE_MIGRATION_STUBS 정의 기호를 통해 활성화)이 포함됩니다. 이는 I2 Localization 또는 Unity Localization에 대한 가짜 자리 표시자 클래스를 생성하여 해당 플러그인을 제거한 직후 프로젝트를 컴파일할 수 있도록 합니다. 이렇게 하면 \"The type name 'Localize' could not be found\" 오류가 방지되고 새 시스템을 사용하도록 코드를 올바르게 리팩터링할 시간을 제공합니다. 스텁 활성화는 이전 로컬라이제이션 플러그인을 삭제한 후 컴파일 오류를 수정할 수 있도록 합니다.",
  "h1_font_glyph_manager": "폰트 및 글리프 관리자",
  "p_font_glyph_manager_access": "**Tools -> Anko Localization Tool -> Font & Glyph Manager**를 통해 액세스.",
  "h2_font_glyph_manager_features": "기능",
  "li_font_glyph_analyze": "모든 번역을 분석하고 할당된 폰트(TMP_FontAsset)가 사용된 모든 문자를 지원하는지 확인합니다.",
  "li_font_glyph_missing": "누락된 글리프 목록을 표시합니다.",
  "li_font_glyph_copy": "폰트 아틀라스 생성을 위해 모든 고유 언어 문자를 복사할 수 있습니다.",
  "h1_pseudo_tool": "의사(Pseudo)-로컬라이제이션 도구",
  "p_pseudo_tool_desc": "더 긴 텍스트가 있는 언어를 시뮬레이션하기 위해 확장된 텍스트로 UI 레이아웃을 테스트하는 도구.",
  "p_pseudo_tool_access": "**Tools -> Anko Localization Tool -> Pseudo-Localization Generator**를 통해 액세스.",
  "h2_pseudo_tool_features": "기능",
  "li_pseudo_tool_setup": "<strong>의사(Pseudo)-로컬라이제이션 생성기:</strong> UI 레이아웃을 스트레스 테스트하기 위해 가짜 언어(예: [E-x-p-a-n-d-e-d])를 생성합니다. 독일어/러시아어 텍스트 확장을 시뮬레이션하기 위해 텍스트 길이를 요소(예: +40%)만큼 확장하는 것을 지원합니다.",
  "h1_ai_audio": "AI 오디오 / 텍스트 음성 변환 (Text-to-Speech)",
  "h2_ai_audio_setup": "설정",
  "li_ai_audio_profile": "**Settings**에서 **Active Audio Profile** (예: OpenAI TTS 또는 ElevenLabs)을 선택합니다.",
  "h2_ai_audio_usage": "사용",
  "li_ai_audio_generate": "**Translation Table Editor**에서 행/셀 선택 -> 마우스 오른쪽 버튼 클릭 -> **Generate Audio**.",
  "li_ai_audio_save": "파일은 프로필에 지정된 폴더에 저장됩니다.",
  "li_ai_audio_hash": "<strong>스마트 업데이트 및 해싱:</strong> 도구는 텍스트의 MD5 해시를 계산하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다. 마지막 오디오 생성 이후 번역이 변경되었는지 감지합니다. 편집기는 'Outdated' 아이콘(노란색)으로 이 행을 강조 표시하여 변경된 줄**만** 업데이트할 수 있도록 합니다. 이 스마트 배치 처리 기능은 불필요한 API 호출을 방지하고 오디오를 다시 생성할 때 비용을 줄입니다. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다.",
  "li_ai_audio_voice_mapping": "<strong>음성 매핑 (다중 화자):</strong> 다른 AI 음성을 다른 캐릭터에 자동으로 할당합니다. **Translation Profile**에서 'Voice Mappings' 목록을 사용하여 정규식 패턴(예: <code>^hero_.*</code>)을 특정 Voice ID에 연결합니다. 도구는 키 이름을 기반으로 올바른 음성을 자동으로 사용합니다.",
  "h2_example_components_updated": "업데이트된 LanguageSelector.cs",
  "p_example_components_updated": "코드가 변경되었습니다. 언어 로딩(특히 Addressables 사용 시)은 이제 비동기식입니다.",
  "li_example_components_old": "<strong>이전:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (동기식/void).",
  "li_example_components_new": "<strong>새로운 기능:</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code> (비동기식/코루틴).",
  "h2_localizedasset_updated": "LocalizedAsset 비동기식 로딩",
  "p_localizedasset_updated": "이제 이 구성 요소는 비동기식 로딩을 지원합니다. 자산이 클라우드/디스크(Addressables)에서 로드되는 경우 언어를 변경할 때 약간의 지연이 있을 수 있습니다.",
  "h2_faq_installation": "10.1. 설치 및 빠른 시작",
  "q_faq_installation_1": "내 프로젝트에 이미 다른 자산의 com.unity.nuget.newtonsoft-json 패키지가 있는 경우 어떻게 됩니까? 종속성 설치 프로그램이 업데이트하려고 시도합니까 아니면 무시합니까?",
  "a_faq_installation_1": "설치 프로그램은 Newtonsoft.Json.JsonConvert 유형의 존재를 확인합니다. 유형이 존재하는 경우 종속성이 충족된 것으로 간주하고 패키지를 설치하거나 업데이트하려고 시도하지 않습니다. 이는 버전 충돌을 방지하기 위해 수행됩니다.",
  "q_faq_installation_2": "선택적 종속성(예: CSV 지원용)에 대해 실수로 \"Skip for Now\"를 클릭하고 \"Don't ask again\"을 선택했습니다. 설치 프로그램 창을 다시 표시하여 설치하려면 어떻게 해야 합니까?",
  "a_faq_installation_2": "Tools -> Localization -> Check Dependencies 메뉴를 통해 언제든지 수동으로 종속성 검사를 트리거할 수 있습니다. 그러면 \"Don't ask again\" 플래그가 재설정되고 누락된 모든 선택적 패키지와 함께 창이 다시 표시됩니다.",
  "q_faq_installation_3": "도구가 Assets/Resources에 LocalizationSettings.asset을 생성하지 않았습니다. 왜 이런 일이 발생할 수 있으며 Assets -> Create 메뉴를 통해 수동으로 생성할 수 있습니까?",
  "a_faq_installation_3": "Assets/Resources 폴더가 없는 경우 발생할 수 있습니다. 도구는 이를 생성하려고 시도하지만 파일 시스템 권한으로 인해 방지될 수 있습니다. 예, 자산을 수동으로 생성할 수 있습니다. Resources 폴더를 마우스 오른쪽 버튼으로 클릭하고 Create -> Localization -> Settings를 선택합니다. 도구가 자동으로 찾을 것입니다.",
  "q_faq_installation_4": "LocalizationSettings.asset 파일을 다른 Resources 폴더(예: Assets/MyGame/Resources)로 이동할 수 있습니까? 도구가 여전히 찾을 수 있습니까?",
  "a_faq_installation_4": "예. 도구는 Resources.Load()를 사용하며, 이는 프로젝트의 Resources라는 이름의 모든 폴더에서 이름으로 자산을 검색합니다. 중요한 것은 파일이 LocalizationSettings.asset 이름을 유지한다는 것입니다.",
  "q_faq_installation_5": "종속성 설치 프로그램이 멈추거나 오류가 발생했습니다. Unity 패키지 관리자를 통해 종속성(Newtonsoft Json, Editor Coroutines)을 수동으로 설치할 수 있습니까?",
  "a_faq_installation_5": "예. Window -> Package Manager를 열고 \"+\" 아이콘을 클릭한 다음 \"Add package by name...\"을 선택할 수 있습니다. 패키지 이름 com.unity.nuget.newtonsoft-json 및 com.unity.editorcoroutines를 입력하십시오.",
  "h2_faq_components": "10.2. 핵심 구성 요소",
  "q_faq_components_1": "LocalizedPrefab 구성 요소는 원본 개체에서 MonoBehaviours를 비활성화합니다. 원본 개체에 Awake()에서 다른 개체를 생성하거나 이벤트에 가입하는 스크립트가 있는 경우 어떻게 됩니까? 이 코드가 실행됩니까?",
  "a_faq_components_1": "아니요, 실행되지 않습니다. MonoBehaviour를 비활성화하면 Awake(), OnEnable() 및 Start()를 포함하여 Unity의 모든 \"마법\" 메서드가 호출되는 것을 방지합니다. 이는 중복 로직 실행을 방지하기 위한 의도적인 조치입니다. 모든 초기화는 프리팹의 로컬라이즈된 버전의 스크립트에서 발생해야 합니다.",
  "q_faq_components_2": "원본 프리팹(LocalizedPrefab)에 Rigidbody 또는 다른 물리 구성 요소가 있는 경우 비활성화됩니까? 로컬라이즈된 프리팹에 물리 구성 요소가 없으면 물리학에 영향을 미칩니까?",
  "a_faq_components_2": "예, 원본 개체의 물리적 동작은 중화됩니다. LocalizedPrefab 구성 요소는 GameObject에서 모든 Rigidbody 및 Rigidbody2D 구성 요소를 찾아 isKinematic 속성을 true로 설정합니다. 이는 동적 물리 계산에서 효과적으로 제거하여 보이지 않는 개체가 떨어지거나 충돌에 반응하는 것과 같은 원치 않는 동작을 방지합니다. 올바른 동작을 위해 로컬라이즈된 버전의 프리팹에 필요한 모든 물리 구성 요소가 포함되어 있는 것이 여전히 권장됩니다.",
  "q_faq_components_3": "LocalizedAsset 구성 요소는 대상 구성 요소 이름을 문자열로 저장합니다(_targetComponentTypeName). 사용자 지정 구성 요소 스크립트의 이름을 바꾸거나 다른 어셈블리(Assembly Definition)로 이동하면 어떻게 됩니까? LocalizedAsset이 작동을 멈춥니까?",
  "a_faq_components_3": "예, 작동을 멈춥니다. 구성 요소는 네임스페이스 및 어셈블리를 포함한 전체 유형 이름을 저장합니다. 스크립트의 이름을 바꾸거나 다른 .asmdef로 이동하면 이 이름이 변경되고 LocalizedAsset은 대상 구성 요소를 찾을 수 없습니다. 이름이 업데이트되도록 Analyze Project & Attach Components를 통해 다른 분석을 실행해야 합니다.",
  "q_faq_components_4": "같은 GameObject에 두 개의 Image 구성 요소가 있는 경우 LocalizedAsset은 어떤 구성 요소를 로컬라이즈할지 어떻게 압니까? 둘 다 또는 첫 번째로 찾은 구성 요소만 작동합니까?",
  "a_faq_components_4": "LocalizedAsset은 특정 구성 요소 인스턴스에 대해 생성됩니다. 코드에서 해당 구성 요소에 대한 참조를 유지합니다. 두 번째 LocalizedAsset을 수동으로 추가하고 \"Analyze for Localization\" 상황별 메뉴를 사용하여 두 번째 Image를 대상으로 지정하면 각각 자체 Image를 관리하는 두 개의 LocalizedAsset 구성 요소가 있습니다. 자동 분석기는 찾은 로컬라이즈 가능한 자산이 있는 첫 번째 Image에 대해서만 구성 요소를 생성합니다.",
  "q_faq_components_5": "문서에 LocalizedPrefab의 실행 순서가 -100이라고 나와 있습니다. Awake()에서 LocalizedPrefab이 생성한 자식 개체를 찾으려는 실행 순서가 -110인 다른 스크립트가 있는 경우 어떻게 됩니까? LocalizedPrefab이 제때 인스턴스를 인스턴스화했습니까?",
  "a_faq_components_5": "예, 인스턴스화했습니다. LocalizedPrefab은 OnEnable() 메서드에서 로컬라이즈된 프리팹의 인스턴스를 생성합니다. Unity의 실행 순서는 모든 OnEnable() 메서드 이전에 모든 Awake() 메서드가 실행되도록 보장합니다. 따라서 순서가 -110인 스크립트가 Awake()를 실행한 다음, 순서가 -100인 LocalizedPrefab이 Awake()를 실행하고, 그 후에만 OnEnable() 메서드가 순서대로 호출됩니다. 스크립트가 아직 생성되지 않았기 때문에 개체를 찾을 수 없습니다.",
  "q_faq_components_6": "LocalizedText 구성 요소에는 isStyleOnly 옵션이 있습니다. 이를 활성화한 다음 코드에서 myLocalizedText.SetFormattedText(\"new_key\")를 호출하면 텍스트가 변경됩니까, 아니면 스타일(폰트/RTL)만 변경됩니까?",
  "a_faq_components_6": "키와 텍스트 모두 변경됩니다. SetFormattedText를 프로그래밍 방식으로 호출하면 해당 특정 업데이트에 대해 isStyleOnly 동작을 무시합니다. isStyleOnly 옵션은 구성 요소가 전역 언어 변경에 반응하는 것을 방지하기 위한 것이지만, 코드를 통한 직접적인 키 변경에는 항상 반응합니다.",
  "q_faq_components_7": "LocalizedBehaviour는 [OnLanguageChange] 속성이 있는 메서드를 자동으로 찾습니다. private 및 protected 메서드를 찾습니까, 아니면 public이어야 합니까?",
  "a_faq_components_7": "모든 접근 한정자(public, private, protected, internal)가 있는 메서드를 찾습니다. Unity의 리플렉션은 접근 수준에 관계없이 모든 인스턴스 메서드를 검색할 수 있도록 합니다.",
  "q_faq_components_8": "LocalizedAsset 구성 요소는 Play on Awake를 가로챕니다. 같은 개체의 다른 스크립트가 LocalizedAsset이 교체하기 전에 Awake() 또는 Start()에서 자산(예: audioSource.clip.length)에 액세스하려고 하면 어떻게 됩니까? NullReferenceException 또는 이전 자산 사용이 가능합니까?",
  "a_faq_components_8": "이전(로컬라이즈되지 않은) 자산 사용이 가능합니다. LocalizedAsset은 OnEnable()에서 교체를 수행합니다. 모든 스크립트의 Awake() 메서드는 OnEnable() 이전에 실행됩니다. 스크립트가 Awake()에서 audioSource.clip에 액세스하면 원본 클립을 가져옵니다. Start()에서 액세스하는 경우 결과는 스크립트 실행 순서에 따라 달라집니다. 로컬라이즈된 자산에 대한 액세스를 보장하려면 스크립트의 실행 순서를 늦추거나 [OnLanguageChange]로 표시된 메서드에서 자산에 액세스하십시오.",
  "h2_faq_window": "10.3. \"로컬라이제이션 도구\" 창",
  "h3_faq_window_preview": "에디터 내 미리보기",
  "q_faq_window_preview_1": "Prefab Mode에서 프리팹을 열고 In-Editor Preview를 적용한 다음 Ctrl+S를 눌렀습니다. 임시 미리보기 데이터가 프리팹 자산에 저장됩니까? LocalizationPreviewProtector는 이 경우를 어떻게 처리합니까?",
  "a_faq_window_preview_1": "아니요, 저장되지 않습니다. LocalizationPreviewProtector는 자산 저장 이벤트(OnWillSaveAssets)를 가로채고 Unity가 디스크에 변경 사항을 쓰기 전에 자동으로 RevertEditorPreview()를 호출합니다. 따라서 프리팹은 원래의 로컬라이즈되지 않은 상태로 저장됩니다.",
  "q_faq_window_preview_2": "In-Editor Preview를 활성화하고 Unity 에디터가 충돌하고 Temp/localization_preview_recovery.json 파일이 손상된 경우(예: 비어 있거나 유효하지 않은 JSON) 다음 실행 시 어떻게 됩니까?",
  "a_faq_window_preview_2": "PreviewCrashProtector는 try-catch 블록으로 래핑됩니다. JSON 역직렬화가 실패하면 복구할 수 없음에 대한 오류가 콘솔에 기록되고 프로세스가 조용히 종료됩니다. 씬은 충돌 당시의 \"손상된\" 상태로 유지됩니다. 이 경우 도구 창에서 \"Revert to Original\"을 수동으로 선택하여 변경 사항을 강제로 롤백해야 합니다.",
  "q_faq_window_preview_3": "LocalizedPrefab에 대한 In-Editor Preview 모드에서는 임시 인스턴스가 생성됩니다. 이 인스턴스에서 Awake() 및 Start() 메서드가 실행됩니까? Edit Mode에서 실행되도록 설계되지 않은 경우 오류가 발생할 수 있습니까?",
  "a_faq_window_preview_3": "예, 실행됩니다. Edit Mode의 PrefabUtility.InstantiatePrefab은 Awake() 및 OnEnable()을 호출합니다. 이러한 메서드에 에디터에서 실행되어서는 안 되는 논리(예: Play Mode에서만 존재하는 싱글톤에 액세스)가 포함된 경우 오류가 발생할 수 있습니다. 이러한 코드를 보호하기 위해 if (Application.isPlaying) 또는 #if UNITY_EDITOR를 사용하는 것이 좋습니다.",
  "h3_faq_window_settings": "\"설정\" 탭",
  "q_faq_window_settings_1": "프로젝트 중간에 Key Generation Mode를 UseTextAsKey에서 AutoGenerateKeysOnly로 변경할 수 있습니다. 기존 번역에 정확히 어떤 일이 발생합니까? 새 키에 매핑됩니까?",
  "a_faq_window_settings_1": "예, 매핑됩니다. 모드를 변경할 때 도구는 \"안전한 마이그레이션\"을 수행합니다. 전체 프로젝트를 다시 구문 분석하고, 새 규칙에 따라 새 키를 생성하지만, 원본 텍스트를 통해 이전 키와 새 키를 매핑합니다. 그런 다음 기존 번역 및 주석을 이전 키에서 새 키로 모두 전송합니다. 번역은 손실되지 않습니다.",
  "q_faq_window_settings_2": "Supported Languages 목록에 복수화 규칙이 없는 코드(예: 카자흐어의 경우 \"kz\")로 언어를 추가하면 기본적으로 어떤 규칙이 사용됩니까?",
  "a_faq_window_settings_2": "영어 및 대부분의 유럽 언어에 적합한 DefaultPluralRule이 사용됩니다(\"one\" 및 \"other\" 형식).",
  "q_faq_window_settings_3": "Translations Path를 StreamingAssets가 아닌 Assets/MyTranslations와 같은 일반 폴더에 지정하면 어떻게 됩니까? json 파일이 게임 빌드에 포함됩니까?",
  "a_faq_window_settings_3": "아니요, 포함되지 않습니다. StreamingAssets 또는 Resources 폴더에 있는 자산만 빌드에 포함되는 것이 보장됩니다. 다른 경로를 지정하면 로컬라이제이션은 에디터에서 작동하지만 번역 파일이 빌드의 일부가 아니므로 컴파일된 게임에서는 작동하지 않습니다.",
  "q_faq_window_settings_4": "자동 번역 API 키는 EditorPrefs에 저장됩니다. 두 대의 다른 컴퓨터에서 프로젝트를 작업하는 경우 각 컴퓨터에 키를 별도로 입력해야 합니까?",
  "a_faq_window_settings_4": "예. EditorPrefs는 각 컴퓨터에 대한 로컬 저장소입니다. 자동 번역 기능을 사용하려는 각 컴퓨터에 API 키를 입력해야 합니다.",
  "h3_faq_window_content": "\"콘텐츠\" 탭",
  "q_faq_window_content_1": "Scenes to Parse에 Build Settings에 포함되지 않은 씬을 추가하면 구문 분석 프로세스 자체 외에 다른 것에 영향을 미칩니까?",
  "a_faq_window_content_1": "아니요, 그렇지 않습니다. Scenes to Parse 목록은 텍스트를 분석하기 위해 어떤 씬을 열어야 하는지 도구에 알리는 데만 사용됩니다. 최종 게임 빌드에 포함될 씬과는 전혀 관련이 없습니다.",
  "q_faq_window_content_2": "Ignore Specific Objects (임시 목록)에 개체를 추가했습니다. 이 개체로 프리팹을 만들면 이 프리팹의 인스턴스도 무시됩니까?",
  "a_faq_window_content_2": "아니요, 무시되지 않습니다. 임시 목록은 씬의 개체에 대한 직접 참조를 저장합니다. 프리팹을 만들 때 새 자산입니다. 해당 인스턴스는 다른 개체이며 무시 규칙이 적용되지 않습니다. 프리팹을 영구적으로 무시하려면 프리팹 자산으로 무시 목록에 추가해야 합니다.",
  "q_faq_window_content_3": "TMPro.TMP_Text 구성 요소를 Parsing Ignores -> Ignore Component Types에 추가했지만 씬에 이미 이 TMP_Text를 참조하는 LocalizedText가 있는 개체가 있는 경우 다음 Update Keys에서 어떻게 됩니까? 키가 삭제됩니까?",
  "a_faq_window_content_3": "예, 삭제됩니다. Update Keys를 클릭하면 파서가 전체 프로젝트를 다시 스캔합니다. TMPro.TMP_Text 유형을 무시해야 함을 확인하고 키를 생성하지 않습니다. 이전 키와 새 키를 비교하는 프로세스 중에 이전 키가 더 이상 사용되지 않는다고 판단하고 \"Removed\"로 표시합니다.",
  "q_faq_window_content_4": "문서에는 \"Pin\"이 개체의 전체 경로를 저장하고 이름이 바뀌면 손상된다고 나와 있습니다. 개체에서 프리팹을 만든 다음 원본 개체의 이름을 바꾸면 \"Pin\"이 프리팹 인스턴스에 대해 계속 작동합니까?",
  "a_faq_window_content_4": "아니요, 작동하지 않습니다. \"Pin\"은 버튼을 클릭한 순간 씬 계층 구조의 절대 경로(예: Canvas/Panel/Button)를 저장합니다. 이 경로는 프리팹 논리와 관련이 없습니다. 프리팹 인스턴스는 동일한 경로를 갖지만 씬에서 부모 개체의 이름을 바꾸면 \"Pin\"이 원본과 인스턴스 모두에 대해 작동을 멈춥니다.",
  "q_faq_window_content_5": "프리팹 인스턴스 내의 자식 개체에 \"Pin\"을 사용하면 어떤 경로가 저장됩니까? 프리팹 루트에 대한 상대 경로입니까, 아니면 씬 루트입니까? 다른 씬에서도 작동합니까?",
  "a_faq_window_content_5": "씬 루트의 전체 경로가 저장됩니다. 예를 들어 MyPrefab(Clone)/Content/Icon입니다. 이 \"고정된\" 경로는 생성한 씬에서만 작동합니다. 다른 씬에서는 이러한 경로를 찾을 수 없을 것입니다.",
  "h3_faq_window_actions": "\"액션\" 탭",
  "h3_faq_window_assets": "\"자산\" 탭",
  "h3_faq_window_report": "\"보고서\" 탭",
  "h2_faq_editor": "10.4. 번역 편집기",
  "h2_faq_examples": "10.5. 사용 예시 및 코드",
  "h2_faq_notes": "10.6. 중요한 뉘앙스 및 경고",
  "h2_faq_extending": "10.7. 기능 확장",
  "q_faq_window_actions_1": "일괄 자동 번역 중에 인터넷 연결이 끊어지면 어떻게 됩니까? 도구가 다시 시도 정책에 따라 실패한 배치를 다시 시도합니까, 아니면 프로세스가 완전히 중단됩니까?",
  "a_faq_window_actions_1": "도구는 다시 시도 정책 설정(시도 횟수 및 지연)에 따라 실패한 정확한 배치를 다시 보내려고 시도합니다. 이 배치에 대한 모든 시도가 실패하면 현재 언어에 대한 번역 프로세스가 중단되고 오류가 콘솔에 기록됩니다. 대기열의 다음 언어에 대한 번역은 시작되지 않습니다.",
  "q_faq_window_actions_2": "프로젝트에 이미 존재하는 키가 포함된 CSV 파일을 가져오지만 일부 언어에 대한 값이 비어 있는 경우 이러한 빈 값이 기존 번역을 대체합니까 아니면 무시됩니까?",
  "a_faq_window_actions_2": "빈 값은 기존 번역을 대체합니다. 가져오기 프로세스는 CSV 파일을 \"진실의 출처\"로 간주합니다. ru 열의 welcome_message 키에 대한 값이 비어 있으면 이 키에 대한 현재 러시아어 번역이 덮어쓰여집니다.",
  "q_faq_window_actions_3": "\"위험 영역\" 섹션에서는 모든 구성 요소를 삭제할 수 있습니다. Content 탭의 Prefab Folders에 지정되지 않은 폴더에 있는 프리팹에서 구성 요소를 제거합니까?",
  "a_faq_window_actions_3": "예, 제거합니다. \"Danger Zone\"의 함수는 가능한 가장 완전한 정리를 보장하기 위해 구문 분석 목록에 지정된 프리팹뿐만 아니라 프로젝트의 모든 프리팹(AssetDatabase.FindAssets(\"t:Prefab\"))을 스캔합니다.",
  "q_faq_window_actions_4": "Google Sheets에서 가져올 때 @placeholders: 지시문을 사용하는 자리 표시자 유효성 검사를 위해 주석 열의 형식을 어떻게 지정해야 합니까?",
  "a_faq_window_actions_4": "Google Sheets 문서에서 열 제목은 \"Developer Notes\"여야 합니다. 이 열의 셀에 평소와 같이 주석을 작성할 수 있습니다. 자리 표시자를 지정하려면 주석 텍스트에 @placeholders: {username}, {score}와 같은 줄을 추가하기만 하면 됩니다. 도구가 가져올 때 이 지시문을 자동으로 인식합니다.",
  "q_faq_window_actions_5": "도구가 단일 Google Sheets 문서의 여러 시트에서 데이터를 가져올 수 있습니까, 아니면 GID당 하나의 시트에서만 작동합니까?",
  "a_faq_window_actions_5": "도구는 한 번에 하나의 시트에서만 작동합니다. 가져오기 URL에는 문서의 특정 시트를 고유하게 식별하는 gid=... 매개변수가 포함됩니다. 다른 시트에서 데이터를 가져오려면 해당 URL(다른 gid 포함)을 복사하고 가져오기를 다시 수행해야 합니다.",
  "q_faq_window_assets_1": "같은 스캔 폴더에 같은 키이지만 다른 유형의 두 자산(예: sound_effect_en.mp3 및 sound_effect_en.wav)이 있는 경우 어떻게 됩니까? 어느 것이 자산 테이블에 포함됩니까?",
  "a_faq_window_assets_1": "자산 스캐너는 예상 유형을 지정하여 로드합니다(AssetDatabase.LoadAssetAtPath(path, expectedType)). AudioClip 범주의 경우 Unity가 AudioClip으로 인식하는 파일만 검색하고 로드합니다. 두 파일 모두 유효한 오디오 클립인 경우 마지막으로 처리된 파일이 테이블에 포함되어 이전 파일을 효과적으로 덮어씁니다. 이러한 중복을 피하는 것이 좋습니다.",
  "q_faq_window_assets_2": "Scan Assets & Analyze Project를 클릭하고 씬에 로컬라이즈된 스프라이트가 이미 존재하는 Image 개체가 있지만 Image 개체 자체에는 아직 LocalizedAsset 구성 요소가 없는 경우 도구가 구성 요소를 추가하고 키를 자동으로 삽입합니까?",
  "a_faq_window_assets_2": "예, 정확히 그렇게 작동합니다. \"Analyze Project\"는 Image 구성 요소를 찾고, 이에 할당된 스프라이트의 이름(예: icon_play_en)을 보고, 거기에서 키(icon_play)와 언어(en)를 추출한 다음, 해당 GameObject에 LocalizedAsset 구성 요소를 추가하고 키 icon_play를 안에 씁니다.",
  "q_faq_window_assets_3": "다른 Scan Folders가 있는 경우 다른 자산 범주에 대해 동일한 Naming Rule을 사용할 수 있습니까? 이로 인해 충돌이 발생합니까?",
  "a_faq_window_assets_3": "예, 사용할 수 있습니다. 각 범주에 대해 별도의 자산 테이블(LocalizedAssetTable)이 생성되므로 충돌이 발생하지 않습니다. \"Sprites\" 범주의 키는 이름이 같더라도 \"AudioClips\" 범주의 키와 겹치지 않습니다.",
  "q_faq_window_assets_4": "로컬라이즈 가능한 자산(예: button_ok_en.png)이 Scan Folder의 루트에 있지 않고 하위 폴더에 있는 경우 스캐너가 찾을 수 있습니까?",
  "a_faq_window_assets_4": "예, 찾을 수 있습니다. 스캐너는 SearchOption.AllDirectories 옵션을 사용하며, 이는 지정한 Scan Folder 내의 모든 하위 폴더를 재귀적으로 확인한다는 의미입니다.",
  "q_faq_window_report_1": "\"Find\" 버튼은 개체를 비동기적으로 검색합니다. 검색을 시작한 다음 즉시 Update Keys를 클릭하면 어떻게 됩니까? 검색이 중단됩니까?",
  "a_faq_window_report_1": "예, 중단됩니다. UI 차단을 요구하는 모든 새 액션(예: Update Keys)은 현재 검색 코루틴을 중지합니다. 새 검색을 시작하려면 현재 검색을 중지하라는 메시지가 포함된 대화 상자가 나타납니다.",
  "q_faq_window_report_2": "키가 여러 곳에서 사용되는 경우(예: 다른 씬의 두 개의 다른 버튼에서) 보고서의 \"Duplicates\" 범주에 어떻게 표시됩니까?",
  "a_faq_window_report_2": "\"Duplicates\" 범주에는 해당 키에 대한 모든 소스가 표시됩니다. 키에 대한 하나의 항목이 표시되고 \"Source\" 필드에는 모든 경로(씬 1과 씬 2)가 나열됩니다. 이 경우 \"Find\" 버튼을 클릭하면 드롭다운 목록이 열려 이동할 개체를 선택할 수 있습니다.",
  "q_faq_window_report_3": "코드에서만 사용되는 키( _() 함수를 통해)에 대해 \"Find\"를 클릭하면 어떻게 됩니까? 도구가 C# 스크립트를 찾아 강조 표시할 수 있습니까?",
  "a_faq_window_report_3": "예. 검색 시스템은 MyScript.cs 스크립트와 같은 소스를 인식하도록 특별히 훈련되었습니다. \"Find\"를 클릭하면 프로젝트에서 MyScript.cs 자산을 검색하고 Project 창에서 강조 표시합니다(ping).",
  "q_faq_editor_1": "자리 표시자 유효성 검사에 우선 순위가 높은 것은 무엇입니까? 주석의 @placeholders: 지시문입니까, 아니면 소스 언어 텍스트에서 발견된 자리 표시자입니까? 예를 들어 소스 텍스트에 {name}이 있고 주석에 @placeholders: {username}이라고 표시된 경우.",
  "a_faq_editor_1": "주석의 @placeholders: 지시문에 우선 순위가 있습니다. 이는 개발자의 명시적인 지침이자 \"진실의 출처\"로 간주됩니다. 예시에서 편집기는 번역에 {username}이 필요하며 소스 텍스트의 {name}을 무시합니다.",
  "q_faq_editor_2": "지시문에 오타가 있는 경우(예: @placeholders: 대신 @placeholder:) 무시됩니까 아니면 도구에서 경고를 발행합니까?",
  "a_faq_editor_2": "단순히 무시됩니다. 도구는 @placeholders:의 정확한 일치를 찾습니다. 지시문에 오타가 있는 경우 일반 주석의 일부로 처리되며 유효성 검사는 이전 방식(소스 텍스트의 자리 표시자를 기반으로 함)으로 작동합니다.",
  "q_faq_editor_3": "자동 저장 시스템은 Backups/AutoSaves 폴더에 파일을 생성합니다. 수동 저장에 성공하거나 창을 닫은 후 이러한 파일이 자동으로 삭제됩니까?",
  "a_faq_editor_3": "예. 수동 저장에 성공하거나 정상적인 창 닫기(변경 사항을 저장할 때) 시 다음 실행 시 복구를 요청하는 것을 방지하기 위해 모든 자동 저장 파일이 삭제됩니다. 에디터 충돌이 발생한 경우에만 남아 있습니다.",
  "q_faq_editor_4": "편집기에서 열 너비를 변경하면 이러한 설정이 Unity 세션 간에 저장됩니까?",
  "a_faq_editor_4": "예. 열 너비는 번역 편집기 창을 닫을 때마다 EditorPrefs에 저장되며 다음에 열 때 복원됩니다.",
  "q_faq_editor_5": "텍스트 편집 팝업 창(MultiLineEditWindow)은 자체 실행 취소/다시 실행 스택(Ctrl+Z를 통해)을 지원하여 그 안에서 이루어진 변경 사항을 지원합니까?",
  "a_faq_editor_5": "예. MultiLineEditWindow에는 창이 열려 있는 동안 작동하는 자체 임시 실행 취소/다시 실행 스택이 있습니다. 이를 통해 해당 창 내에서 텍스트 변경을 실행 취소하고 다시 실행할 수 있습니다. 결과를 저장하면(창을 닫아) 이 변경 사항이 기본 편집기의 전역 실행 취소/다시 실행 스택에 단일 액션으로 기록됩니다.",
  "q_faq_examples_1": "_() 함수에 전달된 익명 형식의 속성 이름이 문자열의 자리 표시자와 일치하지 않으면 어떻게 됩니까? 예를 들어 _(\"Hello, {username}\", new { user_name = \"Bob\" })입니다. 오류가 발생합니까, 아니면 자리 표시자가 단순히 대체되지 않습니까?",
  "a_faq_examples_1": "오류는 발생하지 않습니다. {username} 자리 표시자는 단순히 대체되지 않으며 결과로 \"Hello, {username}\" 문자열을 얻게 됩니다. 대체는 정확한 이름 일치에서만 발생합니다.",
  "q_faq_examples_2": "[LocalizableField] 속성은 private 필드에 대해 작동합니다. static 필드에 대해 작동합니까?",
  "a_faq_examples_2": "예, 작동합니다. 파서는 리플렉션을 사용하여 플래그 BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static가 있는 필드를 찾으므로 static 필드를 찾아 처리합니다.",
  "q_faq_examples_3": "매개변수가 있는 메서드(예: void UpdateUI(string newLang))에 [OnLanguageChange] 속성을 넣으면 어떻게 됩니까? 컴파일 오류 또는 런타임 경고가 발생합니까?",
  "a_faq_examples_3": "컴파일 오류는 없지만 런타임에 LocalizedBehaviour의 경고가 Unity 콘솔에 나타납니다. 속성이 있는 메서드를 찾았지만 메서드에 매개변수가 있기 때문에 무시했다고 보고합니다. 이러한 메서드는 호출되지 않습니다.",
  "q_faq_examples_4": "_(\"apple_count\", count)를 사용하고 있습니다. 현재 언어에 대해 apple_count_one 키가 없는 경우(count = 1의 경우) 시스템은 어떤 형식을 선택합니까? apple_count_other를 대체로 사용합니까?",
  "a_faq_examples_4": "예. 특정 형식(_one, _few 등)을 찾을 수 없는 경우 시스템은 _other 접미사가 있는 키를 대체로 사용하려고 시도합니다. 그것도 찾을 수 없으면 기본 키 apple_count에 대한 번역이 사용됩니다.",
  "q_faq_examples_5": "함수 _(\"key\", new { username = \"Alex\" })는 익명 형식을 사용합니다. 미리 생성된 Dictionary<string, object>를 전달하는 것과 비교하여 Update() 메서드에서 자주 호출할 때 가비지 수집기(GC)에 과도한 \"부하\"를 생성하지 않습니까?",
  "a_faq_examples_5": "예, 생성합니다. new { ... }에 대한 각 호출은 관리되는 힙에 메모리를 할당하므로 가비지 수집기에 추가 작업을 생성합니다. 모든 프레임에서 업데이트되는 텍스트(Update 또는 LateUpdate에서)의 경우 Start()에서 Dictionary<string, object>를 한 번 생성하고 _() 함수에 전달하기 전에 Update()에서 해당 값만 업데이트하는 것이 훨씬 더 성능이 좋습니다.",
  "q_faq_examples_6": "[OnLanguageChange]로 표시된 메서드가 호출되지 않습니다. 왜 그렇습니까?",
  "a_faq_examples_6": "메서드에 매개변수가 있는지 확인하십시오. <code>[OnLanguageChange]</code> 속성은 **매개변수가 없는** 메서드(예: <code>void UpdateUI()</code>)에서만 작동합니다. 메서드에 인수가 필요한 경우 매개변수가 없는 메서드로 래핑하십시오.",
  "q_faq_notes_1": "문서에서는 LanguageSelector를 무시 목록에 추가하도록 권장합니다. 이렇게 하는 것을 잊으면 정확히 무엇이 손상됩니까? \"Option A, Option B\"에 대한 추가 키가 생성됩니까?",
  "a_faq_notes_1": "예. LanguageSelector를 무시 목록에 추가하지 않으면 파서는 해당 TMP_Dropdown을 일반 드롭다운으로 처리합니다. Unity가 생성하는 기본 \"Option A, Option B, Option C\"를 찾아 번역 파일에 대한 키를 추가합니다. LanguageSelector는 런타임에 이러한 옵션을 제거하고 어쨌든 자체 옵션을 생성하므로 불필요한 키로 파일이 복잡해집니다.",
  "q_faq_notes_2": "LanguageSelector에서 사용하는 TMP_Dropdown 내부의 Label에 isStyleOnly 확인란이 활성화된 빈 LocalizedText를 추가하는 것을 잊으면 폰트가 변경되지 않습니까? 왜 이것이 필요합니까?",
  "a_faq_notes_2": "예, 폰트가 변경되지 않습니다. LanguageSelector가 label.text 속성을 직접 변경하기 때문에 필요합니다. 이 개체에 LocalizedText가 없으면 로컬라이제이션 시스템은 언어가 변경될 때 이 요소에 스타일(폰트, RTL)을 적용해야 한다는 것을 알지 못합니다. isStyleOnly가 있는 빈 LocalizedText는 시스템에 대한 \"마커\" 역할을 하며, \"이 개체를 보고 스타일을 적용하되 텍스트를 건드리지 마십시오\"라고 말합니다.",
  "q_faq_notes_3": "Update() 메서드에서 _()를 호출하는 것은 권장되지 않습니다. 하지만 모든 프레임에서 텍스트를 업데이트해야 하는 경우(예: 타이머) 어떻게 됩니까? 형식 문자열만 캐시하는 가장 성능이 좋은 방법은 무엇입니까?",
  "a_faq_notes_3": "가장 성능이 좋은 접근 방식은 Start() 또는 [OnLanguageChange] 메서드에서 형식 문자열을 캐시하고 Update()에서 일반 string.Format을 사용하는 것입니다. 예: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } 이렇게 하면 모든 프레임에서 딕셔너리에서 키를 찾는 것을 방지할 수 있어 훨씬 빠릅니다.",
  "q_faq_extending_1": "내 사용자 지정 파서가 모든 Update Keys 후에 자동으로 호출됩니까? 어딘가에 등록해야 합니까, 아니면 프로젝트에 ITextComponentParser를 구현하는 클래스만 있으면 충분합니까?",
  "a_faq_extending_1": "클래스가 있는 것만으로 충분합니다. TextParser가 실행되면 리플렉션을 사용하여 ITextComponentParser 인터페이스를 구현하는 프로젝트의 모든 클래스를 찾고 각 GameObject에 대해 Parse() 메서드를 자동으로 호출합니다. 수동 등록은 필요하지 않습니다.",
  "q_faq_extending_2": "사용자 지정 파서에서 예외가 발생하면 어떻게 됩니까? 전체 구문 분석 프로세스가 중단됩니까, 아니면 도구가 다른 파서로 안전하게 계속됩니까?",
  "h2_faq_addressables": "Addressables 및 마이그레이션",
  "q_faq_addressables_1": "Addressables 모드를 활성화했지만 자산이 로드되지 않습니다. 무엇을 확인해야 합니까?",
  "a_faq_addressables_1": "Addressables 패키지가 설치되었는지, 설정이 생성되었는지, 그룹에 키를 등록하기 위해 \"Scan Assets & Generate Tables\"를 클릭했는지 확인하십시오.",
  "q_faq_addressables_2": "DeepL/Google에 대한 지원을 추가하려면 어떻게 해야 합니까?",
  "a_faq_addressables_2": "자산 폴더에 <code>Translation Profile</code>을 생성하고, 서비스 유형을 선택하고, API 키를 입력하고, <code>Settings</code> 창에서 이 프로필을 할당합니다.",
  "q_faq_addressables_3": "I2/UnityLoc를 제거한 후 마이그레이터에 컴파일 오류가 표시됩니다. 어떻게 해결할 수 있습니까?",
  "a_faq_addressables_3": "Migration 창(Tab 0)에는 Emergency Stubs 기능을 활성화하는 \"Enable Stubs\" 버튼이 있습니다. 이는 I2 Localization 또는 Unity Localization에 대한 가짜 자리 표시자 클래스를 생성하여 해당 플러그인을 제거한 직후 프로젝트를 컴파일할 수 있도록 합니다. 이 기능은 ANKO_ENABLE_MIGRATION_STUBS 정의 기호를 토글하여 작동합니다. 이렇게 하면 \"The type name 'Localize' could not be found\" 오류가 방지되고 새 시스템을 사용하도록 코드를 올바르게 리팩터링할 시간을 제공합니다. 스텁 활성화는 이전 로컬라이제이션 플러그인을 삭제한 후 컴파일 오류를 수정할 수 있도록 합니다.",
  "a_faq_extending_2": "사용자 지정 파서의 예외로 인해 프로세스가 중단됩니다. 기본 구문 분석 루프는 try-catch 블록에서 사용자 지정 파서에 대한 호출을 래핑하지 않습니다. Parse() 메서드가 처리되지 않은 예외를 throw하면,",
  "h2_faq_audio": "AI 오디오 / 텍스트 음성 변환 (Text-to-Speech)",
  "q_faq_audio_smart_update": "오디오 파일을 다시 생성할 때 도구가 API 크레딧을 절약하는 방법은 무엇입니까?",
  "a_faq_audio_smart_update": "도구는 스마트 배치 처리와 MD5 해싱을 사용하여 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성합니다. 텍스트 콘텐츠의 MD5 해시를 계산하고 이전에 생성된 오디오 파일과 비교합니다. 텍스트가 변경되지 않은 경우 재생성을 건너뛰어 API 크레딧을 절약합니다. 이는 불필요한 API 호출을 방지하고 오디오를 다시 생성할 때 비용을 줄입니다. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다.",
  "toggle_notes_title": "노트 토글",
  "mindmap_toggle_title": "마인드 맵 표시",
  "on_this_page_title": "이 페이지에서",
  "my_notes_title": "내 노트",
  "no_notes_message_new": "노트를 추가하려면 텍스트 위로 마우스를 가져갑니다.",
  "notes_add_title": "이 블록에 노트 추가",
  "notes_placeholder": "당신의 노트...",
  "notes_close_title": "닫기",
  "notes_goto_title": "텍스트로 이동",
  "notes_edit_title": "노트 편집",
  "notes_delete_title": "노트 삭제",
  "notes_edit_text": "편집",
  "copy_code_copy": "복사",
  "copy_code_copied": "복사됨!",
  "copy_code_error": "오류",
  "error_loading_title": "로딩 오류",
  "error_loading_message": "연결을 확인하고 새로 고침하십시오.",
  "lightbox_aria_close": "이미지 뷰어 닫기",
  "lightbox_image_alt": "확대 보기",
  "mindmap_preset_full": "전체 보기",
  "mindmap_preset_quick_start": "빠른 시작",
  "mindmap_preset_dev": "개발자 워크플로",
  "mindmap_preset_translator": "번역가 워크플로",
  "mindmap_edge_configure": "1. 구성",
  "mindmap_edge_specify_content": "2. 콘텐츠 지정",
  "mindmap_edge_parse_project": "3. 프로젝트 구문 분석",
  "mindmap_edge_creates_components": "구성 요소 생성",
  "mindmap_edge_generates": "생성",
  "mindmap_edge_opens": "열기",
  "mindmap_edge_manages_assets": "자산 관리",
  "mindmap_edge_defines_rules": "규칙 정의",
  "mindmap_edge_reports_on": "보고서",
  "mindmap_edge_enables_reaction": "반응 활성화",
  "mindmap_edge_processed_by": "처리",
  "mindmap_edge_edited_in": "편집",
  "mindmap_edge_extends": "확장",
  "mindmap_edge_warns_about": "경고",
  "mindmap_edge_relates_to": "관련",
  "mindmap_edge_recommends_for": "권장",
  "mindmap_edge_see_faq": "FAQ 참조",
  "li_attr_feat_5": "<strong>서식화된 문자열:</strong> 보간된 문자열 (<code>$\"Text {0}\"</code>) 및 축자 문자열 (<code>@\"Text\"</code>)을 지원합니다. 파서는 원본 형식 패턴을 추출합니다.",
  "li_cheat_unattached": "<strong>연결되지 않은 스크립트:</strong> 스크립트는 씬 또는 프리팹의 게임 오브젝트에 있어야 합니다.",
  "li_cheat_base_private": "<strong>기반 private 필드:</strong> 부모 클래스의 <code>private</code> 필드 (상속 제한)",
  "li_attr_feat_1": "<strong>컬렉션:</strong> <code>List&lt;string&gt;</code> 및 <code>string[]</code>을 지원합니다. 키는 <code>_0</code>, <code>_1</code> 등과 같은 접미사로 생성됩니다. 목록 필드 자체에 사용자 지정 키를 사용하여 모든 항목에 접두사를 붙일 수도 있습니다.",
  "li_cheat_serializable": "중첩된 <code>[Serializable] class</code> (인벤토리 아이템, 대화 노드)",
  "li_cheat_structs": "<strong>구조체</strong> (재귀는 클래스만 지원됩니다)",
  "code_example_attribute_limitations": "[LocalizableField] \npublic string Prop { get; set; } // 실패: 속성\n\n[LocalizableField]\npublic static string St = \"X\"; // 실패: 정적\n\n[LocalizableField]\npublic string Head = \"A\" + \"B\"; // 실패: 연결",
  "li_cheat_non_literals": "<strong>변수 및 상수:</strong> <code>string s = MyConst;</code>와 같은 할당 (문자열 리터럴이어야 합니다)",
  "h3_attribute_limitations": "제한 사항",
  "li_cheat_headers": "<code>[Header(\"...\")]</code>와 같은 속성 (설정에 추가된 경우)",
  "li_cheat_static": "<strong>정적 필드:</strong> <code>public static string</code> (파서는 인스턴스만 스캔합니다)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> 필드 (파서는 리플렉션을 사용합니다)",
  "li_attr_feat_2": "<strong>접근 한정자:</strong> <code>private</code>, <code>protected</code>, <code>internal</code>, <code>public</code> 필드에서 작동합니다.",
  "li_attr_limit_3": "<strong>정적 필드:</strong> 코드 파일에서 정적 분석(regex)을 통해 지원되지만, 게임 오브젝트에서 강력한 감지를 위해서는 인스턴스 필드를 사용하는 것이 일반적으로 권장됩니다.",
  "li_attr_feat_3": "<strong>사용자 지정 속성:</strong> <em>Content Tab</em> 설정에서 <code>HeaderAttribute</code>, <code>TooltipAttribute</code> 또는 사용자 지정 속성 이름을 추가할 수 있습니다. 그러면 파서는 이러한 속성(예: <code>[Header(\"Text\")]</code>)이 있는 필드를 지역화 가능한 문자열로 처리합니다!",
  "li_cheat_ternary": "<strong>논리/삼항 연산:</strong> <code>cond ? \"A\" : \"B\"</code> (파서가 값을 결정할 수 없습니다)",
  "li_cheat_concatenation": "<strong>문자열 연결:</strong> <code>\"A\" + \"B\"</code> (정규식은 첫 번째 부분만 캡처합니다: \"A\")",
  "li_attr_limit_1": "<strong>속성은 무시됩니다:</strong> 파서는 <code>Fields</code>만 스캔합니다. <code>[LocalizableField] public string Name { get; set; }</code>와 같은 코드는 <strong>작동하지 않습니다</strong>.",
  "li_attr_limit_2": "<strong>사전:</strong> <code>Dictionary&lt;T, string&gt;</code>은 파싱을 위해 직접 지원되지 않습니다.",
  "li_cheat_dictionaries": "<strong>사전</strong> (Unity 인스펙터에서 기본적으로 직렬화되지 않음)",
  "li_cheat_properties": "<strong>속성</strong> <code>{ get; set; }</code> (필드만 해당!)",
  "h3_attribute_features": "지원되는 유형 및 기능",
  "h3_attribute_cheat_sheet": "빠른 참조: 권장 사항 및 비권장 사항",
  "li_attr_feat_4": "<strong>중첩 객체:</strong> <code>[System.Serializable]</code>로 표시된 클래스 또는 구조체 내부의 필드를 재귀적으로 스캔합니다. 여기에는 단일 인스턴스와 중첩 객체 목록이 포함됩니다.",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> 배열",
  "li_cheat_scriptable_objects": "<strong>ScriptableObject</strong> (MonoBehaviour에서 참조되어야 합니다)",
  "li_cheat_constructor_args": "<strong>복잡한 생성자 인수:</strong> <code>new Item(\"Name\" + index)</code>",
  "lbl_supported": "완전히 지원됨",
  "li_cheat_nested_lists": "<strong>중첩 객체 목록</strong> (예: <code>List&lt;ItemData&gt;</code>)",
  "tip_best_practice": "<strong>전문가 팁:</strong> 속성을 지역화해야 하는 경우, <code>[LocalizableField]</code>로 백킹 필드를 생성하고 속성을 별도로 노출하세요.",
  "lbl_not_supported": "지원되지 않음"
}