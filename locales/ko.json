{
  "a_faq_addressables_1": "Addressables 패키지가 설치되었는지, 설정이 생성되었는지, 그룹에 키를 등록하기 위해 \"Scan Assets & Generate Tables\"를 클릭했는지 확인하십시오.",
  "a_faq_addressables_2": "자산 폴더에 <code>Translation Profile</code>을 생성하고, 서비스 유형을 선택하고, API 키를 입력하고, <code>Settings</code> 창에서 이 프로필을 할당합니다.",
  "a_faq_addressables_3": "마이그레이션 창(Components / Import 탭)에는 Emergency Stubs 기능을 활성화하는 \"Enable Stubs\" 버튼이 있습니다. 이 기능은 I2 Localization 또는 Unity Localization에 대한 가짜 플레이스홀더 클래스를 생성하여 플러그인을 제거한 후 프로젝트를 즉시 컴파일할 수 있게 합니다. 이 기능은 ANKO_ENABLE_MIGRATION_STUBS 정의 심볼을 토글하여 작동합니다. 이는 \"The type name 'Localize' could not be found\" 오류를 방지하고 새로운 시스템을 사용하도록 코드를 적절히 리팩터링할 시간을 제공합니다. Enable Stubs는 오래된 로컬라이제이션 플러그인을 삭제한 후 컴파일 오류를 수정할 수 있게 해줍니다. v2.0에서는 마이그레이션 시스템이 <strong>Migration Profiles</strong>로 확장되어 다른 플러그인으로부터 보다 견고한 전환 규칙을 제공합니다.",
  "a_faq_audio_smart_update": "도구는 스마트 배치 처리와 MD5 해싱을 사용하여 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성합니다. 텍스트 콘텐츠의 MD5 해시를 계산하고 이전에 생성된 오디오 파일과 비교합니다. 텍스트가 변경되지 않은 경우 재생성을 건너뛰어 API 크레딧을 절약합니다. 이는 불필요한 API 호출을 방지하고 오디오를 다시 생성할 때 비용을 줄입니다. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다.",
  "a_faq_components_1": "아니요, 실행되지 않습니다. MonoBehaviour를 비활성화하면 Awake(), OnEnable() 및 Start()를 포함하여 Unity의 모든 \"마법\" 메서드가 호출되는 것을 방지합니다. 이는 중복 로직 실행을 방지하기 위한 의도적인 조치입니다. 모든 초기화는 프리팹의 로컬라이즈된 버전의 스크립트에서 발생해야 합니다.",
  "a_faq_components_2": "예, 원본 개체의 물리적 동작은 중화됩니다. LocalizedPrefab 구성 요소는 GameObject에서 모든 Rigidbody 및 Rigidbody2D 구성 요소를 찾아 isKinematic 속성을 true로 설정합니다. 이는 동적 물리 계산에서 효과적으로 제거하여 보이지 않는 개체가 떨어지거나 충돌에 반응하는 것과 같은 원치 않는 동작을 방지합니다. 올바른 동작을 위해 로컬라이즈된 버전의 프리팹에 필요한 모든 물리 구성 요소가 포함되어 있는 것이 여전히 권장됩니다.",
  "a_faq_components_3": "예, 그렇게 됩니다. 이 컴포넌트는 네임스페이스와 어셈블리를 포함한 전체 타입 이름을 저장합니다. 스크립트의 이름을 바꾸거나 다른 .asmdef로 이동하면 이 이름이 변경되며, LocalizedAsset은 대상 컴포넌트를 찾을 수 없게 됩니다. 이름을 업데이트하려면 Analyze Project & Attach Components를 통해 다시 분석을 실행해야 합니다.",
  "a_faq_components_4": "LocalizedAsset은 특정 구성 요소 인스턴스에 대해 생성됩니다. 코드에서 해당 구성 요소에 대한 참조를 유지합니다. 두 번째 LocalizedAsset을 수동으로 추가하고 \"Analyze for Localization\" 상황별 메뉴를 사용하여 두 번째 Image를 대상으로 지정하면 각각 자체 Image를 관리하는 두 개의 LocalizedAsset 구성 요소가 있습니다. 자동 분석기는 찾은 로컬라이즈 가능한 자산이 있는 첫 번째 Image에 대해서만 구성 요소를 생성합니다.",
  "a_faq_components_5": "예, 인스턴스화했습니다. LocalizedPrefab은 OnEnable() 메서드에서 로컬라이즈된 프리팹의 인스턴스를 생성합니다. Unity의 실행 순서는 모든 OnEnable() 메서드 이전에 모든 Awake() 메서드가 실행되도록 보장합니다. 따라서 순서가 -110인 스크립트가 Awake()를 실행한 다음, 순서가 -100인 LocalizedPrefab이 Awake()를 실행하고, 그 후에만 OnEnable() 메서드가 순서대로 호출됩니다. 스크립트가 아직 생성되지 않았기 때문에 개체를 찾을 수 없습니다.",
  "a_faq_components_6": "키와 텍스트 모두 변경됩니다. SetFormattedText를 프로그래밍 방식으로 호출하면 해당 특정 업데이트에 대해 isStyleOnly 동작을 무시합니다. isStyleOnly 옵션은 구성 요소가 전역 언어 변경에 반응하는 것을 방지하기 위한 것이지만, 코드를 통한 직접적인 키 변경에는 항상 반응합니다.",
  "a_faq_components_7": "모든 접근 한정자(public, private, protected, internal)가 있는 메서드를 찾습니다. Unity의 리플렉션은 접근 수준에 관계없이 모든 인스턴스 메서드를 검색할 수 있도록 합니다.",
  "a_faq_components_8": "이전(로컬라이즈되지 않은) 자산 사용이 가능합니다. LocalizedAsset은 OnEnable()에서 교체를 수행합니다. 모든 스크립트의 Awake() 메서드는 OnEnable() 이전에 실행됩니다. 스크립트가 Awake()에서 audioSource.clip에 액세스하면 원본 클립을 가져옵니다. Start()에서 액세스하는 경우 결과는 스크립트 실행 순서에 따라 달라집니다. 로컬라이즈된 자산에 대한 액세스를 보장하려면 스크립트의 실행 순서를 늦추거나 [OnLanguageChange]로 표시된 메서드에서 자산에 액세스하십시오.",
  "a_faq_custom_keys_attribute": "예. **Content Tab**의 'Attributes to Scan' 아래에 모든 속성 이름(예: <code>[Header]</code>, <code>[TermsPopup]</code>)을 추가할 수 있습니다. 파서는 해당 속성이 있는 모든 문자열 필드를 로컬라이즈 가능한 것으로 처리합니다.",
  "a_faq_custom_provider_1": "클래스가 <code>IAssetProvider</code>를 구현하고 추상 클래스가 아니며 <code>[AssetProviderPlugin]</code> 속성으로 표시되어 있는지 확인하십시오. 또한 도구가 모든 어셈블리를 스캔하므로 시작 시 콘솔에서 리플렉션 관련 오류가 있는지 확인하세요.",
  "a_faq_editor_1": "주석의 @placeholders: 지시문에 우선 순위가 있습니다. 이는 개발자의 명시적인 지침이자 \"진실의 출처\"로 간주됩니다. 예시에서 편집기는 번역에 {username}이 필요하며 소스 텍스트의 {name}을 무시합니다.",
  "a_faq_editor_2": "단순히 무시됩니다. 도구는 @placeholders:의 정확한 일치를 찾습니다. 지시문에 오타가 있는 경우 일반 주석의 일부로 처리되며 유효성 검사는 이전 방식(소스 텍스트의 자리 표시자를 기반으로 함)으로 작동합니다.",
  "a_faq_editor_3": "예. 수동 저장에 성공하거나 정상적인 창 닫기(변경 사항을 저장할 때) 시 다음 실행 시 복구를 요청하는 것을 방지하기 위해 모든 자동 저장 파일이 삭제됩니다. 에디터 충돌이 발생한 경우에만 남아 있습니다.",
  "a_faq_editor_4": "예. 열 너비는 번역 편집기 창을 닫을 때마다 EditorPrefs에 저장되며 다음에 열 때 복원됩니다.",
  "a_faq_editor_5": "예. MultiLineEditWindow에는 창이 열려 있는 동안 작동하는 자체 임시 실행 취소/다시 실행 스택이 있습니다. 이를 통해 해당 창 내에서 텍스트 변경을 실행 취소하고 다시 실행할 수 있습니다. 결과를 저장하면(창을 닫아) 이 변경 사항이 기본 편집기의 전역 실행 취소/다시 실행 스택에 단일 액션으로 기록됩니다.",
  "a_faq_examples_1": "오류는 발생하지 않습니다. {username} 자리 표시자는 단순히 대체되지 않으며 결과로 \"Hello, {username}\" 문자열을 얻게 됩니다. 대체는 정확한 이름 일치에서만 발생합니다.",
  "a_faq_examples_2": "예, 작동합니다. 파서는 리플렉션을 사용하여 플래그 BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static가 있는 필드를 찾으므로 static 필드를 찾아 처리합니다.",
  "a_faq_examples_3": "컴파일 오류는 없지만 런타임에 LocalizedBehaviour의 경고가 Unity 콘솔에 나타납니다. 속성이 있는 메서드를 찾았지만 메서드에 매개변수가 있기 때문에 무시했다고 보고합니다. 이러한 메서드는 호출되지 않습니다.",
  "a_faq_examples_4": "예. 특정 형식(_one, _few 등)을 찾을 수 없는 경우 시스템은 _other 접미사가 있는 키를 대체로 사용하려고 시도합니다. 그것도 찾을 수 없으면 기본 키 apple_count에 대한 번역이 사용됩니다.",
  "a_faq_examples_5": "예, 생성합니다. new { ... }에 대한 각 호출은 관리되는 힙에 메모리를 할당하므로 가비지 수집기에 추가 작업을 생성합니다. 모든 프레임에서 업데이트되는 텍스트(Update 또는 LateUpdate에서)의 경우 Start()에서 Dictionary<string, object>를 한 번 생성하고 _() 함수에 전달하기 전에 Update()에서 해당 값만 업데이트하는 것이 훨씬 더 성능이 좋습니다.",
  "a_faq_examples_6": "메서드에 매개변수가 있는지 확인하십시오. <code>[OnLanguageChange]</code> 속성은 **매개변수가 없는** 메서드(예: <code>void UpdateUI()</code>)에서만 작동합니다. 메서드에 인수가 필요한 경우 매개변수가 없는 메서드로 래핑하십시오.",
  "a_faq_extending_1": "클래스가 있는 것만으로 충분합니다. TextParser가 실행되면 리플렉션을 사용하여 ITextComponentParser 인터페이스를 구현하는 프로젝트의 모든 클래스를 찾고 각 GameObject에 대해 Parse() 메서드를 자동으로 호출합니다. 수동 등록은 필요하지 않습니다.",
  "a_faq_extending_2": "사용자 지정 파서의 예외로 인해 프로세스가 중단됩니다. 기본 구문 분석 루프는 try-catch 블록에서 사용자 지정 파서에 대한 호출을 래핑하지 않습니다. Parse() 메서드가 처리되지 않은 예외를 throw하면,",
  "a_faq_installation_1": "설치 프로그램은 Newtonsoft.Json.JsonConvert 유형의 존재를 확인합니다. 유형이 존재하는 경우 종속성이 충족된 것으로 간주하고 패키지를 설치하거나 업데이트하려고 시도하지 않습니다. 이는 버전 충돌을 방지하기 위해 수행됩니다.",
  "a_faq_installation_2": "Tools -> Localization -> Check Dependencies 메뉴를 통해 언제든지 수동으로 종속성 검사를 트리거할 수 있습니다. 그러면 \"Don't ask again\" 플래그가 재설정되고 누락된 모든 선택적 패키지와 함께 창이 다시 표시됩니다.",
  "a_faq_installation_3": "Assets/Resources 폴더가 없는 경우 발생할 수 있습니다. 도구는 이를 생성하려고 시도하지만 파일 시스템 권한으로 인해 방지될 수 있습니다. 예, 자산을 수동으로 생성할 수 있습니다. Resources 폴더를 마우스 오른쪽 버튼으로 클릭하고 Create -> Localization -> Settings를 선택합니다. 도구가 자동으로 찾을 것입니다.",
  "a_faq_installation_4": "예. 도구는 Resources.Load()를 사용하며, 이는 프로젝트의 Resources라는 이름의 모든 폴더에서 이름으로 자산을 검색합니다. 중요한 것은 파일이 LocalizationSettings.asset 이름을 유지한다는 것입니다.",
  "a_faq_installation_5": "예. Window -> Package Manager를 열고 \"+\" 아이콘을 클릭한 다음 \"Add package by name...\"을 선택할 수 있습니다. 패키지 이름 com.unity.nuget.newtonsoft-json 및 com.unity.editorcoroutines를 입력하십시오.",
  "a_faq_notes_1": "예. LanguageSelector를 무시 목록에 추가하지 않으면 파서는 해당 TMP_Dropdown을 일반 드롭다운으로 처리합니다. Unity가 생성하는 기본 \"Option A, Option B, Option C\"를 찾아 번역 파일에 대한 키를 추가합니다. LanguageSelector는 런타임에 이러한 옵션을 제거하고 어쨌든 자체 옵션을 생성하므로 불필요한 키로 파일이 복잡해집니다.",
  "a_faq_notes_2": "예, 폰트가 변경되지 않습니다. LanguageSelector가 label.text 속성을 직접 변경하기 때문에 필요합니다. 이 개체에 LocalizedText가 없으면 로컬라이제이션 시스템은 언어가 변경될 때 이 요소에 스타일(폰트, RTL)을 적용해야 한다는 것을 알지 못합니다. isStyleOnly가 있는 빈 LocalizedText는 시스템에 대한 \"마커\" 역할을 하며, \"이 개체를 보고 스타일을 적용하되 텍스트를 건드리지 마십시오\"라고 말합니다.",
  "a_faq_notes_3": "가장 성능이 좋은 접근 방식은 Start() 또는 [OnLanguageChange] 메서드에서 형식 문자열을 캐시하고 Update()에서 일반 string.Format을 사용하는 것입니다. 예: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } 이렇게 하면 모든 프레임에서 딕셔너리에서 키를 찾는 것을 방지할 수 있어 훨씬 빠릅니다.",
  "a_faq_runtime_api_key_distinction": "<strong>Q: 'Translation Service Keys'와 'Runtime API Key'의 차이는 무엇인가요?</strong><br>A: <strong>Translation Service Keys</strong> (OpenAI, DeepL)는 <strong>Unity Editor</strong>에서 번역을 생성하는 데 사용됩니다. 이 키들은 컴퓨터 레지스트리(EditorPrefs)에 저장되며 빌드에 포함되지 않습니다.<br><strong>Runtime API Key</strong>는 <strong>Game Build</strong>에서 실시간 업데이트를 가져오는 데 사용됩니다. 이는 빌드에 포함됩니다(암호화됨).",
  "a_faq_tts_voices": "**Translation Profile** (인스펙터)에서 'Voice Mappings' 목록을 사용하십시오. 정규식 패턴(예: <code>^hero_.*</code>)을 특정 Voice ID에 매핑할 수 있습니다. 생성기는 키 이름을 기반으로 올바른 음성을 자동으로 선택합니다.",
  "a_faq_window_actions_1": "도구는 다시 시도 정책 설정(시도 횟수 및 지연)에 따라 실패한 정확한 배치를 다시 보내려고 시도합니다. 이 배치에 대한 모든 시도가 실패하면 현재 언어에 대한 번역 프로세스가 중단되고 오류가 콘솔에 기록됩니다. 대기열의 다음 언어에 대한 번역은 시작되지 않습니다.",
  "a_faq_window_actions_2": "빈 값은 기존 번역을 대체합니다. 가져오기 프로세스는 CSV 파일을 \"진실의 출처\"로 간주합니다. ru 열의 welcome_message 키에 대한 값이 비어 있으면 이 키에 대한 현재 러시아어 번역이 덮어쓰여집니다.",
  "a_faq_window_actions_3": "예, 제거합니다. \"Danger Zone\"의 함수는 가능한 가장 완전한 정리를 보장하기 위해 구문 분석 목록에 지정된 프리팹뿐만 아니라 프로젝트의 모든 프리팹(AssetDatabase.FindAssets(\"t:Prefab\"))을 스캔합니다.",
  "a_faq_window_actions_4": "Google Sheets 문서에서 열 제목은 \"Developer Notes\"여야 합니다. 이 열의 셀에 평소와 같이 주석을 작성할 수 있습니다. 자리 표시자를 지정하려면 주석 텍스트에 @placeholders: {username}, {score}와 같은 줄을 추가하기만 하면 됩니다. 도구가 가져올 때 이 지시문을 자동으로 인식합니다.",
  "a_faq_window_actions_5": "도구는 한 번에 하나의 시트에서만 작동합니다. 가져오기 URL에는 문서의 특정 시트를 고유하게 식별하는 gid=... 매개변수가 포함됩니다. 다른 시트에서 데이터를 가져오려면 해당 URL(다른 gid 포함)을 복사하고 가져오기를 다시 수행해야 합니다.",
  "a_faq_window_assets_1": "자산 스캐너는 예상 유형을 지정하여 로드합니다(AssetDatabase.LoadAssetAtPath(path, expectedType)). AudioClip 범주의 경우 Unity가 AudioClip으로 인식하는 파일만 검색하고 로드합니다. 두 파일 모두 유효한 오디오 클립인 경우 마지막으로 처리된 파일이 테이블에 포함되어 이전 파일을 효과적으로 덮어씁니다. 이러한 중복을 피하는 것이 좋습니다.",
  "a_faq_window_assets_2": "예, 정확히 그렇게 작동합니다. \"Analyze Project\"는 Image 구성 요소를 찾고, 이에 할당된 스프라이트의 이름(예: icon_play_en)을 보고, 거기에서 키(icon_play)와 언어(en)를 추출한 다음, 해당 GameObject에 LocalizedAsset 구성 요소를 추가하고 키 icon_play를 안에 씁니다.",
  "a_faq_window_assets_3": "예, 사용할 수 있습니다. 각 범주에 대해 별도의 자산 테이블(LocalizedAssetTable)이 생성되므로 충돌이 발생하지 않습니다. \"Sprites\" 범주의 키는 이름이 같더라도 \"AudioClips\" 범주의 키와 겹치지 않습니다.",
  "a_faq_window_assets_4": "예, 찾을 수 있습니다. 스캐너는 SearchOption.AllDirectories 옵션을 사용하며, 이는 지정한 Scan Folder 내의 모든 하위 폴더를 재귀적으로 확인한다는 의미입니다.",
  "a_faq_window_content_1": "아니요, 그렇지 않습니다. Scenes to Parse 목록은 텍스트를 분석하기 위해 어떤 씬을 열어야 하는지 도구에 알리는 데만 사용됩니다. 최종 게임 빌드에 포함될 씬과는 전혀 관련이 없습니다.",
  "a_faq_window_content_2": "아니요, 무시되지 않습니다. 임시 목록은 씬의 개체에 대한 직접 참조를 저장합니다. 프리팹을 만들 때 새 자산입니다. 해당 인스턴스는 다른 개체이며 무시 규칙이 적용되지 않습니다. 프리팹을 영구적으로 무시하려면 프리팹 자산으로 무시 목록에 추가해야 합니다.",
  "a_faq_window_content_3": "예, 삭제됩니다. Update Keys를 클릭하면 파서가 전체 프로젝트를 다시 스캔합니다. TMPro.TMP_Text 유형을 무시해야 함을 확인하고 키를 생성하지 않습니다. 이전 키와 새 키를 비교하는 프로세스 중에 이전 키가 더 이상 사용되지 않는다고 판단하고 \"Removed\"로 표시합니다.",
  "a_faq_window_content_4": "아니요, 작동하지 않습니다. \"Pin\"은 버튼을 클릭한 순간 씬 계층 구조의 절대 경로(예: Canvas/Panel/Button)를 저장합니다. 이 경로는 프리팹 논리와 관련이 없습니다. 프리팹 인스턴스는 동일한 경로를 갖지만 씬에서 부모 개체의 이름을 바꾸면 \"Pin\"이 원본과 인스턴스 모두에 대해 작동을 멈춥니다.",
  "a_faq_window_content_5": "씬 루트의 전체 경로가 저장됩니다. 예를 들어 MyPrefab(Clone)/Content/Icon입니다. 이 \"고정된\" 경로는 생성한 씬에서만 작동합니다. 다른 씬에서는 이러한 경로를 찾을 수 없을 것입니다.",
  "a_faq_window_preview_1": "아니요, 저장되지 않습니다. PreviewSafetyBridge가 에셋 저장 이벤트(OnWillSaveAssets)를 가로채어 Unity가 디스크에 변경 사항을 기록하기 전에 자동으로 RevertEditorPreview()를 호출합니다. 따라서 prefab은 원래의 비지역화된 상태로 저장됩니다.",
  "a_faq_window_preview_2": "PreviewRecoveryService는 충돌 복구를 처리합니다. Unity가 충돌하면 서비스가 다음 실행 시 백업 파일을 감지하고 씬 상태를 복원하려 시도합니다. 자동 복구가 실패하면 도구 창에서 \"Revert to Original\"을 수동으로 선택해야 할 수 있습니다.",
  "a_faq_window_preview_3": "예, 실행됩니다. Edit Mode의 PrefabUtility.InstantiatePrefab은 Awake() 및 OnEnable()을 호출합니다. 이러한 메서드에 에디터에서 실행되어서는 안 되는 논리(예: Play Mode에서만 존재하는 싱글톤에 액세스)가 포함된 경우 오류가 발생할 수 있습니다. 이러한 코드를 보호하기 위해 if (Application.isPlaying) 또는 #if UNITY_EDITOR를 사용하는 것이 좋습니다.",
  "a_faq_window_report_1": "예, 중단됩니다. UI 차단을 요구하는 모든 새 액션(예: Update Keys)은 현재 검색 코루틴을 중지합니다. 새 검색을 시작하려면 현재 검색을 중지하라는 메시지가 포함된 대화 상자가 나타납니다.",
  "a_faq_window_report_2": "\"Duplicates\" 범주에는 해당 키에 대한 모든 소스가 표시됩니다. 키에 대한 하나의 항목이 표시되고 \"Source\" 필드에는 모든 경로(씬 1과 씬 2)가 나열됩니다. 이 경우 \"Find\" 버튼을 클릭하면 드롭다운 목록이 열려 이동할 개체를 선택할 수 있습니다.",
  "a_faq_window_report_3": "예. 검색 시스템은 MyScript.cs 스크립트와 같은 소스를 인식하도록 특별히 훈련되었습니다. \"Find\"를 클릭하면 프로젝트에서 MyScript.cs 자산을 검색하고 Project 창에서 강조 표시합니다(ping).",
  "a_faq_window_settings_1": "예, 매핑됩니다. 모드를 변경할 때 도구는 \"안전한 마이그레이션\"을 수행합니다. 전체 프로젝트를 다시 구문 분석하고, 새 규칙에 따라 새 키를 생성하지만, 원본 텍스트를 통해 이전 키와 새 키를 매핑합니다. 그런 다음 기존 번역 및 주석을 이전 키에서 새 키로 모두 전송합니다. 번역은 손실되지 않습니다.",
  "a_faq_window_settings_2": "영어 및 대부분의 유럽 언어에 적합한 DefaultPluralRule이 사용됩니다(\"one\" 및 \"other\" 형식).",
  "a_faq_window_settings_3": "아니요, 포함되지 않습니다. StreamingAssets 또는 Resources 폴더에 있는 자산만 빌드에 포함되는 것이 보장됩니다. 다른 경로를 지정하면 로컬라이제이션은 에디터에서 작동하지만 번역 파일이 빌드의 일부가 아니므로 컴파일된 게임에서는 작동하지 않습니다.",
  "a_faq_window_settings_4": "예. EditorPrefs는 각 컴퓨터에 대한 로컬 저장소입니다. 각 머신에서 <strong>Translation Service API Key</strong>(OpenAI/DeepL과 같은 에디터 사용용)를 입력해야 합니다. 그러나 <strong>Runtime API Key</strong>(빌드에서 사용)는 프로젝트 설정에 저장되며 소스 컨트롤을 통해 공유됩니다(암호화됨).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "복사됨!",
  "copy_code_copy": "복사",
  "copy_code_error": "오류",
  "error_loading_message": "연결을 확인하고 새로 고침하십시오.",
  "error_loading_title": "로딩 오류",
  "h1_ai_audio": "AI 오디오 / 텍스트 음성 변환 (Text-to-Speech)",
  "h1_ai_profiles": "AI 및 번역 프로필",
  "h1_api_snippets": "API 및 코드 스니펫",
  "h1_components": "핵심 구성 요소 (자동으로 할당됨)",
  "h1_extending": "기능 확장",
  "h1_faq": "FAQ 및 문제 해결",
  "h1_font_glyph_manager": "폰트 및 글리프 관리자",
  "h1_important_notes": "중요 참고 사항 및 경고",
  "h1_introduction": "소개",
  "h1_loc_tool_window": "\"로컬라이제이션 도구\" 창",
  "h1_migration_tool": "마이그레이션 도구",
  "h1_quick_start": "빠른 시작 및 설정",
  "h1_tms": "외부 TMS 통합 (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "번역 테이블 편집기",
  "h1_usage_examples": "사용 예시",
  "h2_ai_assistant": "AI 어시스턴트 명령",
  "h2_ai_audio_setup": "설정",
  "h2_ai_audio_usage": "사용",
  "h2_ai_context": "컨텍스트 및 용어집",
  "h2_ai_profiles_overview": "번역 프로필",
  "h2_async_api": "비동기 API (Addressables)",
  "h2_backup_manager": "백업 관리자",
  "h2_bridge_generation": "C# 브리지 생성 (강력한 타입 액세스)",
  "h2_custom_ai": "맞춤형 AI 및 모델",
  "h2_custom_asset_provider": "맞춤형 Asset Provider 만들기",
  "h2_custom_attributes": "사용자 정의 속성 스캔",
  "h2_custom_parser": "맞춤 파서 만들기",
  "h2_example_attribute": "[LocalizableField] 속성",
  "h2_example_components": "기성 컴포넌트 및 예시",
  "h2_example_components_updated": "업데이트된 LanguageSelector.cs",
  "h2_example_function": "_() 함수 및 [OnLanguageChange] 속성",
  "h2_example_plurals": "복수형 및 성별",
  "h2_faq_addressables": "Addressables 및 마이그레이션",
  "h2_faq_audio": "AI 오디오 / 텍스트 음성 변환 (Text-to-Speech)",
  "h2_faq_components": "핵심 컴포넌트",
  "h2_faq_editor": "번역 편집기",
  "h2_faq_examples": "사용 예시 및 코드",
  "h2_faq_extending": "기능 확장",
  "h2_faq_installation": "설치 및 빠른 시작",
  "h2_faq_notes": "중요한 뉘앙스 및 경고",
  "h2_faq_window": "\"Localization Tool\" 창",
  "h2_font_glyph_manager_features": "기능",
  "h2_in_editor_preview": "인-에디터 & Prefab 미리보기",
  "h2_initial_setup": "초기 설정",
  "h2_installation": "설치",
  "h2_key_features": "주요 기능",
  "h2_live_updates_guide": "실시간 업데이트 가이드",
  "h2_localizedasset": "LocalizedAsset",
  "h2_localizedasset_updated": "LocalizedAsset 비동기식 로딩",
  "h2_localizedbehaviour": "LocalizedBehaviour",
  "h2_localizeddropdown": "LocalizedDropdown",
  "h2_localizedprefab": "LocalizedPrefab",
  "h2_localizedtext": "LocalizedText",
  "h2_migration_custom": "맞춤형 프로필 만들기",
  "h2_migration_google_sheets": "Google Sheets 키",
  "h2_migration_import_formats": "가져오기 형식 (CSV 및 Google Sheets)",
  "h2_migration_stubs": "안전한 마이그레이션 및 Emergency Stubs",
  "h2_migration_tool_features": "기능",
  "h2_migration_workflow": "마이그레이션 워크플로 가이드",
  "h2_preview_overlay": "씬 뷰 오버레이",
  "h2_safety_caps": "제한 및 안전 할당량",
  "h2_script_parsing_rules": "스크립트 파싱 규칙 (호환성)",
  "h2_tab_actions": "\"동작\" 탭",
  "h2_tab_assets": "\"에셋\" 탭",
  "h2_tab_content": "\"Content\" 탭",
  "h2_tab_report": "\"보고서\" 탭",
  "h2_tab_settings": "\"설정\" 탭",
  "h2_tab_tutorials": "\"Tutorials\" 탭",
  "h2_tms_setup": "설정 및 사용",
  "h2_tms_supported": "지원되는 서비스",
  "h2_uitklocalization": "UITKLocalization",
  "h2_visual_debugging_guide": "시각적 디버깅",
  "h2_window_footer": "윈도우 푸터 (상태 표시줄)",
  "h2_window_header": "윈도우 헤더 및 툴바",
  "h2_window_sidebar": "메인 메뉴 (사이드바)",
  "h3_actions_autotranslate": "자동 번역",
  "h3_actions_danger": "위험 구역",
  "h3_actions_data": "데이터 관리",
  "h3_actions_editor": "번역 편집기",
  "h3_actions_parsing": "파싱",
  "h3_actions_tms_integration": "외부 서비스 (TMS)",
  "h3_assets_automation": "자동화",
  "h3_assets_categories": "에셋 카테고리",
  "h3_assets_folder_gen": "폴더 생성",
  "h3_assets_loading": "로드 전략",
  "h3_assets_storage": "스토리지 구성",
  "h3_attribute_cheat_sheet": "빠른 참조: 권장 사항 및 비권장 사항",
  "h3_attribute_features": "지원되는 유형 및 기능",
  "h3_attribute_limitations": "제한 사항",
  "h3_content_components_ignore": "무시할 컴포넌트 유형",
  "h3_content_dynamic_keys": "동적 키 접두사",
  "h3_content_dynamic_texts": "동적 텍스트",
  "h3_content_objects_ignore": "무시할 오브젝트",
  "h3_content_prefabs": "Prefab 폴더",
  "h3_content_regex": "무시된 정규식 패턴",
  "h3_content_scenes": "파싱할 씬",
  "h3_content_script_rules": "스크립트 파싱 규칙",
  "h3_content_scripts_ignore": "무시할 스크립트",
  "h3_custom_provider_steps": "구현 단계",
  "h3_faq_window_actions": "\"액션\" 탭",
  "h3_faq_window_assets": "\"자산\" 탭",
  "h3_faq_window_content": "\"콘텐츠\" 탭",
  "h3_faq_window_preview": "에디터 내 미리보기",
  "h3_faq_window_report": "\"보고서\" 탭",
  "h3_faq_window_settings": "\"설정\" 탭",
  "h3_mode_auto": "AutoGenerateKeysOnly (표준)",
  "h3_mode_hybrid": "Hybrid Modes (맞춤 우선순위)",
  "h3_mode_text": "UseTextAsKey (단순화)",
  "h3_report_all_keys": "전체 키",
  "h3_settings_debugging": "디버깅",
  "h3_settings_general": "일반 설정",
  "h3_settings_keygen": "키 생성",
  "h3_settings_languages": "언어 관리",
  "h3_settings_liveupdates": "실시간 업데이트",
  "h3_settings_pseudo": "가상 현지화 설정",
  "h3_settings_runtimeapi": "런타임 API",
  "h3_settings_tools": "일반 및 개발 도구",
  "h3_tutorials_list": "튜토리얼 목록",
  "lbl_not_supported": "지원되지 않음",
  "lbl_supported": "완전히 지원됨",
  "li_actions_1": "<strong>구문 분석:</strong><ul><li><strong>Update Keys:</strong> 'Content' 탭 설정에 정의된 전체 프로젝트 스캔.</li><li><strong>Scan Selected Assets:</strong> Project View에서 현재 선택된 파일/폴더**만** 스캔합니다. 'Remove Missing Keys'를 자동으로 비활성화하므로 부분 업데이트에 더 안전합니다.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> 모든 번역을 편집하기 위한 별도의 더 편리한 창을 엽니다.",
  "li_actions_3": "<strong>Data Management:</strong> 번역가와 데이터 교환에 사용 (CSV/XML/YAML/XLIFF로 내보내기/가져오기, Google Sheets에서 가져오기). <strong>Google Sheets:</strong> 'Edit' 링크와 'Publish to Web' URL 모두 지원합니다(GID 매개변수 확인).",
  "li_actions_4": "<strong>자동 번역:</strong> 활성 **Translation Profile**을 사용하여 모든 빈 번역 문자열을 자동으로 채웁니다.",
  "li_actions_5": "<strong>위험 영역:</strong> 프로젝트에서 모든 로컬라이제이션 구성 요소를 완전히 제거하기 위한 버튼이 포함되어 있습니다. 주의해서 사용하십시오!",
  "li_ai_1": "<strong>프로필 생성:</strong> Project 뷰에서 마우스 오른쪽 버튼 클릭 -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>서비스:</strong> DeepL, Google Translate, Microsoft Azure 및 **Custom AI**를 지원합니다.",
  "li_ai_3": "<strong>설정:</strong> 각 프로필은 자체 API 키, 제한(배치 크기, 최대 문자) 및 모델 설정을 저장합니다.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> 내장된 생성기를 사용하여 인기 있는 서비스(OpenAI, Gemini, Claude, Ollama)에 대한 프로필을 빠르게 생성합니다.",
  "li_ai_audio_generate": "**Translation Table Editor**에서 행/셀 선택 -> 마우스 오른쪽 버튼 클릭 -> **Generate Audio**.",
  "li_ai_audio_hash": "<strong>스마트 업데이트 및 해싱:</strong> 도구는 텍스트의 MD5 해시를 계산하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다. 마지막 오디오 생성 이후 번역이 변경되었는지 감지합니다. 편집기는 'Outdated' 아이콘(노란색)으로 이 행을 강조 표시하여 변경된 줄**만** 업데이트할 수 있도록 합니다. 이 스마트 배치 처리 기능은 불필요한 API 호출을 방지하고 오디오를 다시 생성할 때 비용을 줄입니다. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다.",
  "li_ai_audio_profile": "**Settings**에서 **Active Audio Profile** (예: OpenAI TTS 또는 ElevenLabs)을 선택합니다.",
  "li_ai_audio_save": "파일은 프로필에 지정된 폴더에 저장됩니다.",
  "li_ai_audio_voice_mapping": "<strong>Voice Mapping (Multi-Speaker):</strong> 서로 다른 AI 음성을 서로 다른 캐릭터에 자동으로 할당합니다. <strong>Voice Mappings</strong> 목록을 사용하여 정규식 패턴(e.g. <code>^hero_.*</code>)을 특정 Voice ID와 연결합니다. 도구는 오디오 생성 시 키 이름을 기반으로 올바른 음성을 자동으로 선택합니다.",
  "li_ai_provider_settings": "<strong>Provider Settings:</strong> 각 서비스는 API 키, 모델(e.g., GPT-4o, Sonnet) 및 음성 전용 매개변수(안정성, 유사성)를 구성할 수 있습니다.",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Addressables 에셋을 비동기적으로 로드할 때 사용합니다. <code>Task&lt;T&gt;</code> 를 반환합니다.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) 은(는) 성별에 맞는 번역을 반환합니다.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> 은(는) 언어별 규칙에 따라 올바른 복수형을 반환합니다.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> 언어를 변경하기 위한 코루틴(<code>IEnumerator</code>)입니다. 항상 <code>StartCoroutine()</code>을 사용하세요.",
  "li_assets_1": "<strong>폴더 구조 생성 (선택 사항):</strong> **2. Asset Folder Generation** 섹션에서 **Create Asset Folders Now**를 클릭합니다.",
  "li_assets_2": "<strong>범주 및 명명 규칙 구성:</strong> **3. Asset Categories & Scanning** 섹션에서 **Naming Rule** (<code>{key}_{lang}</code>)이 파일(예: <code>button_ok_en.png</code>)과 일치하는지 확인합니다.",
  "li_assets_3": "<strong>자산 배치:</strong> 로컬라이즈된 자산을 폴더에 넣습니다.",
  "li_assets_4": "<strong>자산 스캔:</strong> **4. Automation** 섹션에서 **Scan Assets & Update Tables**를 클릭합니다. 정리 프로세스가 더 안전해졌습니다. 이제 전체 폴더가 아닌 오래된 테이블 파일(<code>.asset</code>)만 삭제됩니다.",
  "li_assets_5": "<strong>개체에 자산 연결:</strong> **Analyze Project & Attach Components**를 클릭합니다.",
  "li_assets_6": "<strong>Addressables 통합:</strong> **Addressables** 모드가 활성화된 경우, 스캔 중에 자산이 <code>{Category}/{Language}/{Key}</code> 형식의 주소로 Addressables 그룹에 자동으로 등록됩니다.",
  "li_assets_addressables_naming": "<strong>명명 규칙:</strong> 스캔 시 도구는 Addressable 주소를 자동으로 <code>{Category}/{Language}/{Key}</code> 형식으로 설정합니다. LocalizationManager가 런타임에 자산을 로드하기 위해 이 특정 형식에 의존하므로 이 주소를 수동으로 **이름을 바꾸지 마십시오**.",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> 활성화하면, 도구가 첫 번째 에셋 현지화 시 지원되는 모든 언어에 대한 필요한 디렉터리 구조를 자동으로 생성합니다.",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> 규칙에 따라 현지화된 에셋의 폴더 구조를 자동으로 생성합니다.",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> 모든 현지화된 에셋(스프라이트, 오디오 등)의 루트 디렉터리를 정의합니다. <code>{lang}</code> 변수를 사용하여 언어별 폴더 구조를 지정합니다.",
  "li_assistant_1": "<strong>구성 가능:</strong> Translation Profile에서 명령 정의(예: \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\").",
  "li_assistant_2": "<strong>일괄 처리:</strong> 여러 셀을 선택하여 명령을 한 번에 모두 적용합니다.",
  "li_assistant_3": "<strong>Custom Commands:</strong> <strong>Translation Profile</strong> 인스펙터에서 자체 프롬프트를 정의합니다(<code>AIAssistantCommand</code> 목록). 각 명령은 <strong>Label</strong>(컨텍스트 메뉴에 표시)과 <strong>Prompt</strong>(AI에 전달되는 지시문, 예: '해적 스타일로 다시 쓰기')을 가집니다.",
  "li_attr_feat_1": "<strong>컬렉션:</strong> <code>List&lt;string&gt;</code> 및 <code>string[]</code>을 지원합니다. 키는 <code>_0</code>, <code>_1</code> 등과 같은 접미사로 생성됩니다. 목록 필드 자체에 사용자 지정 키를 사용하여 모든 항목에 접두사를 붙일 수도 있습니다.",
  "li_attr_feat_2": "<strong>접근 한정자:</strong> <code>private</code>, <code>protected</code>, <code>internal</code>, <code>public</code> 필드에서 작동합니다.",
  "li_attr_feat_3": "<strong>사용자 지정 속성:</strong> <em>Content Tab</em> 설정에서 <code>HeaderAttribute</code>, <code>TooltipAttribute</code> 또는 사용자 지정 속성 이름을 추가할 수 있습니다. 그러면 파서는 이러한 속성(예: <code>[Header(\"Text\")]</code>)이 있는 필드를 지역화 가능한 문자열로 처리합니다!",
  "li_attr_feat_4": "<strong>중첩 객체:</strong> <code>[System.Serializable]</code>로 표시된 클래스 또는 구조체 내부의 필드를 재귀적으로 스캔합니다. 여기에는 단일 인스턴스와 중첩 객체 목록이 포함됩니다.",
  "li_attr_feat_5": "<strong>Formatted Strings:</strong> 보간 문자열(<code>$\"Text {0}\"</code>), 원시 문자열(<code>@\"Text\"</code>), 그리고 연결(<code>\"A\" + \"B\"</code>)을 지원합니다.",
  "li_attr_limit_1": "<strong>Properties are Supported:</strong> 파서는 <code>Fields</code>와 <code>Properties</code> 모두를 스캔합니다. Getter가 필요합니다.",
  "li_attr_limit_2": "<strong>사전:</strong> <code>Dictionary&lt;T, string&gt;</code>은 파싱을 위해 직접 지원되지 않습니다.",
  "li_attr_limit_3": "<strong>정적 필드:</strong> 코드 파일에서 정적 분석(regex)을 통해 지원되지만, 게임 오브젝트에서 강력한 감지를 위해서는 인스턴스 필드를 사용하는 것이 일반적으로 권장됩니다.",
  "li_backup_desc": "변경 사항을 추적하고 번역의 이전 버전을 복원합니다.",
  "li_backup_rollback": "<strong>Rollback:</strong> 선택한 키 또는 전체 테이블을 즉시 이전 상태로 되돌립니다.",
  "li_backup_snapshots": "<strong>Snapshots:</strong> 대량 작업 전에 명명된 복원 지점을 생성합니다.",
  "li_cheat_base_private": "<strong>Base Private Fields:</strong> 지원됨(스캐너가 기본 클래스 파일을 직접 읽음)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> 배열",
  "li_cheat_concatenation": "<strong>String Concatenation:</strong> <code>\"A\" + \"B\"</code> (지원됨)",
  "li_cheat_constructor_args": "<strong>복잡한 생성자 인수:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>사전</strong> (Unity 인스펙터에서 기본적으로 직렬화되지 않음)",
  "li_cheat_headers": "<code>[Header(\"...\")]</code>와 같은 속성(완전 지원)",
  "li_cheat_nested_lists": "<strong>중첩 객체 목록</strong> (예: <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>변수 및 상수:</strong> <code>const string s = \"Value\";</code> 또는 <code>static string</code> (지원됨, Roslyn이 동일 파일에서 값을 해결합니다)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> 필드(지원됨)",
  "li_cheat_properties": "<strong>Properties:</strong> <code>{ get; set; }</code> (자동 속성 및 전체 속성 지원)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (참조된 경우 지원됨)",
  "li_cheat_serializable": "중첩된 <code>[Serializable] class</code> (인벤토리 아이템, 대화 노드)",
  "li_cheat_static": "<strong>Static Fields:</strong> <code>public static string</code> (완전 지원)",
  "li_cheat_structs": "<strong>Structs & Records:</strong> 지원됨(재귀 스캔)",
  "li_cheat_ternary": "<strong>논리/삼항 연산:</strong> <code>cond ? \"A\" : \"B\"</code> (파서가 값을 결정할 수 없습니다)",
  "li_cheat_unattached": "<strong>Unattached Scripts:</strong> 지원됨(스캐너가 프로젝트의 모든 .cs 파일을 읽음)",
  "li_content_1": "<strong>Scenes to Parse:</strong> 분석할 모든 씬을 여기에 끌어다 놓습니다.",
  "li_content_2": "<strong>Prefab Folders:</strong> 프리팹이 있는 폴더를 지정합니다. 이제 대규모 프로젝트를 위한 페이지 매김 및 검색을 지원합니다.",
  "li_content_3": "<strong>Dynamic Texts:</strong> 코드에서만 생성되는 문자열(예: \"Game Over\")을 여기에 입력합니다.",
  "li_content_4": "<strong>Component Types to Ignore:</strong> 스캔 중에 건너뛰어야 할 Unity Component 유형을 지정합니다.",
  "li_content_5": "<strong>Pin to Ignore:</strong> 이 기능을 사용하면 씬에서 오브젝트를 영구적으로 무시 목록에 \"고정\"할 수 있습니다.",
  "li_content_6": "<strong>Scripts to Ignore:</strong> 특정 C# 스크립트 또는 전체 폴더를 추가하여 파싱에서 제외합니다.",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> 정리 중에 삭제되지 않을 키 접두사의 목록(e.g., <code>Item_</code>)입니다.",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> 잠재적으로 동적일 수 있는 접두사(e.g., <code>quest_item_</code>)를 정의합니다. 이는 도구가 정적 UI 레이블과 데이터 기반 키를 구분하는 데 도움이 됩니다.",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> 코드에 의해 동적으로 업데이트되는 텍스트에 대한 패턴을 구성합니다. 이는 런타임에 변경되는 텍스트에 대해 스캐너가 중복 키를 생성하는 것을 방지합니다.",
  "li_content_regex_example": "<strong>맞춤 래퍼 예시:</strong> <code>MyGame.Loc(\"KEY\")</code>와 같은 사용자 정의 함수를 사용하는 경우, 다음 정규식으로 스크립트 파싱 규칙을 추가하십시오: <code>\\\\bMyGame\\\\.Loc\\\\s*\\\\(\\\\s*\\\"([^\\\"]*)\\\"</code>.",
  "li_content_regex_presets": "<strong>무시되는 정규식 패턴:</strong> <strong>'Add Common Pattern'</strong>을 클릭하여 URL, 이메일 등과 같은 동적 콘텐츠를 빠르게 제외하십시오.",
  "li_content_scanner": "<strong>Roslyn 코드 스캐너:</strong> C# 구문 트리를 이해하여 강력한 키 감지를 수행하는 깊은 정적 분석 엔진입니다.",
  "li_content_scanner_details_1": "<strong>Smart Call Detection:</strong> 자동으로 <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code>, <code>GetTranslation(\"Text\")</code> 호출을 찾습니다. 이러한 호출에 대해 <strong>Text-As-Key</strong> 모드를 적용하여 복수형 및 성별과 같은 런타임 기능이 올바르게 작동하도록 합니다.",
  "li_content_scanner_details_2": "<strong>Constant Resolution:</strong> 스캐너는 `const` 또는 `static readonly` 문자열 변수를 해결할 수 있을 만큼 스마트합니다. <code>_ (MyConst)</code>을 사용하면 동일 클래스에 정의된 경우 `MyConst`의 값을 찾아 소스 텍스트로 사용합니다.",
  "li_content_scanner_details_3": "<strong>속성 & 메타데이터:</strong> 구성된 경우 `[LocalizableField]`, `[Header]`, 또는 `[Tooltip]`이 있는 모든 필드 또는 속성을 스캔합니다. <strong>배열</strong>, <strong>리스트</strong>, 심지어 <strong>중첩된 Serializable 클래스</strong>까지 재귀적으로 처리합니다.",
  "li_content_scanner_details_4": "<strong>최신 C# 지원:</strong> target-typed <code>new()</code> 표현식, 암시적 배열 생성, 보간된 문자열(`$\"String {0}\"`)을 포함한 C# 9.0+ 문법을 완벽하게 지원합니다.",
  "li_content_script_rules_attributes": "<strong>스캔할 속성:</strong> 파서가 현지화 가능한 문자열 소스로 인식해야 하는 사용자 정의 속성(예: <code>[Header]</code> 또는 <code>[Tooltip]</code>)을 정의하십시오.",
  "li_content_script_rules_bridge_name": "<strong>브리지 클래스 이름:</strong> 생성된 정적 클래스의 이름을 정의할 수 있습니다.",
  "li_content_script_rules_bridges": "<strong>C# 브리지 생성:</strong> 모든 키에 대한 강력한 타입 액세스를 제공하는 정적 클래스를 자동으로 생성합니다(예: <code>AnkoLoc</code>). 매직 문자열을 없애고 IDE 자동 완성을 가능하게 합니다.",
  "li_context_1": "<strong>개발자 참고 사항:</strong> 번역 테이블의 주석이 AI에 컨텍스트로 전달됩니다.",
  "li_context_2": "<strong>개체 경로:</strong> 주석이 없으면 개체의 계층 구조 경로(예: <code>MainMenu/Canvas/StartButton</code>)가 대체 컨텍스트로 사용됩니다.",
  "li_context_3": "<strong>용어집:</strong> 특정 용어 및 이름에 대한 특정 번역을 적용하도록 CSV 용어집을 프로필에 로드할 수 있습니다.",
  "li_context_4": "<strong>프로젝트 설명:</strong> AI가 전반적인 맥락을 이해할 수 있도록 게임의 설정과 대상을 설명하세요.",
  "li_context_5": "<strong>어조 & 스타일:</strong> 원하는 페르소나(예: 'Friendly', 'Professional', 'Pirate')와 서식 규칙을 정의하세요.",
  "li_context_glossary": "<strong>사전 관리자:</strong> 용어집과 직접 상호 작용하여 용어를 'Add', 'Edit', 또는 'Remove'합니다. 대소문자 구분 및 'Do Not Translate' 유형을 지원합니다.",
  "li_context_optimization": "<strong>토큰 최적화:</strong> 시스템은 토큰 사용량과 비용을 최소화하기 위해 컨텍스트를 지능적으로 압축하고 캐시를 재사용합니다.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> OpenAI 호환 API(Ollama를 통한 로컬 LLM 포함)와 통신할 수 있는 유연한 구현.",
  "li_custom_ai_2": "<strong>템플릿 및 인증:</strong> 요청을 완전히 사용자 정의합니다. <ul><li><strong>Auth:</strong> <code>Auth Header Key</code>(예: <code>Authorization</code>)와 <code>Format</code>(예: <code>Bearer {0}</code>)를 구성합니다. 쿼리 매개변수에 API 키를 지원합니다.</li><li><strong>Body Template:</strong> 텍스트용 <code>{model}</code> 및 <code>{prompt}</code>와 같은 자리표시자가 포함된 JSON 템플릿을 사용하거나, 오디오용 <code>{input}</code> 및 <code>{voice}</code>를 사용합니다.</li><li><strong>Response Path:</strong> 결과에 대한 JSON 경로를 정의합니다(예: <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>내장 안전 기능:</strong> AI 모델에서 자주 반환되는 손상된 형식 지정 태그(예: <ph0>)를 자동으로 복구하여 안정적이고 일관된 번역을 보장합니다.",
  "li_custom_parser_1": "프로젝트의 **Editor** 폴더에 새 C# 스크립트를 생성합니다.",
  "li_custom_parser_2": "아래 템플릿을 복사하여 붙여넣습니다.",
  "li_custom_parser_3": "구성 요소와 일치하도록 논리를 수정합니다.",
  "li_custom_provider_manual_reg": "<strong>수동 등록:</strong> 고급 시나리오(예: DI 주입 또는 지연 초기화)의 경우, 초기화 중에 <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code>를 통해 공급자를 수동으로 등록할 수 있습니다.",
  "li_custom_provider_step_1": "<strong>인터페이스 구현:</strong> <code>IAssetProvider</code>를 구현하는 새 클래스를 생성합니다. 시스템의 API를 사용하여 <code>Load&lt;T&gt;</code> (동기) 및 <code>LoadAsync&lt;T&gt;</code> (비동기) Asset을 로드하는 방법을 정의해야 합니다.",
  "li_custom_provider_step_2": "<strong>수명 주기 정의:</strong> <code>Initialize</code>, <code>Dispose</code>, 및 <code>UnloadAll</code>을 구현합니다. 이 메서드들은 언어를 전환하거나 리소스를 정리할 때 <code>LocalizationManager</code>에 의해 호출됩니다.",
  "li_custom_provider_step_3": "<strong>언어 안전성:</strong> <code>SetCurrentLanguage</code> 메서드는 활성 언어가 변경될 때마다 호출됩니다. 이를 사용하여 내부 경로를 업데이트하거나 Asset 메타데이터를 다시 가져올 수 있습니다.",
  "li_custom_provider_step_4": "<strong>자동 검색 (권장):</strong> 클래스에 <code>[AssetProviderPlugin]</code> 속성을 추가합니다. 이렇게 하면 공급자가 <strong>Settings Tab -&gt; Asset Loading Strategy</strong> 드롭다운에 즉시 표시됩니다.",
  "li_editor_1": "<strong>스마트 그룹화:</strong> 복수형 및 성별에 대한 키(예: <code>apple_count_one</code>, <code>apple_count_few</code>)가 자동으로 접을 수 있는 그룹으로 결합됩니다.",
  "li_editor_2": "<strong>고급 편집:</strong> 셀을 클릭하여 **MultiLineEditWindow** 팝업을 엽니다. 비교를 위한 원본 텍스트를 표시하고 자리 표시자를 검증합니다.",
  "li_editor_3": "<strong>고급 선택:</strong> 개별 셀, 전체 행 또는 특정 열(언어)과 같은 유연한 선택 모드를 지원합니다. 복잡한 선택에는 <code>Ctrl+Click</code> 및 <code>Shift+Click</code>을 사용하세요.",
  "li_editor_4": "<strong>대량 작업:</strong> 수천 개의 셀에 대한 작업을 한 번에 실행합니다. 선택 항목을 마우스 오른쪽 버튼으로 클릭하여: <ul><li><strong>자동 번역:</strong> 활성 AI Profile을 사용하여 누락된 번역을 채웁니다.</li><li><strong>소스에서 채우기:</strong> 번역을 빠르게 재설정합니다.</li><li><strong>잠금 토글:</strong> '완벽한' 번역을 실수로 덮어쓰는 것을 방지합니다.</li><li><strong>오디오 생성:</strong> 선택된 Phrase에 대한 TTS를 일괄 처리합니다.</li></ul>",
  "li_editor_5": "<strong>고성능 탐색:</strong> 에디터는 10k+ 키로 부드러운 스크롤링을 위해 가상화된 'MultiColumnListView'를 사용합니다. 키보드 탐색(화살표/Tab) 및 강력한 단축키를 지원합니다: <code>Ctrl+S</code> (저장), <code>Ctrl+Z/Y</code> (실행 취소/다시 실행), <code>Ctrl+F</code> (검색 포커스).",
  "li_editor_6": "<strong>고급 검색 프리셋:</strong> 특수 필터를 사용하여 프로젝트를 감사합니다: <ul><li><strong>상태:</strong> 번역되지 않음 (현재/모든 언어), 원본과 동일, 잠김.</li><li><strong>내용:</strong> 댓글 있음, Placeholders 있음/없음, 길이 문제 있음 (자동 감지).</li><li><strong>구조:</strong> 복수형, 성별, 또는 둘 다.</li><li><strong>오디오:</strong> 오디오 없음, 오래됨 (해시 불일치).</li></ul>",
  "li_editor_7": "<strong>스마트 오디오 관리:</strong> TTS 파일의 '신선도'를 추적합니다. 번역 텍스트를 편집하면 오디오 파일 해시가 텍스트와 더 이상 일치하지 않음을 나타내는 <strong>노란색 표시기 (오래됨)</strong>가 나타납니다. 한 번 클릭으로 오래된 파일만 재생성합니다.",
  "li_editor_8": "<strong>잠금 메커니즘:</strong> 설명: <ul><li><strong>잠긴 셀/행:</strong> <strong>자동 번역</strong>, <strong>CSV/Google 가져오기</strong>, 또는 <strong>소스에서 채우기</strong>에 의한 모든 수정을 방지합니다.</li><li><strong>사용 사례:</strong> 원어민이 수동으로 확인한 'Golden' 번역을 잠급니다.</li><li><strong>대량 제어:</strong> 전체 언어 또는 특정 기능(예: 캐릭터 이름)을 프로젝트 전체에서 잠급니다.</li></ul>",
  "li_editor_layout": "<strong>동적 다중 창 레이아웃:</strong> 3-창 시스템을 사용하여 '고정된' 열(예: Keys)을 왼쪽에 고정하고 중간에 20개 이상의 언어를 스크롤합니다. 헤더 컨텍스트 메뉴를 통해 열 가시성을 전환합니다.",
  "li_editor_regex": "<strong>Regex 검색:</strong> 메인 창과 테이블 에디터 모두 <strong>Regular Expressions</strong>를 지원합니다. 쿼리에 <code>* + ? ^ $ [ ] ( ) { } | .</code>와 같은 기호가 포함되어 있으면 자동으로 Regex로 처리됩니다(예: 'item_'으로 시작하는 모든 Keys를 찾으려면 <code>^item_.*</code>).",
  "li_editor_structure": "<strong>테이블 & 그룹:</strong> 데이터는 테이블(파일)로 구성되며, 더 나은 탐색을 위해 에디터에서 그룹(폴더)으로 표시됩니다.",
  "li_editor_ui_test": "<strong>내장 UI 테스트:</strong> <ul><li><strong>길이 확장 슬라이더:</strong> 텍스트 확장 (0% - 100%)을 시뮬레이션하여 독일어나 러시아어와 같은 긴 언어를 UI가 어떻게 처리하는지 에디터를 떠나지 않고 확인할 수 있습니다.</li><li><strong>리치 텍스트 렌더러:</strong> 태그 (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) 렌더링을 토글하여 게임을 실행하지 않고 스타일링을 확인할 수 있습니다.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 언어 전환을 위한 UI 드롭다운 목록을 만들기 위한 미리 만들어진 구성 요소입니다. 사용 가능한 모든 언어를 자동으로 찾고 전환을 관리합니다.<br><strong>사용 방법:</strong> <code>LanguageSelector</code> 구성 요소를 씬에 추가하고(예: 빈 GameObject에) 인스펙터에서 <code>TMP_Dropdown</code>을 지정하기만 하면 됩니다.",
  "li_example_components_2": "<strong>코드 예시:</strong> <code>[LocalizableField]</code> 작업, <code>_()</code> 함수, 복수형 및 성별과 같은 고급 기술을 배우려면 <code>StatPurchaseTest.cs</code> 및 <code>TestLocalization.cs</code> 파일을 연구하십시오. 이들은 코드에서 도구의 모든 주요 기능 구현을 명확하게 보여줍니다.",
  "li_example_components_new": "<strong>신규 (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. <code>IEnumerator</code>를 반환합니다. yield되어야 합니다.",
  "li_example_components_old": "<strong>이전:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (동기 void) - <strong>더 이상 사용되지 않음</strong>. Coroutine 버전을 사용하세요.",
  "li_feature_1": "<strong>고급 구문 분석(Advanced Parsing):</strong> 씬, 프리팹, UI 툴킷(UXML), C# 스크립트(<code>[LocalizableField]</code> 속성으로 표시된 필드, 중첩 클래스 및 목록 포함)의 자동 스캔.",
  "li_feature_10": "<strong>백업 관리자:</strong> 백업 생성 및 복원을 위한 내장 도구.",
  "li_feature_11": "<strong>AI 기반:</strong> 사용자 지정 가능한 프로필을 통해 OpenAI, Anthropic (Claude), Google Gemini 및 로컬 LLM (Ollama) 지원.",
  "li_feature_12": "<strong>텍스트 음성 변환 (TTS):</strong> AI (OpenAI, ElevenLabs)를 사용하여 로컬라이즈된 문자열에 대한 오디오 파일 생성.",
  "li_feature_13": "<strong>마이그레이션 도구:</strong> I2 Localization 및 Unity Localization 플러그인에서 자동 전환을 위한 도구.",
  "li_feature_14": "<strong>폰트 및 글리프 관리자:</strong> 사용된 문자 분석 및 폰트에서 누락된 글리프 찾기 도구.",
  "li_feature_15": "<strong>시각적 디버깅:</strong> 빠른 디버깅을 위한 계층 구조의 아이콘 및 Scene View의 레이블.",
  "li_feature_2": "<strong>모든 자산의 로컬라이제이션:</strong> 스프라이트, 오디오, 프리팹, 재질 등 관리.",
  "li_feature_3": "<strong>강력한 번역 에디터:</strong> 자동 저장, 전체 실행 취소/다시 실행 지원, 스마트 키 그룹화 및 다중 선택 작업을 갖춘 중앙 집중식 인터페이스.",
  "li_feature_4": "<strong>AI & 기계 번역:</strong> DeepL, Google, Microsoft, 그리고 컨텍스트 인식을 지원하는 <strong>사용자 지정 AI (OpenAI, Gemini, Claude, Ollama)</strong> 프로필 시스템.",
  "li_feature_5": "<strong>유연한 가져오기/내보내기:</strong> CSV, XML, YAML, XLIFF 및 Google Sheets에서 직접 가져오기 지원.",
  "li_feature_6": "<strong>실시간 미리보기:</strong> 게임을 실행하지 않고 Scene View 또는 **프리팹 모드**에서 모든 언어를 미리 봅니다.",
  "li_feature_7": "<strong>복수형 & 성별 지원:</strong> CLDR (v43) 전체 지원. <strong>아시아</strong> (없음), <strong>영어/게르만어</strong> (One, Other), <strong>프랑스어</strong> (One 0-1), <strong>슬라브어</strong> (One, Few, Many - RU, UK, PL), <strong>아랍어</strong>, <strong>켈트어</strong>, <strong>발트어</strong> (LT, LV) 등에 대한 규칙을 포함합니다.",
  "li_feature_8": "<strong>전체 RTL 지원:</strong> 오른쪽에서 왼쪽으로 쓰는 언어의 올바른 표시.",
  "li_feature_9": "<strong>실시간 업데이트:</strong> 게임 시작 시 원격 서버에서 최신 번역을 로드합니다.",
  "li_feature_tool_translation": "<strong>완전히 번역된 UI:</strong> 도구의 인터페이스는 지역화 가능합니다. <strong>메인 창 헤더</strong>의 드롭다운을 사용하여 에디터 언어를 전환할 수 있습니다.",
  "li_font_global": "<strong>글로벌 보고서:</strong> 모든 언어에서 누락된 모든 글리프에 대한 보고서를 생성합니다.",
  "li_font_glyph_analyze": "모든 번역을 분석하고 할당된 폰트(TMP_FontAsset)가 사용된 모든 문자를 지원하는지 확인합니다.",
  "li_font_glyph_copy": "폰트 아틀라스 생성을 위해 모든 고유 언어 문자를 복사할 수 있습니다. 텍스처 공간을 최적화하기 위해 <strong>ASCII, 숫자, 구두점을 제외하는 필터</strong>를 포함합니다.",
  "li_font_glyph_missing": "누락된 글리프 목록을 표시합니다.",
  "li_font_glyph_workflow": "<strong>TMP용 워크플로:</strong> 1. 스캔 실행. 2. 누락된 글리프가 있는 언어 선택. 3. **'Copy Character Set'** 클릭. 4. Window -> TextMeshPro -> Font Asset Creator 열기. 5. 클립보드를 'Character Sequence (Custom Range)' 필드에 붙여넣어 게임에 정확히 필요한 문자가 포함된 아틀라스를 생성합니다.",
  "li_font_unicode": "<strong>Unicode 범위:</strong> 폰트 Asset을 최적화하기 위해 번역에 사용된 특정 Unicode 범위(예: Basic Latin, Cyrillic)를 확인합니다.",
  "li_footer_status": "<strong>상태 및 진행 상황:</strong> 파싱, 가져오기 또는 AI 생성 작업에 대한 실시간 피드백을 제공합니다.",
  "li_header_lang_selector": "<strong>에디터 언어:</strong> 도구의 인터페이스 언어를 전환합니다. 도구 UI는 완전히 현지화 가능합니다.",
  "li_header_preview_btn": "<strong>미리보기 토글:</strong> 에디터 내 미리보기를 빠르게 켜거나 끕니다. 'Revert' 버튼을 사용하여 원래 씬 값을 복원하십시오.",
  "li_header_toolbar_buttons": "<strong>전역 툴바:</strong> Documentation, Discord, Settings Asset, Dependency Checker 및 Review 페이지에 직접 접근합니다.",
  "li_install_1": "<strong>중요 (v2.0 업데이트):</strong> v1.x에서 업그레이드하는 경우, 가져오기 전에 이전 `Ankonoanko` 폴더를 <strong>반드시 삭제</strong>해야 합니다. Version 2.0은 네임스페이스 변경으로 인해 클린 설치가 필요합니다.",
  "li_install_2": "도구가 필요한 종속성을 자동으로 확인합니다. 나타나는 대화 상자에서 설치를 확인합니다.",
  "li_install_3": "필수 종속성(<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>)은 기본 기능에 필요합니다.",
  "li_install_4": "선택적 종속성(<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>)은 추가 기능을 활성화합니다.",
  "li_install_5": "권장 패키지를 설치하려면 **선택 항목 설치**를 클릭합니다.",
  "li_install_6": "설치 후 **Tools -> Localization Tool** 메뉴를 통해 기본 도구 창을 엽니다.",
  "li_install_7": "비동기식 자산 로딩을 사용하려면 패키지 관리자를 통해 **Addressables** 패키지를 설치합니다.",
  "li_live_updates_1": "<strong>활성화:</strong> Settings에서 'Enable Live Updates'를 확인하세요.",
  "li_live_updates_2": "<strong>소스:</strong> JSON 딕셔너리를 반환하는 <code>Live Update URL</code> 또는 <code>Google Sheet URL</code>을 제공하세요.",
  "li_live_updates_3": "<strong>캐시:</strong> 게임이 오프라인에서 작동하도록 번역은 <code>liveUpdateCachePath</code>에 로컬로 캐시됩니다.",
  "li_live_updates_4": "<strong>보안:</strong> 서버에 인증이 필요한 경우 <strong>Runtime API Key</strong> (암호화됨)를 사용하세요.",
  "li_localizedtext_1": "<code>localizationKey</code>: 번역을 찾는 데 사용되는 Key입니다. 자동 생성되거나 수동으로 할당될 수 있습니다.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code>인 경우, 컴포넌트는 스타일(폰트, RTL)만 적용하고 텍스트 자체는 변경하지 않습니다. 동적 텍스트 요소(예: 스크립트에서 `_()` 호출을 통해 업데이트되는 텍스트)에 중요합니다.",
  "li_localizedtext_3": "<code>originalSourceText</code>: 기본 언어의 원본 텍스트입니다. 대체(fallback)로 사용됩니다.",
  "li_localizedtext_key_override": "<strong>수동 키 재정의:</strong> 키 옆의 'Edit' 아이콘을 클릭하여 직접 키를 입력할 수 있습니다. 'X'를 사용하면 자동 생성으로 되돌릴 수 있습니다. 이는 <code>LocalizedText</code>, <code>LocalizedDropdown</code>(각 옵션별) 및 <code>UITKLocalization</code>에 적용됩니다.",
  "li_localizedtext_search_key": "<strong>테이블에서 검색:</strong> 돋보기 아이콘을 클릭하여 즉시 Translation Table을 열고 해당 특정 Key에 초점을 맞춥니다.",
  "li_migration_csv_details_1": "<strong>스마트 필터링:</strong> 가져오기 도구는 텍스트 데이터베이스를 깨끗하게 유지하기 위해 Asset 경로처럼 보이는 행(예: <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>)을 자동으로 건너뜁니다.",
  "li_migration_csv_details_2": "<strong>'Type' 열:</strong> 'Type' 열이 있는 경우 (I2 형식), 'Text'로 표시되거나 유형이 비어 있는 행만 가져옵니다. Asset을 가져오려면 Migration Profiles를 사용하여 <code>LocalizedAsset</code>에 매핑합니다.",
  "li_migration_csv_req_1": "<strong>Key 열:</strong> <code>Key</code>로 이름 지정되어야 하거나 (대소문자 구분 없음) Migration Profile에 정의되어야 합니다.",
  "li_migration_csv_req_2": "<strong>언어 열:</strong> 무시할 것으로 표시되지 않은 모든 열은 언어 코드(예: 'en', 'ja', 'English')로 처리됩니다. 이 도구는 이를 프로젝트 언어에 퍼지 매칭하려고 시도합니다.",
  "li_migration_csv_req_3": "<strong>주석:</strong> <code>Desc</code>, <code>Description</code>, <code>Comment</code>라는 이름의 열은 개발자 노트로 가져옵니다. 이 목록은 <strong>Migration Profile</strong>에서 구성할 수 있습니다.",
  "li_migration_custom_1": "Project View에서 마우스 오른쪽 버튼 클릭 -> 생성 -> Anko Localization -> Migration Profile.",
  "li_migration_custom_2": "<strong>규칙:</strong> 변환 규칙을 정의합니다([Source Component]에 [Context Filter]가 있으면 [Target Component]로 변환). 규칙은 <strong>Priority</strong>(숫자가 높을수록 먼저 처리), <strong>Harvest Assets</strong>(스프라이트 또는 오디오와 같은 참조된 자산을 자동으로 추출 및 등록), 및 <strong>Context Filtering</strong>을 지원하여 동일 객체의 여러 구성 요소를 구분합니다.",
  "li_migration_fallback_keys": "<strong>대체 키 필드:</strong> 레거시 컴포넌트에서 키를 추출할 때 확인할 추가 필드 이름을 지정합니다. 기존 시스템이 비표준 속성 이름을 키로 사용하는 경우에 유용합니다.",
  "li_migration_gs_1": "<strong>액세스:</strong> 시트는 공유('Anyone with the link can view')되거나 웹에 게시되어야 합니다.",
  "li_migration_gs_2": "<strong>시트 탭 (GID):</strong> URL에는 <code>gid=...</code> 매개변수가 포함되어야 합니다. 이는 도구에 정확히 어떤 탭을 읽을지 알려줍니다(예: <code>gid=0</code>은 일반적으로 첫 번째 탭/시트입니다).",
  "li_migration_ignored_headers": "<strong>무시할 CSV 헤더:</strong> 가져오기 중에 건너뛰어야 할 열을 정의합니다 (예: 'Type', 'Description'). 이렇게 하면 도구가 메타데이터 열을 언어 데이터로 처리하는 것을 방지합니다.",
  "li_migration_legacy_components": "<strong>추가 레거시 컴포넌트:</strong> 마이그레이션 스캔 중에 도구가 '레거시'로 감지해야 하는 컴포넌트 이름을 직접 나열합니다. 직접 변환 규칙이 정의되지 않은 경우에도 적용됩니다.",
  "li_migration_profile_details": "<strong>고급 프로필 설정:</strong><ul><li><code>CsvKeyHeader</code>: Key 열의 헤더 이름입니다.</li><li><code>CsvCommentHeaders</code>: 개발자 노트/주석으로 처리할 헤더 목록입니다.</li><li><code>IgnoredCsvHeaders</code>: 언어로 인식되지 않도록 건너뛸 열(예: 'Type' 또는 'Status'와 같은 메타데이터)입니다.</li><li><code>AssetExtensions</code>: 스캔 중에 자산으로 인식되는 파일 유형입니다.</li><li><code>FallbackKeyFields</code>: 기본 키 필드가 비어 있을 경우 확인할 추가 필드 이름입니다.</li></ul>",
  "li_migration_rule_fields": "<strong>규칙 구성:</strong><ul><li><code>Priority</code>: 값이 높을수록 먼저 처리됩니다. 일반 규칙보다 특정 경우를 먼저 처리할 때 사용합니다.</li><li><code>Context Filter</code>: 동일 객체에 특정 컴포넌트(예: <code>Text</code>)가 있을 때만 규칙을 적용합니다.</li><li><code>Harvest Assets</code>: 활성화하면 레거시 컴포넌트에서 현재 자산(예: Sprite)을 추출하여 자산 테이블에 등록합니다.</li><li><code>Asset Field Path</code>: 수확을 위해 자산 참조가 포함된 필드의 경로입니다.</li><li><code>Additional Data Path</code>: Dropdown과 같은 복합 컴포넌트에서 여러 값/옵션을 수확할 때 사용합니다.</li></ul>",
  "li_migration_stubs_1": "<strong>문제:</strong> 이전 플러그인 Asset을 삭제합니다. Unity는 누락된 스크립트(예: <code>Localize</code> 컴포넌트 누락)를 감지합니다. 에디터는 컴파일 오류 모드로 들어갑니다.",
  "li_migration_stubs_2": "<strong>해결책:</strong> 'Emergency Stubs' 기능은 이전 플러그인과 정확히 동일한 이름 및 네임스페이스를 가진 경량의 빈 클래스를 생성합니다. 이는 컴파일러를 만족시킵니다.",
  "li_migration_stubs_3": "<strong>워크플로우:</strong> 1. <strong>Enable Emergency Stubs</strong>을 클릭합니다(이렇게 하면 <code>ANKO_ENABLE_MIGRATION_STUBS</code>가 Project Settings에 추가됩니다). 2. 이전 플러그인 폴더를 삭제합니다. 3. Unity가 가짜 클래스를 사용하여 성공적으로 재컴파일됩니다. 4. <strong>Component Converter</strong>를 실행하여 스텁을 공식 컴포넌트로 교체합니다. 5. 리팩터링이 완료되면 <strong>Disable Stubs</strong>를 클릭합니다.",
  "li_migration_tool_converter": "<strong>단계 2: 구성 요소 변환기:</strong> 씬 및 프리팹 스캔. 이전 구성 요소(예: <code>Localize</code>)를 <code>LocalizedText</code> / <code>LocalizedAsset</code>으로 자동 교체하고 키를 전송합니다.",
  "li_migration_tool_fields": "<strong>프로필 설정:</strong> 구성 가능한 'Source Plugin' 유형과 'Asset Mapping' 규칙은 텍스처와 오디오의 올바른 전송을 보장합니다.",
  "li_migration_tool_import": "<strong>단계 1: 데이터 가져오기:</strong> CSV (I2) 또는 XLIFF (Unity Loc) 파일을 가져와 키 데이터베이스를 생성합니다.",
  "li_migration_tool_profiles": "<strong>마이그레이션 프로필:</strong> 타사 플러그인(I2, Unity Loc)의 애셋과 설정을 매핑하기 위한 사용자 정의 프로필을 생성합니다.",
  "li_migration_tool_safemode": "<strong>Safe Mode 및 Emergency Stubs:</strong> 컴포넌트가 삭제되지 않고 비활성화됩니다. 중요한 <strong>Emergency Stubs</strong> 기능을 포함합니다( <code>ANKO_ENABLE_MIGRATION_STUBS</code> 정의 기호로 활성화): I2 Localization 또는 Unity Localization에 대한 가짜 플레이스홀더 클래스를 생성하여 해당 플러그인을 제거한 후 프로젝트가 즉시 컴파일될 수 있게 합니다. 이는 \"The type name 'Localize' could not be found\" 오류를 방지하고 새 시스템으로 코드를 적절히 리팩터링할 시간을 제공합니다. Enable Stubs를 사용하면 오래된 현지화 플러그인을 삭제한 후 컴파일 오류를 수정할 수 있습니다.",
  "li_migration_tool_setup": "<strong>단계 0: 설정:</strong> 구성 요소 이름(예: I2의 경우 <code>Localize</code>)과 키가 저장되는 필드를 구성합니다. 사전 설정이 제공됩니다.",
  "li_migration_workflow_1": "<strong>1. 백업:</strong> 시작하기 전에 프로젝트를 소스 제어(Git)에 커밋하거나 파일 백업을 만드십시오.",
  "li_migration_workflow_2": "<strong>2. 스텁 활성화:</strong> Migration Tool -> 'Safe Mode' 탭을 엽니다. 대상 시스템(I2/UnityLoc)에 대해 <strong>Enable Emergency Stubs</strong>를 클릭합니다. 이렇게 하면 프로젝트에 경량의 가짜 클래스가 생성됩니다.",
  "li_migration_workflow_3": "<strong>3. 이전 플러그인 제거:</strong> 이전 플러그인 폴더(예: 'Assets/Plugins/I2')를 삭제합니다. Unity가 재컴파일됩니다. 스텁 덕분에 'Type not found' 오류가 <strong>발생하지 않으며</strong>, 프리팹의 모든 컴포넌트 참조가 유지됩니다.",
  "li_migration_workflow_4": "<strong>4. 데이터 가져오기:</strong> 'Import Data' 탭에서 Source CSV/XLIFF를 로드합니다. 미리보기를 확인하고 <strong>Import</strong>를 클릭합니다. 이 작업은 AnKo 번역 테이블을 채웁니다.",
  "li_migration_workflow_5": "<strong>5. 컴포넌트 변환:</strong> 'Component Converter' 탭에서 'Entire Project'를 선택하고 <strong>Scan & Convert</strong>를 클릭합니다. 이 도구는 이전 스텁을 'LocalizedText'/'LocalizedAsset' 컴포넌트로 대체하고 키를 전송합니다.",
  "li_migration_workflow_6": "<strong>6. 정리:</strong> 모든 것이 작동하면 <strong>Disable Stubs</strong>를 클릭하고 Unity가 다시 재컴파일되도록 합니다.",
  "li_notes_1": "<strong>백업:</strong> 주요 변경 전에 항상 **Translation Table Editor -> Manage Backups**를 통해 백업을 생성하십시오. 백업은 Unity 프로젝트를 깨끗하게 유지하고 가져오기 시간을 줄이기 위해 **프로젝트 루트(Assets 폴더 외부)**의 <code>LocalizationBackups</code> 폴더에 저장됩니다.",
  "li_notes_2": "<strong>API 키 보안:</strong> 에디터에서 작업하기 위한 키는 사용자 컴퓨터에 로컬로 저장되며(<code>EditorPrefs</code>에) 리포지토리에 들어가지 않습니다. 게임 빌드에 필요한 키의 경우 **Runtime API Key** 섹션을 사용하십시오.",
  "li_notes_3": "<strong><code>StreamingAssets</code> 폴더:</strong> 번역 파일은 게임 빌드에 포함되려면 <code>Assets/StreamingAssets/</code>의 하위 폴더에 있어야 합니다.",
  "li_notes_4": "<strong>\"바보 방지\":</strong> 도구는 실수로 미리보기 모드의 임시 데이터를 씬 또는 프리팹에 저장하는 것으로부터 사용자를 자동으로 보호합니다.",
  "li_notes_5": "<strong>성능:</strong> <code>_()</code> 호출은 빠르지만, 모든 프레임에서 실행되는 루프(예: <code>Update</code>에서)에서는 결과를 변수에 캐시하려고 시도하십시오.",
  "li_notes_6": "<strong><code>LanguageSelector</code>를 구문 분석에서 제외:</strong> <code>LanguageSelector</code> 구성 요소와 해당 <code>TMP_Dropdown</code>이 있는 개체는 **Content** 탭의 **Ignore Specific Objects** 목록에 추가해야 합니다. 이는 <code>LanguageSelector</code> 스크립트가 런타임에 드롭다운 옵션을 동적으로 채우기 때문에 파서가 드롭다운 옵션에 대한 추가 키를 생성하는 것을 방지하는 데 필요합니다. 무시하면 충돌을 방지하고 번역 파일을 깨끗하게 유지합니다.",
  "li_notes_7": "<strong><code>LanguageSelector</code>용 폰트:</strong> <code>TMP_Dropdown</code>에서 선택한 언어가 해당 폰트를 올바르게 업데이트하려면 드롭다운의 자식 **Label** 개체에 빈 <code>LocalizedText</code> 구성 요소를 수동으로 추가하고 <code>isStyleOnly</code> 상자를 확인하십시오.",
  "li_notes_addressables_code": "<strong>코드 및 Addressables:</strong> **Addressables (Async)** 모드로 전환하는 경우 스크립트에서 <code>GetLocalizedAssetAsync<T>()</code>를 **사용해야 합니다**. 동기식 <code>GetLocalizedAsset<T>()</code>를 호출하면 null이 반환되고 기본 스레드 정지를 방지하기 위해 경고가 기록됩니다.",
  "li_notes_addressables_sync_warning": "<strong>동기식 vs 비동기식:</strong> **Addressables (Async)** 모드로 전환하는 경우 코드를 업데이트하여 <code>GetLocalizedAssetAsync<T>()</code>를 **사용해야 합니다**. 동기식 메서드를 호출하면 null이 반환되고 기본 스레드가 멈추는 것을 방지하기 위해 경고가 기록됩니다.",
  "li_preview_1": "<strong>작동 방식:</strong> 목록에서 언어를 선택하면 도구가 활성 씬 또는 열린 프리팹의 모든 로컬라이즈 가능한 개체에 해당 번역, 폰트, RTL 설정 및 자산을 즉시 적용합니다.",
  "li_preview_2": "<strong>자리 표시자:</strong> **Settings** 탭에서 자리 표시자 스타일(예: **Accents** 또는 **Brackets**)이 선택된 경우 실제 번역 대신 미리보기 모드에서 이러한 자리 표시자가 표시됩니다. 이는 레이아웃을 테스트하고 로컬라이즈되지 않은 요소를 찾는 데 이상적입니다.",
  "li_preview_3": "<strong>안전:</strong> 미리보기 모드에서 이루어진 모든 변경 사항은 임시적입니다. 도구는 \"<strong>Revert to Original</strong>\"을 선택하거나, 창을 닫거나, 씬을 변경하거나, 씬/프리팹을 저장하기 전에(<code>LocalizationPreviewProtector</code> 구성 요소 덕분에) 모든 것을 자동으로 원래 상태로 되돌립니다.",
  "li_preview_4": "<strong>충돌 방지:</strong> 시스템은 미리보기 전에 씬 상태를 <code>Library</code> 폴더에 자동으로 백업합니다. 미리보기 중에 Unity가 충돌하거나 강제 종료하는 경우, 도구는 다음 실행 시 복구 파일을 감지하고 원본 씬 상태를 복원하도록 제안합니다.",
  "li_preview_overlay_1": "<strong>접근:</strong> 오버레이는 Scene View에 자동으로 나타납니다. Unity 오버레이 메뉴(Scene View에서 <code>Space</code> 키)를 통해 전환할 수 있습니다.",
  "li_preview_overlay_2": "<strong>기능:</strong> 메인 창을 열지 않고 현재 미리보기 언어를 빠르게 전환할 수 있는 드롭다운을 제공합니다.",
  "li_report_1": "<strong>범주:</strong> All Keys, Added, Updated (텍스트 변경됨), Removed, Duplicates, Migrated, Skipped (변경되지 않음).",
  "li_report_2": "<strong>고급 찾기:</strong> 항목 옆의 **Find** 버튼을 클릭하면 프로젝트에서 해당 개체를 즉시 찾을 수 있습니다. 검색은 비동기적으로 작동하며 편집기를 차단하지 않고 모든 씬과 프리팹을 검색합니다.",
  "li_report_all_keys": "<strong>전체 키:</strong> 프로젝트에서 감지된 모든 현지화 키의 목록이며 검색 및 필터링 옵션을 제공합니다.",
  "li_report_btn_clear": "<strong>보고서 지우기:</strong> 현재 세션 메모리에서 모든 스캔 결과를 제거합니다.",
  "li_report_btn_copy_all": "<strong>전체 키 복사:</strong> 현재 카테고리의 모든 현지화 키를 시스템 클립보드에 복사합니다.",
  "li_report_btn_load_last": "<strong>마지막 스캔 로드:</strong> 재스캔 없이 가장 최근 프로젝트 분석 결과를 즉시 복원합니다.",
  "li_report_btn_save": "<strong>보고서 저장:</strong> 현재 스캔 결과를 텍스트 또는 CSV 파일로 내보내어 외부 문서화 또는 감사를 위해 사용합니다.",
  "li_report_source_filter": "<strong>소스 필터:</strong> 결과를 원본(예: Scripts, Scenes, Prefabs에서 찾은 키만 표시)별로 좁혀서 보여줍니다.",
  "li_safety_global_limit": "<strong>글로벌 월별 제한:</strong> <code>monthlyCharLimit</code> (기본값: 500,000자)은 모든 요청에 대한 회로 차단기 역할을 합니다. <code>enableApiLimitWarning</code>을 통해 경고를 전환할 수 있습니다.",
  "li_safety_profile_limit": "<strong>프로필 제한:</strong> 각 번역 프로필은 자체 '요청당 최대 문자 수' 및 '배치 크기'를 설정할 수 있습니다.",
  "li_settings_1": "<strong>키 생성 모드:</strong> 텍스트에 대한 고유 식별자를 만드는 전략을 정의합니다:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(기본 - 권장)</strong>: 씬/Prefab 이름 및 객체 계층 구조를 기반으로 키를 생성합니다(예: <code>scene_Menu_BtnPlay_682412</code>). 대규모 프로젝트에 적합하며 고유성을 보장하고 텍스트 변경에 영향을 받지 않습니다.</li><li><code>UseTextAsKey</code>: 원본 텍스트 자체를 키로 사용합니다(예: \"Start Game\" → <code>Start Game</code>). 키가 사람이 읽기 쉬워야 하는 빠른 프로토타이핑에 이상적입니다.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Hybrid)</strong>: 가장 유연한 모드입니다. 먼저 컴포넌트에 수동으로 할당된 키 또는 <code>[LocalizableField(key=\"...\")]</code>가 있는지 확인합니다. 키가 없으면 계층적 키를 생성합니다. <em>기존 작업을 보존하면서 새 콘텐츠를 자동화하려면 이 옵션을 사용하십시오.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Hybrid)</strong>: 위와 유사하지만 수동 키가 없을 경우 텍스트 자체를 사용합니다. 기존 컴포넌트와 데이터를 존중합니다.</li><li><code>Manual</code>: 스캐너가 새 키를 생성하지 않습니다. 이미 키가 있는 현지화 컴포넌트를 가진 객체만 업데이트합니다. 엄격한 수동 제어에 적합합니다.</li></ul>",
  "li_settings_10": "<strong>개발자 도구:</strong> 설정 탭 하단에서 **Clear Saved Language Pref** (저장된 언어를 PlayerPrefs에서 재설정하여 게임이 기본 언어로 다시 시작되도록 함)와 같은 유틸리티 버튼을 찾을 수 있습니다.",
  "li_settings_11": "<strong>기술 드롭다운 옵션:</strong> 파서가 드롭다운을 스캔할 때 **무시**할 문자열 값 목록(기본값: 'Option A', 'Option B', 'Option C')입니다. 이는 Unity의 기본 UI 자리 표시자 텍스트로부터 번역 테이블을 깨끗하게 유지합니다.",
  "li_settings_2": "<strong>언어 관리:</strong><ul><li><strong>Source Language:</strong> Unity 씬/프리팹에서 사용되는 언어(개발 언어).</li><li><strong>Default Language:</strong> 사용자의 시스템 언어가 지원되지 않는 경우 첫 번째 게임 실행 시 선택되는 언어.</li><li><strong>List:</strong> 지원되는 언어를 관리하고, 특정 **Font Assets**을 할당하고, **RTL** 지원을 활성화합니다.</li></ul>",
  "li_settings_3": "<strong>일반 설정:</strong> 프로젝트 전체 동작을 구성합니다:<ul><li><code>Translations Save Path</code>: <code>.json</code> 번역 파일을 저장할 루트 디렉터리입니다. 게임 내에서 접근하려면 <code>Assets/Resources</code> 또는 <code>Assets/StreamingAssets</code> 내부에 있어야 합니다.</li><li><code>Safe Mode</code>: 프로젝트 불일치나 누락된 종속성이 감지될 경우 Auto-Translate와 같은 작업을 차단하는 보호 레이어입니다.</li><li><code>Remove Missing Keys</code>: 활성화하면 스캐너가 프로젝트 업데이트 중에 씬이나 Prefab에 더 이상 존재하지 않는 데이터베이스 항목을 자동으로 삭제합니다.</li><li><code>Parse Inactive Objects</code>: 비활성 또는 숨겨진 GameObject를 스캔하고 현지화할지 여부를 결정합니다.</li><li><code>Parse All Prefabs</code>: 프로젝트의 모든 Prefab을 스캔합니다. 비활성화하면 <strong>Content</strong> 탭에 지정된 폴더의 Prefab만 처리됩니다.</li><li><code>Fill Comments By Paths</code>: 번역 테이블의 'Comment' 필드를 객체의 씬/Prefab 계층 경로로 자동 채웁니다.</li><li><code>Split Files by Language</code>: 번역 데이터베이스를 여러 파일(예: <code>en.json</code>, <code>ja.json</code>)로 분할합니다. 대규모 프로젝트에서 런타임 메모리 오버헤드를 줄이기 위해 강력히 권장됩니다.</li><li><code>Allow Empty Source/Keys</code>: 소스 텍스트가 비어 있어도 객체를 등록하고 추적할 수 있게 합니다. 코드에서만 설정되는 동적 텍스트에 유용합니다.</li><li><code>Attach to Regex-Ignored Text</code>: 제외 정규식(예: 숫자)과 일치하는 텍스트를 가진 객체에도 현지화 컴포넌트를 추가하도록 강제하여 수동 재정의를 가능하게 합니다.</li><li><code>Find Settings Asset</code>: 프로젝트 창에서 <code>LocalizationSettings.asset</code> 파일을 즉시 찾고 선택하는 유틸리티 버튼입니다.</li></ul>",
  "li_settings_4": "<strong>디버깅 및 테스트:</strong><ul><li><code>Placeholder Style</code>: 미리보기 모드에서 자리표시자를 표시할 스타일을 선택합니다.</li><li><code>Pseudo-Localization</code>: <strong>'Custom Pseudo'</strong>를 선택하면 고급 레이아웃 테스트 설정(확장 계수, 악센트, 구분자)을 표시합니다.</li></ul>",
  "li_settings_5": "<strong>실시간 업데이트:</strong> 원격 서버에서 번역을 로드하기 위한 설정.",
  "li_settings_6": "<strong>런타임 API 키:</strong> <strong>라이브 업데이트</strong>(게임 내에서 새 번역 가져오기)를 위한 API 키를 안전하게 저장합니다. 이는 Editor에서 사용되는 번역 서비스 키와 다릅니다. 키는 문자열 검색을 통한 쉬운 추출을 방지하기 위해 빌드에서 <strong>난독화</strong>(암호화)되지만, 기억하십시오: 클라이언트 측 비밀은 100% 안전하지 않습니다.",
  "li_settings_7": "<strong>애셋 로딩 전략:</strong> <code>Resources (Legacy)</code>, <code>Addressables (Async)</code>, 및 <code>Custom</code> 중에서 선택합니다. 경고: 이 모드를 변경하려면 프로젝트를 다시 스캔해야 합니다. 모바일 및 WebGL에서는 메모리 사용량을 줄이기 위해 Addressables 모드를 강력히 권장합니다.",
  "li_settings_8": "<strong>자동 번역:</strong> AI 기반 현지화를 위해 <strong>Translation Profiles</strong> 시스템을 사용합니다. 구성 항목은 다음과 같습니다:<ul><li><code>Text & Audio Profiles</code>: 다양한 서비스(OpenAI, DeepL, Google 등)를 설정할 ScriptableObject 프로필을 선택하거나 생성합니다.</li><li><code>Presets Folder</code>: 번역 프리셋 및 프로필이 저장되는 디렉터리입니다.</li><li><code>Target Languages</code>: 선택된 프로필에 대한 실시간 상태, 진행률 표시줄 및 문자 수와 함께 모든 프로젝트 언어 목록을 보여줍니다.</li><li><code>Start Auto Translation</code>: 지정된 프로필을 사용하여 선택된 모든 언어에 대한 번역을 시작합니다.</li></ul>",
  "li_settings_9": "<strong>디버깅 향상:</strong><ul><li><code>Show Hierarchy Icons</code>: 계층 구조에 상태 아이콘(녹색 체크 / 노란 경고)을 표시합니다. <strong>성능 최적화:</strong> 캐싱을 사용하여 대형 씬에서도 지연 없이 동작합니다.</li><li><code>Show Scene View Labels</code>: 씬 뷰에서 직접 시각 디버깅을 제공합니다. 라벨은 인터랙티브하며, 씬 라벨을 오른쪽 클릭하면 현지화 키를 클립보드에 즉시 복사합니다.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>폴더 구조 규칙:</strong> 현지화 자산을 생성할 때 하위 폴더가 어떻게 구성되는지 정의합니다(예: <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>브리지 클래스 이름:</strong> 생성된 정적 클래스의 이름을 사용자 지정할 수 있습니다(기본값은 <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Safe Mode:</strong> 프로젝트 상태가 일관되지 않을 경우 중요한 작업이 진행되지 않도록 보장합니다.",
  "li_settings_icons_legend": "<strong>계층 구조 아이콘 범례:</strong><br>🟢 (녹색 체크): 로컬라이즈됨 및 키 설정됨.<br>🔴 (빨간색 오류): 로컬라이즈된 구성 요소가 있지만 **키가 누락됨**.<br>🟡 (노란색 경고): 텍스트/이미지 구성 요소는 있지만 **로컬라이제이션 구성 요소가 첨부되지 않음**.<br>🐛 (버그): 개체가 설정에 의해 **무시됨**.",
  "li_settings_lang_culture_fallback": "<strong>문화 폴백 사용:</strong> 특정 지역 방언(예: <code>en-AU</code>)이 없을 경우, 도구는 <strong>Default Language</strong>로 폴백하기 전에 기본 언어(<code>en</code>)를 사용하려 시도합니다.",
  "li_settings_lang_follow_system": "<strong>시스템 언어 따르기:</strong> 첫 실행 시 플레이어의 OS 언어에 맞게 게임 언어를 자동으로 전환합니다.",
  "li_settings_live_updates_security": "<strong>보안:</strong> 런타임 API 키는 손쉬운 추출을 방지하기 위해 빌드에서 암호화(AES)됩니다. 항상 HTTPS를 사용하십시오.",
  "li_settings_pseudo_accents": "<strong>악센트 사용:</strong> 표준 문자를 악센트가 있는 문자(예: <code>å</code>, <code>é</code>)로 교체합니다. 이를 통해 폰트가 필요한 모든 글리프를 지원하도록 할 수 있습니다.",
  "li_settings_pseudo_brackets": "<strong>대괄호 추가:</strong> 텍스트를 <code>[ ]</code>로 감싸 현지화 문자열의 시작과 끝을 확인하여 텍스트 잘림 또는 연결 문제를 파악하는 데 도움을 줍니다.",
  "li_settings_pseudo_expand_length": "<strong>길이 확장:</strong> 독일어 또는 러시아어와 같이 텍스트가 늘어나는 현상을 시뮬레이션하기 위해 뒤에 문자를 추가합니다.",
  "li_settings_pseudo_expansion_factor": "<strong>확장 계수:</strong> 텍스트 길이 시뮬레이션을 위한 배수(예: 2.0이면 텍스트가 두 배 길어짐).",
  "li_settings_pseudo_prefix": "<strong>사용자 정의 접두사:</strong> 모든 현지화 텍스트 앞에 특정 문자열(예: <code>PSEUDO-</code>)을 추가합니다.",
  "li_settings_pseudo_suffix": "<strong>사용자 정의 접미사:</strong> 모든 현지화 텍스트 끝에 특정 문자열을 추가합니다.",
  "li_settings_return_source": "<strong>누락 시 원본 반환:</strong> 활성화하면 현재 언어에 대한 번역이 없을 경우 시스템이 원본 언어 텍스트(또는 키 자체)를 반환합니다.",
  "li_settings_tms_timeout": "<strong>TMS 타임아웃:</strong> 외부 TMS 서비스에 대한 네트워크 요청의 최대 대기 시간(초)을 지정합니다.",
  "li_settings_tool_check_deps": "<strong>종속성 확인:</strong> 프로젝트를 다시 스캔하여 필요한 패키지(예: Newtonsoft)와 선택적 통합을 확인합니다.",
  "li_settings_tool_cleanup": "<strong>전체 프로젝트 정리:</strong> 프로젝트에서 모든 Anko Localization 컴포넌트와 데이터를 제거하는 파괴적인 도구입니다(주의해서 사용하십시오!).",
  "li_settings_tool_clear_prefs": "<strong>언어 설정 초기화:</strong> PlayerPrefs에 저장된 언어를 초기화하여 다음 실행 시 게임이 기본 언어나 시스템 언어를 사용하도록 강제합니다.",
  "li_settings_tool_font_manager": "<strong>폰트 매니저:</strong> 누락된 문자 분석 및 최적화된 폰트 자산 생성을 위해 Font & Glyph Manager를 엽니다.",
  "li_settings_tool_migration": "<strong>마이그레이션 도구:</strong> I2 Localization 또는 Unity Localization에서 데이터와 컴포넌트를 이동하는 작업을 지원합니다.",
  "li_settings_tool_test_center": "<strong>현지화 테스트 센터:</strong> 프로젝트 상태를 확인하고, 깨진 참조를 검사하며, 현지화 무결성을 보장하는 진단 도구입니다.",
  "li_setup_1": "<strong>설정 생성:</strong> 처음 열 때, 도구는 <code>Assets/Resources</code> 폴더에 <code>LocalizationSettings.asset</code> 파일을 생성합니다.",
  "li_setup_2": "<strong>언어 및 모드 구성:</strong> <strong>Settings</strong> 탭에서 <strong>Source Language</strong>가 올바른지 확인하십시오. 또한 <strong>Key Generation Mode</strong>를 확인하십시오 (기본값은 <code>AutoGenerateKeysOnly</code>이며 대부분의 프로젝트에 권장됩니다).",
  "li_setup_3": "<strong>구문 분석할 콘텐츠 지정:</strong> **Content** 탭에서 분석할 모든 씬을 **Scenes to Parse** 목록에 추가합니다. 텍스트가 있는 프리팹을 사용하는 경우 해당 폴더가 **Prefab Folders**에 추가되었는지 확인합니다.",
  "li_setup_4": "<strong>첫 번째 파서 실행:</strong> **Actions** 탭으로 이동하여 <code>Update Keys</code> 버튼을 클릭합니다. 도구는 프로젝트를 스캔하고, 번역 파일을 생성하며, 필요한 구성 요소(<code>LocalizedText</code>, <code>LocalizedAsset</code> 등)를 게임 개체에 자동으로 추가합니다.",
  "li_setup_5": "<strong>설정 및 빌드 (중요):</strong> 도구는 <code>LocalizationSettings.asset</code>을 <code>Project Settings -> Player -> Preloaded Assets</code>에 자동으로 추가합니다. <br>⚠️ <strong>안전 점검:</strong> 설정이 Preloaded Assets에 없거나 Resources 폴더에 없으면, 도구는 게임이 시작할 때 충돌하는 것을 방지하기 위해 <code>BuildFailedException</code>으로 **빌드를 차단**합니다.",
  "li_sidebar_presets": "<strong>검색 프리셋:</strong> 번역되지 않은 문자열이나 누락된 자리표시자가 있는 키를 찾는 등 일반 작업을 위한 사전 정의된 필터입니다.",
  "li_sidebar_search": "<strong>전역 검색:</strong> 프로젝트의 모든 테이블에서 특정 키 또는 텍스트를 검색합니다.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> 프로젝트 ID와 API 키가 필요합니다. 소스 XLIFF를 업로드하고 번역을 ZIP 아카이브로 다운로드하는 것을 지원합니다. <em>고급:</em> <code>File Name</code> (Crowdin의 대상 경로).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> API 키가 필요합니다. 소규모 프로젝트에 대한 간단하고 빠른 통합을 제공합니다. <em>고급:</em> <code>Import/Export Params</code> (<code>&amp;tag=v1</code> 또는 <code>&amp;status=translated</code>와 같은 추가 Loco API 플래그를 추가할 수 있습니다.)",
  "li_tms_phrase": "<strong>Phrase:</strong> 엔터프라이즈 수준의 현지화 관리. <em>고급:</em> <code>Update Translations/Descriptions</code> 업로드 시 Phrase가 기존 데이터를 덮어쓸지 여부를 제어하는 플래그.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> 조직/프로젝트 슬러그와 API 토큰 인증을 지원합니다. <em>고급:</em> <code>Resource Slug</code> (리소스가 존재하지 않을 경우 자동으로 생성합니다.)",
  "li_tutorials_1": "<strong>대화형 학습:</strong> 가이드는 특정 UI 요소를 강조하고 사용자의 행동을 기다립니다.",
  "li_tutorials_2": "<strong>사용 가능한 레슨:</strong>",
  "li_tutorials_editor": "<strong>번역 편집기:</strong> 스프레드시트와 같은 편집기의 고급 기능.",
  "li_tutorials_list": "<strong>Tutorial List:</strong> 도구의 주요 기능에 대한 인터랙티브 가이드를 이용할 수 있습니다.",
  "li_tutorials_migration": "<strong>마이그레이션:</strong> 다른 로컬라이제이션 시스템(I2, Unity Localization)에서 이동하는 방법.",
  "li_tutorials_quickstart": "<strong>빠른 시작:</strong> 텍스트와 에셋에 대한 기본 설정.",
  "li_tutorials_size": "<strong>Tutorial Size:</strong> 인터랙티브 가이드의 UI 스케일과 상세 정도를 조정합니다 (Compact부터 Extra Large까지). Tutorials 탭의 헤더에 위치합니다.",
  "li_vis_debug_1": "<strong>계층 구조 아이콘:</strong> 문제(누락된 키, 누락된 컴포넌트)를 즉시 파악합니다. 성능에 전혀 영향을 미치지 않도록 최적화되었습니다.",
  "li_vis_debug_2": "<strong>Scene View 레이블:</strong> 모든 지역화된 객체 위에 키를 표시합니다. 레이블을 <strong>오른쪽 클릭</strong>하여 '키 복사' 또는 '객체 선택'을 수행합니다.",
  "li_vis_debug_3": "<strong>오버레이:</strong> 씬 뷰 오버레이(스페이스 바)를 사용하여 미리보기 언어를 즉시 전환합니다.",
  "lightbox_aria_close": "이미지 뷰어 닫기",
  "lightbox_image_alt": "확대 보기",
  "mindmap_edge_configure": "1. 구성",
  "mindmap_edge_creates_components": "구성 요소 생성",
  "mindmap_edge_defines_rules": "규칙 정의",
  "mindmap_edge_edited_in": "편집",
  "mindmap_edge_enables_reaction": "반응 활성화",
  "mindmap_edge_extends": "확장",
  "mindmap_edge_generates": "생성",
  "mindmap_edge_manages_assets": "자산 관리",
  "mindmap_edge_opens": "열기",
  "mindmap_edge_parse_project": "3. 프로젝트 구문 분석",
  "mindmap_edge_processed_by": "처리",
  "mindmap_edge_recommends_for": "권장",
  "mindmap_edge_relates_to": "관련",
  "mindmap_edge_reports_on": "보고서",
  "mindmap_edge_see_faq": "FAQ 참조",
  "mindmap_edge_specify_content": "2. 콘텐츠 지정",
  "mindmap_edge_warns_about": "경고",
  "mindmap_node_ai_ecosystem": "AI 생태계",
  "mindmap_node_async_code": "비동기 / Addressables",
  "mindmap_node_dev_tools": "도구 및 유틸리티",
  "mindmap_node_tms_integration": "TMS 통합",
  "mindmap_preset_ai": "AI 및 자동화",
  "mindmap_preset_dev": "개발자 워크플로",
  "mindmap_preset_full": "전체 보기",
  "mindmap_preset_quick_start": "빠른 시작",
  "mindmap_preset_tools": "도구 및 통합",
  "mindmap_preset_translator": "번역가 워크플로",
  "mindmap_toggle_title": "마인드 맵 표시",
  "my_notes_title": "내 노트",
  "no_notes_message_new": "노트를 추가하려면 텍스트 위로 마우스를 가져갑니다.",
  "notes_add_title": "이 블록에 노트 추가",
  "notes_close_title": "닫기",
  "notes_delete_title": "노트 삭제",
  "notes_edit_text": "편집",
  "notes_edit_title": "노트 편집",
  "notes_goto_title": "텍스트로 이동",
  "notes_placeholder": "당신의 노트...",
  "on_this_page_title": "이 페이지에서",
  "p_actions_1": "주요 작업 탭입니다.",
  "p_ai_assistant": "번역 테이블 편집기에서 상황별 메뉴(마우스 오른쪽 버튼 클릭 -> AI: ...)를 통해 선택한 셀에서 사용자 지정 AI 명령을 실행할 수 있습니다.",
  "p_ai_audio_economy": "<strong>비용 절감:</strong> 도구는 텍스트의 MD5 해시를 계산하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 API 크레딧을 절약합니다. 번역을 변경하면 시스템은 해당 특정 오디오 파일만 'Outdated'로 플래그를 지정합니다. 변경된 항목만 다시 생성하려면 'Generate Missing/Outdated'를 사용하여 API 크레딧을 절약하십시오. 도구는 텍스트를 해시하고 소스 텍스트가 변경된 경우에만 오디오 파일을 다시 생성하여 스마트 배치 처리를 통해 API 크레딧을 절약합니다.",
  "p_ai_context": "번역 품질을 개선하기 위해 AI는 이제 추가 컨텍스트를 받습니다.",
  "p_ai_intro": "이 도구는 <strong>번역 프로필</strong> 시스템(ScriptableObject)을 사용합니다. 이는 번역 서비스 설정을 개별 프로필 애셋에 유지하여 구성을 쉽게 전환할 수 있도록 합니다.",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code>는 런타임 현지화 관리를 위한 강력한 API를 제공합니다. 아래는 스크립트에서 사용할 주요 메서드들입니다.",
  "p_assets_1": "이 탭은 텍스트가 아닌 리소스를 로컬라이즈하는 데 전적으로 전념합니다.",
  "p_async_api": "Addressables를 사용할 때, 에셋이 즉시 로드되지 않습니다. 프레임 드롭을 방지하려면 비동기 API를 사용해야 합니다.",
  "p_bridge_description": "이 도구는 키 접근을 위한 정적 클래스 생성기를 포함하여 매직 문자열 대신 강력하게 타입화된 참조를 사용할 수 있게 합니다. 이렇게 하면 오타를 방지하고 IDE 자동 완성을 활성화합니다.",
  "p_bridge_usage_title": "사용 예시:",
  "p_components_intro": "이 구성 요소는 씬의 개체와 번역 데이터베이스 간의 \"다리\"입니다. 언어 변경을 \"수신\"하고 올바른 텍스트 또는 자산을 자동으로 대체합니다.",
  "p_content_1": "여기에서 도구에게 텍스트를 정확히 어디에서 찾아야 하는지 알려줍니다. 인터페이스는 더 나은 사용성을 위해 완전히 재설계되었습니다.",
  "p_custom_ai": "<strong>Custom AI</strong> 서비스 유형을 사용하면 REST API를 통해 모든 LLM을 연결할 수 있습니다.",
  "p_custom_asset_provider_1": "사용자 지정 제공자를 개발하면 자신만의 Asset 관리 시스템(예: 사용자 지정 클라우드 로더, 특정 내부 번들링 시스템 또는 데이터베이스 기반 Asset 저장소)을 지역화 워크플로에 직접 통합할 수 있습니다.",
  "p_custom_asset_provider_intro": "Asset Provider 시스템은 런타임에 에셋(스프라이트, 오디오, Prefab 등)이 로드되는 방식을 추상화합니다. <strong>Plugin Registry</strong>를 사용하여 <code>[AssetProviderPlugin]</code> 속성이 지정된 <code>IAssetProvider</code> 구현 클래스를 자동으로 탐지합니다. 이를 통해 코어 툴킷을 수정하지 않고도 커스텀 로딩 시스템(클라우드 로더나 내부 번들링 등)을 원활하게 통합할 수 있습니다.",
  "p_custom_attributes_description": "함수 호출 외에도, 스크립트의 문자열 필드를 사용자 정의 속성을 사용해 로컬라이즈 가능하도록 표시할 수 있습니다. 기본적으로 도구는 <code>[LocalizableField]</code>를 인식하지만, <code>[Header]</code> 또는 <code>[Tooltip]</code>와 같은 속성 이름을 <strong>Attributes to Scan</strong> 목록에 추가할 수 있습니다.",
  "p_custom_parser_1": "자체 파서 클래스를 생성하여 사용자 지정 구성 요소를 지원하도록 시스템을 쉽게 확장할 수 있습니다.",
  "p_editor_1": "**Tools -> Localization -> Translation Table Editor**를 통해 열립니다. 수동으로 번역을 편집하기 위한 주요 도구입니다.",
  "p_example_attribute_1": "스크립트 변수들을 현지화하는 가장 강력한 방법입니다. <strong>private, protected, and public</strong> 필드와 함께 작동합니다. 파서는 <strong>Arrays, Lists</strong> 및 <strong>Nested Serializable Classes</strong>를 재귀적으로 처리합니다. 설정에서 구성된 경우 <code>[Header]</code> 또는 <code>[Tooltip]</code>와 같은 다른 속성에 대한 키도 생성할 수 있습니다.",
  "p_example_components_1": "프로젝트에는 훌륭한 예시 역할을 하는 즉시 사용 가능한 스크립트가 포함되어 있습니다.",
  "p_example_components_updated": "코드가 변경되었습니다. 언어 로딩(특히 Addressables 사용 시)은 이제 비동기식입니다.",
  "p_example_function_1": "게임 플레이 중에 변경되는 동적 텍스트에 <code>_()</code> 함수를 사용합니다. UI를 업데이트하는 메서드는 언어가 변경될 때 자동으로 호출되도록 <code>[OnLanguageChange]</code> 속성으로 표시해야 합니다. 이를 위해 <code>LocalizedBehaviour</code> 구성 요소가 개체에 자동으로 추가됩니다.",
  "p_example_plurals_1": "이제 이 도구는 다른 언어 그룹에 대해 더 정확한 규칙을 사용합니다.",
  "p_font_glyph_manager_access": "**Tools -> Anko Localization Tool -> Font & Glyph Manager**를 통해 액세스.",
  "p_intro_1": "이 도구는 Unity에서 게임 및 응용 프로그램을 로컬라이즈하기 위한 포괄적인 솔루션입니다. 텍스트 및 자산 수집 프로세스를 자동화하고, 강력한 인터페이스를 통해 번역을 관리하며, 기계 번역 서비스(사용자 지정 AI 포함)와 통합하고, 게임에서 로컬라이즈된 콘텐츠를 동적으로 업데이트합니다.",
  "p_live_updates_guide": "라이브 업데이트 시스템을 사용하면 새 빌드 없이도 런타임에 원격 서버나 Google Sheet에서 새 번역을 가져올 수 있습니다.",
  "p_localizedasset_1": "언어에 따라 자산을 교체하는 데 사용됩니다. 구성 요소 유형을 자동으로 감지합니다. 지원: <ul><li><strong>2D:</strong> 스프라이트 (<code>Image</code>, <code>SpriteRenderer</code>), 텍스처 (<code>RawImage</code>).</li><li><strong>오디오/비디오:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/애니메이션:</strong> <code>MeshFilter</code> (메시), <code>Renderer</code> (재질), <code>Animator</code> (컨트롤러), <code>PlayableDirector</code> (타임라인).</li></ul>",
  "p_localizedasset_2": "<strong>Play on Awake</strong> 옵션이 있는 구성 요소(<code>AudioSource</code>, <code>VideoPlayer</code> 등)의 경우, <code>LocalizedAsset</code>은 자동 재생을 올바르게 가로채고, 자산을 교체한 다음, 로컬라이즈되지 않은 콘텐츠가 재생되는 것을 방지하기 위해 재생을 시작합니다.",
  "p_localizedasset_updated": "이제 이 구성 요소는 비동기식 로딩을 지원합니다. 자산이 클라우드/디스크(Addressables)에서 로드되는 경우 언어를 변경할 때 약간의 지연이 있을 수 있습니다.",
  "p_localizedbehaviour_1": "스크립트가 언어 변경에 반응할 수 있도록 하는 유틸리티 구성 요소입니다. <code>[OnLanguageChange]</code> 속성으로 표시된 메서드를 자동으로 찾아 호출합니다.",
  "p_localizeddropdown_1": "옵션을 번역하기 위해 <code>Dropdown</code> 및 <code>TMP_Dropdown</code>에 추가됩니다.",
  "p_localizedprefab_1": "전체 프리팹을 로컬라이즈하기 위한 구성 요소입니다. 비파괴적으로 작동합니다. 원본 프리팹을 수정하지 않고, 로컬라이즈된 버전의 인스턴스를 자식 개체로 생성하고, 원본 개체의 모든 스크립트(<code>MonoBehaviour</code>), 렌더러(<code>Renderer</code>) 및 충돌체(<code>Collider</code>)를 비활성화합니다. 이는 이중 로직 실행 및 시각적 아티팩트를 방지합니다. 올바른 런타임 작동을 위해 실행 순서가 -100 (<code>[DefaultExecutionOrder(-100)]</code>)으로 설정되어 다른 스크립트보다 먼저 실행되도록 합니다.",
  "p_localizedtext_1": "번역된 텍스트를 표시하는 기본 구성 요소입니다. <code>Text</code>, <code>TMP_Text</code> 및 <code>TextMesh</code>가 있는 개체에 배치됩니다.",
  "p_migration_custom": "맞춤형 시스템이나 특정 프로젝트 설정을 지원하기 위해 자체 마이그레이션 프로파일을 만들 수 있습니다. 각 프로파일은 컴포넌트와 해당 필드를 변환하는 방법을 정의하는 <strong>Rules</strong> 목록을 포함합니다. Rules는 <strong>Priority</strong> 순서대로 확인됩니다.",
  "p_migration_custom_advanced": "마이그레이션 프로파일은 가져오기 및 감지 프로세스를 미세 조정하기 위한 고급 설정을 제공합니다:",
  "p_migration_google_sheet": "파일을 다운로드하지 않고 Google Sheet URL에서 직접 가져올 수 있습니다.",
  "p_migration_import_csv": "이 도구는 표준 CSV 파일(쉼표로 구분됨)을 지원합니다. 첫 번째 행은 헤더여야 합니다.",
  "p_migration_stubs": "마이그레이션 시 흔히 발생하는 문제는 이전 플러그인(예: I2)을 삭제하면 빌드가 중단되어 Unity가 마이그레이션 도구 자체를 컴파일하지 못하게 되는 것입니다.",
  "p_migration_tool_access": "**Tools -> Anko Localization Tool -> Migration Tool**을 통해 액세스.",
  "p_migration_tool_desc": "다른 로컬라이제이션 시스템(I2 Localization, Unity Localization)에서 전환하기 위한 도구.",
  "p_preview_1": "헤더 바로 아래에는 **Preview Language** 드롭다운 목록이 있습니다. 이 강력한 기능을 사용하면 게임을 실행하지 않고 **Scene** 창 또는 **Prefab Mode**에서 로컬라이제이션이 모든 언어에서 어떻게 보일지 직접 확인할 수 있습니다.",
  "p_preview_overlay": "더 빠른 반복을 위해 전용 <strong>Localization Preview Overlay</strong>를 사용하여 Scene View에서 직접 언어를 전환할 수 있습니다.",
  "p_report_1": "각 구문 분석 후, 이 보고서는 로컬라이제이션 상태의 전체 그림을 보여줍니다.",
  "p_safety_caps": "예기치 않은 높은 비용이나 대규모 트래픽 검사를 방지하기 위해:",
  "p_script_parsing_rules_description": "도구는 기존 코드를 수정하지 않고도 사용자 정의 함수나 경쟁 시스템(I2 Localization 등)에서 사용되는 로컬라이제이션 키를 인식하도록 구성할 수 있습니다. 이는 스캐너가 스크립트에서 키를 추출하기 위해 사용하는 정규식 패턴을 정의함으로써 구현됩니다.",
  "p_script_parsing_rules_usage": "<strong>Content</strong> 탭의 <strong>Script Parsing Rules</strong> 섹션에서 특정 함수 호출에 맞는 규칙을 추가할 수 있습니다. 예를 들어 <code>I2.Loc.Get(\"key\")</code>을 지원하려면 괄호 안의 문자열을 캡처하는 패턴을 가진 규칙을 추가하면 됩니다.",
  "p_settings_1": "제어 센터입니다. 여기에서 전체 로컬라이제이션 프로세스에 대한 전역 규칙을 정의합니다.",
  "p_tms_intro": "이 도구는 이제 인기 있는 번역 관리 시스템과의 동기화를 지원합니다. Unity 내에서 소스 키를 푸시하고 번역을 풀 수 있습니다.",
  "p_tms_setup": "1. <strong>Settings -> TMS Integration</strong>으로 이동합니다.<br>2. 서비스 제공자를 선택합니다.<br>3. API 키와 프로젝트 ID를 입력합니다.<br>4. 설정 창에서 <strong>Push</strong> (키 업로드) 및 <strong>Pull</strong> (번역 다운로드) 버튼을 사용합니다.",
  "p_tutorials_1": "튜토리얼 탭은 Unity Editor 내에서 도구의 기능을 마스터할 수 있도록 대화형 단계별 가이드를 제공합니다.",
  "p_uitklocalization_1": "<code>UIDocument</code>가 있는 객체에 추가됩니다. 어떤 요소든 <strong>Labels, Buttons, HelpBox, Foldout, ProgressBar (title), TextField (label & placeholder), DropdownField (label & choices), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), 및 Tooltips</strong>의 현지화를 지원합니다. UI Builder에서 ID를 설정하면 이름이 변경되어도 식별자는 유지됩니다.",
  "p_window_footer": "현재 상태, 백그라운드 작업 진행 상황 및 툴 버전을 표시합니다.",
  "p_window_header": "상단 바는 선택된 탭과 관계없이 지속되는 미리보기 컨트롤 및 유틸리티 도구에 대한 전역 접근을 제공합니다.",
  "p_window_sidebar": "사이드바는 다양한 기능 탭 간 탐색 및 전역 검색 도구를 처리합니다.",
  "page_title": "Unity Localization Tool 문서",
  "q_faq_addressables_1": "Addressables 모드를 활성화했지만 자산이 로드되지 않습니다. 무엇을 확인해야 합니까?",
  "q_faq_addressables_2": "DeepL/Google에 대한 지원을 추가하려면 어떻게 해야 합니까?",
  "q_faq_addressables_3": "I2/UnityLoc를 제거한 후 마이그레이터에 컴파일 오류가 표시됩니다. 어떻게 해결할 수 있습니까?",
  "q_faq_audio_smart_update": "오디오 파일을 다시 생성할 때 도구가 API 크레딧을 절약하는 방법은 무엇입니까?",
  "q_faq_components_1": "LocalizedPrefab 컴포넌트는 원본 오브젝트의 MonoBehavior를 비활성화합니다. 원본 오브젝트에 다른 오브젝트를 생성하거나 Awake()에서 이벤트에 구독하는 스크립트가 있다면 어떻게 되나요?",
  "q_faq_components_2": "원본 프리팹(LocalizedPrefab)에 Rigidbody 또는 다른 물리 구성 요소가 있는 경우 비활성화됩니까? 로컬라이즈된 프리팹에 물리 구성 요소가 없으면 물리학에 영향을 미칩니까?",
  "q_faq_components_3": "LocalizedAsset 구성 요소는 대상 구성 요소 이름을 문자열로 저장합니다(_targetComponentTypeName). 사용자 지정 구성 요소 스크립트의 이름을 바꾸거나 다른 어셈블리(Assembly Definition)로 이동하면 어떻게 됩니까? LocalizedAsset이 작동을 멈춥니까?",
  "q_faq_components_4": "같은 GameObject에 두 개의 Image 구성 요소가 있는 경우 LocalizedAsset은 어떤 구성 요소를 로컬라이즈할지 어떻게 압니까? 둘 다 또는 첫 번째로 찾은 구성 요소만 작동합니까?",
  "q_faq_components_5": "문서에 LocalizedPrefab의 실행 순서가 -100이라고 나와 있습니다. Awake()에서 LocalizedPrefab이 생성한 자식 개체를 찾으려는 실행 순서가 -110인 다른 스크립트가 있는 경우 어떻게 됩니까? LocalizedPrefab이 제때 인스턴스를 인스턴스화했습니까?",
  "q_faq_components_6": "LocalizedText 구성 요소에는 isStyleOnly 옵션이 있습니다. 이를 활성화한 다음 코드에서 myLocalizedText.SetFormattedText(\"new_key\")를 호출하면 텍스트가 변경됩니까, 아니면 스타일(폰트/RTL)만 변경됩니까?",
  "q_faq_components_7": "LocalizedBehaviour는 [OnLanguageChange] 속성이 있는 메서드를 자동으로 찾습니다. private 및 protected 메서드를 찾습니까, 아니면 public이어야 합니까?",
  "q_faq_components_8": "LocalizedAsset 구성 요소는 Play on Awake를 가로챕니다. 같은 개체의 다른 스크립트가 LocalizedAsset이 교체하기 전에 Awake() 또는 Start()에서 자산(예: audioSource.clip.length)에 액세스하려고 하면 어떻게 됩니까? NullReferenceException 또는 이전 자산 사용이 가능합니까?",
  "q_faq_custom_keys_attribute": "[LocalizableField] 대신 사용자 지정 키에 내 자신의 속성을 사용할 수 있습니까?",
  "q_faq_custom_provider_1": "내 사용자 지정 제공자가 설정 드롭다운에 나타나지 않는 이유는 무엇입니까?",
  "q_faq_editor_1": "자리 표시자 유효성 검사에 우선 순위가 높은 것은 무엇입니까? 주석의 @placeholders: 지시문입니까, 아니면 소스 언어 텍스트에서 발견된 자리 표시자입니까? 예를 들어 소스 텍스트에 {name}이 있고 주석에 @placeholders: {username}이라고 표시된 경우.",
  "q_faq_editor_2": "지시문에 오타가 있는 경우(예: @placeholders: 대신 @placeholder:) 무시됩니까 아니면 도구에서 경고를 발행합니까?",
  "q_faq_editor_3": "자동 저장 시스템은 Backups/AutoSaves 폴더에 파일을 생성합니다. 수동 저장에 성공하거나 창을 닫은 후 이러한 파일이 자동으로 삭제됩니까?",
  "q_faq_editor_4": "편집기에서 열 너비를 변경하면 이러한 설정이 Unity 세션 간에 저장됩니까?",
  "q_faq_editor_5": "텍스트 편집 팝업 창(MultiLineEditWindow)은 자체 실행 취소/다시 실행 스택(Ctrl+Z를 통해)을 지원하여 그 안에서 이루어진 변경 사항을 지원합니까?",
  "q_faq_examples_1": "_() 함수에 전달된 익명 형식의 속성 이름이 문자열의 자리 표시자와 일치하지 않으면 어떻게 됩니까? 예를 들어 _(\"Hello, {username}\", new { user_name = \"Bob\" })입니다. 오류가 발생합니까, 아니면 자리 표시자가 단순히 대체되지 않습니까?",
  "q_faq_examples_2": "[LocalizableField] 속성은 private 필드에 대해 작동합니다. static 필드에 대해 작동합니까?",
  "q_faq_examples_3": "매개변수가 있는 메서드(예: void UpdateUI(string newLang))에 [OnLanguageChange] 속성을 넣으면 어떻게 됩니까? 컴파일 오류 또는 런타임 경고가 발생합니까?",
  "q_faq_examples_4": "_(\"apple_count\", count)를 사용하고 있습니다. 현재 언어에 대해 apple_count_one 키가 없는 경우(count = 1의 경우) 시스템은 어떤 형식을 선택합니까? apple_count_other를 대체로 사용합니까?",
  "q_faq_examples_5": "함수 _(\"key\", new { username = \"Alex\" })는 익명 형식을 사용합니다. 미리 생성된 Dictionary<string, object>를 전달하는 것과 비교하여 Update() 메서드에서 자주 호출할 때 가비지 수집기(GC)에 과도한 \"부하\"를 생성하지 않습니까?",
  "q_faq_examples_6": "[OnLanguageChange]로 표시된 메서드가 호출되지 않습니다. 왜 그렇습니까?",
  "q_faq_extending_1": "내 사용자 지정 파서가 모든 Update Keys 후에 자동으로 호출됩니까? 어딘가에 등록해야 합니까, 아니면 프로젝트에 ITextComponentParser를 구현하는 클래스만 있으면 충분합니까?",
  "q_faq_extending_2": "사용자 지정 파서에서 예외가 발생하면 어떻게 됩니까? 전체 구문 분석 프로세스가 중단됩니까, 아니면 도구가 다른 파서로 안전하게 계속됩니까?",
  "q_faq_installation_1": "내 프로젝트에 이미 다른 자산의 com.unity.nuget.newtonsoft-json 패키지가 있는 경우 어떻게 됩니까? 종속성 설치 프로그램이 업데이트하려고 시도합니까 아니면 무시합니까?",
  "q_faq_installation_2": "선택적 종속성(예: CSV 지원용)에 대해 실수로 \"Skip for Now\"를 클릭하고 \"Don't ask again\"을 선택했습니다. 설치 프로그램 창을 다시 표시하여 설치하려면 어떻게 해야 합니까?",
  "q_faq_installation_3": "도구가 Assets/Resources에 LocalizationSettings.asset을 생성하지 않았습니다. 왜 이런 일이 발생할 수 있으며 Assets -> Create 메뉴를 통해 수동으로 생성할 수 있습니까?",
  "q_faq_installation_4": "LocalizationSettings.asset 파일을 다른 Resources 폴더(예: Assets/MyGame/Resources)로 이동할 수 있습니까? 도구가 여전히 찾을 수 있습니까?",
  "q_faq_installation_5": "종속성 설치 프로그램이 멈추거나 오류가 발생했습니다. Unity 패키지 관리자를 통해 종속성(Newtonsoft Json, Editor Coroutines)을 수동으로 설치할 수 있습니까?",
  "q_faq_notes_1": "문서에서는 LanguageSelector를 무시 목록에 추가하도록 권장합니다. 이렇게 하는 것을 잊으면 정확히 무엇이 손상됩니까? \"Option A, Option B\"에 대한 추가 키가 생성됩니까?",
  "q_faq_notes_2": "LanguageSelector에서 사용하는 TMP_Dropdown 내부의 Label에 isStyleOnly 확인란이 활성화된 빈 LocalizedText를 추가하는 것을 잊으면 폰트가 변경되지 않습니까? 왜 이것이 필요합니까?",
  "q_faq_notes_3": "Update() 메서드에서 _()를 호출하는 것은 권장되지 않습니다. 하지만 모든 프레임에서 텍스트를 업데이트해야 하는 경우(예: 타이머) 어떻게 됩니까? 형식 문자열만 캐시하는 가장 성능이 좋은 방법은 무엇입니까?",
  "q_faq_tts_voices": "특정 캐릭터에 특정 음성을 할당하려면 어떻게 해야 합니까?",
  "q_faq_window_actions_1": "일괄 자동 번역 중에 인터넷 연결이 끊어지면 어떻게 됩니까? 도구가 다시 시도 정책에 따라 실패한 배치를 다시 시도합니까, 아니면 프로세스가 완전히 중단됩니까?",
  "q_faq_window_actions_2": "프로젝트에 이미 존재하는 키가 포함된 CSV 파일을 가져오지만 일부 언어에 대한 값이 비어 있는 경우 이러한 빈 값이 기존 번역을 대체합니까 아니면 무시됩니까?",
  "q_faq_window_actions_3": "\"위험 영역\" 섹션에서는 모든 구성 요소를 삭제할 수 있습니다. Content 탭의 Prefab Folders에 지정되지 않은 폴더에 있는 프리팹에서 구성 요소를 제거합니까?",
  "q_faq_window_actions_4": "Google Sheets에서 가져올 때 @placeholders: 지시문을 사용하는 자리 표시자 유효성 검사를 위해 주석 열의 형식을 어떻게 지정해야 합니까?",
  "q_faq_window_actions_5": "도구가 단일 Google Sheets 문서의 여러 시트에서 데이터를 가져올 수 있습니까, 아니면 GID당 하나의 시트에서만 작동합니까?",
  "q_faq_window_assets_1": "같은 스캔 폴더에 같은 키이지만 다른 유형의 두 자산(예: sound_effect_en.mp3 및 sound_effect_en.wav)이 있는 경우 어떻게 됩니까? 어느 것이 자산 테이블에 포함됩니까?",
  "q_faq_window_assets_2": "Scan Assets & Analyze Project를 클릭하고 씬에 로컬라이즈된 스프라이트가 이미 존재하는 Image 개체가 있지만 Image 개체 자체에는 아직 LocalizedAsset 구성 요소가 없는 경우 도구가 구성 요소를 추가하고 키를 자동으로 삽입합니까?",
  "q_faq_window_assets_3": "다른 Scan Folders가 있는 경우 다른 자산 범주에 대해 동일한 Naming Rule을 사용할 수 있습니까? 이로 인해 충돌이 발생합니까?",
  "q_faq_window_assets_4": "로컬라이즈 가능한 자산(예: button_ok_en.png)이 Scan Folder의 루트에 있지 않고 하위 폴더에 있는 경우 스캐너가 찾을 수 있습니까?",
  "q_faq_window_content_1": "Scenes to Parse에 Build Settings에 포함되지 않은 씬을 추가하면 구문 분석 프로세스 자체 외에 다른 것에 영향을 미칩니까?",
  "q_faq_window_content_2": "Ignore Specific Objects (임시 목록)에 개체를 추가했습니다. 이 개체로 프리팹을 만들면 이 프리팹의 인스턴스도 무시됩니까?",
  "q_faq_window_content_3": "TMPro.TMP_Text 구성 요소를 Parsing Ignores -> Ignore Component Types에 추가했지만 씬에 이미 이 TMP_Text를 참조하는 LocalizedText가 있는 개체가 있는 경우 다음 Update Keys에서 어떻게 됩니까? 키가 삭제됩니까?",
  "q_faq_window_content_4": "문서에는 \"Pin\"이 개체의 전체 경로를 저장하고 이름이 바뀌면 손상된다고 나와 있습니다. 개체에서 프리팹을 만든 다음 원본 개체의 이름을 바꾸면 \"Pin\"이 프리팹 인스턴스에 대해 계속 작동합니까?",
  "q_faq_window_content_5": "프리팹 인스턴스 내의 자식 개체에 \"Pin\"을 사용하면 어떤 경로가 저장됩니까? 프리팹 루트에 대한 상대 경로입니까, 아니면 씬 루트입니까? 다른 씬에서도 작동합니까?",
  "q_faq_window_preview_1": "Prefab Mode에서 프리팹을 열고 In-Editor Preview를 적용한 다음 Ctrl+S를 눌렀습니다. 임시 미리보기 데이터가 프리팹 자산에 저장됩니까? LocalizationPreviewProtector는 이 경우를 어떻게 처리합니까?",
  "q_faq_window_preview_2": "In-Editor Preview를 활성화하고 Unity 에디터가 충돌하고 Temp/localization_preview_recovery.json 파일이 손상된 경우(예: 비어 있거나 유효하지 않은 JSON) 다음 실행 시 어떻게 됩니까?",
  "q_faq_window_preview_3": "LocalizedPrefab에 대한 In-Editor Preview 모드에서는 임시 인스턴스가 생성됩니다. 이 인스턴스에서 Awake() 및 Start() 메서드가 실행됩니까? Edit Mode에서 실행되도록 설계되지 않은 경우 오류가 발생할 수 있습니까?",
  "q_faq_window_report_1": "\"Find\" 버튼은 개체를 비동기적으로 검색합니다. 검색을 시작한 다음 즉시 Update Keys를 클릭하면 어떻게 됩니까? 검색이 중단됩니까?",
  "q_faq_window_report_2": "키가 여러 곳에서 사용되는 경우(예: 다른 씬의 두 개의 다른 버튼에서) 보고서의 \"Duplicates\" 범주에 어떻게 표시됩니까?",
  "q_faq_window_report_3": "코드에서만 사용되는 키( _() 함수를 통해)에 대해 \"Find\"를 클릭하면 어떻게 됩니까? 도구가 C# 스크립트를 찾아 강조 표시할 수 있습니까?",
  "q_faq_window_settings_1": "프로젝트 중간에 Key Generation Mode를 UseTextAsKey에서 AutoGenerateKeysOnly로 변경할 수 있습니다. 기존 번역에 정확히 어떤 일이 발생합니까? 새 키에 매핑됩니까?",
  "q_faq_window_settings_2": "Supported Languages 목록에 복수화 규칙이 없는 코드(예: 카자흐어의 경우 \"kz\")로 언어를 추가하면 기본적으로 어떤 규칙이 사용됩니까?",
  "q_faq_window_settings_3": "Translations Path를 StreamingAssets가 아닌 Assets/MyTranslations와 같은 일반 폴더에 지정하면 어떻게 됩니까? json 파일이 게임 빌드에 포함됩니까?",
  "q_faq_window_settings_4": "자동 번역 API 키는 EditorPrefs에 저장됩니다. 두 대의 다른 컴퓨터에서 프로젝트를 작업하는 경우 각 컴퓨터에 키를 별도로 입력해야 합니까?",
  "tip_best_practice": "<strong>전문가 팁:</strong> 속성을 지역화해야 하는 경우, <code>[LocalizableField]</code>로 백킹 필드를 생성하고 속성을 별도로 노출하세요.",
  "toc_search_placeholder": "문서 검색...",
  "toc_title": "목차",
  "toggle_notes_title": "노트 토글",
  "warning_box_components": "<strong>중요 참고:</strong> 아래에 설명된 모든 구성 요소는 구문 분석(<code>Update Keys</code> 버튼 클릭 시) 중에 게임 개체에 자동으로 추가됩니다. 수동으로 추가할 필요가 없습니다.",
  "warning_tms_overwrite": "<strong>Warning:</strong> TMS에서 풀하면 일치하는 키에 대한 로컬 번역이 덮어쓰여집니다. TMS가 유일한 진실의 출처인지 확인하십시오."
}