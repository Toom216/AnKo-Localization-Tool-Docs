{
    "page_title": "Unity 로컬라이제이션 도구 문서",
    "toc_title": "목차",
    "toc_search_placeholder": "문서 검색...",
    "nav_introduction": "1. 소개",
    "nav_quick_start": "2. 빠른 시작",
    "nav_components": "3. 핵심 구성 요소",
    "nav_loc_tool_window": "4. \"로컬라이제이션 도구\" 창",
    "nav_translation_editor": "5. 번역 편집기",
    "nav_usage_examples": "6. 사용 예제",
    "nav_important_notes": "7. 중요 참고사항",
    "nav_extending": "8. 기능 확장",
    "nav_faq": "9. FAQ 및 문제 해결",
    "nav_key_features": "주요 기능",
    "nav_installation": "2.1. 설치",
    "nav_initial_setup": "2.2. 초기 설정",
    "nav_localizedtext": "3.1. LocalizedText",
    "nav_localizedasset": "3.2. LocalizedAsset",
    "nav_localizedprefab": "3.3. LocalizedPrefab",
    "nav_uitklocalization": "3.4. UITKLocalization",
    "nav_localizeddropdown": "3.5. LocalizedDropdown",
    "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
    "nav_context_menu": "3.7. 컨텍스트 메뉴",
    "nav_in_editor_preview": "4.1. 에디터 내 미리보기",
    "nav_tab_settings": "4.2. \"설정\" 탭",
    "nav_tab_content": "4.3. \"콘텐츠\" 탭",
    "nav_tab_actions": "4.4. \"작업\" 탭",
    "nav_tab_assets": "4.5. \"에셋\" 탭",
    "nav_tab_report": "4.6. \"보고서\" 탭",
    "nav_example_components": "6.1. 기성 컴포넌트",
    "nav_example_attribute": "6.2. [LocalizableField] 속성",
    "nav_example_function": "6.3. _() 함수",
    "nav_example_plurals": "6.4. 복수형 및 성별",
    "nav_custom_parser": "8.1. 파서 만들기",
    "nav_faq_installation": "9.1. 설치 및 빠른 시작",
    "nav_faq_components": "9.2. 핵심 컴포넌트",
    "nav_faq_window": "9.3. \"로컬라이제이션 도구\" 창",
    "nav_faq_window_actions": "9.3. \"로컬라이제이션 도구\" 창 - \"작업\" 탭",
    "nav_faq_window_assets": "9.3. \"로컬라이제이션 도구\" 창 - \"에셋\" 탭",
    "nav_faq_window_report": "9.3. \"로컬라이제이션 도구\" 창 - \"보고서\" 탭",
    "nav_faq_editor": "9.4. 번역 편집기",
    "nav_faq_examples": "9.5. 사용 예제 및 코드",
    "nav_faq_notes": "9.6. 중요한 뉘앙스 및 경고",
    "nav_faq_extending": "9.7. 기능 확장",
    "h1_introduction": "소개",
    "p_intro_1": "이 도구는 Unity에서 게임과 애플리케이션을 로컬라이즈하기 위한 포괄적인 솔루션입니다. 텍스트 및 에셋 수집, 강력한 인터페이스를 통한 번역 관리, 기계 번역 서비스와의 통합, 게임 내 로컬라이즈된 콘텐츠의 동적 업데이트 프로세스를 자동화합니다.",
    "h2_key_features": "주요 기능",
    "li_feature_1": "<strong>고급 파싱:</strong> 씬, 프리팹, UI 툴킷(UXML) 및 C# 스크립트의 자동 스캔. <code>[LocalizableField]</code> 속성으로 표시된 필드, 중첩 클래스 및 리스트 포함.",
    "li_feature_2": "<strong>모든 에셋 로컬라이제이션:</strong> 스프라이트, 오디오, 프리팹, 머티리얼 등 관리.",
    "li_feature_3": "<strong>강력한 번역 편집기:</strong> 자동 저장, 전체 실행 취소/다시 실행 지원, 스마트 키 그룹화를 갖춘 중앙 집중식 인터페이스.",
    "li_feature_4": "<strong>기계 번역:</strong> 각 서비스(DeepL, Google Translate, Microsoft Translator)에 대한 유연한 설정(배치 크기, 재시도 횟수)과 통합.",
    "li_feature_5": "<strong>유연한 가져오기/내보내기:</strong> CSV, XML, YAML, XLIFF 및 Google Sheets에서 직접 가져오기 지원.",
    "li_feature_6": "<strong>에디터 내 실시간 미리보기:</strong> 게임을 실행하지 않고 모든 언어로 미리보기.",
    "li_feature_7": "<strong>복수형 및 성별 지원:</strong> 복수형(슬라브어, 아랍어 및 기타 언어 규칙 포함) 및 성별의 올바른 처리.",
    "li_feature_8": "<strong>완벽한 RTL 지원:</strong> 오른쪽에서 왼쪽으로 쓰는 언어의 올바른 표시.",
    "li_feature_9": "<strong>실시간 업데이트:</strong> 게임 시작 시 원격 서버에서 최신 번역 로드.",
    "li_feature_10": "<strong>백업 관리자:</strong> 백업 생성 및 복원을 위한 내장 도구.",
    "h1_quick_start": "빠른 시작 및 설정",
    "h2_installation": "2.1. 설치",
    "li_install_1": "에셋을 Unity 프로젝트 폴더에 복사합니다.",
    "li_install_2": "도구가 필요한 종속성을 자동으로 확인합니다. 나타나는 대화 상자에서 설치를 확인합니다.",
    "li_install_3": "필수 종속성(<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>)은 기본 기능에 필요합니다.",
    "li_install_4": "선택적 종속성(<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>)은 추가 기능을 활성화합니다.",
    "li_install_5": "<strong>선택 항목 설치</strong>를 클릭하여 권장 패키지를 설치합니다.",
    "li_install_6": "설치 후 <strong>Tools -> Localization Tool</strong> 메뉴를 통해 기본 도구 창을 엽니다.",
    "h2_initial_setup": "2.2. 초기 설정",
    "li_setup_1": "<strong>설정 생성:</strong> 처음 열 때 도구가 <code>Assets/Resources</code> 폴더에 <code>LocalizationSettings.asset</code> 파일을 생성합니다.",
    "li_setup_2": "<strong>언어 구성:</strong> <strong>설정</strong> 탭의 <strong>언어 관리</strong>에서 기본 언어(예: 영어의 경우 <code>en</code>)가 <strong>소스 언어</strong>로 선택되었는지 확인합니다. 지원하려는 모든 언어를 활성화합니다.",
    "li_setup_3": "<strong>파싱할 콘텐츠 지정:</strong> <strong>콘텐츠</strong> 탭에서 분석할 모든 씬을 <strong>파싱할 씬</strong> 목록에 추가합니다. 텍스트가 있는 프리팹을 사용하는 경우 해당 폴더가 <strong>프리팹 폴더</strong>에 추가되었는지 확인합니다.",
    "li_setup_4": "<strong>첫 파서 실행:</strong> <strong>작업</strong> 탭으로 이동하여 <code>키 업데이트</code> 버튼을 클릭합니다. 도구가 프로젝트를 스캔하고 번역 파일을 생성하며 필요한 구성 요소(<code>LocalizedText</code>, <code>LocalizedAsset</code> 등)를 게임 개체에 자동으로 추가합니다.",
    "h1_components": "핵심 구성 요소 (자동으로 할당됨)",
    "warning_box_components": "<strong>중요 참고:</strong> 아래에 설명된 모든 구성 요소는 파싱 중에(<code>키 업데이트</code> 버튼을 클릭할 때) 게임 개체에 자동으로 추가됩니다. 수동으로 추가할 필요가 없습니다.",
    "p_components_intro": "이러한 구성 요소는 씬의 개체와 번역 데이터베이스 간의 \"다리\" 역할을 합니다. 언어 변경을 \"수신\"하고 올바른 텍스트나 에셋을 자동으로 대체합니다.",
    "h2_localizedtext": "3.1. LocalizedText",
    "p_localizedtext_1": "번역된 텍스트를 표시하기 위한 주요 구성 요소입니다. <code>Text</code>, <code>TMP_Text</code> 및 <code>TextMesh</code>가 있는 개체에 배치됩니다.",
    "li_localizedtext_1": "<code>localizationKey</code>: 번역을 찾는 데 사용되는 키. 자동으로 생성됩니다.",
    "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code>인 경우 구성 요소는 스타일(글꼴, RTL)만 적용하고 텍스트 자체는 변경하지 않습니다. 텍스트가 다른 스크립트(예: <code>LanguageSelector</code>)에 의해 관리되는 요소에 유용합니다.",
    "li_localizedtext_3": "<code>originalSourceText</code>: 기본 언어의 원본 텍스트. 대체 텍스트로 사용됩니다.",
    "h2_localizedasset": "3.2. LocalizedAsset",
    "p_localizedasset_1": "에셋(<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code> 등)을 교체하는 데 사용됩니다. 개체의 대상 구성 요소 유형(<code>Image</code>, <code>AudioSource</code>)을 자동으로 감지하고 리소스를 교체합니다.",
    "p_localizedasset_2": "<strong>Play on Awake</strong> 옵션이 있는 구성 요소(예: <code>AudioSource</code>, <code>VideoPlayer</code>)의 경우 <code>LocalizedAsset</code>은 자동 재생을 올바르게 가로채고 에셋을 교체한 다음 재생을 시작하여 로컬라이즈되지 않은 콘텐츠가 재생되는 것을 방지합니다.",
    "h2_localizedprefab": "3.3. LocalizedPrefab",
    "p_localizedprefab_1": "전체 프리팹을 로컬라이즈하기 위한 구성 요소입니다. 비파괴적으로 작동합니다. 원본 프리팹을 수정하지 않고 로컬라이즈된 버전의 인스턴스를 자식 개체로 생성하여 원본 개체의 모든 스크립트(<code>MonoBehaviour</code>), 렌더러(<code>Renderer</code>) 및 콜라이더(<code>Collider</code>)를 비활성화합니다. 이렇게 하면 이중 로직 실행 및 시각적 아티팩트를 방지할 수 있습니다. 올바른 런타임 작동을 위해 실행 순서는 -100(<code>[DefaultExecutionOrder(-100)]</code>)으로 설정되어 다른 스크립트보다 먼저 실행되도록 합니다.",
    "h2_uitklocalization": "3.4. UITKLocalization",
    "p_uitklocalization_1": "<code>UIDocument</code>가 있는 개체에 추가되어 UI 툴킷 문서(UXML) 내의 모든 텍스트 요소의 로컬라이제이션을 관리합니다.",
    "h2_localizeddropdown": "3.5. LocalizedDropdown",
    "p_localizeddropdown_1": "<code>Dropdown</code> 및 <code>TMP_Dropdown</code>에 추가되어 옵션을 번역합니다.",
    "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
    "p_localizedbehaviour_1": "스크립트가 언어 변경에 반응할 수 있도록 하는 유틸리티 구성 요소입니다. <code>[OnLanguageChange]</code> 속성으로 표시된 메서드를 자동으로 찾아 호출합니다.",
    "h2_context_menu": "3.7. \"로컬라이제이션 분석\" 컨텍스트 메뉴",
    "p_context_menu_1": "개체에 <code>LocalizedAsset</code>을 빠르게 추가하려면 검사기에서 원하는 구성 요소(예: <code>Image</code>, <code>AudioSource</code>)를 마우스 오른쪽 버튼으로 클릭하고 <strong>로컬라이제이션 분석</strong>을 선택하면 됩니다. 도구가 구성 요소를 직접 추가하고 구성합니다. (이것은 선택 사항이지만 수동 추가에 사용할 수 있습니다.)",
    "h1_loc_tool_window": "\"로컬라이제이션 도구\" 창",
    "h2_in_editor_preview": "4.1. 에디터 내 미리보기",
    "p_preview_1": "헤더 바로 아래에는 <strong>미리보기 언어</strong> 드롭다운 목록이 있습니다. 이 강력한 기능을 사용하면 게임을 실행하지 않고 <strong>씬</strong> 창에서 직접 모든 언어로 로컬라이제이션이 어떻게 보일지 확인할 수 있습니다.",
    "li_preview_1": "<strong>작동 방식:</strong> 목록에서 언어를 선택하면 도구가 즉시 해당 번역, 글꼴, RTL 설정 및 에셋을 활성 씬의 모든 로컬라이즈 가능한 개체에 적용합니다.",
    "li_preview_2": "<strong>자리 표시자:</strong> <strong>설정</strong> 탭에서 자리 표시자 스타일(예: <strong>악센트</strong> 또는 <strong>괄호</strong>)이 선택된 경우 실제 번역 대신 미리보기 모드에서 이러한 자리 표시자가 표시됩니다. 이는 레이아웃을 테스트하고 로컬라이즈되지 않은 요소를 찾는 데 이상적입니다.",
    "li_preview_3": "<strong>안전성:</strong> 미리보기 모드에서 변경된 모든 내용은 일시적입니다. \"<strong>원본으로 되돌리기</strong>\"를 선택하거나, 창을 닫거나, 씬을 변경하거나, 씬/프리팹을 저장하기 전에(<code>LocalizationPreviewProtector</code> 구성 요소 덕분에) 도구가 자동으로 모든 것을 원래 상태로 되돌립니다.",
    "li_preview_4": "<strong>충돌 방지:</strong> 내장된 <code>PreviewCrashProtector</code> 시스템은 미리보기가 활성 상태일 때 Unity 편집기가 충돌하면 개체의 원래 상태를 자동으로 복원합니다.",
    "h2_tab_settings": "4.2. \"설정\" 탭",
    "p_settings_1": "제어 센터입니다. 여기서 전체 로컬라이제이션 프로세스에 대한 전역 규칙을 정의합니다.",
    "li_settings_1": "<strong>키 생성 모드:</strong> 키를 생성하는 방법을 선택합니다.<ul><li><code>UseTextAsKey</code>: 텍스트 자체가 키가 됩니다. 프로토타입에 이상적입니다. 단점: 소스 텍스트를 변경하면 키가 변경되고 모든 번역이 손실됩니다.</li><li><code>AutoGenerateKeysOnly</code>: 키는 개체의 계층 구조 및 이름을 기반으로 생성됩니다. 프로덕션에 신뢰할 수 있습니다. 장점: 텍스트를 변경해도 번역이 깨지지 않습니다.</li><li><code>UseTextAsKeyWithCustomPriority</code> 및 <code>AutoGenerateWithCustomKeys</code>: <code>[LocalizableField(\"my_custom_key\")]</code> 속성을 통해 코드에서 사용자 지정 키를 설정할 수 있는 하이브리드 모드입니다.</li><li><strong>안전한 마이그레이션:</strong> 언제든지 모드를 변경할 수 있습니다. 도구가 기존의 모든 번역을 새 키 시스템으로 자동으로 마이그레이션합니다.</li></ul>",
    "li_settings_2": "<strong>언어 관리:</strong> 언어 목록을 구성합니다. 특수 문자가 있는 언어의 경우 적절한 <strong>글꼴 에셋</strong>을 할당합니다. 오른쪽에서 왼쪽으로 쓰는 언어의 경우 <strong>RTL</strong> 옵션을 활성화합니다.",
    "li_settings_3": "<strong>일반 설정:</strong><ul><li><code>Parse Prefabs</code>: 프리팹 파싱을 활성화합니다.</li><li><code>Split files by language</code>: 번역을 저장하는 방법을 결정합니다(하나의 큰 파일 또는 언어당 하나의 파일).</li><li><code>Translations Path</code>: <code>.json</code> 번역 파일을 저장할 경로입니다. 중요: 폴더는 <code>Assets/StreamingAssets/</code> 내에 있어야 합니다.</li></ul>",
    "li_settings_4": "<strong>디버깅 및 테스트:</strong><ul><li><code>Placeholder Style</code>: 미리보기 모드에서 자리 표시자를 표시할 스타일을 선택합니다.</li></ul>",
    "li_settings_5": "<strong>실시간 업데이트:</strong> 원격 서버에서 번역을 로드하기 위한 설정입니다.",
    "li_settings_6": "<strong>런타임 API 키:</strong> 컴파일된 게임에서 필요할 수 있는 API 키를 안전하게 저장하기 위한 섹션입니다(암호화된 형태로 저장됨).",
    "h2_tab_content": "4.3. \"콘텐츠\" 탭",
    "p_content_1": "여기서 도구에 텍스트를 정확히 어디서 찾아야 하는지 알려줍니다.",
    "li_content_1": "<strong>파싱할 씬:</strong> 분석할 모든 씬을 여기에 끌어다 놓습니다.",
    "li_content_2": "<strong>프리팹 폴더:</strong> 프리팹이 있는 폴더를 지정합니다.",
    "li_content_3": "<strong>동적 텍스트:</strong> 코드에서만 생성되는 문자열(예: \"Game Over\")을 여기에 입력합니다.",
    "li_content_4": "<strong>파싱 무시:</strong> 무시할 스크립트, 구성 요소 또는 개체를 지정합니다.",
    "li_content_5": "<strong>고정:</strong> 이 기능을 사용하면 씬의 개체를 무시 목록에 \"고정\"할 수 있습니다. 개체에 대한 임시 참조 대신 도구는 계층 구조의 전체 경로를 저장하여 세션 간에 무시를 영구적으로 만듭니다(단, 개체 또는 부모의 이름을 바꾸면 이 링크가 깨집니다).",
    "h2_tab_actions": "4.4. \"작업\" 탭",
    "p_actions_1": "주요 작업 탭입니다.",
    "li_actions_1": "<strong>키 업데이트:</strong> 파서를 실행하여 번역 파일을 업데이트합니다.",
    "li_actions_2": "<strong>번역 편집기 열기:</strong> 모든 번역을 편집하기 위한 별도의 더 편리한 창을 엽니다.",
    "li_actions_3": "<strong>데이터 관리:</strong> 번역가와 데이터를 교환하는 데 사용합니다(CSV/XML/YAML/XLIFF로 내보내기/가져오기, Google Sheets에서 가져오기).",
    "li_actions_4": "<strong>자동 번역:</strong> 모든 빈 번역 문자열을 자동으로 채웁니다. 새 설정을 사용하면 각 서비스(DeepL, Google, Microsoft)에 대해 배치 크기(<strong>배치 크기</strong>) 및 재시도 정책(<strong>재시도 정책</strong>)을 별도로 관리할 수 있습니다. 도구는 번역된 문자 수를 추적하고 잠재적인 제한 초과에 대해 경고합니다.",
    "li_actions_5": "<strong>위험 구역:</strong> 프로젝트에서 모든 로컬라이제이션 구성 요소를 완전히 제거하는 버튼이 포함되어 있습니다. 주의해서 사용하십시오!",
    "h2_tab_assets": "4.5. \"에셋\" 탭",
    "p_assets_1": "이 탭은 전적으로 비텍스트 리소스 로컬라이제이션에 사용됩니다.",
    "li_assets_1": "<strong>폴더 구조 생성(선택 사항):</strong> 섹션 <strong>2. 에셋 폴더 생성</strong>에서 <strong>지금 에셋 폴더 생성</strong>을 클릭합니다.",
    "li_assets_2": "<strong>카테고리 및 이름 지정 규칙 구성:</strong> 섹션 <strong>3. 에셋 카테고리 및 스캔</strong>에서 <strong>이름 지정 규칙</strong>(<code>{key}_{lang}</code>)이 파일(예: <code>button_ok_en.png</code>)과 일치하는지 확인합니다.",
    "li_assets_3": "<strong>에셋 배치:</strong> 로컬라이즈된 에셋을 폴더에 넣습니다.",
    "li_assets_4": "<strong>에셋 스캔:</strong> 섹션 <strong>4. 자동화</strong>에서 <strong>에셋 스캔 및 테이블 업데이트</strong>를 클릭합니다. 정리 프로세스가 더 안전해졌습니다. 이제 전체 폴더가 아닌 오래된 테이블 파일(<code>.asset</code>)만 삭제됩니다.",
    "li_assets_5": "<strong>개체에 에셋 연결:</strong> <strong>프로젝트 분석 및 구성 요소 연결</strong>을 클릭합니다.",
    "h2_tab_report": "4.6. \"보고서\" 탭",
    "p_report_1": "각 파싱 후 이 보고서는 로컬라이제이션 상태의 전체 그림을 보여줍니다.",
    "li_report_1": "<strong>카테고리:</strong> 모든 키, 추가됨, 업데이트됨(텍스트 변경됨), 제거됨, 중복, 마이그레이션됨, 건너뜀(변경되지 않음).",
    "li_report_2": "<strong>고급 찾기:</strong> 항목 옆에 있는 <strong>찾기</strong> 버튼을 클릭하여 프로젝트에서 해당 개체를 즉시 찾습니다. 검색은 비동기적으로 작동하여 편집기를 차단하지 않으며 모든 씬과 프리팹에서 검색합니다. 키가 여러 위치에서 사용되는 경우 모든 소스가 포함된 드롭다운 목록이 나타납니다.",
    "h1_translation_editor": "번역 테이블 편집기",
    "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong>를 통해 엽니다. 이것은 번역을 수동으로 편집하는 기본 도구입니다.",
    "li_editor_1": "<strong>스마트 그룹화:</strong> 복수형 및 성별에 대한 키(예: <code>apple_count_one</code>, <code>apple_count_few</code>)는 자동으로 접을 수 있는 그룹으로 결합됩니다.",
    "li_editor_2": "<strong>고급 편집:</strong> 셀을 클릭하여 <strong>MultiLineEditWindow</strong> 팝업을 엽니다. 비교를 위해 소스 텍스트를 표시하고, 빠르게 복사할 수 있으며, 실시간으로 자리 표시자 불일치(예: <code>{username}</code>)를 확인하여 누락되거나 추가된 것을 강조 표시합니다.",
    "li_editor_3": "<strong>주석을 통한 자리 표시자 유효성 검사:</strong> 키의 주석에 특수 지시문을 추가하여 번역에 어떤 자리 표시자가 있어야 하는지 명시적으로 지정할 수 있습니다. 예: <code>@placeholders: {username}, {score}</code>. <strong>MultiLineEditWindow</strong>는 이 목록을 기본 진실의 원천으로 사용합니다.",
    "li_editor_4": "<strong>탐색 및 관리:</strong> 스크롤 막대 또는 마우스 가운데 버튼을 누른 채로 테이블을 탐색합니다. 구분선을 드래그하여 열 너비를 변경합니다. <code>Ctrl+S</code>로 변경 사항을 저장합니다.",
    "li_editor_5": "<strong>전체 실행 취소/다시 실행:</strong> 모든 작업 스택(텍스트 변경, 키 추가/삭제)은 <code>Ctrl+Z</code> / <code>Ctrl+Y</code>를 통해 완벽하게 지원됩니다.",
    "li_editor_6": "<strong>백업 및 자동 저장:</strong> <strong>백업 관리</strong> 버튼을 사용합니다. 도구는 또한 몇 분마다 세션을 자동으로 저장합니다. 충돌이 발생하면 변경 사항을 복원하라는 메시지가 표시됩니다.",
    "h1_usage_examples": "사용 예제",
    "h2_example_components": "6.1. 기성 컴포넌트 및 예제",
    "p_example_components_1": "프로젝트에는 훌륭한 예제로 사용되는 기성 스크립트가 포함되어 있습니다.",
    "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 언어 전환을 위한 UI 드롭다운 목록을 만드는 기성 구성 요소입니다. 사용 가능한 모든 언어를 자동으로 찾아 전환을 관리합니다.<br><strong>사용 방법:</strong> 씬에 <code>LanguageSelector</code> 구성 요소를 추가하고(예: 빈 GameObject에) 검사기에서 <code>TMP_Dropdown</code>을 지정하기만 하면 됩니다.",
    "li_example_components_2": "<strong>코드 예제:</strong> <code>[LocalizableField]</code>, <code>_()</code> 함수, 복수형 및 성별과 같은 고급 기술을 배우려면 <code>StatPurchaseTest.cs</code> 및 <code>TestLocalization.cs</code> 파일을 연구하십시오. 코드에서 도구의 모든 주요 기능 구현을 명확하게 보여줍니다.",
    "h2_example_attribute": "6.2. [LocalizableField] 속성",
    "p_example_attribute_1": "검사기에서 구성 요소 구성의 일부인 텍스트에 선호되는 방법입니다. 이제 파서는 문자열, 문자열 목록/배열, 심지어 중첩된 <code>[System.Serializable]</code> 클래스 내의 필드와도 작동할 수 있습니다.",
    "code_example_attribute": "using Ankonoanko.Localization; // [LocalizableField]에 필요\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // 파서가 이 필드를 찾아 키를 생성합니다.\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"퀘스트에 실패했습니다.\";\n    \n    // 사용자 지정 키를 설정할 수 있습니다.\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"모험을 떠날 준비가 되셨습니까?\";\n    \n    // 목록과 함께 작동합니다.\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"보물 찾기\" };\n    \n    // 그리고 중첩 클래스와도 함께 작동합니다!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
    "h2_example_function": "6.3. _() 함수 및 [OnLanguageChange] 속성",
    "p_example_function_1": "게임 플레이 중에 변경되는 동적 텍스트에 <code>_()</code> 함수를 사용합니다. UI를 업데이트하는 메서드는 언어가 변경될 때 자동으로 호출되도록 <code>[OnLanguageChange]</code> 속성으로 표시되어야 합니다. 이를 위해 개체에 <code>LocalizedBehaviour</code> 구성 요소가 자동으로 추가됩니다.",
    "code_example_function": "// 짧은 _() 호출을 사용하려면 이 줄을 추가하십시오.\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange]에 필요\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // 초기 업데이트\n    }\n    \n    // 이 메서드는 언어가 변경될 때 자동으로 호출됩니다.\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. 인덱싱된 자리 표시자 (string.Format과 유사)\n        // 키: \"score_label\", 파일의 텍스트: \"점수: {0}\"\n        scoreText.text = _(\"score_label\", score); // 결과: \"점수: 100\"\n        \n        // 2. 명명된 자리 표시자 (가독성을 위해 권장)\n        // 키: \"welcome_message\", 텍스트: \"환영합니다, {username}님!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // 복잡한 경우 또는 고성능을 위해\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
    "h2_example_plurals": "6.4. 복수형 및 성별",
    "p_example_plurals_1": "이제 도구는 다른 언어 그룹에 대해 더 정확한 규칙을 사용합니다.",
    "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // 키: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // 텍스트: \"사과 {0}개\", \"사과 {0}개\", \"사과 {0}개\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // 올바른 형식을 자동으로 선택합니다.\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // 키: \"user_greeted_male\", \"user_greeted_female\"\n        // 텍스트: \"그가 도착했습니다.\", \"그녀가 도착했습니다.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
    "h1_important_notes": "중요 참고사항 및 경고",
    "li_notes_1": "<strong>백업:</strong> 전역 작업(<code>키 업데이트</code>, 데이터 가져오기) 전에 항상 <strong>번역 테이블 편집기 -> 백업 관리</strong>를 통해 백업을 만드십시오.",
    "li_notes_2": "<strong>API 키 보안:</strong> 편집기에서 작업하기 위한 키는 컴퓨터에 로컬로 저장되며(<code>EditorPrefs</code>에) 저장소에 들어가지 않습니다. 게임 빌드에 필요한 키의 경우 <strong>런타임 API 키</strong> 섹션을 사용하십시오.",
    "li_notes_3": "<strong><code>StreamingAssets</code> 폴더:</strong> 번역 파일은 게임 빌드에 포함되도록 <code>Assets/StreamingAssets/</code>의 하위 폴더에 있어야 합니다.",
    "li_notes_4": "<strong>\"바보 방지\":</strong> 이 도구는 미리보기 모드의 임시 데이터가 씬이나 프리팹에 실수로 저장되는 것을 자동으로 방지합니다.",
    "li_notes_5": "<strong>성능:</strong> <code>_()</code> 호출은 빠르지만 매 프레임 실행되는 루프(예: <code>Update</code>)에서는 결과를 변수에 캐시하십시오.",
    "li_notes_6": "<strong>파싱에서 <code>LanguageSelector</code> 제외:</strong> <code>LanguageSelector</code> 구성 요소와 해당 <code>TMP_Dropdown</code>이 있는 개체는 <strong>콘텐츠</strong> 탭의 <strong>특정 개체 무시</strong> 목록에 추가해야 합니다. 이는 파서가 드롭다운 옵션에 대한 추가 키를 생성하는 것을 방지하기 위해 필요합니다. <code>LanguageSelector</code> 스크립트는 런타임에 동적으로 채우기 때문입니다. 무시하면 충돌을 방지하고 번역 파일을 깨끗하게 유지할 수 있습니다.",
    "li_notes_7": "<strong><code>LanguageSelector</code>용 글꼴:</strong> <code>TMP_Dropdown</code>에서 선택한 언어가 글꼴을 올바르게 업데이트하려면 드롭다운의 자식 <strong>Label</strong> 개체에 빈 <code>LocalizedText</code> 구성 요소를 수동으로 추가하고 <code>isStyleOnly</code> 확인란을 선택하십시오.",
    "h1_extending": "기능 확장",
    "h2_custom_parser": "8.1. 사용자 지정 파서 만들기",
    "p_custom_parser_1": "사용자 지정 파서 클래스를 만들어 사용자 지정 구성 요소를 지원하도록 시스템을 쉽게 확장할 수 있습니다.",
    "li_custom_parser_1": "프로젝트의 <strong>Editor</strong> 폴더에 새 C# 스크립트를 만듭니다.",
    "li_custom_parser_2": "아래 템플릿을 복사하여 붙여넣습니다.",
    "li_custom_parser_3": "구성 요소와 일치하도록 로직을 수정합니다.",
    "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// 사용자 지정 구성 요소용 파서를 만들기 위한 템플릿입니다.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. 개체에 필요한 사용자 지정 구성 요소가 있는지 확인합니다.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // 구성 요소를 찾을 수 없으면 종료합니다.\n        }\n        \n        // 2. 사용자 지정 구성 요소의 필드에서 텍스트를 가져옵니다.\n        string titleText = component.Title;\n        \n        // 3. 텍스트가 로컬라이제이션에 유효한지 확인합니다.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. TextParser의 도우미를 사용하여 키와 소스를 생성합니다.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. 결과를 반환합니다.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. 다른 필드에 대해 반복합니다...\n        // (키를 고유하게 만들기 위해 접미사를 추가할 수 있습니다)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
    "h1_faq": "FAQ 및 문제 해결",
    "h2_faq_installation": "9.1. 설치 및 빠른 시작",
    "q_faq_installation_1": "내 프로젝트에 다른 에셋의 com.unity.nuget.newtonsoft-json 패키지가 이미 있으면 어떻게 됩니까? 종속성 설치 프로그램이 업데이트를 시도하거나 무시합니까?",
    "a_faq_installation_1": "설치 프로그램은 Newtonsoft.Json.JsonConvert 유형의 존재를 확인합니다. 유형이 존재하면 종속성이 충족된 것으로 간주하고 패키지를 설치하거나 업데이트하려고 시도하지 않습니다. 이는 버전 충돌을 방지하기 위함입니다.",
    "q_faq_installation_2": "실수로 \"지금 건너뛰기\"를 클릭하고 선택적 종속성(예: CSV 지원)에 대해 \"다시 묻지 않음\"을 선택했습니다. 설치 프로그램 창을 다시 열어 설치하려면 어떻게 해야 합니까?",
    "a_faq_installation_2": "Tools -> Localization -> Check Dependencies 메뉴를 통해 언제든지 종속성 확인을 수동으로 트리거할 수 있습니다. 이렇게 하면 \"다시 묻지 않음\" 플래그가 재설정되고 누락된 모든 선택적 패키지가 포함된 창이 다시 표시됩니다.",
    "q_faq_installation_3": "도구가 Assets/Resources에 LocalizationSettings.asset을 만들지 않았습니다. 왜 이런 일이 발생했을 수 있으며 Assets -> Create 메뉴를 통해 수동으로 만들 수 있습니까?",
    "a_faq_installation_3": "Assets/Resources 폴더가 없는 경우 발생할 수 있습니다. 도구가 생성을 시도하지만 파일 시스템 권한으로 인해 실패할 수 있습니다. 예, 수동으로 에셋을 만들 수 있습니다. Resources 폴더를 마우스 오른쪽 버튼으로 클릭하고 Create -> Localization -> Settings를 선택합니다. 도구가 자동으로 찾습니다.",
    "q_faq_installation_4": "LocalizationSettings.asset 파일을 다른 Resources 폴더(예: Assets/MyGame/Resources)로 이동할 수 있습니까? 도구가 여전히 찾을 수 있습니까?",
    "a_faq_installation_4": "예. 이 도구는 Resources.Load()를 사용하며, 프로젝트의 모든 Resources 폴더에서 이름으로 에셋을 검색합니다. 중요한 것은 파일 이름이 LocalizationSettings.asset으로 유지되는 것입니다.",
    "q_faq_installation_5": "종속성 설치 프로그램이 중단되거나 오류가 발생했습니다. Unity 패키지 관리자를 통해 종속성(Newtonsoft Json, Editor Coroutines)을 수동으로 설치할 수 있습니까?",
    "a_faq_installation_5": "예. Window -> Package Manager를 열고 \"+\" 아이콘을 클릭한 다음 \"Add package by name...\"을 선택할 수 있습니다. 패키지 이름: com.unity.nuget.newtonsoft-json 및 com.unity.editorcoroutines를 입력합니다.",
    "h2_faq_components": "9.2. 핵심 구성 요소",
    "q_faq_components_1": "LocalizedPrefab 구성 요소는 원본 개체에서 MonoBehaviour를 비활성화합니다. 원본 개체에 다른 개체를 만들거나 Awake()에서 이벤트에 구독하는 스크립트가 있으면 어떻게 됩니까? 이 코드가 실행됩니까?",
    "a_faq_components_1": "아니요, 실행되지 않습니다. MonoBehaviour를 비활성화하면 Awake(), OnEnable() 및 Start()를 포함한 모든 Unity의 \"마법\" 메서드가 호출되지 않습니다. 이는 중복 로직 실행을 피하기 위한 의도적인 조치입니다. 모든 초기화는 로컬라이즈된 버전의 프리팹에 있는 스크립트에서 발생해야 합니다.",
    "q_faq_components_2": "원본 프리팹(LocalizedPrefab)에 Rigidbody 또는 다른 물리 구성 요소가 있으면 비활성화됩니까? 로컬라이즈된 프리팹에 없으면 물리 현상에 영향을 줍니까?",
    "a_faq_components_2": "네, 원본 객체의 물리 동작은 중화됩니다. LocalizedPrefab 컴포넌트는 해당 GameObject의 모든 Rigidbody 및 Rigidbody2D 컴포넌트를 찾아 isKinematic 속성을 true로 설정합니다. 이는 보이지 않는 객체가 떨어지거나 충돌에 반응하는 것과 같은 원치 않는 동작을 방지하여 동적 물리 계산에서 효과적으로 제거합니다. 로컬라이즈된 버전의 프리팹에 올바른 동작을 위한 모든 필수 물리 컴포넌트가 포함되도록 권장됩니다.",
    "q_faq_components_3": "LocalizedAsset 구성 요소는 대상 구성 요소 이름을 문자열(_targetComponentTypeName)으로 저장합니다. 사용자 지정 구성 요소 스크립트의 이름을 바꾸거나 다른 어셈블리(어셈블리 정의)로 이동하면 어떻게 됩니까? LocalizedAsset이 작동을 멈춥니까?",
    "a_faq_components_3": "예, 작동을 멈춥니다. 구성 요소는 네임스페이스와 어셈블리를 포함한 전체 유형 이름을 저장합니다. 스크립트의 이름을 바꾸거나 다른 .asmdef로 이동하면 이 이름이 변경되고 LocalizedAsset은 대상 구성 요소를 찾을 수 없습니다. 이름이 업데이트되도록 하려면 Analyze Project & Attach Components를 통해 다른 분석을 실행해야 합니다.",
    "q_faq_components_4": "동일한 GameObject에 두 개의 이미지 구성 요소가 있는 경우 LocalizedAsset은 어느 것을 로컬라이즈해야 하는지 어떻게 알 수 있습니까? 둘 다 작동합니까, 아니면 처음 찾은 것만 작동합니까?",
    "a_faq_components_4": "LocalizedAsset은 특정 구성 요소 인스턴스에 대해 생성됩니다. 코드에서 해당 구성 요소에 대한 참조를 보유합니다. 두 번째 LocalizedAsset을 수동으로 추가하고 \"로컬라이제이션 분석\" 컨텍스트 메뉴를 사용하여 두 번째 이미지를 대상으로 지정하면 각각 자체 이미지를 관리하는 두 개의 LocalizedAsset 구성 요소가 생성됩니다. 자동 분석기는 찾은 로컬라이즈 가능한 에셋이 있는 첫 번째 이미지에 대해서만 구성 요소를 생성합니다.",
    "q_faq_components_5": "문서에는 LocalizedPrefab의 실행 순서가 -100이라고 나와 있습니다. 실행 순서가 -110인 다른 스크립트가 Awake()에서 LocalizedPrefab이 만든 자식 개체를 찾으려고 하면 어떻게 됩니까? LocalizedPrefab이 제때 인스턴스를 인스턴스화했을까요?",
    "a_faq_components_5": "예, 그럴 것입니다. LocalizedPrefab은 OnEnable() 메서드에서 로컬라이즈된 프리팹의 인스턴스를 만듭니다. Unity의 실행 순서는 모든 Awake() 메서드가 모든 OnEnable() 메서드보다 먼저 실행되도록 보장합니다. 따라서 순서 -110의 스크립트는 Awake()를 실행하고, 순서 -100의 LocalizedPrefab은 Awake()를 실행한 다음, 그 후에야 OnEnable() 메서드가 순서대로 호출됩니다. 아직 생성되지 않았기 때문에 스크립트는 개체를 찾지 못합니다.",
    "q_faq_components_6": "LocalizedText 구성 요소에는 isStyleOnly 옵션이 있습니다. 이 옵션을 활성화한 다음 코드에서 myLocalizedText.SetFormattedText(\"new_key\")를 호출하면 텍스트가 변경됩니까, 아니면 스타일(글꼴/RTL)만 변경됩니까?",
    "a_faq_components_6": "키와 텍스트가 모두 변경됩니다. SetFormattedText를 프로그래밍 방식으로 호출하면 해당 특정 업데이트에 대한 isStyleOnly 동작이 재정의됩니다. isStyleOnly 옵션은 구성 요소가 전역 언어 변경에 반응하는 것을 방지하기 위한 것이지만 코드를 통해 직접 키를 변경하면 항상 반응합니다.",
    "q_faq_components_7": "LocalizedBehaviour는 [OnLanguageChange] 속성이 있는 메서드를 자동으로 찾습니다. private 및 protected 메서드를 찾습니까, 아니면 public이어야 합니까?",
    "a_faq_components_7": "모든 액세스 한정자(public, private, protected, internal)가 있는 메서드를 찾습니다. Unity의 리플렉션은 액세스 수준에 관계없이 모든 인스턴스 메서드를 검색할 수 있도록 합니다.",
    "q_faq_components_8": "LocalizedAsset 구성 요소는 Play on Awake를 가로챕니다. 동일한 개체의 다른 스크립트가 LocalizedAsset이 교체하기 전에 Awake() 또는 Start()에서 에셋(예: audioSource.clip.length)에 액세스하려고 하면 어떻게 됩니까? NullReferenceException 또는 이전 에셋 사용이 가능합니까?",
    "a_faq_components_8": "이전(로컬라이즈되지 않은) 에셋을 사용할 수 있습니다. LocalizedAsset은 OnEnable()에서 교체를 수행합니다. 모든 스크립트의 Awake() 메서드는 OnEnable()보다 먼저 실행됩니다. 스크립트가 Awake()에서 audioSource.clip에 액세스하면 원본 클립을 가져옵니다. Start()에서 액세스하면 결과는 스크립트 실행 순서에 따라 달라집니다. 로컬라이즈된 에셋에 대한 액세스를 보장하려면 스크립트에 대해 나중에 실행 순서를 설정하거나 [OnLanguageChange]로 표시된 메서드에서 에셋에 액세스하십시오.",
    "h2_faq_window": "9.3. \"로컬라이제이션 도구\" 창",
    "h3_faq_window_preview": "에디터 내 미리보기",
    "q_faq_window_preview_1": "프리팹 모드에서 프리팹을 열고 에디터 내 미리보기를 적용한 다음 Ctrl+S를 눌렀습니다. 임시 미리보기 데이터가 프리팹 에셋에 저장됩니까? LocalizationPreviewProtector는 이 경우를 어떻게 처리합니까?",
    "a_faq_window_preview_1": "아니요, 저장되지 않습니다. LocalizationPreviewProtector는 에셋 저장 이벤트(OnWillSaveAssets)를 가로채고 Unity가 변경 사항을 디스크에 쓰기 전에 RevertEditorPreview()를 자동으로 호출합니다. 따라서 프리팹은 원래의 로컬라이즈되지 않은 상태로 저장됩니다.",
    "q_faq_window_preview_2": "에디터 내 미리보기를 활성화하고 Unity 편집기가 충돌하고 Temp/localization_preview_recovery.json 파일이 손상(예: 비어 있거나 잘못된 JSON)되면 다음 실행 시 어떻게 됩니까?",
    "a_faq_window_preview_2": "PreviewCrashProtector는 try-catch 블록으로 래핑됩니다. JSON 역직렬화에 실패하면 복구할 수 없다는 오류가 콘솔에 기록되고 프로세스가 조용히 종료됩니다. 씬은 충돌 시점의 \"깨진\" 상태로 유지됩니다. 이 경우 변경 사항 롤백을 강제하려면 도구 창에서 수동으로 \"원본으로 되돌리기\"를 선택해야 합니다.",
    "q_faq_window_preview_3": "LocalizedPrefab용 에디터 내 미리보기 모드에서 임시 인스턴스가 생성됩니다. 이 인스턴스에서 Awake() 및 Start() 메서드가 실행됩니까? 편집 모드에서 실행되도록 설계되지 않은 경우 오류가 발생할 수 있습니까?",
    "a_faq_window_preview_3": "예, 그렇습니다. 편집 모드의 PrefabUtility.InstantiatePrefab은 Awake() 및 OnEnable()을 호출합니다. 이러한 메서드에 편집기에서 실행되어서는 안 되는 로직(예: 재생 모드에만 존재하는 싱글톤에 액세스)이 포함되어 있으면 오류가 발생할 수 있습니다. 이러한 코드를 보호하려면 if (Application.isPlaying) 또는 #if UNITY_EDITOR를 사용하는 것이 좋습니다.",
    "h3_faq_window_settings": "\"설정\" 탭",
    "q_faq_window_settings_1": "프로젝트 중간에 키 생성 모드를 UseTextAsKey에서 AutoGenerateKeysOnly로 변경할 수 있습니다. 기존 번역에 정확히 어떤 일이 발생합니까? 새 키에 매핑됩니까?",
    "a_faq_window_settings_1": "예, 그렇습니다. 모드를 변경할 때 도구는 \"안전한 마이그레이션\"을 수행합니다. 전체 프로젝트를 다시 파싱하고 새 규칙에 따라 새 키를 만들지만 원본 텍스트를 통해 이전 키와 새 키를 매핑합니다. 그런 다음 기존의 모든 번역과 주석을 이전 키에서 새 키로 전송합니다. 번역은 손실되지 않습니다.",
    "q_faq_window_settings_2": "지원되는 언어 목록에 복수화 규칙이 없는 코드(예: 카자흐어의 경우 \"kz\")를 가진 언어를 추가하면 기본적으로 어떤 규칙이 사용됩니까?",
    "a_faq_window_settings_2": "DefaultPluralRule이 사용되며, 이는 영어 및 대부분의 유럽 언어( \"하나\"와 \"기타\" 형식)에 적합합니다.",
    "q_faq_window_settings_3": "StreamingAssets가 아닌 Assets/MyTranslations와 같은 일반 폴더에 번역 경로를 지정하면 어떻게 됩니까? json 파일이 게임 빌드에 포함됩니까?",
    "a_faq_window_settings_3": "아니요, 그렇지 않습니다. StreamingAssets 또는 Resources 폴더에 있는 에셋만 빌드에 포함되는 것이 보장됩니다. 다른 경로를 지정하면 편집기에서는 로컬라이제이션이 작동하지만 번역 파일이 빌드의 일부가 아니므로 컴파일된 게임에서는 작동하지 않습니다.",
    "q_faq_window_settings_4": "자동 번역 API 키는 EditorPrefs에 저장됩니다. 두 대의 다른 컴퓨터에서 프로젝트 작업을 하는 경우 각 컴퓨터에서 키를 별도로 입력해야 합니까?",
    "a_faq_window_settings_4": "예. EditorPrefs는 각 컴퓨터의 로컬 저장소입니다. 자동 번역 기능을 사용하려는 각 컴퓨터에서 API 키를 입력해야 합니다.",
    "h3_faq_window_content": "\"콘텐츠\" 탭",
    "q_faq_window_content_1": "빌드 설정에 포함되지 않은 씬을 파싱할 씬에 추가하면 어떻게 됩니까? 파싱 프로세스 자체 외에 다른 것에 영향을 줍니까?",
    "a_faq_window_content_1": "아니요, 그렇지 않습니다. 파싱할 씬 목록은 도구가 텍스트를 열고 분석할 씬을 알리는 데만 사용됩니다. 게임의 최종 빌드에 포함될 씬과는 관련이 없습니다.",
    "q_faq_window_content_2": "특정 개체 무시(임시 목록)에 개체를 추가했습니다. 이 개체로 프리팹을 만들면 이 프리팹의 인스턴스도 무시됩니까?",
    "a_faq_window_content_2": "아니요, 그렇지 않습니다. 임시 목록은 씬의 개체에 대한 직접 참조를 저장합니다. 프리팹을 만들면 새 에셋입니다. 인스턴스는 다른 개체이며 무시 규칙이 적용되지 않습니다. 프리팹을 영구적으로 무시하려면 프리팹 에셋으로 무시 목록에 추가해야 합니다.",
    "q_faq_window_content_3": "TMPro.TMP_Text 구성 요소를 파싱 무시 -> 구성 요소 유형 무시에 추가했지만 씬에 이미 이 TMP_Text를 참조하는 LocalizedText가 있는 개체가 있으면 다음 키 업데이트 시 어떻게 됩니까? 키가 삭제됩니까?",
    "a_faq_window_content_3": "예, 그렇습니다. 키 업데이트를 클릭하면 파서가 전체 프로젝트를 다시 스캔합니다. TMPro.TMP_Text 유형을 무시해야 함을 확인하고 키를 생성하지 않습니다. 이전 키와 새 키를 비교하는 과정에서 이전 키가 더 이상 사용되지 않는다고 판단하고 \"제거됨\"으로 표시합니다.",
    "q_faq_window_content_4": "문서에는 \"고정\"이 개체의 전체 경로를 저장하고 이름을 바꾸면 깨진다고 나와 있습니다. 개체에서 프리팹을 만든 다음 원본 개체의 이름을 바꾸면 \"고정\"이 프리팹 인스턴스에 계속 작동합니까?",
    "a_faq_window_content_4": "아니요, 그렇지 않습니다. \"고정\"은 버튼을 클릭한 순간의 씬 계층 구조의 절대 경로(예: Canvas/Panel/Button)를 저장합니다. 이 경로는 프리팹 로직과 관련이 없습니다. 프리팹 인스턴스는 동일한 경로를 갖지만 씬에서 부모 개체의 이름을 바꾸면 \"고정\"이 원본 및 인스턴스 모두에서 작동을 멈춥니다.",
    "q_faq_window_content_5": "프리팹 인스턴스 내의 자식 개체에 \"고정\"을 사용하면 어떤 경로가 저장됩니까? 프리팹 루트 또는 씬 루트에 상대적입니까? 다른 씬에서도 작동합니까?",
    "a_faq_window_content_5": "씬 루트의 전체 경로가 저장됩니다. 예를 들어 MyPrefab(Clone)/Content/Icon입니다. 이 \"고정된\" 경로는 생성한 씬에서만 작동합니다. 다른 씬에서는 이러한 경로를 찾을 수 없을 것입니다.",
    "h3_faq_window_actions": "\"작업\" 탭",
    "h3_faq_window_assets": "\"에셋\" 탭",
    "h3_faq_window_report": "\"보고서\" 탭",
    "h2_faq_editor": "9.4. 번역 편집기",
    "h2_faq_examples": "9.5. 사용 예제 및 코드",
    "h2_faq_notes": "9.6. 중요한 뉘앙스 및 경고",
    "h2_faq_extending": "9.7. 기능 확장",
    "q_faq_window_actions_1": "일괄 자동 번역 중에 인터넷 연결이 끊어지면 어떻게 됩니까? 도구가 재시도 정책에 따라 실패한 배치를 재시도합니까, 아니면 프로세스가 완전히 중단됩니까?",
    "a_faq_window_actions_1": "도구는 재시도 정책 설정(시도 횟수 및 지연)에 따라 실패한 정확한 배치를 다시 보내려고 시도합니다. 이 배치에 대한 모든 시도가 실패하면 현재 언어에 대한 번역 프로세스가 중단되고 오류가 콘솔에 기록됩니다. 대기열의 다음 언어에 대한 번역은 시작되지 않습니다.",
    "q_faq_window_actions_2": "프로젝트에 이미 존재하는 키가 포함되어 있지만 일부 언어에 대해 빈 값이 있는 CSV 파일을 가져오면 이러한 빈 값이 기존 번역을 대체합니까, 아니면 무시됩니까?",
    "a_faq_window_actions_2": "빈 값이 기존 번역을 대체합니다. 가져오기 프로세스는 CSV 파일을 \"진실의 원천\"으로 간주합니다. ru 열의 welcome_message 키에 대한 값이 비어 있으면 이 키에 대한 현재 러시아어 번역이 덮어쓰여집니다.",
    "q_faq_window_actions_3": "\"위험 구역\" 섹션에서는 모든 구성 요소를 삭제할 수 있습니다. 콘텐츠 탭의 프리팹 폴더에 지정되지 않은 폴더에 있는 프리팹에서 구성 요소를 제거합니까?",
    "a_faq_window_actions_3": "예, 그렇습니다. \"위험 구역\"의 기능은 가능한 가장 완벽한 정리를 보장하기 위해 파싱 목록에 지정된 것뿐만 아니라 프로젝트의 모든 프리팹(AssetDatabase.FindAssets(\"t:Prefab\"))을 스캔합니다.",
    "q_faq_window_actions_4": "Google Sheets에서 가져올 때 @placeholders: 지시문을 사용하여 자리 표시자 유효성 검사를 작동시키려면 주석 열을 어떻게 서식 지정해야 합니까?",
    "a_faq_window_actions_4": "Google Sheets 문서에서 열 제목은 \"개발자 노트\"여야 합니다. 이 열의 셀에 평소와 같이 주석을 쓸 수 있습니다. 자리 표시자를 지정하려면 주석 텍스트에 @placeholders: {username}, {score}와 같은 줄을 추가하기만 하면 됩니다. 도구가 가져올 때 이 지시문을 자동으로 인식합니다.",
    "q_faq_window_actions_5": "도구가 단일 Google Sheets 문서의 여러 시트에서 데이터를 가져올 수 있습니까, 아니면 GID당 하나의 시트만 작동합니까?",
    "a_faq_window_actions_5": "도구는 한 번에 하나의 시트만 작동합니다. 가져오기 URL에는 gid=... 매개변수가 포함되어 있으며, 이는 문서의 특정 시트를 고유하게 식별합니다. 다른 시트에서 데이터를 가져오려면 해당 URL(다른 gid 포함)을 복사하고 가져오기를 다시 수행해야 합니다.",
    "q_faq_window_assets_1": "동일한 스캔 폴더에 동일한 키를 가진 두 개의 에셋이 있지만 유형이 다른 경우(예: sound_effect_en.mp3 및 sound_effect_en.wav) 어떻게 됩니까? 어느 것이 에셋 테이블에 포함됩니까?",
    "a_faq_window_assets_1": "에셋 스캐너는 예상 유형을 지정하여 로드합니다(AssetDatabase.LoadAssetAtPath(path, expectedType)). AudioClip 카테고리의 경우 Unity가 AudioClip으로 인식하는 파일만 검색하고 로드합니다. 두 파일이 모두 유효한 오디오 클립인 경우 마지막으로 처리된 파일이 테이블에 포함되어 이전 파일을 효과적으로 덮어씁니다. 이러한 중복은 피하는 것이 좋습니다.",
    "q_faq_window_assets_2": "에셋 스캔 및 프로젝트 분석을 클릭하고 로컬라이즈된 스프라이트가 이미 존재하지만 이미지 개체 자체에 아직 LocalizedAsset 구성 요소가 없는 씬에 이미지 개체가 있으면 도구가 구성 요소를 추가하고 자동으로 키를 삽입합니까?",
    "a_faq_window_assets_2": "예, 정확히 그렇게 작동합니다. \"프로젝트 분석\"은 이미지 구성 요소를 찾고 할당된 스프라이트의 이름(예: icon_play_en)을 보고 키(icon_play)와 언어(en)를 추출한 다음 해당 GameObject에 LocalizedAsset 구성 요소를 추가하고 키 icon_play를 씁니다.",
    "q_faq_window_assets_3": "다른 에셋 카테고리에 대해 스캔 폴더가 다른 경우 동일한 이름 지정 규칙을 사용할 수 있습니까? 충돌이 발생합니까?",
    "a_faq_window_assets_3": "예, 사용할 수 있습니다. 각 카테고리에 대해 별도의 에셋 테이블(LocalizedAssetTable)이 생성되므로 충돌이 발생하지 않습니다. \"스프라이트\" 카테고리의 키는 이름이 같더라도 \"AudioClips\" 카테고리의 키와 겹치지 않습니다.",
    "q_faq_window_assets_4": "로컬라이즈 가능한 에셋(예: button_ok_en.png)이 스캔 폴더의 루트가 아닌 하위 폴더에 있으면 스캐너가 찾을 수 있습니까?",
    "a_faq_window_assets_4": "예, 그렇습니다. 스캐너는 SearchOption.AllDirectories 옵션을 사용하므로 지정한 스캔 폴더 내의 모든 하위 폴더를 재귀적으로 확인합니다.",
    "q_faq_window_report_1": "\"찾기\" 버튼은 개체를 비동기적으로 검색합니다. 검색을 시작한 다음 즉시 키 업데이트를 클릭하면 어떻게 됩니까? 검색이 중단됩니까?",
    "a_faq_window_report_1": "예, 중단됩니다. UI 차단이 필요한 새 작업(키 업데이트 등)은 현재 검색 코루틴을 중지합니다. 새 검색을 시작하려면 현재 검색을 중지하라는 메시지가 표시되는 대화 상자가 나타납니다.",
    "q_faq_window_report_2": "키가 여러 위치(예: 다른 씬의 두 개의 다른 버튼)에서 사용되는 경우 \"중복\" 카테고리의 보고서에 어떻게 표시됩니까?",
    "a_faq_window_report_2": "\"중복\" 카테고리는 해당 키에 대한 모든 소스를 표시합니다. 키에 대한 하나의 항목이 표시되고 \"소스\" 필드에는 모든 경로(씬 1 및 씬 2)가 나열됩니다. 이 경우 \"찾기\" 버튼을 누르면 드롭다운 목록이 열리고 탐색할 개체를 선택할 수 있습니다.",
    "q_faq_window_report_3": "코드에서만 사용되는 키( _() 함수를 통해)에 대해 \"찾기\"를 클릭하면 어떻게 됩니까? 도구가 C# 스크립트를 찾아 강조 표시할 수 있습니까?",
    "a_faq_window_report_3": "예. 검색 시스템은 MyScript.cs와 같은 소스를 인식하도록 특별히 훈련되었습니다. \"찾기\"를 클릭하면 프로젝트에서 MyScript.cs 에셋을 검색하고 프로젝트 창에서 강조 표시(핑)합니다.",
    "q_faq_editor_1": "자리 표시자 유효성 검사에 우선 순위가 더 높은 것은 무엇입니까? 주석의 @placeholders: 지시문 또는 소스 언어 텍스트에서 찾은 자리 표시자? 예를 들어 소스 텍스트에 {name}이 있고 주석에 @placeholders: {username}이라고 되어 있는 경우.",
    "a_faq_editor_1": "주석의 @placeholders: 지시문이 우선합니다. 이는 개발자의 명시적인 지침이자 \"진실의 원천\"으로 간주됩니다. 예제에서 편집기는 번역에 {username}을 요구하고 소스 텍스트의 {name}을 무시합니다.",
    "q_faq_editor_2": "지시문에 오타가 있으면(예: @placeholders: 대신 @placeholder:) 무시됩니까, 아니면 도구에서 경고를 발행합니까?",
    "a_faq_editor_2": "단순히 무시됩니다. 도구는 @placeholders:의 정확한 일치를 찾습니다. 지시문에 오타가 있으면 일반 주석의 일부로 처리되고 유효성 검사는 이전 방식, 즉 소스 텍스트의 자리 표시자를 기반으로 작동합니다.",
    "q_faq_editor_3": "자동 저장 시스템은 Backups/AutoSaves 폴더에 파일을 만듭니다. 이 파일은 수동 저장이 성공하거나 창을 닫은 후 자동으로 삭제됩니까?",
    "a_faq_editor_3": "예. 수동 저장이 성공하거나 창을 정상적으로 닫으면(변경 사항을 저장할 때) 다음 실행 시 복구를 묻는 메시지가 표시되지 않도록 모든 자동 저장 파일이 삭제됩니다. 편집기 충돌 시에만 남아 있습니다.",
    "q_faq_editor_4": "편집기에서 열 너비를 변경하면 이 설정이 Unity 세션 간에 저장됩니까?",
    "a_faq_editor_4": "예. 열 너비는 번역 편집기 창을 닫을 때마다 EditorPrefs에 저장되고 다음에 열 때 복원됩니다.",
    "q_faq_editor_5": "텍스트 편집 팝업 창(MultiLineEditWindow)은 그 안에서 변경한 내용에 대해 자체 실행 취소/다시 실행 스택(Ctrl+Z 사용)을 지원합니까?",
    "a_faq_editor_5": "예. MultiLineEditWindow에는 창이 열려 있는 동안 작동하는 자체 임시 실행 취소/다시 실행 스택이 있습니다. 이를 통해 해당 창 내에서 텍스트 변경을 실행 취소하고 다시 실행할 수 있습니다. 결과를 저장하면(창을 닫음) 이 변경 사항이 기본 편집기의 전역 실행 취소/다시 실행 스택에 단일 작업으로 기록됩니다.",
    "q_faq_examples_1": "_() 함수에 전달된 익명 유형의 속성 이름이 문자열의 자리 표시자와 일치하지 않으면 어떻게 됩니까? 예를 들어 _(\"안녕하세요, {username}님\", new { user_name = \"Bob\" }). 오류가 발생합니까, 아니면 자리 표시자가 단순히 대체되지 않습니까?",
    "a_faq_examples_1": "오류가 발생하지 않습니다. {username} 자리 표시자는 단순히 대체되지 않고 결과적으로 \"안녕하세요, {username}님\" 문자열을 얻게 됩니다. 대체는 정확한 이름 일치 시에만 발생합니다.",
    "q_faq_examples_2": "[LocalizableField] 속성은 private 필드에 대해 작동합니다. static 필드에 대해서도 작동합니까?",
    "a_faq_examples_2": "예, 그렇습니다. 파서는 BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static 플래그가 있는 필드를 찾기 위해 리플렉션을 사용하므로 정적 필드를 찾아 처리합니다.",
    "q_faq_examples_3": "매개변수가 있는 메서드(예: void UpdateUI(string newLang))에 [OnLanguageChange] 속성을 넣으면 어떻게 됩니까? 컴파일 오류 또는 런타임 경고가 발생합니까?",
    "a_faq_examples_3": "컴파일 오류는 발생하지 않지만 런타임에 Unity 콘솔에 LocalizedBehaviour에서 경고가 표시됩니다. 속성이 있는 메서드를 찾았지만 메서드에 매개변수가 있기 때문에 무시했다고 보고합니다. 이러한 메서드는 호출되지 않습니다.",
    "q_faq_examples_4": " _(\"apple_count\", count)를 사용하고 있습니다. 현재 언어에 대해 count = 1에 대한 apple_count_one 키가 없으면 시스템은 어떤 형식을 선택합니까? 대체로 apple_count_other를 사용합니까?",
    "a_faq_examples_4": "예. 특정 형식(_one, _few 등)을 찾을 수 없는 경우 시스템은 _other 접미사가 있는 키를 대체로 사용하려고 시도합니다. 그것도 찾을 수 없으면 기본 키 apple_count에 대한 번역이 사용됩니다.",
    "q_faq_examples_5": " _(\"key\", new { username = \"Alex\" }) 함수는 익명 유형을 사용합니다. 이것이 Update() 메서드에서 자주 호출될 때 미리 생성된 Dictionary<string, object>를 전달하는 것과 비교하여 가비지 수집기(GC)에 과도한 \"부하\"를 생성하지 않습니까?",
    "a_faq_examples_5": "예, 그렇습니다. new { ... }를 호출할 때마다 관리되는 힙에 메모리가 할당되어 가비지 수집기에 추가 작업이 발생합니다. 매 프레임 업데이트되는 텍스트(Update 또는 LateUpdate에서)의 경우 Start()에서 한 번 Dictionary<string, object>를 만들고 _() 함수에 전달하기 전에 Update()에서 해당 값만 업데이트하는 것이 훨씬 더 효율적입니다.",
    "q_faq_notes_1": "문서에서는 LanguageSelector를 무시 목록에 추가하는 것을 권장합니다. 이 작업을 잊으면 정확히 무엇이 깨집니까? \"옵션 A, 옵션 B\"에 대한 추가 키가 생성됩니까?",
    "a_faq_notes_1": "예. LanguageSelector를 무시 목록에 추가하지 않으면 파서는 TMP_Dropdown을 일반 드롭다운으로 처리합니다. Unity가 만드는 기본 \"옵션 A, 옵션 B, 옵션 C\"를 찾아 번역 파일에 키를 추가합니다. LanguageSelector는 런타임에 이러한 옵션을 제거하고 자체 옵션을 생성하므로 불필요한 키로 파일이 복잡해집니다.",
    "q_faq_notes_2": "LanguageSelector가 사용하는 TMP_Dropdown 내의 레이블에 isStyleOnly 확인란이 활성화된 빈 LocalizedText를 추가하는 것을 잊으면 글꼴이 변경되지 않습니까? 이것이 왜 필요합니까?",
    "a_faq_notes_2": "예, 글꼴이 변경되지 않습니다. LanguageSelector가 label.text 속성을 직접 변경하기 때문에 필요합니다. 이 개체에 LocalizedText가 없으면 로컬라이제이션 시스템은 언어가 변경될 때 이 요소에 스타일(글꼴, RTL)을 적용해야 한다는 것을 알지 못합니다. isStyleOnly가 있는 빈 LocalizedText는 시스템에 대한 \"마커\" 역할을 하여 \"이 개체를 보고 스타일을 적용하되 텍스트는 건드리지 마십시오.\"라고 말합니다.",
    "q_faq_notes_3": "Update() 메서드에서 _()를 호출하는 것은 권장되지 않습니다. 하지만 매 프레임 텍스트를 업데이트해야 하는 경우(예: 타이머) 어떻게 합니까? 형식 문자열만 캐싱하여 가장 성능이 좋은 방법은 무엇입니까?",
    "a_faq_notes_3": "가장 성능이 좋은 접근 방식은 Start() 또는 [OnLanguageChange] 메서드에서 형식 문자열을 캐시하고 Update()에서 일반 string.Format을 사용하는 것입니다. 예: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } 이렇게 하면 매 프레임 딕셔너리에서 키를 조회하는 것을 피할 수 있어 훨씬 빠릅니다.",
    "q_faq_extending_1": "내 사용자 지정 파서는 모든 키 업데이트 후 자동으로 호출됩니까? 어딘가에 등록해야 합니까, 아니면 프로젝트에 ITextComponentParser를 구현하는 클래스가 있는 것만으로 충분합니까?",
    "a_faq_extending_1": "클래스가 있는 것만으로 충분합니다. TextParser가 실행되면 리플렉션을 사용하여 프로젝트에서 ITextComponentParser 인터페이스를 구현하는 모든 클래스를 찾아 각 GameObject에 대해 Parse() 메서드를 자동으로 호출합니다. 수동 등록은 필요하지 않습니다.",
    "q_faq_extending_2": "내 사용자 지정 파서에서 예외가 발생하면 어떻게 됩니까? 전체 파싱 프로세스를 중단합니까, 아니면 도구가 다른 파서로 안전하게 계속됩니까?",
    "a_faq_extending_2": "사용자 지정 파서에서 예외가 발생하면 전체 파싱 프로세스가 중단됩니다. 주 파싱 루프는 사용자 지정 파서 호출을 try-catch 블록으로 감싸지 않습니다. 만약 Parse() 메서드에서 처리되지 않은 예외가 발생하면,",
    "toggle_notes_title": "노트 토글",
    "mindmap_toggle_title": "마인드맵 보기",
    "on_this_page_title": "이 페이지의 내용",
    "my_notes_title": "내 노트",
    "no_notes_message_new": "텍스트 위로 마우스를 가져가 노트를 추가하세요.",
    "notes_add_title": "이 블록에 노트 추가",
    "notes_placeholder": "노트 내용...",
    "notes_close_title": "닫기",
    "notes_goto_title": "텍스트로 이동",
    "notes_edit_title": "노트 편집",
    "notes_delete_title": "노트 삭제",
    "notes_edit_text": "편집",
    "copy_code_copy": "복사",
    "copy_code_copied": "복사됨!",
    "copy_code_error": "오류",
    "error_loading_title": "로딩 오류",
    "error_loading_message": "연결을 확인하고 새로고침하세요.",
    "lightbox_aria_close": "이미지 뷰어 닫기",
    "lightbox_image_alt": "확대된 이미지",
    "mindmap_preset_full": "전체 보기",
    "mindmap_preset_quick_start": "빠른 시작",
    "mindmap_preset_dev": "개발자 워크플로우",
    "mindmap_preset_translator": "번역가 워크플로우",
    "mindmap_edge_configure": "1. 구성",
    "mindmap_edge_specify_content": "2. 콘텐츠 지정",
    "mindmap_edge_parse_project": "3. 프로젝트 파싱",
    "mindmap_edge_creates_components": "컴포넌트 생성",
    "mindmap_edge_generates": "생성",
    "mindmap_edge_opens": "열기",
    "mindmap_edge_manages_assets": "에셋 관리",
    "mindmap_edge_defines_rules": "규칙 정의",
    "mindmap_edge_reports_on": "보고",
    "mindmap_edge_enables_reaction": "...를 통해 반응 활성화",
    "mindmap_edge_processed_by": "처리기",
    "mindmap_edge_edited_in": "편집 도구",
    "mindmap_edge_extends": "확장",
    "mindmap_edge_warns_about": "경고",
    "mindmap_edge_relates_to": "관련",
    "mindmap_edge_recommends_for": "권장",
    "mindmap_edge_see_faq": "FAQ 보기"
}