{
  "a_faq_addressables_1": "Upewnij się, że pakiet Addressables jest zainstalowany, ustawienia są utworzone i kliknąłeś „Scan Assets & Generate Tables”, aby zarejestrować klucze w grupach.",
  "a_faq_addressables_2": "Utwórz <code>Translation Profile</code> w folderze zasobów, wybierz typ usługi, wprowadź klucz API i przypisz ten profil w oknie <code>Settings</code>.",
  "a_faq_addressables_3": "W oknie migracji (zakładki Komponenty / Import) znajduje się przycisk \"Włącz Stubs\", który aktywuje funkcję awaryjnych stubów. Tworzy on fałszywe klasy zastępcze dla I2 Localization lub Unity Localization, dzięki czemu projekt może zostać skompilowany natychmiast po usunięciu tych wtyczek. Funkcja działa poprzez przełączanie symbolu definicji ANKO_ENABLE_MIGRATION_STUBS. Zapobiega to błędom \"Nazwa typu 'Localize' nie została znaleziona\" i daje czas na odpowiednie refaktoryzowanie kodu do użycia nowego systemu. Włączenie stubów pozwala naprawić błędy kompilacji po usunięciu starej wtyczki do lokalizacji. W wersji 2.0 system migracji został rozszerzony o <strong>Profile Migracji</strong>, co pozwala na bardziej niezawodne reguły przejścia z innych wtyczek.",
  "a_faq_audio_smart_update": "Narzędzie używa inteligentnego grupowania z hashowaniem MD5, aby regenerować pliki audio tylko wtedy, gdy tekst źródłowy uległ zmianie. Oblicza hash MD5 Twojej zawartości tekstowej i porównuje go z wcześniej wygenerowanymi plikami audio. Jeśli tekst się nie zmienił, pomija regenerację, oszczędzając Twoje kredyty API. Zapobiega to niepotrzebnym wywołaniom API i redukuje koszty przy regenerowaniu audio. Narzędzie hashuje Twój tekst i regeneruje pliki audio tylko, jeśli tekst źródłowy uległ zmianie, oszczędzając Twoje kredyty API.",
  "a_faq_components_1": "Nie, nie zostanie. Wyłączenie MonoBehaviour zapobiega wywołaniu wszystkich „magicznych” metod Unity, włączając Awake(), OnEnable() i Start(). Jest to celowe, aby uniknąć duplikacji wykonania logiki. Cała inicjalizacja powinna odbywać się w skryptach na zlokalizowanych wersjach prefabu.",
  "a_faq_components_2": "Tak, zachowanie fizyczne oryginalnego obiektu zostanie zneutralizowane. Komponent LocalizedPrefab znajduje wszystkie komponenty Rigidbody i Rigidbody2D na swoim GameObject i ustawia ich właściwość isKinematic na true. Skutecznie usuwa to je z dynamicznych obliczeń fizycznych, zapobiegając niepożądanemu zachowaniu, takiemu jak niewidoczny obiekt spadający lub reagujący na kolizje. Nadal zaleca się, aby zlokalizowana wersja prefabu zawierała wszystkie niezbędne komponenty fizyczne dla poprawnego zachowania.",
  "a_faq_components_3": "Tak, tak będzie. Komponent przechowuje pełną nazwę typu, włącznie z przestrzenią nazw i zestawem. Zmiana nazwy skryptu lub przeniesienie go do innego .asmdef spowoduje zmianę tej nazwy, a LocalizedAsset nie będzie w stanie znaleźć docelowego komponentu. Będziesz musiał uruchomić kolejną analizę za pomocą Analyze Project & Attach Components, aby zaktualizować nazwę.",
  "a_faq_components_4": "LocalizedAsset jest tworzony dla konkretnej instancji komponentu. Przechowuje odniesienie do tego komponentu w kodzie. Jeśli ręcznie dodasz drugi LocalizedAsset i użyjesz menu kontekstowego „Analyze for Localization”, aby wycelować w drugi Image, będziesz miał dwa komponenty LocalizedAsset, z których każdy zarządza swoim własnym Image. Automatyczny analizator utworzy komponent tylko dla pierwszego Image z lokalizowalnym zasobem, który znajdzie.",
  "a_faq_components_5": "Tak, zdąży. LocalizedPrefab tworzy instancję zlokalizowanego prefabu w swojej metodzie OnEnable(). Kolejność wykonania Unity gwarantuje, że wszystkie metody Awake() są wykonywane przed wszystkimi metodami OnEnable(). W ten sposób Twój skrypt z kolejnością -110 wykona swoje Awake(), następnie LocalizedPrefab z kolejnością -100 wykona swoje Awake(), a dopiero potem zostaną wywołane ich metody OnEnable() w kolejności. Twój skrypt nie znajdzie obiektu, ponieważ nie zostanie on jeszcze utworzony.",
  "a_faq_components_6": "Zmieni się zarówno klucz, jak i tekst. Programowe wywołanie SetFormattedText nadpisuje zachowanie isStyleOnly dla tej konkretnej aktualizacji. Opcja isStyleOnly ma na celu zapobieganie reagowaniu komponentu na globalne zmiany języka, ale zawsze zareaguje na bezpośrednią zmianę klucza poprzez kod.",
  "a_faq_components_7": "Znajdzie metody z dowolnym modyfikatorem dostępu (public, private, protected, internal). Refleksja w Unity pozwala na wykrycie wszystkich metod instancji niezależnie od ich poziomu dostępu.",
  "a_faq_components_8": "Możliwe jest użycie starego (niezlokalizowanego) zasobu. LocalizedAsset wykonuje zamianę w swoim OnEnable(). Metody Awake() wszystkich skryptów są wykonywane przed OnEnable(). Jeśli Twój skrypt uzyskuje dostęp do audioSource.clip w Awake(), otrzyma oryginalny klip. Jeśli uzyskuje do niego dostęp w Start(), wynik będzie zależał od kolejności wykonania skryptu. Aby zagwarantować dostęp do zlokalizowanego zasobu, ustaw późniejszą kolejność wykonania dla swojego skryptu lub uzyskaj dostęp do zasobu w metodzie oznaczonej [OnLanguageChange].",
  "a_faq_custom_keys_attribute": "Tak. W <strong>Zakładce Zawartość</strong> w sekcji 'Atrybuty do Skanowania' możesz dodać dowolną nazwę atrybutu (np. <code>[Header]</code>, <code>[TermsPopup]</code>). Parser potraktuje każde pole typu string z tym atrybutem jako lokalizowalne.",
  "a_faq_custom_provider_1": "Upewnij się, że Twoja klasa implementuje `IAssetProvider`, NIE jest abstrakcyjna i jest oznaczona atrybutem `[AssetProviderPlugin]`. Sprawdź również konsolę pod kątem błędów związanych z refleksją podczas uruchamiania, ponieważ narzędzie skanuje wszystkie zestawy w poszukiwaniu dostawców.",
  "a_faq_editor_1": "Dyrektywa @placeholders: w komentarzu ma priorytet. Jest uważana za wyraźną instrukcję od dewelopera i „źródło prawdy”. W Twoim przykładzie edytor będzie wymagał {username} w tłumaczeniu i zignoruje {name} z tekstu źródłowego.",
  "a_faq_editor_2": "Zostanie po prostu zignorowana. Narzędzie szuka dokładnego dopasowania @placeholders:. Jeśli dyrektywa jest źle napisana, zostanie potraktowana jako część zwykłego komentarza, a walidacja będzie działać po staremu – w oparciu o placeholdery z tekstu źródłowego.",
  "a_faq_editor_3": "Tak. Po pomyślnym ręcznym zapisie lub normalnym zamknięciu okna (gdy zapisujesz zmiany), wszystkie pliki automatycznego zapisywania są usuwane, aby uniknąć monitowania o odzyskanie przy następnym uruchomieniu. Pozostają tylko w przypadku awarii edytora.",
  "a_faq_editor_4": "Tak. Szerokości kolumn są zapisywane do EditorPrefs za każdym razem, gdy zamykasz okno edytora tłumaczeń i zostaną przywrócone przy następnym otwarciu.",
  "a_faq_editor_5": "Tak. MultiLineEditWindow ma własny tymczasowy stos Cofnij/Ponów, który działa, gdy okno jest otwarte. Pozwala to na cofanie i ponawianie zmian tekstu w tym oknie. Gdy zapiszesz wynik (poprzez zamknięcie okna), ta zmiana jest rejestrowana jako pojedyncza akcja w globalnym stosie Cofnij/Ponów głównego edytora.",
  "a_faq_examples_1": "Nie wystąpi błąd. Placeholder {username} po prostu nie zostanie zastąpiony, a otrzymasz ciąg \"Hello, {username}\" jako wynik. Zastąpienie następuje tylko przy dokładnym dopasowaniu nazwy.",
  "a_faq_examples_2": "Tak, będzie. Parser używa refleksji, aby znaleźć pola z flagami BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, więc znajdzie i przetworzy pola statyczne.",
  "a_faq_examples_3": "Nie wystąpi błąd kompilacji, ale w konsoli Unity w runtime pojawi się ostrzeżenie od LocalizedBehaviour. Zgłosi, że znalazło metodę z atrybutem, ale ją zignorowało, ponieważ metoda ma parametry. Taka metoda nie zostanie wywołana.",
  "a_faq_examples_4": "Tak. Jeśli nie zostanie znaleziona konkretna forma (_one, _few, itp.), system spróbuje użyć klucza z sufiksem _other jako awaryjnego. Jeśli ten również nie zostanie znaleziony, zostanie użyte tłumaczenie dla klucza bazowego apple_count.",
  "a_faq_examples_5": "Tak, spowoduje. Każde wywołanie new { ... } alokuje pamięć na zarządzanym stosie, co tworzy dodatkową pracę dla garbage collector'a. Dla tekstu, który jest aktualizowany w każdej klatce (w Update lub LateUpdate), znacznie bardziej wydajne jest utworzenie Dictionary<string, object> raz w Start() i aktualizowanie tylko jego wartości w Update() przed przekazaniem go do funkcji _().",
  "a_faq_examples_6": "Sprawdź, czy Twoja metoda ma parametry. Atrybut <code>[OnLanguageChange]</code> działa tylko na metodach <strong>bez parametrów</strong> (np. <code>void UpdateUI()</code>). Jeśli Twoja metoda wymaga argumentów, zawrzyj ją w metodzie bez parametrów.",
  "a_faq_extending_1": "Wystarczy mieć klasę. Gdy TextParser działa, używa refleksji, aby znaleźć wszystkie klasy w projekcie, które implementują interfejs ITextComponentParser i automatycznie wywołuje ich metodę Parse() dla każdego GameObject. Nie jest wymagana ręczna rejestracja.",
  "a_faq_extending_2": "Wyjątek w Twoim niestandardowym parserze przerwie proces. Główna pętla parsowania nie zawija wywołań do niestandardowych parserów w blok try-catch. Jeśli Twoja metoda Parse() zgłosi nieobsługiwany wyjątek,",
  "a_faq_installation_1": "Instalator sprawdza istnienie typu Newtonsoft.Json.JsonConvert. Jeśli typ istnieje, uważa zależność za spełnioną i nie będzie próbował instalować ani aktualizować pakietu. Ma to na celu zapobieganie konfliktom wersji.",
  "a_faq_installation_2": "Możesz ręcznie wywołać sprawdzenie zależności w dowolnym momencie poprzez menu Tools -> Localization -> Check Dependencies. Spowoduje to zresetowanie flagi „Nie pytaj ponownie” i ponowne wyświetlenie okna ze wszystkimi brakującymi opcjonalnymi pakietami.",
  "a_faq_installation_3": "Może się tak zdarzyć, jeśli nie masz folderu Assets/Resources. Narzędzie spróbuje go utworzyć, ale mogą to uniemożliwić uprawnienia systemu plików. Tak, możesz ręcznie utworzyć zasób: kliknij prawym przyciskiem myszy w folderze Resources, wybierz Create -> Localization -> Settings. Narzędzie znajdzie go automatycznie.",
  "a_faq_installation_4": "Tak. Narzędzie używa Resources.Load(), które szuka zasobu po nazwie we wszystkich folderach o nazwie Resources w Twoim projekcie. Ważne jest, aby plik zachował swoją nazwę LocalizationSettings.asset.",
  "a_faq_installation_5": "Tak. Możesz otworzyć Window -> Package Manager, kliknąć ikonę „+” i wybrać „Add package by name...”. Wprowadź nazwy pakietów: com.unity.nuget.newtonsoft-json i com.unity.editorcoroutines.",
  "a_faq_notes_1": "Tak. Jeśli nie dodasz LanguageSelector do listy ignorowania, parser potraktuje jego TMP_Dropdown jako zwykły dropdown. Znajdzie domyślne „Option A, Option B, Option C”, które Unity tworzy, i doda dla nich klucze do Twoich plików tłumaczeń. To zaśmieci Twoje pliki niepotrzebnymi kluczami, ponieważ LanguageSelector i tak usunie te opcje w runtime i utworzy własne.",
  "a_faq_notes_2": "Tak, czcionka się nie zmieni. Jest to konieczne, ponieważ LanguageSelector bezpośrednio zmienia właściwość label.text. Bez LocalizedText na tym obiekcie, system lokalizacji nie wie, że ten element wymaga zastosowania stylów (czcionka, RTL) przy zmianie języka. Pusty LocalizedText z isStyleOnly służy jako „marker” dla systemu, mówiąc: „Obserwuj ten obiekt i stosuj do niego style, ale nie ruszaj jego tekstu”.",
  "a_faq_notes_3": "Najbardziej wydajnym podejściem jest buforowanie ciągu formatującego w Start() lub w metodzie [OnLanguageChange], a następnie używanie regularnego string.Format w Update(). Przykład: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } To pozwala uniknąć wyszukiwania klucza w słowniku w każdej klatce, co jest znacznie szybsze.",
  "a_faq_runtime_api_key_distinction": "<strong>P: Jaka jest różnica między 'Translation Service Keys' a 'Runtime API Key'?</strong><br>O: <strong>Translation Service Keys</strong> (OpenAI, DeepL) są używane w <strong>Unity Editor</strong> do generowania tłumaczeń. Są przechowywane w rejestrze Twojego komputera (EditorPrefs) i NIE są dołączane do kompilacji.<br><strong>Runtime API Key</strong> jest używany przez <strong>kompilację gry</strong> do pobierania aktualizacji na żywo. JEST on dołączony do kompilacji (zaszyfrowany).",
  "a_faq_tts_voices": "W swoim <strong>Profilu Tłumaczeń</strong> (Inspektor), użyj listy 'Voice Mappings'. Możesz zmapować wzorzec Regex (np. <code>^hero_.*</code>) do określonego ID Głosu. Generator automatycznie wybierze prawidłowy głos na podstawie nazwy klucza.",
  "a_faq_window_actions_1": "Narzędzie spróbuje ponownie wysłać dokładnie tę partię, która się nie powiodła, zgodnie z ustawieniami Polityki Ponawiania (liczba prób i opóźnienie). Jeśli wszystkie próby dla tej partii się nie powiodą, proces tłumaczenia dla bieżącego języka zostanie przerwany, a do konsoli zostanie zalogowany błąd. Tłumaczenie dla następnych języków w kolejce nie rozpocznie się.",
  "a_faq_window_actions_2": "Puste wartości zastąpią istniejące tłumaczenia. Proces importu traktuje plik CSV jako „źródło prawdy”. Jeśli wartość dla klucza welcome_message w kolumnie ru jest pusta, obecne rosyjskie tłumaczenie dla tego klucza zostanie nadpisane.",
  "a_faq_window_actions_3": "Tak, usunie. Funkcje w „Strefie Zagrożenia” skanują wszystkie prefabrykaty w projekcie (AssetDatabase.FindAssets(\"t:Prefab\")), a nie tylko te określone na liście parsowania, aby zapewnić jak najpełniejsze czyszczenie.",
  "a_faq_window_actions_4": "W Twoim dokumencie Google Sheets, kolumna musi być zatytułowana „Developer Notes”. W komórkach tej kolumny możesz pisać komentarze jak zwykle. Aby określić placeholdery, po prostu dodaj linię, taką jak @placeholders: {username}, {score} w tekście komentarza. Narzędzie automatycznie rozpozna tę dyrektywę podczas importu.",
  "a_faq_window_actions_5": "Narzędzie działa tylko z jednym arkuszem naraz. Adres URL importu zawiera parametr gid=..., który jednoznacznie identyfikuje konkretny arkusz w dokumencie. Aby zaimportować dane z innego arkusza, musisz skopiować jego adres URL (z innym gid) i ponownie wykonać import.",
  "a_faq_window_assets_1": "Skaner zasobów ładuje je, określając oczekiwany typ (AssetDatabase.LoadAssetAtPath(path, expectedType)). Dla kategorii AudioClip będzie szukał i ładował tylko pliki, które Unity rozpoznaje jako AudioClips. Jeśli oba pliki są prawidłowymi klipami audio, ten, który zostanie przetworzony jako ostatni, zostanie uwzględniony w tabeli, skutecznie nadpisując poprzedni. Zaleca się unikanie takich duplikatów.",
  "a_faq_window_assets_2": "Tak, dokładnie tak to działa. „Analyze Project” znajduje komponent Image, patrzy na nazwę przypisanego do niego sprite'a (np. icon_play_en), wyodrębnia z niej klucz (icon_play) i język (en), a następnie dodaje komponent LocalizedAsset do tego GameObject i zapisuje w nim klucz icon_play.",
  "a_faq_window_assets_3": "Tak, możesz. Nie będzie konfliktów, ponieważ dla każdej kategorii tworzona jest oddzielna tabela zasobów (LocalizedAssetTable). Klucze z kategorii „Sprites” nie nakładają się na klucze z kategorii „AudioClips”, nawet jeśli są nazwane tak samo.",
  "a_faq_window_assets_4": "Tak, znajdzie. Skaner używa opcji SearchOption.AllDirectories, co oznacza, że rekurencyjnie sprawdzi wszystkie podfoldery w określonym Folderze Skanowania.",
  "a_faq_window_content_1": "Nie, nie wpłynie. Lista Scen do Parsowania jest używana wyłącznie po to, aby narzędzie wiedziało, które sceny ma otworzyć i analizować pod kątem tekstu. W żaden sposób nie jest powiązana ze scenami, które znajdą się w finalnym buildzie Twojej gry.",
  "a_faq_window_content_2": "Nie, nie zostanie. Lista tymczasowa przechowuje bezpośrednie odniesienie do obiektu w scenie. Kiedy tworzysz prefab, jest to nowy zasób. Jego instancje są innymi obiektami, a reguła ignorowania nie będzie ich dotyczyć. Aby trwale ignorować prefaby, muszą one zostać dodane do listy ignorowania jako zasób prefabu.",
  "a_faq_window_content_3": "Tak, zostanie. Po kliknięciu Update Keys, parser ponownie skanuje cały projekt. Zobaczy, że typ TMPro.TMP_Text powinien zostać zignorowany i nie wygeneruje dla niego klucza. Podczas procesu porównywania starych i nowych kluczy, ustali, że stary klucz nie jest już używany i oznaczy go jako „Removed”.",
  "a_faq_window_content_4": "Nie, nie będzie. „Przypnij” zapisuje bezwzględną ścieżkę w hierarchii sceny w momencie kliknięcia przycisku (np. Canvas/Panel/Button). Ta ścieżka nie jest związana z logiką prefabu. Instancje prefabu będą miały tę samą ścieżkę, ale jeśli zmienisz nazwę obiektu nadrzędnego w scenie, „Przypnij” przestanie działać zarówno dla oryginału, jak i instancji.",
  "a_faq_window_content_5": "Zostanie zapisana pełna ścieżka od korzenia sceny. Na przykład, MyPrefab(Clone)/Content/Icon. Ta „przypięta” ścieżka będzie działać tylko w scenie, w której ją utworzyłeś. W innych scenach znalezienie takiej ścieżki jest mało prawdopodobne.",
  "a_faq_window_preview_1": "Nie, nie zostanie on zapisany. PreviewSafetyBridge przechwytuje zdarzenie zapisu zasobów (OnWillSaveAssets) i automatycznie wywołuje RevertEditorPreview() zanim Unity zapisze zmiany na dysku. W ten sposób Prefab zostanie zapisany w swoim oryginalnym, niezlokalizowanym stanie.",
  "a_faq_window_preview_2": "PreviewRecoveryService obsługuje odzyskiwanie po awarii. Jeśli Unity ulegnie awarii, usługa wykrywa plik kopii zapasowej przy następnym uruchomieniu i próbuje przywrócić stan sceny. Jeśli automatyczne odzyskiwanie się nie powiedzie, może być konieczne ręczne wybranie opcji \"Przywróć do oryginału\" w oknie narzędzia.",
  "a_faq_window_preview_3": "Tak, zostaną. PrefabUtility.InstantiatePrefab w Edit Mode wywołuje Awake() i OnEnable(). Jeśli te metody zawierają logikę, która nie powinna działać w edytorze (np. dostęp do singletonów, które istnieją tylko w Play Mode), może to powodować błędy. Zaleca się użycie if (Application.isPlaying) lub #if UNITY_EDITOR, aby zabezpieczyć taki kod.",
  "a_faq_window_report_1": "Tak, zostanie przerwane. Każda nowa akcja, która wymaga blokowania interfejsu użytkownika (jak Update Keys), zatrzyma bieżącą coroutine wyszukiwania. Pojawi się okno dialogowe, które poprosi Cię o zatrzymanie bieżącego wyszukiwania, aby rozpocząć nowe.",
  "a_faq_window_report_2": "Kategoria „Duplicates” pokaże wszystkie źródła dla tego klucza. Zobaczysz jeden wpis dla klucza, a pole „Source” wyświetli listę wszystkich ścieżek (w scenie 1 i scenie 2). Przycisk „Find” w tym przypadku otworzy rozwijaną listę, umożliwiając wybór obiektu, do którego należy nawigować.",
  "a_faq_window_report_3": "Tak. System wyszukiwania jest specjalnie przeszkolony do rozpoznawania źródeł, takich jak skrypt MyScript.cs. Po kliknięciu „Find”, wyszuka zasób MyScript.cs w projekcie i podświetli go (ping) w oknie Project.",
  "a_faq_window_settings_1": "Tak, zostaną. Przy zmianie trybu, narzędzie wykonuje „bezpieczną migrację”: ponownie parsuje cały projekt, tworzy nowe klucze zgodnie z nowymi regułami, ale mapuje stare i nowe klucze poprzez oryginalny tekst. Następnie przenosi wszystkie Twoje istniejące tłumaczenia i komentarze ze starych kluczy do nowych. Twoje tłumaczenia nie zostaną utracone.",
  "a_faq_window_settings_2": "Zostanie użyta DefaultPluralRule, która jest odpowiednia dla angielskiego i większości języków europejskich (formy dla „one” i „other”).",
  "a_faq_window_settings_3": "Nie, nie zostaną. Tylko zasoby znajdujące się w folderze StreamingAssets lub Resources są gwarantowane do uwzględnienia w buildzie. Jeśli określisz inną ścieżkę, lokalizacja będzie działać w edytorze, ale nie będzie działać w skompilowanej grze, ponieważ pliki tłumaczeń nie będą częścią builda.",
  "a_faq_window_settings_4": "Tak. EditorPrefs to lokalna pamięć masowa dla każdego komputera. Będziesz musiał wprowadzić <strong>Klucz API Usługi Tłumaczeń</strong> (do użytku w Edytorze, np. OpenAI/DeepL) na każdej maszynie. Jednakże <strong>Klucz API Środowiska Uruchomieniowego</strong> (używany w kompilacjach) jest przechowywany w ustawieniach projektu i udostępniany poprzez kontrolę wersji (zaszyfrowany).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "Skopiowano!",
  "copy_code_copy": "Kopiuj",
  "copy_code_error": "Błąd",
  "error_loading_message": "Sprawdź połączenie i odśwież.",
  "error_loading_title": "Błąd Ładowania",
  "h1_ai_audio": "AI Audio / Text-to-Speech",
  "h1_ai_profiles": "Profile AI i Tłumaczeń",
  "h1_api_snippets": "API i fragmenty kodu",
  "h1_components": "Kluczowe Komponenty (przypisywane automatycznie)",
  "h1_extending": "Rozszerzanie Funkcjonalności",
  "h1_faq": "FAQ i Rozwiązywanie Problemów",
  "h1_font_glyph_manager": "Menedżer Czcionek i Glifów",
  "h1_important_notes": "Ważne Uwagi i Ostrzeżenia",
  "h1_introduction": "Wprowadzenie",
  "h1_loc_tool_window": "Okno „Narzędzie Lokalizacji”",
  "h1_migration_tool": "Narzędzie Migracji",
  "h1_quick_start": "Szybki Start i Konfiguracja",
  "h1_tms": "Zewnętrzna integracja TMS (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Edytor Tabeli Tłumaczeń",
  "h1_usage_examples": "Przykłady Użycia",
  "h2_ai_assistant": "Polecenia asystenta AI",
  "h2_ai_audio_setup": "Konfiguracja",
  "h2_ai_audio_usage": "Użycie",
  "h2_ai_context": "Kontekst i słownik",
  "h2_ai_profiles_overview": "Profile tłumaczeń",
  "h2_async_api": "Asynchroniczne API (Addressables)",
  "h2_backup_manager": "Menedżer Kopii Zapasowych",
  "h2_bridge_generation": "Generuj mosty C# (dostęp silnie typowany)",
  "h2_custom_ai": "Niestandardowa AI i modele",
  "h2_custom_asset_provider": "Tworzenie Niestandardowego Dostawcy Zasobów",
  "h2_custom_attributes": "Skanowanie atrybutów niestandardowych",
  "h2_custom_parser": "Tworzenie niestandardowego parsera",
  "h2_example_attribute": "[LocalizableField] Atrybut",
  "h2_example_components": "Gotowe komponenty i przykłady",
  "h2_example_components_updated": "Zaktualizowany LanguageSelector.cs",
  "h2_example_function": "_() Funkcja i [OnLanguageChange] Atrybut",
  "h2_example_plurals": "Liczby mnogie i rodzaj",
  "h2_faq_addressables": "Addressables i Migracja",
  "h2_faq_audio": "AI Audio / Text-to-Speech",
  "h2_faq_components": "Podstawowe komponenty",
  "h2_faq_editor": "Edytor tłumaczeń",
  "h2_faq_examples": "Przykłady użycia i kod",
  "h2_faq_extending": "Rozszerzanie funkcjonalności",
  "h2_faq_installation": "Instalacja i szybki start",
  "h2_faq_notes": "Ważne niuanse i ostrzeżenia",
  "h2_faq_window": "Okno \"Localization Tool\"",
  "h2_font_glyph_manager_features": "Funkcje",
  "h2_in_editor_preview": "Podgląd w edytorze i Prefab",
  "h2_initial_setup": "Początkowa konfiguracja",
  "h2_installation": "Instalacja",
  "h2_key_features": "Kluczowe Funkcje",
  "h2_live_updates_guide": "Przewodnik po Aktualizacjach na Żywo",
  "h2_localizedasset": "LocalizedAsset",
  "h2_localizedasset_updated": "Asynchroniczne Ładowanie LocalizedAsset",
  "h2_localizedbehaviour": "LocalizedBehaviour",
  "h2_localizeddropdown": "LocalizedDropdown",
  "h2_localizedprefab": "LocalizedPrefab",
  "h2_localizedtext": "LocalizedText",
  "h2_migration_custom": "Tworzenie Niestandardowych Profili",
  "h2_migration_google_sheets": "Klucz Google Sheets",
  "h2_migration_import_formats": "Formaty Importu (CSV i Google Sheets)",
  "h2_migration_stubs": "Bezpieczna Migracja i Awaryjne Stubs",
  "h2_migration_tool_features": "Funkcje",
  "h2_migration_workflow": "Przewodnik po Procesie Migracji",
  "h2_preview_overlay": "Nakładka Widoku Sceny",
  "h2_safety_caps": "Limity i Kwoty Bezpieczeństwa",
  "h2_script_parsing_rules": "Reguły parsowania skryptów (kompatybilność)",
  "h2_tab_actions": "Zakładka \"Akcje\"",
  "h2_tab_assets": "Zakładka \"Zasoby\"",
  "h2_tab_content": "Zakładka \"Zawartość\"",
  "h2_tab_report": "Zakładka \"Raport\"",
  "h2_tab_settings": "Zakładka \"Ustawienia\"",
  "h2_tab_tutorials": "\"Tutorials\" zakładka",
  "h2_tms_setup": "Konfiguracja i użycie",
  "h2_tms_supported": "Obsługiwane usługi",
  "h2_uitklocalization": "UITKLocalization",
  "h2_visual_debugging_guide": "Wizualne Debugowanie",
  "h2_window_footer": "Stopka okna (pasek statusu)",
  "h2_window_header": "Nagłówek okna i pasek narzędzi",
  "h2_window_sidebar": "Menu główne (pasek boczny)",
  "h3_actions_autotranslate": "Automatyczne tłumaczenie",
  "h3_actions_danger": "Strefa niebezpieczeństwa",
  "h3_actions_data": "Zarządzanie danymi",
  "h3_actions_editor": "Edytor tłumaczeń",
  "h3_actions_parsing": "Parsowanie",
  "h3_actions_tms_integration": "Usługi zewnętrzne (TMS)",
  "h3_assets_automation": "Automatyzacja",
  "h3_assets_categories": "Kategorie zasobów",
  "h3_assets_folder_gen": "Generowanie folderów",
  "h3_assets_loading": "Strategia ładowania",
  "h3_assets_storage": "Konfiguracja przechowywania",
  "h3_attribute_cheat_sheet": "Szybki przewodnik: Co robić, a czego nie",
  "h3_attribute_features": "Obsługiwane typy i funkcje",
  "h3_attribute_limitations": "Ograniczenia",
  "h3_content_components_ignore": "Typy komponentów do pominięcia",
  "h3_content_dynamic_keys": "Prefiksy kluczy dynamicznych",
  "h3_content_dynamic_texts": "Dynamiczne teksty",
  "h3_content_objects_ignore": "Obiekty do pominięcia",
  "h3_content_prefabs": "Foldery Prefab",
  "h3_content_regex": "Ignorowane wzorce regex",
  "h3_content_scenes": "Sceny do parsowania",
  "h3_content_script_rules": "Reguły parsowania skryptów",
  "h3_content_scripts_ignore": "Skrypty do pominięcia",
  "h3_custom_provider_steps": "Kroki Implementacji",
  "h3_faq_window_actions": "Zakładka „Akcje”",
  "h3_faq_window_assets": "Zakładka „Zasoby”",
  "h3_faq_window_content": "Zakładka „Zawartość”",
  "h3_faq_window_preview": "Podgląd w Edytorze",
  "h3_faq_window_report": "Zakładka „Raport”",
  "h3_faq_window_settings": "Zakładka „Ustawienia”",
  "h3_mode_auto": "AutoGenerateKeysOnly (Standardowy)",
  "h3_mode_hybrid": "Tryby hybrydowe (niestandardowy priorytet)",
  "h3_mode_text": "UseTextAsKey (Uproszczony)",
  "h3_report_all_keys": "Wszystkie klucze",
  "h3_settings_debugging": "Debugowanie",
  "h3_settings_general": "Ustawienia ogólne",
  "h3_settings_keygen": "Generowanie kluczy",
  "h3_settings_languages": "Zarządzanie językami",
  "h3_settings_liveupdates": "Aktualizacje na żywo",
  "h3_settings_pseudo": "Ustawienia pseudo-lokalizacji",
  "h3_settings_runtimeapi": "Runtime API",
  "h3_settings_tools": "Narzędzia ogólne i deweloperskie",
  "h3_tutorials_list": "Lista tutoriali",
  "lbl_not_supported": "NIEobsługiwane",
  "lbl_supported": "W pełni obsługiwane",
  "li_actions_1": "<strong>Parsowanie:</strong><ul><li><strong>Update Keys:</strong> Pełne skanowanie projektu zdefiniowane przez ustawienia zakładki 'Zawartość'.</li><li><strong>Scan Selected Assets:</strong> Skanuje TYLKO pliki/foldery aktualnie wybrane w Project View. Bezpieczniejsze dla częściowych aktualizacji, ponieważ automatycznie wyłącza 'Remove Missing Keys'.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Otwiera osobne, wygodniejsze okno do edycji wszystkich tłumaczeń.",
  "li_actions_3": "<strong>Zarządzanie Danymi:</strong> Służy do wymiany danych z tłumaczami (Eksport/Import do CSV/XML/YAML/XLIFF, import z Google Sheets). <strong>Google Sheets:</strong> Obsługuje zarówno linki 'Edit', jak i URL 'Publish to Web' (sprawdź parametr GID).",
  "li_actions_4": "<strong>Auto-Tłumaczenie:</strong> Automatycznie wypełnia wszystkie puste ciągi tłumaczeń, używając aktywnego <strong>Profilu Tłumaczeń</strong>.",
  "li_actions_5": "<strong>Strefa Zagrożenia:</strong> Zawiera przyciski do całkowitego usunięcia wszystkich komponentów lokalizacyjnych z projektu. Używaj ostrożnie!",
  "li_ai_1": "<strong>Utwórz Profil:</strong> Prawy przycisk myszy w widoku Project -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Usługi:</strong> Obsługuje DeepL, Google Translate, Microsoft Azure i <strong>Własne AI</strong>.",
  "li_ai_3": "<strong>Ustawienia:</strong> Każdy profil przechowuje własny Klucz API, limity (rozmiar partii, maksymalna liczba znaków) i ustawienia modelu.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Użyj wbudowanego generatora, aby szybko utworzyć profile dla popularnych usług (OpenAI, Gemini, Claude, Ollama).",
  "li_ai_audio_generate": "W <strong>Translation Table Editor</strong>, wybierz wiersze/komórki -> Prawy przycisk myszy -> <strong>Generate Audio</strong>.",
  "li_ai_audio_hash": "<strong>Inteligentna Aktualizacja i Hashowanie:</strong> Narzędzie oblicza hash MD5 Twojego tekstu i regeneruje pliki audio tylko, jeśli tekst źródłowy uległ zmianie, oszczędzając Twoje kredyty API. Wykrywa, czy tłumaczenie zmieniło się od ostatniego generowania audio. Edytor podświetla te wiersze ikoną 'Przestarzały' (żółtą), umożliwiając zaktualizowanie TYLKO zmienionych linii. Ta funkcja inteligentnego grupowania zapobiega niepotrzebnym wywołaniom API i redukuje koszty przy regenerowaniu audio. Narzędzie hashuje Twój tekst i regeneruje pliki audio tylko, jeśli tekst źródłowy uległ zmianie, oszczędzając Twoje kredyty API.",
  "li_ai_audio_profile": "W <strong>Ustawieniach</strong>, wybierz <strong>Aktywny Profil Audio</strong> (np. OpenAI TTS lub ElevenLabs).",
  "li_ai_audio_save": "Pliki są zapisywane do folderu określonego w profilu.",
  "li_ai_audio_voice_mapping": "<strong>Mapowanie głosu (wielogłośnik):</strong> Automatycznie przypisuj różne głosy AI do różnych postaci. Użyj listy <strong>Voice Mappings</strong>, aby powiązać wzorce Regex (np. <code>^hero_.*</code>) z konkretnymi identyfikatorami głosów. Narzędzie automatycznie wybierze właściwy głos na podstawie nazwy klucza podczas generowania dźwięku.",
  "li_ai_provider_settings": "<strong>Ustawienia Dostawcy:</strong> Każda usługa pozwala na konfigurację Kluczy API, Modeli (np. GPT-4o, Sonnet) oraz parametrów specyficznych dla głosu (Stabilność, Podobieństwo).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Użyj tego do asynchronicznego ładowania zasobów Addressables. Zwraca <code>Task&lt;T&gt;</code>.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) zwraca tłumaczenie specyficzne dla płci.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> zwraca prawidłową formę liczby mnogiej w oparciu o reguły specyficzne dla języka.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> Korutyna (<code>IEnumerator</code>) do zmiany języka. Zawsze używaj <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Utwórz strukturę folderów (opcjonalne):</strong> W sekcji <strong>2. Asset Folder Generation</strong>, kliknij <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Skonfiguruj kategorie i reguły nazewnictwa:</strong> W sekcji <strong>3. Asset Categories & Scanning</strong>, upewnij się, że <strong>Reguła Nazewnictwa</strong> (<code>{key}_{lang}</code>) pasuje do Twoich plików (np. <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Umieść swoje zasoby:</strong> Włóż zlokalizowane zasoby do folderów.",
  "li_assets_4": "<strong>Skanuj zasoby:</strong> W sekcji <strong>4. Automation</strong>, kliknij <strong>Scan Assets & Update Tables</strong>. Proces czyszczenia stał się bezpieczniejszy: teraz usuwane są tylko stare pliki tabel (<code>.asset</code>), a nie cały folder.",
  "li_assets_5": "<strong>Połącz zasoby z obiektami:</strong> Kliknij <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Integracja z Addressables:</strong> Jeśli włączony jest tryb <strong>Addressables</strong>, zasoby zostaną automatycznie zarejestrowane w grupach Addressables z adresami w formacie <code>{Category}/{Language}/{Key}</code> podczas skanowania.",
  "li_assets_addressables_naming": "<strong>Konwencja Nazewnictwa:</strong> Podczas skanowania, narzędzie automatycznie ustawia Adresy Addressable na format <code>{Category}/{Language}/{Key}</code>. <strong>Nie zmieniaj nazw</strong> tych adresów ręcznie, ponieważ LocalizationManager polega na tym specyficznym formacie do ładowania zasobów w runtime.",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> Jeśli włączone, narzędzie automatycznie utworzy niezbędną strukturę katalogów dla wszystkich obsługiwanych języków podczas pierwszej lokalizacji zasobów.",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> Automatycznie twórz strukturę folderów dla zlokalizowanych zasobów zgodnie z Twoimi zasadami.",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> Zdefiniuj katalog główny dla wszystkich zlokalizowanych zasobów (Sprite'y, audio itp.). Użyj zmiennej <code>{lang}</code>, aby określić, jak są strukturyzowane foldery per język.",
  "li_assistant_1": "<strong>Konfigurowalne:</strong> Zdefiniuj komendy w swoim Profilu Tłumaczeń (np. „Popraw Gramatykę”, „Uczyń Formalnym”, „Skróć dla UI”).",
  "li_assistant_2": "<strong>Przetwarzanie Partiami:</strong> Wybierz wiele komórek, aby zastosować komendę do wszystkich naraz.",
  "li_assistant_3": "<strong>Custom Commands:</strong> Zdefiniuj własne podpowiedzi w inspektorze <strong>Translation Profile</strong> (lista <code>AIAssistantCommand</code>). Każde polecenie ma <strong>Label</strong> (wyświetlany w menu kontekstowym) oraz <strong>Prompt</strong> (instrukcje wysyłane do AI, np. 'Przepisz w stylu pirata').",
  "li_attr_feat_1": "<strong>Kolekcje:</strong> Obsługuje <code>List&lt;string&gt;</code> i <code>string[]</code>. Klucze są generowane z sufiksami <code>_0</code>, <code>_1</code> itd. Możesz nawet użyć niestandardowego klucza w samym polu listy, aby poprzedzić nim wszystkie elementy.",
  "li_attr_feat_2": "<strong>Modyfikatory dostępu:</strong> Działa z polami <code>private</code>, <code>protected</code>, <code>internal</code> i <code>public</code>.",
  "li_attr_feat_3": "<strong>Niestandardowe atrybuty:</strong> W ustawieniach <em>zakładki Zawartość</em> możesz dodać <code>HeaderAttribute</code>, <code>TooltipAttribute</code> lub dowolną niestandardową nazwę atrybutu. Parser będzie wtedy traktować pola z tymi atrybutami (np. <code>[Header(\"Text\")]</code>) jako lokalizowalne ciągi znaków!",
  "li_attr_feat_4": "<strong>Zagnieżdżone obiekty:</strong> Rekurencyjnie skanuje pola wewnątrz klas lub struktur oznaczonych <code>[System.Serializable]</code>. Obejmuje to pojedyncze instancje i listy zagnieżdżonych obiektów.",
  "li_attr_feat_5": "<strong>Sformatowane Ciągi Znaków:</strong> Obsługuje ciągi interpolowane (<code>$\"Text {0}\"</code>), ciągi dosłowne (<code>@\"Text\"</code>) i konkatenację (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Właściwości są obsługiwane:</strong> Parser skanuje zarówno <code>Fields</code>, jak i <code>Properties</code>. Wymagany jest getter.",
  "li_attr_limit_2": "<strong>Słowniki:</strong> <code>Dictionary&lt;T, string&gt;</code> nie jest bezpośrednio obsługiwany do parsowania.",
  "li_attr_limit_3": "<strong>Pola statyczne:</strong> Obsługiwane za pomocą analizy statycznej (regex) w plikach kodu, ale ogólnie zaleca się używanie pól instancji dla solidnego wykrywania na obiektach GameObject.",
  "li_backup_desc": "Śledź zmiany i przywracaj poprzednie wersje swoich tłumaczeń.",
  "li_backup_rollback": "<strong>Wycofaj:</strong> Natychmiast przywróć wybrane klucze lub całą tabelę do poprzedniego stanu.",
  "li_backup_snapshots": "<strong>Migawki:</strong> Tworzy nazwane punkty przywracania przed operacjami masowymi.",
  "li_cheat_base_private": "<strong>Prywatne Pola Klas Bazowych:</strong> Obsługiwane (Skaner czyta bezpośrednio pliki klas bazowych)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> Tablice",
  "li_cheat_concatenation": "<strong>Konkatenacja Ciągów Znaków:</strong> <code>\"A\" + \"B\"</code> (Obsługiwane)",
  "li_cheat_constructor_args": "<strong>Złożone argumenty konstruktora:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>Słowniki</strong> (Nie są domyślnie serializowalne przez inspektora Unity).",
  "li_cheat_headers": "Atrybuty takie jak <code>[Header(\"...\")]</code> (W pełni obsługiwane)",
  "li_cheat_nested_lists": "<strong>Listy zagnieżdżonych obiektów</strong> (np. <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Zmienne i stałe:</strong> <code>const string s = \"Value\";</code> lub <code>static string</code> (Obsługiwane, Roslyn rozwiązuje wartości z tego samego pliku)",
  "li_cheat_private": "pola <code>private</code> / <code>protected</code> (Obsługiwane)",
  "li_cheat_properties": "<strong>Właściwości:</strong> <code>{ get; set; }</code> (Obsługiwane automatyczne właściwości i pełne właściwości)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Obsługiwane, jeśli są referencjonowane)",
  "li_cheat_serializable": "Zagnieżdżona klasa <code>[Serializable]</code> (elementy ekwipunku, węzły dialogowe).",
  "li_cheat_static": "<strong>Pola Statyczne:</strong> <code>public static string</code> (W pełni obsługiwane)",
  "li_cheat_structs": "<strong>Struktury i Rekordy:</strong> Obsługiwane (Skanowanie rekurencyjne)",
  "li_cheat_ternary": "<strong>Logika/Ternary:</strong> <code>cond ? \"A\" : \"B\"</code> (Parser nie może określić wartości).",
  "li_cheat_unattached": "<strong>Niedołączone Skrypty:</strong> Obsługiwane (Skaner czyta wszystkie pliki .cs w projekcie)",
  "li_content_1": "<strong>Sceny do Parsowania:</strong> Przeciągnij i upuść tutaj wszystkie sceny do analizy.",
  "li_content_2": "<strong>Foldery Prefabów:</strong> Określ foldery z prefabami. Teraz obsługuje paginację i wyszukiwanie dla dużych projektów.",
  "li_content_3": "<strong>Teksty Dynamiczne:</strong> Wprowadź tutaj ciągi tekstowe, które są tworzone wyłącznie w kodzie (np. „Game Over”).",
  "li_content_4": "<strong>Component Types to Ignore:</strong> Określ typy komponentów Unity, które powinny być pomijane podczas skanowania.",
  "li_content_5": "<strong>Pin to Ignore:</strong> Ta funkcja pozwala trwale \"przypiąć\" obiekt z sceny do listy ignorowanych.",
  "li_content_6": "<strong>Scripts to Ignore:</strong> Dodaj konkretne skrypty C# LUB całe foldery, aby wykluczyć je z parsowania.",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> Lista prefiksów dla kluczy (np. <code>Item_</code>), które nie będą usuwane podczas czyszczenia.",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> Zdefiniuj prefiksy (np. <code>quest_item_</code>), które powinny być rozpoznawane jako potencjalnie dynamiczne. To pomaga narzędziu odróżnić statyczne etykiety UI od kluczy generowanych danymi.",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> Skonfiguruj wzorce dla tekstu, który jest aktualizowany dynamicznie poprzez kod. Zapobiega to tworzeniu przez skaner zbędnych kluczy dla tekstu zmieniającego się w czasie działania.",
  "li_content_regex_example": "<strong>Przykład własnego wrappera:</strong> Jeśli używasz własnej funkcji takiej jak <code>MyGame.Loc(\"KEY\")</code>, dodaj regułę parsowania skryptu z wyrażeniem regularnym: <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Ignorowane wzorce wyrażeń regularnych:</strong> Kliknij <strong>'Add Common Pattern'</strong>, aby szybko wykluczyć dynamiczną zawartość, taką jak adresy URL, e‑maile itp.",
  "li_content_scanner": "<strong>Roslyn Code Scanner:</strong> Głęboki silnik analizy statycznej, który rozumie drzewa składni C# w celu solidnego wykrywania kluczy.",
  "li_content_scanner_details_1": "<strong>Inteligentne Wykrywanie Wywołań:</strong> automatycznie znajduje wywołania <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> i <code>GetTranslation(\"Text\")</code>. Wymusza tryb <strong>Text-As-Key</strong> dla tych wywołań, aby zapewnić poprawne działanie funkcji środowiska uruchomieniowego, takich jak Pluralizacja i Płeć.",
  "li_content_scanner_details_2": "<strong>Rozwiązywanie Stałych:</strong> Skaner jest wystarczająco inteligentny, aby rozwiązywać zmienne string `const` lub `static readonly`. Jeśli użyjesz <code>_ (MyConst)</code>, znajdzie wartość `MyConst` (jeśli zdefiniowana w tej samej klasie) i użyje jej jako tekstu źródłowego.",
  "li_content_scanner_details_3": "<strong>Atrybut i Metadane:</strong> Skanuje każde pole lub właściwość z `[LocalizableField]`, `[Header]` lub `[Tooltip]` (jeśli skonfigurowano). Obsługuje <strong>Tablice</strong>, <strong>Listy</strong>, a nawet <strong>Zagnieżdżone Klasy Serializowalne</strong> rekurencyjnie.",
  "li_content_scanner_details_4": "<strong>Wsparcie dla nowoczesnego C#:</strong> Pełne wsparcie dla składni C# 9.0+, w tym wyrażeń <code>new()</code> z typem docelowym, niejawnego tworzenia tablic i ciągów interpolowanych (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Atrybuty do skanowania:</strong> Zdefiniuj własne atrybuty (np. <code>[Header]</code> lub <code>[Tooltip]</code>), które parser powinien rozpoznawać jako źródła lokalizowalnych ciągów znaków.",
  "li_content_script_rules_bridge_name": "<strong>Nazwa klasy mostka:</strong> Umożliwia określenie nazwy generowanej klasy statycznej.",
  "li_content_script_rules_bridges": "<strong>Generuj mostki C#:</strong> Automatycznie tworzy klasę statyczną (np. <code>AnkoLoc</code>) zapewniającą dostęp typowany do wszystkich kluczy, eliminując magiczne ciągi i umożliwiając autouzupełnianie w IDE.",
  "li_context_1": "<strong>Notatki Dewelopera:</strong> Komentarze z tabeli tłumaczeń są przekazywane do AI jako kontekst.",
  "li_context_2": "<strong>Ścieżka Obiektu:</strong> Jeśli nie ma komentarza, ścieżka hierarchii obiektu (np. <code>MainMenu/Canvas/StartButton</code>) jest używana jako awaryjny kontekst.",
  "li_context_3": "<strong>Słowniczek:</strong> Możesz załadować słowniczek CSV do profilu, aby wymusić określone tłumaczenia terminów i nazw.",
  "li_context_4": "<strong>Opis Projektu:</strong> Opisz scenerię i odbiorców swojej gry, aby pomóc AI zrozumieć ogólny kontekst.",
  "li_context_5": "<strong>Ton i Styl:</strong> Zdefiniuj pożądaną personę (np. 'Przyjazny', 'Profesjonalny', 'Pirat') oraz zasady formatowania.",
  "li_context_glossary": "<strong>Menedżer Słownika:</strong> Bezpośrednio zarządzaj słownikiem, aby 'Dodawać', 'Edytować' lub 'Usuwać' terminy. Obsługuje rozróżnianie wielkości liter i typy 'Nie tłumacz'.",
  "li_context_optimization": "<strong>Optymalizacja Tokenów:</strong> System inteligentnie kompresuje kontekst i ponownie wykorzystuje pamięć podręczną, aby zminimalizować użycie tokenów i koszty.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Elastyczna implementacja, która może komunikować się z API kompatybilnymi z OpenAI (w tym lokalnymi LLM przez Ollama).",
  "li_custom_ai_2": "<strong>Szablony i uwierzytelnianie:</strong> W pełni dostosuj żądanie. <ul><li><strong>Uwierzytelnianie:</strong> Skonfiguruj klucz nagłówka uwierzytelniania (np. <code>Authorization</code>) oraz format (np. <code>Bearer {0}</code>). Obsługuje klucz API w parametrach zapytania.</li><li><strong>Szablon ciała:</strong> Użyj szablonu JSON z placeholderami takimi jak <code>{model}</code> i <code>{prompt}</code> dla tekstu lub <code>{input}</code> i <code>{voice}</code> dla audio.</li><li><strong>Ścieżka odpowiedzi:</strong> Zdefiniuj ścieżkę JSON do wyniku (np. <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Wbudowane Funkcje Bezpieczeństwa:</strong> Automatycznie naprawiaj uszkodzone tagi formatowania (jak <ph0>) często zwracane przez modele AI, zapewniając niezawodne i spójne tłumaczenia.",
  "li_custom_parser_1": "Utwórz nowy skrypt C# w folderze <strong>Editor</strong> Twojego projektu.",
  "li_custom_parser_2": "Skopiuj do niego poniższy szablon.",
  "li_custom_parser_3": "Zmodyfikuj logikę, aby pasowała do Twojego komponentu.",
  "li_custom_provider_manual_reg": "<strong>Ręczna Rejestracja:</strong> W zaawansowanych scenariuszach (takich jak wstrzykiwanie zależności DI lub leniwa inicjalizacja) możesz ręcznie zarejestrować swojego dostawcę za pomocą <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> podczas inicjalizacji.",
  "li_custom_provider_step_1": "<strong>Zaimplementuj Interfejs:</strong> Utwórz nową klasę, która implementuje <code>IAssetProvider</code>. Musisz zdefiniować, jak ładować zasoby <code>Load&lt;T&gt;</code> (synchronicznie) i <code>LoadAsync&lt;T&gt;</code> (asynchronicznie) za pomocą API Twojego systemu.",
  "li_custom_provider_step_2": "<strong>Zdefiniuj Cykl Życia:</strong> Zaimplementuj <code>Initialize</code>, <code>Dispose</code> i <code>UnloadAll</code>. Metody te są wywoływane przez <code>LocalizationManager</code> podczas zmiany języka lub oczyszczania zasobów.",
  "li_custom_provider_step_3": "<strong>Bezpieczeństwo Językowe:</strong> Metoda <code>SetCurrentLanguage</code> jest wywoływana za każdym razem, gdy aktywny język ulega zmianie. Użyj tego do aktualizacji wewnętrznych ścieżek lub ponownego pobrania metadanych zasobów.",
  "li_custom_provider_step_4": "<strong>Automatyczne Wykrywanie (Zalecane):</strong> Udekoruj swoją klasę atrybutem <code>[AssetProviderPlugin]</code>. Dzięki temu Twój dostawca będzie natychmiast widoczny w rozwijanej liście <strong>Zakładka Ustawienia -> Strategia Ładowania Zasobów</strong>.",
  "li_editor_1": "<strong>Inteligentne Grupowanie:</strong> Klucze dla liczby mnogiej i rodzaju (np. <code>apple_count_one</code>, <code>apple_count_few</code>) są automatycznie łączone w zwijane grupy.",
  "li_editor_2": "<strong>Zaawansowana Edycja:</strong> Kliknij na komórkę, aby otworzyć wyskakujące okienko <strong>MultiLineEditWindow</strong>. Pokazuje ono tekst źródłowy do porównania i waliduje placeholdery.",
  "li_editor_3": "<strong>Zaawansowana Selekcja:</strong> Obsługuje elastyczne tryby zaznaczania: pojedyncze komórki, całe wiersze lub konkretne kolumny (języki). Użyj <code>Ctrl+Click</code> i <code>Shift+Click</code> do złożonych zaznaczeń.",
  "li_editor_4": "<strong>Masowe Działania:</strong> Wykonuj operacje na tysiącach komórek jednocześnie. Kliknij prawym przyciskiem myszy na zaznaczenie, aby: <ul><li><strong>Automatyczne Tłumaczenie:</strong> Uzupełniaj brakujące tłumaczenia za pomocą aktywnego Profilu AI.</li><li><strong>Wypełnij ze Źródła:</strong> Szybko resetuj tłumaczenia.</li><li><strong>Przełącz Blokadę:</strong> Chroń 'idealne' tłumaczenia przed przypadkowym nadpisaniem.</li><li><strong>Generuj Dźwięk:</strong> Przetwarzaj TTS wsadowo dla wybranych fraz.</li></ul>",
  "li_editor_5": "<strong>Wysokowydajna Nawigacja:</strong> Edytor wykorzystuje zwirtualizowaną 'MultiColumnListView' do płynnego przewijania z ponad 10 tys. kluczy. Obsługuje nawigację klawiaturą (Strzałki/Tab) i niezawodne skróty: <code>Ctrl+S</code> (Zapisz), <code>Ctrl+Z/Y</code> (Cofnij/Ponów), <code>Ctrl+F</code> (Fokus wyszukiwania).",
  "li_editor_6": "<strong>Zaawansowane Presety Wyszukiwania:</strong> Przeprowadź audyt swojego projektu za pomocą specjalistycznych filtrów: <ul><li><strong>Status:</strong> Nieprzetłumaczone (Bieżący/Dowolny Język), Identyczne ze Źródłem, Zablokowane.</li><li><strong>Zawartość:</strong> Ma Komentarze, Ma/Brak Placeholders, Ma Problemy z Długością (Auto-wykryte).</li><li><strong>Struktura:</strong> Liczba mnoga, Rodzaj, lub Oba.</li><li><strong>Dźwięk:</strong> Brak Dźwięku, Nieaktualne (Niezgodność Hasha).</li></ul>",
  "li_editor_7": "<strong>Inteligentne Zarządzanie Dźwiękiem:</strong> Śledzi 'świeżość' Twoich plików TTS. Jeśli edytujesz tekst tłumaczenia, pojawi się <strong>Żółty Wskaźnik (Nieaktualne)</strong>, informujący, że hash pliku audio nie odpowiada już tekstowi. Jedno kliknięcie regeneruje tylko nieaktualne pliki.",
  "li_editor_8": "<strong>Mechanizm Blokowania:</strong> Wyjaśnienie: <ul><li><strong>Zablokowane Komórki/Wiersze:</strong> Zapobiega wszelkim modyfikacjom przez <strong>Automatyczne Tłumaczenie</strong>, <strong>Import CSV/Google</strong> lub <strong>Wypełnij ze Źródła</strong>.</li><li><strong>Przypadek Użycia:</strong> Zablokuj 'złote' tłumaczenia, które zostały ręcznie zweryfikowane przez native speakerów.</li><li><strong>Kontrola Masowa:</strong> Zablokuj całe języki lub konkretne funkcje (jak imiona postaci) w całym projekcie.</li></ul>",
  "li_editor_layout": "<strong>Dynamiczny Układ Wielopaskowy:</strong> Użyj systemu 3-panelowego, aby przypiąć 'stałe' kolumny (takie jak Klucze) po lewej stronie, przewijając jednocześnie ponad 20 języków w środku. Przełącz widoczność kolumn za pomocą menu kontekstowego nagłówka.",
  "li_editor_regex": "<strong>Wyszukiwanie Regex:</strong> Zarówno główne okno, jak i edytor tabeli obsługują <strong>Wyrażenia Regularne</strong>. Jeśli Twoje zapytanie zawiera symbole takie jak <code>* + ? ^ $ [ ] ( ) { } | .</code>, jest ono automatycznie traktowane jako Regex (np. <code>^item_.*</code>, aby znaleźć wszystkie klucze zaczynające się od 'item_').",
  "li_editor_structure": "<strong>Tabele i Grupy:</strong> Dane są zorganizowane w Tabelach (Plikach), wyświetlane jako Grupy (Foldery) w edytorze dla lepszej nawigacji.",
  "li_editor_ui_test": "<strong>Wbudowane Testowanie UI:</strong> <ul><li><strong>Suwak Rozszerzenia Długości:</strong> Symuluj rozszerzanie tekstu (0% - 100%), aby zobaczyć, jak Twój interfejs użytkownika radzi sobie z dłuższymi językami, takimi jak niemiecki czy rosyjski, bez opuszczania edytora.</li><li><strong>Renderer Tekstu Formatowanego:</strong> Przełącz renderowanie tagów (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>), aby zweryfikować stylizację bez uruchamiania gry.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Gotowy komponent do tworzenia rozwijanej listy UI do przełączania języka. Automatycznie znajduje wszystkie dostępne języki i zarządza ich przełączaniem.<br><strong>Jak używać:</strong> Po prostu dodaj komponent <code>LanguageSelector</code> do swojej sceny (np. na pustym GameObject) i określ swój <code>TMP_Dropdown</code> w inspektorze.",
  "li_example_components_2": "<strong>Przykłady Kodu:</strong> Aby nauczyć się zaawansowanych technik, takich jak praca z <code>[LocalizableField]</code>, funkcją <code>_()</code>, liczbą mnogą i rodzajem, przestudiuj pliki <code>StatPurchaseTest.cs</code> i <code>TestLocalization.cs</code>. Wyraźnie demonstrują one implementację wszystkich głównych funkcji narzędzia w kodzie.",
  "li_example_components_new": "<strong>Nowość (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Zwraca <code>IEnumerator</code>. Musi być yieldowane.",
  "li_example_components_old": "<strong>Stare:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (synchroniczne void) - <strong>Przestarzałe</strong>. Użyj wersji Coroutine.",
  "li_feature_1": "<strong>Zaawansowane Parsowanie:</strong> Automatyczne skanowanie scen, prefabów, UI Toolkit (UXML) i skryptów C#, w tym pól oznaczonych atrybutem <code>[LocalizableField]</code>, a także zagnieżdżonych klas i list.",
  "li_feature_10": "<strong>Menedżer Kopii Zapasowych:</strong> Wbudowane narzędzie do tworzenia i przywracania kopii zapasowych.",
  "li_feature_11": "<strong>Wspierane przez AI:</strong> Obsługa OpenAI, Anthropic (Claude), Google Gemini i lokalnych LLM (Ollama) za pomocą konfigurowalnych profili.",
  "li_feature_12": "<strong>Text-to-Speech (TTS):</strong> Generowanie plików audio dla zlokalizowanych ciągów tekstowych za pomocą AI (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Narzędzia Migracji:</strong> Narzędzia do automatycznego przejścia z wtyczek I2 Localization i Unity Localization.",
  "li_feature_14": "<strong>Menedżer Czcionek i Glifów:</strong> Narzędzie do analizy używanych znaków i znajdowania brakujących glifów w czcionkach.",
  "li_feature_15": "<strong>Wizualne Debugowanie:</strong> Ikony w hierarchii i etykiety w Widoku Sceny do szybkiego debugowania.",
  "li_feature_2": "<strong>Lokalizacja Dowolnych Zasobów:</strong> Zarządzanie sprite'ami, dźwiękiem, prefabami, materiałami itp.",
  "li_feature_3": "<strong>Potężny Edytor Tłumaczeń:</strong> Scentralizowany interfejs z automatycznym zapisem, pełną obsługą Cofnij/Ponów, inteligentnym grupowaniem kluczy i akcjami wielokrotnego wyboru.",
  "li_feature_4": "<strong>AI i Tłumaczenie Maszynowe:</strong> System profili obsługujący DeepL, Google, Microsoft oraz <strong>Niestandardowe AI (OpenAI, Gemini, Claude, Ollama)</strong> z uwzględnieniem kontekstu.",
  "li_feature_5": "<strong>Elastyczny Import/Eksport:</strong> Obsługa CSV, XML, YAML, XLIFF i bezpośredni import z Google Sheets.",
  "li_feature_6": "<strong>Podgląd na Żywo:</strong> Podgląd dowolnego języka w Widoku Sceny lub <strong>Trybie Prefabu</strong> bez uruchamiania gry.",
  "li_feature_7": "<strong>Obsługa Liczby Mnogiej i Rodzaju:</strong> Pełne wsparcie CLDR (v43). Obejmuje zasady dla <strong>azjatyckich</strong> (Brak), <strong>angielskich/germańskich</strong> (Jeden, Inny), <strong>francuskich</strong> (Jeden 0-1), <strong>słowiańskich</strong> (Jeden, Kilka, Wiele - RU, UK, PL), <strong>arabskich</strong>, <strong>celtyckich</strong>, <strong>bałtyckich</strong> (LT, LV) i innych.",
  "li_feature_8": "<strong>Pełna Obsługa RTL:</strong> Prawidłowe wyświetlanie języków pisanych od prawej do lewej.",
  "li_feature_9": "<strong>Aktualizacje na Żywo:</strong> Ładowanie aktualnych tłumaczeń z zdalnego serwera przy starcie gry.",
  "li_feature_tool_translation": "<strong>W pełni Przetłumaczony Interfejs:</strong> Interfejs narzędzia jest lokalizowalny. Możesz zmienić język edytora za pomocą rozwijanej listy w <strong>nagłówku Głównego Okna</strong>.",
  "li_font_global": "<strong>Raport Globalny:</strong> Generuje raport wszystkich brakujących glifów we wszystkich językach.",
  "li_font_glyph_analyze": "Analizuje wszystkie tłumaczenia i sprawdza, czy przypisana czcionka (TMP_FontAsset) obsługuje wszystkie użyte znaki.",
  "li_font_glyph_copy": "Umożliwia kopiowanie wszystkich unikalnych znaków językowych do generowania atlasu czcionek. Zawiera <strong>filtry wykluczające ASCII, cyfry i interpunkcję</strong> w celu optymalizacji przestrzeni tekstury.",
  "li_font_glyph_missing": "Pokazuje listę brakujących glifów.",
  "li_font_glyph_workflow": "<strong>Workflow dla TMP:</strong> 1. Uruchom Skanowanie. 2. Wybierz język z brakującymi glifami. 3. Kliknij <strong>'Copy Character Set'</strong>. 4. Otwórz Window -> TextMeshPro -> Font Asset Creator. 5. Wklej zawartość schowka do pola 'Character Sequence (Custom Range)', aby wygenerować atlas zawierający dokładnie te znaki, których potrzebuje Twoja gra.",
  "li_font_unicode": "<strong>Zakresy Unicode:</strong> Wyświetl konkretne zakresy Unicode używane w Twoich tłumaczeniach (np. Podstawowy Łaciński, Cyrylica), aby zoptymalizować zasoby czcionek.",
  "li_footer_status": "<strong>Status i postęp:</strong> Informacje zwrotne w czasie rzeczywistym dotyczące parsowania, importowania lub zadań generowania AI.",
  "li_header_lang_selector": "<strong>Język edytora:</strong> Zmień język interfejsu narzędzia. UI narzędzia jest w pełni lokalizowalne.",
  "li_header_preview_btn": "<strong>Przełącznik podglądu:</strong> Szybko włącz lub wyłącz podgląd w edytorze. Użyj przycisku 'Revert', aby przywrócić pierwotne wartości sceny.",
  "li_header_toolbar_buttons": "<strong>Globalny pasek narzędzi:</strong> Bezpośredni dostęp do Dokumentacji, Discorda, zasobu ustawień, sprawdzania zależności i strony recenzji.",
  "li_install_1": "<strong>WAŻNE (Aktualizacja v2.0):</strong> W przypadku aktualizacji z v1.x <strong>MUSISZ usunąć</strong> stary folder `Ankonoanko` przed importem. Wersja 2.0 wymaga czystej instalacji z powodu zmian w przestrzeni nazw.",
  "li_install_2": "Narzędzie automatycznie sprawdzi wymagane zależności. Potwierdź instalację w wyświetlonym oknie dialogowym.",
  "li_install_3": "Wymagane zależności (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) są niezbędne do podstawowej funkcjonalności.",
  "li_install_4": "Opcjonalne zależności (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) umożliwiają dodatkowe funkcje.",
  "li_install_5": "Kliknij <strong>Zainstaluj Wybrane</strong>, aby zainstalować zalecane pakiety.",
  "li_install_6": "Po instalacji otwórz główne okno narzędzia poprzez menu <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Jeśli planujesz używać asynchronicznego ładowania zasobów, zainstaluj pakiet <strong>Addressables</strong> przez Menedżera Pakietów.",
  "li_live_updates_1": "<strong>Włącz:</strong> w Ustawieniach, zaznacz 'Włącz Aktualizacje na Żywo'.",
  "li_live_updates_2": "<strong>Źródło:</strong> Podaj <code>URL Aktualizacji na Żywo</code> zwracający słownik JSON lub <code>URL Arkusza Google</code>.",
  "li_live_updates_3": "<strong>Pamięć podręczna:</strong> Tłumaczenia są buforowane lokalnie w <code>liveUpdateCachePath</code>, aby zapewnić działanie gry w trybie offline.",
  "li_live_updates_4": "<strong>Bezpieczeństwo:</strong> Użyj <strong>Klucza API środowiska uruchomieniowego</strong> (zaszyfrowanego), jeśli Twój serwer wymaga uwierzytelnienia.",
  "li_localizedtext_1": "<code>localizationKey</code>: Klucz używany do znalezienia tłumaczenia. Może być automatycznie generowany lub ręcznie przypisany.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Jeśli <code>true</code>, komponent zastosuje tylko style (czcionka, RTL), ale nie zmieni samego tekstu. Kluczowe dla dynamicznych elementów tekstowych (np. tekst aktualizowany za pomocą wywołań `_()` w skryptach).",
  "li_localizedtext_3": "<code>originalSourceText</code>: Oryginalny tekst w języku bazowym. Używany jako awaryjny (fallback).",
  "li_localizedtext_key_override": "<strong>Ręczne nadpisanie klucza:</strong> Możesz kliknąć ikonę 'Edit' obok klucza, aby ręcznie wprowadzić klucz. Użyj 'X', aby przywrócić automatyczne generowanie. Działa to dla <code>LocalizedText</code>, <code>LocalizedDropdown</code> (dla każdej opcji osobno) i <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>Szukaj w Tabeli:</strong> Kliknij ikonę lupy, aby natychmiast otworzyć Tabelę Tłumaczeń i skupić się na konkretnym kluczu.",
  "li_migration_csv_details_1": "<strong>Inteligentne Filtrowanie:</strong> Importer automatycznie pomija wiersze, które wyglądają jak ścieżki zasobów (np. <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>), aby utrzymać czystość bazy danych tekstu.",
  "li_migration_csv_details_2": "<strong>Kolumna 'Type':</strong> Jeśli istnieje kolumna 'Type' (format I2), importowane są tylko wiersze oznaczone jako 'Text' lub z pustym typem. Aby zaimportować zasoby, użyj Profili Migracji, aby zmapować je do <code>LocalizedAsset</code>.",
  "li_migration_csv_req_1": "<strong>Kolumna Klucza:</strong> Musi nosić nazwę <code>Key</code> (niezależnie od wielkości liter) lub być zdefiniowana w Twoim Profilu Migracji.",
  "li_migration_csv_req_2": "<strong>Kolumny Językowe:</strong> Każda kolumna nieoznaczona jako ignorowana jest traktowana jako kod języka (np. 'en', 'ja', 'English'). Narzędzie próbuje luźno dopasować je do języków Twojego projektu.",
  "li_migration_csv_req_3": "<strong>Komentarze:</strong> Kolumny o nazwach <code>Desc</code>, <code>Description</code> lub <code>Comment</code> są importowane jako notatki dewelopera. Ta lista jest konfigurowalna w <strong>Migration Profile</strong>.",
  "li_migration_custom_1": "Prawy przycisk myszy w Project View -> Create -> Anko Localization -> Migration Profile.",
  "li_migration_custom_2": "<strong>Reguły:</strong> Zdefiniuj reguły konwersji (jeśli [Source Component] z [Context Filter], wtedy konwertuj na [Target Component]). Reguły obsługują <strong>Priority</strong> (wyższe liczby przetwarzane najpierw), <strong>Harvest Assets</strong> (automatyczne wyodrębnianie i rejestrowanie odwołanych zasobów, takich jak Sprites lub Audio) oraz <strong>Context Filtering</strong> umożliwiające rozróżnienie wielu komponentów na tym samym obiekcie.",
  "li_migration_fallback_keys": "<strong>Pola kluczy awaryjnych:</strong> Określ dodatkowe nazwy pól do sprawdzenia podczas wyodrębniania kluczy z komponentów legacy. Przydatne, jeśli Twój stary system używa niestandardowych nazw właściwości dla kluczy.",
  "li_migration_gs_1": "<strong>Dostęp:</strong> Arkusz musi być udostępniony ('Każdy, kto ma link, może przeglądać') lub Opublikowany w Sieci.",
  "li_migration_gs_2": "<strong>Zakładki Arkusza (GID):</strong> URL musi zawierać parametr <code>gid=...</code>. Informuje to narzędzie, którą zakładkę dokładnie odczytać (np. <code>gid=0</code> to zazwyczaj pierwsza zakładka/arkusz).",
  "li_migration_ignored_headers": "<strong>Ignorowane nagłówki CSV:</strong> Zdefiniuj kolumny, które powinny zostać pominięte podczas importu (np. 'Type', 'Description'). Zapobiega to traktowaniu przez narzędzie kolumn metadanych jako danych językowych.",
  "li_migration_legacy_components": "<strong>Dodatkowe komponenty legacy:</strong> Ręcznie wymień nazwy komponentów, które narzędzie powinno wykryć jako 'legacy' podczas skanowania migracyjnego, nawet jeśli nie zdefiniowano bezpośredniej reguły konwersji.",
  "li_migration_profile_details": "<strong>Zaawansowane ustawienia profilu:</strong><ul><li><code>CsvKeyHeader</code>: Nazwa nagłówka dla kolumny Key.</li><li><code>CsvCommentHeaders</code>: Lista nagłówków traktowanych jako notatki/komentarze dewelopera.</li><li><code>IgnoredCsvHeaders</code>: Kolumny do pominięcia (metadane takie jak 'Type' lub 'Status'), aby nie były traktowane jako języki.</li><li><code>AssetExtensions</code>: Typy plików rozpoznawane jako zasoby podczas skanowania.</li><li><code>FallbackKeyFields</code>: Dodatkowe nazwy pól do sprawdzenia, jeśli główne pole klucza jest puste.</li></ul>",
  "li_migration_rule_fields": "<strong>Konfiguracja reguły:</strong><ul><li><code>Priority</code>: Wyższe wartości są przetwarzane najpierw. Użyj tego, aby obsłużyć konkretne przypadki przed ogólnymi.</li><li><code>Context Filter</code>: Zastosuj regułę tylko, jeśli określony komponent (np. <code>Text</code>) znajduje się na tym samym obiekcie.</li><li><code>Harvest Assets</code>: Jeśli włączone, wyodrębnia bieżący zasób (np. Sprite) z przestarzałego komponentu i rejestruje go w tabeli zasobów.</li><li><code>Asset Field Path</code>: Ścieżka do pola zawierającego odwołanie do zasobu do zebrania.</li><li><code>Additional Data Path</code>: Używane w przypadku złożonych komponentów, takich jak Dropdown, aby zebrać wiele wartości/opcji.</li></ul>",
  "li_migration_stubs_1": "<strong>Problem:</strong> Usuwasz stare zasoby wtyczki. Unity wykrywa brakujące skrypty (np. brakujący komponent <code>Localize</code>). Edytor wchodzi w tryb błędu kompilacji.",
  "li_migration_stubs_2": "<strong>Rozwiązanie:</strong> Funkcja „Awaryjne Stubs” generuje lekkie, puste klasy o dokładnie takich samych nazwach i przestrzeniach nazw jak stary plugin. To zadowala kompilator.",
  "li_migration_stubs_3": "<strong>Przebieg pracy:</strong> 1. Kliknij <strong>Enable Emergency Stubs</strong> (dodaje <code>ANKO_ENABLE_MIGRATION_STUBS</code> do ustawień projektu). 2. Usuń stary folder wtyczki. 3. Unity pomyślnie kompiluje się, używając fałszywych klas. 4. Uruchom <strong>Component Converter</strong>, aby zastąpić stuby oficjalnymi komponentami. 5. Kliknij <strong>Disable Stubs</strong>, gdy refaktoryzacja zostanie zakończona.",
  "li_migration_tool_converter": "<strong>Krok 2: Konwerter Komponentów:</strong> Skanuj sceny i prefabrykaty. Automatycznie zastępuje stare komponenty (np. <code>Localize</code>) komponentami <code>LocalizedText</code> / <code>LocalizedAsset</code>, przenosząc klucze.",
  "li_migration_tool_fields": "<strong>Ustawienia profilu:</strong> Konfigurowalny typ 'Source Plugin' i reguły 'Asset Mapping' zapewniają prawidłowe przenoszenie tekstur i dźwięku.",
  "li_migration_tool_import": "<strong>Krok 1: Import Danych:</strong> Importuj pliki CSV (I2) lub XLIFF (Unity Loc), aby utworzyć bazę danych kluczy.",
  "li_migration_tool_profiles": "<strong>Profile migracji:</strong> Twórz niestandardowe profile do mapowania zasobów i ustawień z pluginów innych firm (I2, Unity Loc).",
  "li_migration_tool_safemode": "<strong>Tryb bezpieczny i awaryjne stuby:</strong> Komponenty są wyłączane zamiast usuwane. Zawiera krytyczną funkcję <strong>Emergency Stubs</strong> (aktywowaną przez symbol definicji <code>ANKO_ENABLE_MIGRATION_STUBS</code>): generuje fałszywe klasy zastępcze dla I2 Localization lub Unity Localization, aby projekt mógł się natychmiast skompilować po usunięciu tych wtyczek. Zapobiega błędom typu \"The type name 'Localize' could not be found\" i daje czas na właściwą refaktoryzację kodu w celu użycia nowego systemu. Włączenie Stubs pozwala naprawić błędy kompilacji po usunięciu starej wtyczki lokalizacyjnej.",
  "li_migration_tool_setup": "<strong>Krok 0: Konfiguracja:</strong> Skonfiguruj nazwy komponentów (np. <code>Localize</code> dla I2) i pól, w których przechowywany jest klucz. Dostępne są presety.",
  "li_migration_workflow_1": "<strong>1. Kopia zapasowa:</strong> Zapisz swój projekt w systemie kontroli wersji (Git) lub wykonaj kopię zapasową plików przed rozpoczęciem.",
  "li_migration_workflow_2": "<strong>2. Włącz Stubs:</strong> Otwórz Narzędzie migracji -> zakładka 'Safe Mode'. Kliknij <strong>Włącz awaryjne Stubs</strong> dla swojego systemu docelowego (I2/UnityLoc). Spowoduje to utworzenie lekkich fałszywych klas w Twoim projekcie.",
  "li_migration_workflow_3": "<strong>3. Usuń stary plugin:</strong> Usuń folder starego pluginu (np. 'Assets/Plugins/I2'). Unity dokona rekompilacji. Dzięki Stubs <strong>NIE</strong> otrzymasz błędów 'Type not found', zachowując wszystkie odniesienia komponentów w prefabs.",
  "li_migration_workflow_4": "<strong>4. Importuj dane:</strong> W zakładce 'Import Data' załaduj swój plik CSV/XLIFF źródłowy. Zweryfikuj podgląd i kliknij <strong>Importuj</strong>. Spowoduje to wypełnienie tabel tłumaczeń AnKo.",
  "li_migration_workflow_5": "<strong>5. Konwertuj komponenty:</strong> W zakładce 'Component Converter' wybierz 'Entire Project' i kliknij <strong>Skanuj i konwertuj</strong>. Narzędzie zastąpi stare stubs komponentami 'LocalizedText'/'LocalizedAsset', przenosząc klucze.",
  "li_migration_workflow_6": "<strong>6. Oczyszczanie:</strong> Gdy wszystko działa, kliknij <strong>Wyłącz Stubs</strong> i pozwól Unity ponownie skompilować.",
  "li_notes_1": "<strong>Kopie Zapasowe:</strong> Zawsze twórz kopię zapasową poprzez <strong>Translation Table Editor -> Manage Backups</strong> przed większymi zmianami. Kopie zapasowe są przechowywane w folderze <code>LocalizationBackups</code> <strong>w katalogu głównym projektu (poza folderem Assets)</strong>, aby utrzymać czystość projektu Unity i skrócić czas importu.",
  "li_notes_2": "<strong>Bezpieczeństwo Klucza API:</strong> Klucz do pracy w edytorze jest przechowywany lokalnie na Twojej maszynie (w <code>EditorPrefs</code>) i nie trafia do repozytorium. Dla kluczy potrzebnych w buildzie gry, użyj sekcji <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Folder <code>StreamingAssets</code>:</strong> Pliki tłumaczeń muszą znajdować się w podfolderze <code>Assets/StreamingAssets/</code>, aby zostały uwzględnione w buildzie gry.",
  "li_notes_4": "<strong>„Odporność na Błędy”:</strong> Narzędzie automatycznie chroni Cię przed przypadkowym zapisaniem tymczasowych danych z trybu podglądu do sceny lub prefabu.",
  "li_notes_5": "<strong>Wydajność:</strong> Wywołanie <code>_()</code> jest szybkie, ale w pętlach uruchamianych w każdej klatce (np. w <code>Update</code>), staraj się buforować wynik w zmiennej.",
  "li_notes_6": "<strong>Wykluczenie <code>LanguageSelector</code> z parsowania:</strong> Obiekt z komponentem <code>LanguageSelector</code> i jego <code>TMP_Dropdown</code> musi zostać dodany do listy <strong>Ignoruj Konkretne Obiekty</strong> w zakładce <strong>Zawartość</strong>. Jest to konieczne, aby zapobiec tworzeniu przez parser dodatkowych kluczy dla opcji dropdown, ponieważ skrypt <code>LanguageSelector</code> wypełnia je dynamicznie w runtime. Ignorowanie zapobiega konfliktom i utrzymuje czystość plików tłumaczeń.",
  "li_notes_7": "<strong>Czcionki dla <code>LanguageSelector</code>:</strong> Aby wybrany język w <code>TMP_Dropdown</code> poprawnie zaktualizował swoją czcionkę, ręcznie dodaj pusty komponent <code>LocalizedText</code> do podrzędnego obiektu <strong>Label</strong> Dropdownu i zaznacz pole <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Kod i Addressables:</strong> Jeśli przełączysz się na tryb <strong>Addressables (Async)</strong>, MUSISZ używać <code>GetLocalizedAssetAsync<T>()</code> w swoich skryptach. Wywołanie synchronicznego <code>GetLocalizedAsset<T>()</code> zwróci null i zarejestruje ostrzeżenie, aby zapobiec zawieszaniu głównego wątku.",
  "li_notes_addressables_sync_warning": "<strong>Sync vs Async:</strong> Jeśli przełączysz się na tryb <strong>Addressables (Async)</strong>, MUSISZ zaktualizować swój kod, aby używał <code>GetLocalizedAssetAsync<T>()</code>. Wywołanie metody synchronicznej zwróci null i zarejestruje ostrzeżenie, aby uniknąć zawieszania głównego wątku.",
  "li_preview_1": "<strong>Jak to działa:</strong> Wybierz język z listy, a narzędzie natychmiast zastosuje odpowiednie tłumaczenia, czcionki, ustawienia RTL i zasoby do wszystkich lokalizowalnych obiektów w aktywnej scenie lub otwartym prefabie.",
  "li_preview_2": "<strong>Placeholdery:</strong> Jeśli w zakładce <strong>Ustawienia</strong> wybrano styl placeholderów (np. <strong>Accents</strong> lub <strong>Brackets</strong>), te placeholdery będą wyświetlane w trybie podglądu zamiast rzeczywistych tłumaczeń. Jest to idealne do testowania układu i znajdowania niezlokalizowanych elementów.",
  "li_preview_3": "<strong>Bezpieczeństwo:</strong> Wszystkie zmiany dokonane w trybie podglądu są tymczasowe. Narzędzie automatycznie przywróci wszystko do stanu oryginalnego po wybraniu „<strong>Revert to Original</strong>”, zamknięciu okna, zmianie sceny lub przed zapisaniem sceny/prefabu (dzięki komponentowi <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Ochrona przed Awarią:</strong> System automatycznie tworzy kopię zapasową stanu sceny do folderu <code>Library</code> przed podglądem. Jeśli Unity się zawiesi lub wymusisz zamknięcie podczas podglądu, narzędzie wykryje plik odzyskiwania przy następnym uruchomieniu i zaoferuje przywrócenie oryginalnego stanu sceny.",
  "li_preview_overlay_1": "<strong>Dostęp:</strong> Nakładka pojawia się automatycznie w widoku sceny. Możesz ją przełączać za pomocą menu nakładek Unity (klawisz <code>Spacja</code> w widoku sceny).",
  "li_preview_overlay_2": "<strong>Funkcjonalność:</strong> Udostępnia rozwijaną listę do szybkiej zmiany bieżącego języka podglądu bez otwierania głównego okna.",
  "li_report_1": "<strong>Kategorie:</strong> Wszystkie Klucze, Dodane, Zaktualizowane (zmieniony tekst), Usunięte, Duplikaty, Zmigrowane, Pominięte (niezmienione).",
  "li_report_2": "<strong>Zaawansowane Szukanie:</strong> Kliknij przycisk <strong>Find</strong> obok dowolnego wpisu, aby natychmiast znaleźć odpowiadający mu obiekt w projekcie. Wyszukiwanie działa asynchronicznie, nie blokując edytora, i przeszukuje wszystkie sceny i prefabrykaty.",
  "li_report_all_keys": "<strong>Wszystkie klucze:</strong> Lista wszystkich wykrytych w projekcie kluczy lokalizacji z opcjami wyszukiwania i filtrowania.",
  "li_report_btn_clear": "<strong>Wyczyść raport:</strong> Usuwa wszystkie wyniki skanowania z pamięci bieżącej sesji.",
  "li_report_btn_copy_all": "<strong>Kopiuj wszystkie klucze:</strong> Kopiuje wszystkie klucze lokalizacji w bieżącej kategorii do schowka systemowego.",
  "li_report_btn_load_last": "<strong>Wczytaj ostatnie skanowanie:</strong> Natychmiast przywraca wyniki najnowszej analizy projektu bez ponownego skanowania.",
  "li_report_btn_save": "<strong>Zapisz raport:</strong> Eksportuje bieżące wyniki skanowania do pliku tekstowego lub CSV w celu dokumentacji lub audytu zewnętrznego.",
  "li_report_source_filter": "<strong>Filtr źródła:</strong> Zawęża wyniki według ich pochodzenia (np. wyświetlaj tylko klucze znalezione w Skryptach, Scenach lub Prefabach).",
  "li_safety_global_limit": "<strong>Globalny limit miesięczny:</strong> <code>monthlyCharLimit</code> (domyślnie: 500 000 znaków) działa jako wyłącznik awaryjny dla wszystkich żądań. Możesz przełączać ostrzeżenia za pomocą <code>enableApiLimitWarning</code>.",
  "li_safety_profile_limit": "<strong>Limity profili:</strong> Każdy profil tłumaczeniowy umożliwia ustawienie własnych wartości 'Maks. znaków na żądanie' i 'Rozmiar partii'.",
  "li_settings_1": "<strong>Tryb generowania kluczy:</strong> Określa strategię tworzenia unikalnych identyfikatorów dla Twojego tekstu:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(Domyślny - Zalecany)</strong>: Generuje klucze na podstawie nazwy sceny/prefabu oraz hierarchii obiektów (np. <code>scene_Menu_BtnPlay_682412</code>). Najlepszy dla dużych projektów, ponieważ zapewnia unikalność i jest odporny na zmiany tekstu.</li><li><code>UseTextAsKey</code>: Używa samego tekstu źródłowego jako klucza (np. \"Start Game\" → <code>Start Game</code>). Idealny do szybkiego prototypowania, gdy klucze powinny być czytelne dla człowieka.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Hy‑brydowy)</strong>: Najbardziej elastyczny tryb. Najpierw sprawdza, czy komponent ma już ręcznie przypisany klucz lub <code>[LocalizableField(key=\"...\")]</code>. Jeśli klucz nie istnieje, generuje hierarchiczny. <em>Użyj tego, aby zachować istniejącą pracę przy automatyzacji nowej zawartości.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Hy‑brydowy)</strong>: Podobnie jak powyżej, ale w razie braku ręcznego klucza używa samego tekstu. Szanuje istniejące komponenty i dane.</li><li><code>Manual</code>: Skaner nigdy nie tworzy nowych kluczy. Aktualizuje tylko obiekty, które już mają komponent lokalizacji z kluczem. Idealny dla ścisłej kontroli ręcznej.</li></ul>",
  "li_settings_10": "<strong>Narzędzia Deweloperskie:</strong> Na dole zakładki Ustawienia znajdziesz przyciski narzędziowe, takie jak <strong>Clear Saved Language Pref</strong> (resetuje zapisany język w PlayerPrefs, dzięki czemu gra ponownie uruchomi się z Językiem Domyślnym).",
  "li_settings_11": "<strong>Techniczne Opcje Dropdown:</strong> Lista wartości tekstowych (domyślne: 'Option A', 'Option B', 'Option C'), które parser <strong>zignoruje</strong> podczas skanowania Dropdownów. To utrzymuje czystość Twojej tabeli tłumaczeń od domyślnego tekstu placeholderów UI w Unity.",
  "li_settings_2": "<strong>Zarządzanie Językami:</strong><ul><li><strong>Język Źródłowy:</strong> Język używany w Twoich scenach/prefabach Unity (język deweloperski).</li><li><strong>Język Domyślny:</strong> Język wybrany przy pierwszym uruchomieniu gry, jeśli język systemowy użytkownika nie jest obsługiwany.</li><li><strong>Lista:</strong> Zarządzaj obsługiwanymi językami, przypisuj określone <strong>Zasoby Czcionek</strong> i włączaj obsługę <strong>RTL</strong>.</li></ul>",
  "li_settings_3": "<strong>Ustawienia ogólne:</strong> Konfiguracja zachowania na poziomie całego projektu:<ul><li><code>Translations Save Path</code>: Katalog główny do przechowywania plików tłumaczeń <code>.json</code>. Aby były dostępne w grze, musi znajdować się w <code>Assets/Resources</code> lub <code>Assets/StreamingAssets</code>.</li><li><code>Safe Mode</code>: Warstwa ochronna blokująca operacje (np. Auto-Translate), jeśli wykryte zostaną niezgodności projektu lub brakujące zależności.</li><li><code>Remove Missing Keys</code>: Jeśli włączone, skaner automatycznie usunie z bazy wpisy, które nie występują już w żadnej scenie ani prefabu podczas aktualizacji projektu.</li><li><code>Parse Inactive Objects</code>: Określa, czy narzędzie ma skanować i lokalizować wyłączone lub ukryte GameObjecty.</li><li><code>Parse All Prefabs</code>: Skanuje wszystkie prefabrykaty w projekcie. Jeśli wyłączone, przetwarzane są tylko prefabrykaty w folderach określonych w zakładce <strong>Content</strong>.</li><li><code>Fill Comments By Paths</code>: Automatycznie wypełnia pole 'Comment' w tabeli tłumaczeń ścieżką hierarchii sceny/prefabu obiektu.</li><li><code>Split Files by Language</code>: Dzieli bazę tłumaczeń na wiele plików (np. <code>en.json</code>, <code>ja.json</code>). Mocno zalecane w dużych projektach, aby zmniejszyć zużycie pamięci w czasie działania.</li><li><code>Allow Empty Source/Keys</code>: Pozwala narzędziu rejestrować i śledzić obiekty, nawet jeśli ich tekst źródłowy jest pusty. Przydatne dla dynamicznego tekstu ustawianego wyłącznie w kodzie.</li><li><code>Attach to Regex-Ignored Text</code>: Zmusza narzędzie do dodawania komponentów lokalizacji do obiektów, których tekst pasuje do wykluczającego wyrażenia regularnego (np. liczby), umożliwiając ręczne nadpisanie.</li><li><code>Find Settings Asset</code>: Przycisk narzędziowy, który natychmiast podświetla i wybiera plik <code>LocalizationSettings.asset</code> w oknie Projektu.</li></ul>",
  "li_settings_4": "<strong>Debugowanie i testowanie:</strong><ul><li><code>Placeholder Style</code>: Wybierz styl wyświetlania placeholderów w trybie podglądu.</li><li><code>Pseudo-Localization</code>: Wybierz <strong>'Custom Pseudo'</strong>, aby ujawnić zaawansowane ustawienia testowania układu (Współczynnik rozszerzenia, Akcenty i Delimitery).</li></ul>",
  "li_settings_5": "<strong>Aktualizacje na Żywo:</strong> Ustawienia ładowania tłumaczeń ze zdalnego serwera.",
  "li_settings_6": "<strong>Klucz API środowiska uruchomieniowego:</strong> Bezpiecznie przechowuje Twój klucz API dla <strong>Aktualizacji na żywo</strong> (pobieranie nowych tłumaczeń w grze). Różni się on od kluczy Usługi Tłumaczeń używanych w Edytorze. Klucz jest <strong>zaciemniony</strong> (zaszyfrowany) w kompilacji, aby zapobiec łatwemu wyodrębnianiu za pomocą wyszukiwania ciągów znaków, ale pamiętaj: żaden sekret po stronie klienta nie jest w 100% bezpieczny.",
  "li_settings_7": "<strong>Strategia ładowania zasobów:</strong> Wybór między <code>Resources (Legacy)</code>, <code>Addressables (Async)</code> a <code>Custom</code>. Ostrzeżenie: Zmiana tego trybu wymaga ponownego skanowania projektu. Tryb Addressables jest wysoce zalecany dla urządzeń mobilnych i WebGL w celu zmniejszenia zużycia pamięci.",
  "li_settings_8": "<strong>Auto-tłumaczenie:</strong> Używa systemu <strong>Translation Profiles</strong> do lokalizacji napędzanej AI. Konfiguracja obejmuje:<ul><li><code>Text & Audio Profiles</code>: Wybierz lub utwórz profile ScriptableObject, aby skonfigurować różne usługi (np. OpenAI, DeepL, Google).</li><li><code>Presets Folder</code>: Katalog, w którym przechowywane są Twoje preset i profile tłumaczeń.</li><li><code>Target Languages</code>: Lista wszystkich języków projektu z bieżącym statusem, paskami postępu i liczbą znaków dla wybranego profilu.</li><li><code>Start Auto Translation</code>: Rozpoczyna proces dla wszystkich wybranych języków przy użyciu określonych profili.</li></ul>",
  "li_settings_9": "<strong>Ulepszenia debugowania:</strong><ul><li><code>Show Hierarchy Icons</code>: Wyświetla ikony statusu (zielony ptaszek / żółte ostrzeżenie) w hierarchii. <strong>Optymalizacja wydajności:</strong> Używa buforowania, aby zapewnić zerowe opóźnienia nawet w dużych scenach.</li><li><code>Show Scene View Labels</code>: Wizualne debugowanie bezpośrednio w widoku sceny. Etykiety są interaktywne: kliknij prawym przyciskiem myszy dowolną etykietę sceny, aby natychmiast skopiować klucz lokalizacji do schowka.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Zasada struktury folderów:</strong> Określa, jak podfoldery są organizowane przy generowaniu zlokalizowanych zasobów (np. <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Nazwa klasy mostka:</strong> Umożliwia dostosowanie nazwy generowanej klasy statycznej (domyślnie <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Tryb bezpieczny:</strong> Zapewnia, że krytyczne operacje nie będą kontynuowane, jeśli mogą spowodować niespójny stan projektu.",
  "li_settings_icons_legend": "<strong>Legenda Ikon Hierarchii:</strong><br>🟢 (Zielony Haczyk): Zlokalizowany i Klucz ustawiony.<br>🔴 (Czerwony Błąd): Komponent lokalizacyjny obecny, ale <strong>brakuje Klucza</strong>.<br>🟡 (Żółte Ostrzeżenie): Znaleziono komponent Tekstu/Obrazu, ale <strong>nie dołączono komponentu Lokalizacji</strong>.<br>🐛 (Błąd): Obiekt jest <strong>Ignorowany</strong> przez ustawienia.",
  "li_settings_lang_culture_fallback": "<strong>Użyj awaryjnego języka kulturowego:</strong> Jeśli brak konkretnego dialektu regionalnego (np. <code>en-AU</code>), narzędzie spróbuje użyć języka bazowego (<code>en</code>) przed przejściem do <strong>Default Language</strong>.",
  "li_settings_lang_follow_system": "<strong>Śledź język systemowy:</strong> Automatycznie przełącza język gry, aby dopasować go do języka systemu operacyjnego gracza przy pierwszym uruchomieniu.",
  "li_settings_live_updates_security": "<strong>Bezpieczeństwo:</strong> Klucze API środowiska uruchomieniowego są szyfrowane (AES) w kompilacji, aby zapobiec przypadkowemu wyodrębnianiu. Zawsze używaj HTTPS.",
  "li_settings_pseudo_accents": "<strong>Użyj akcentów:</strong> Zastępuje standardowe znaki wersjami z akcentami (np. <code>å</code>, <code>é</code>). Użyj tego, aby zapewnić, że czcionki obsługują wszystkie wymagane glify.",
  "li_settings_pseudo_brackets": "<strong>Dodaj nawiasy:</strong> Otacza tekst w <code>[ ]</code>, aby zweryfikować początek i koniec zlokalizowanych ciągów, pomagając wykrywać problemy z obcięciem lub konkatenacją tekstu.",
  "li_settings_pseudo_expand_length": "<strong>Rozszerz długość:</strong> Symuluje rozszerzanie tekstu typowe dla języków takich jak niemiecki czy rosyjski, dodając znaki na końcu.",
  "li_settings_pseudo_expansion_factor": "<strong>Współczynnik rozszerzenia:</strong> Mnożnik symulacji długości tekstu (np. 2.0 spowoduje, że tekst będzie dwa razy dłuższy).",
  "li_settings_pseudo_prefix": "<strong>Własny prefiks:</strong> Dodaj określony ciąg (np. <code>PSEUDO-</code>) na początek każdego zlokalizowanego tekstu.",
  "li_settings_pseudo_suffix": "<strong>Własny sufiks:</strong> Dodaj określony ciąg na koniec każdego zlokalizowanego tekstu.",
  "li_settings_return_source": "<strong>Zwróć źródło, jeśli brak:</strong> Jeśli włączone, system zwróci tekst w języku źródłowym (lub sam klucz), gdy nie znajdzie tłumaczenia dla bieżącego języka.",
  "li_settings_tms_timeout": "<strong>Limit czasu TMS:</strong> Określa maksymalny czas oczekiwania (w sekundach) na żądania sieciowe do zewnętrznych usług TMS.",
  "li_settings_tool_check_deps": "<strong>Sprawdź zależności:</strong> Ponownie skanuje projekt w poszukiwaniu wymaganych pakietów (np. Newtonsoft) i opcjonalnych integracji.",
  "li_settings_tool_cleanup": "<strong>Pełne czyszczenie projektu:</strong> Niszczące narzędzie, które usuwa wszystkie komponenty i dane Anko Localization z projektu (używać ostrożnie!).",
  "li_settings_tool_clear_prefs": "<strong>Wyczyść preferencje językowe:</strong> Resetuje zapisany język w PlayerPrefs, zmuszając grę do użycia domyślnego lub systemowego języka przy następnym uruchomieniu.",
  "li_settings_tool_font_manager": "<strong>Menedżer czcionek:</strong> Otwiera Menedżer czcionek i glifów, aby analizować brakujące znaki i generować zoptymalizowane zasoby czcionek.",
  "li_settings_tool_migration": "<strong>Narzędzie migracji:</strong> Ułatwia przenoszenie danych i komponentów z I2 Localization lub Unity Localization.",
  "li_settings_tool_test_center": "<strong>Centrum testów lokalizacji:</strong> Narzędzie diagnostyczne służące do weryfikacji stanu projektu, sprawdzania uszkodzonych odwołań i zapewniania integralności lokalizacji.",
  "li_setup_1": "<strong>Utwórz Ustawienia:</strong> Przy pierwszym otwarciu narzędzie utworzy plik <code>LocalizationSettings.asset</code> w folderze <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Konfiguruj języki i tryb:</strong> W zakładce <strong>Settings</strong> upewnij się, że Twój <strong>Source Language</strong> jest poprawny. Sprawdź również <strong>Key Generation Mode</strong> (domyślny to <code>AutoGenerateKeysOnly</code>, który jest zalecany dla większości projektów).",
  "li_setup_3": "<strong>Określ Zawartość do Parsowania:</strong> W zakładce <strong>Zawartość</strong> dodaj wszystkie sceny do analizy do listy <strong>Sceny do Parsowania</strong>. Jeśli używasz prefabów z tekstem, upewnij się, że ich foldery zostały dodane do <strong>Folderów Prefabów</strong>.",
  "li_setup_4": "<strong>Pierwsze Uruchomienie Parsera:</strong> Przejdź do zakładki <strong>Akcje</strong> i kliknij przycisk <code>Aktualizuj Klucze</code>. Narzędzie przeskanuje Twój projekt, utworzy pliki tłumaczeń i automatycznie doda niezbędne komponenty (<code>LocalizedText</code>, <code>LocalizedAsset</code>, itp.) do obiektów gry.",
  "li_setup_5": "<strong>Ustawienia i Buildy (KRYTYCZNE):</strong> Narzędzie automatycznie dodaje <code>LocalizationSettings.asset</code> do <code>Project Settings -> Player -> Preloaded Assets</code>. <br>⚠️ <strong>Kontrola Bezpieczeństwa:</strong> Jeśli ustawienia brakuje w Preloaded Assets i nie znajduje się w folderze Resources, narzędzie <strong>zablokuje build</strong> za pomocą <code>BuildFailedException</code>, aby zapobiec awarii gry na starcie.",
  "li_sidebar_presets": "<strong>Predefiniowane wyszukiwania:</strong> Predefiniowane filtry do typowych zadań, takich jak znajdowanie nieprzetłumaczonych ciągów lub kluczy z brakującymi placeholderami.",
  "li_sidebar_search": "<strong>Globalne wyszukiwanie:</strong> Wyszukaj określone klucze lub tekst we wszystkich tabelach w projekcie.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Wymaga identyfikatora projektu i klucza API. Obsługuje przesyłanie źródłowego XLIFF i pobieranie tłumaczeń jako archiwum ZIP. <em>Zaawansowane:</em> <code>File Name</code> (docelowa ścieżka w Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Wymaga klucza API. Prosta i szybka integracja dla mniejszych projektów. <em>Zaawansowane:</em> <code>Import/Export Params</code> (pozwala dodać dodatkowe flagi API Loco, takie jak <code>&tag=v1</code> lub <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Zarządzanie lokalizacją na poziomie przedsiębiorstwa. <em>Zaawansowane:</em> <code>Update Translations/Descriptions</code> flagi kontrolujące, czy Phrase nadpisuje istniejące dane podczas przesyłania.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Obsługuje slugi organizacji/projektu oraz uwierzytelnianie tokenem API. <em>Zaawansowane:</em> <code>Resource Slug</code> (automatycznie tworzy zasób, jeśli nie istnieje).",
  "li_tutorials_1": "<strong>Interaktywna nauka:</strong> Przewodniki podświetlają konkretne elementy interfejsu użytkownika i czekają na Twoje działania.",
  "li_tutorials_2": "<strong>Dostępne lekcje:</strong>",
  "li_tutorials_editor": "<strong>Edytor tłumaczeń:</strong> Zaawansowane funkcje edytora przypominającego arkusz kalkulacyjny.",
  "li_tutorials_list": "<strong>Lista samouczków:</strong> Dostęp do interaktywnych przewodników po głównych funkcjach narzędzia.",
  "li_tutorials_migration": "<strong>Migracja:</strong> Jak przenieść się z innych systemów lokalizacji (I2, Unity Localization).",
  "li_tutorials_quickstart": "<strong>Szybki start:</strong> Podstawowa konfiguracja dla tekstu i zasobów.",
  "li_tutorials_size": "<strong>Rozmiar samouczka:</strong> Dostosowuje skalę UI i szczegółowość interaktywnych przewodników (od kompaktowego do bardzo dużego). Znajduje się w nagłówku zakładki Samouczki.",
  "li_vis_debug_1": "<strong>Ikony hierarchii:</strong> Natychmiast wykrywaj problemy (Brakujący klucz, Brakujący komponent). Zoptymalizowane, aby nie miały wpływu na wydajność.",
  "li_vis_debug_2": "<strong>Etykiety widoku sceny:</strong> Wyświetla klucz nad każdym zlokalizowanym obiektem. <strong>Kliknij prawym przyciskiem myszy</strong> etykietę, aby 'Kopiuj klucz' lub 'Wybierz obiekt'.",
  "li_vis_debug_3": "<strong>Nakładki:</strong> Użyj nakładki widoku sceny (spacja), aby błyskawicznie przełączać języki podglądu.",
  "lightbox_aria_close": "Zamknij przeglądarkę obrazów",
  "lightbox_image_alt": "Powiększony widok",
  "mindmap_edge_configure": "1. Konfiguruj",
  "mindmap_edge_creates_components": "Tworzy Komponenty",
  "mindmap_edge_defines_rules": "Definiuje reguły dla",
  "mindmap_edge_edited_in": "Edytowane w",
  "mindmap_edge_enables_reaction": "Umożliwia reakcję poprzez",
  "mindmap_edge_extends": "Rozszerza",
  "mindmap_edge_generates": "Generuje",
  "mindmap_edge_manages_assets": "Zarządza zasobami dla",
  "mindmap_edge_opens": "Otwiera",
  "mindmap_edge_parse_project": "3. Parsuj Projekt",
  "mindmap_edge_processed_by": "Przetwarzane przez",
  "mindmap_edge_recommends_for": "Zaleca dla",
  "mindmap_edge_relates_to": "Odpowiada",
  "mindmap_edge_reports_on": "Raportuje na temat",
  "mindmap_edge_see_faq": "Zobacz FAQ",
  "mindmap_edge_specify_content": "2. Określ Zawartość",
  "mindmap_edge_warns_about": "Ostrzega przed",
  "mindmap_node_ai_ecosystem": "Ekosystem AI",
  "mindmap_node_async_code": "Asynchroniczne / Addressables",
  "mindmap_node_dev_tools": "Narzędzia i narzędzia pomocnicze",
  "mindmap_node_tms_integration": "Integracja TMS",
  "mindmap_preset_ai": "AI i automatyzacja",
  "mindmap_preset_dev": "Workflow Dewelopera",
  "mindmap_preset_full": "Pełny Widok",
  "mindmap_preset_quick_start": "Szybki Start",
  "mindmap_preset_tools": "Narzędzia i integracje",
  "mindmap_preset_translator": "Workflow Tłumacza",
  "mindmap_toggle_title": "Pokaż Mapę Myśli",
  "my_notes_title": "Moje Notatki",
  "no_notes_message_new": "Najedź kursorem na tekst, aby dodać notatkę.",
  "notes_add_title": "Dodaj notatkę do tego bloku",
  "notes_close_title": "Zamknij",
  "notes_delete_title": "Usuń notatkę",
  "notes_edit_text": "Edytuj",
  "notes_edit_title": "Edytuj notatkę",
  "notes_goto_title": "Przejdź do tekstu",
  "notes_placeholder": "Twoja notatka...",
  "on_this_page_title": "Na Tej Stronie",
  "p_actions_1": "Główna zakładka robocza.",
  "p_ai_assistant": "W Edytorze Tabeli Tłumaczeń możesz teraz uruchamiać własne komendy AI na wybranych komórkach za pomocą menu kontekstowego (Prawy Przycisk Myszki -> AI: ...).",
  "p_ai_audio_economy": "<strong>Oszczędność Kosztów:</strong> Narzędzie oblicza hash MD5 Twojego tekstu i regeneruje pliki audio tylko, jeśli tekst źródłowy uległ zmianie, oszczędzając Twoje kredyty API. Jeśli zmienisz tłumaczenie, system oznacza tylko ten konkretny plik audio jako 'Przestarzały'. Użyj 'Generate Missing/Outdated', aby zregenerować tylko to, co się zmieniło, oszczędzając kredyty API. Narzędzie hashuje Twój tekst i regeneruje pliki audio tylko, jeśli tekst źródłowy uległ zmianie, oszczędzając Twoje kredyty API poprzez inteligentne grupowanie.",
  "p_ai_context": "Aby poprawić jakość tłumaczenia, AI otrzymuje dodatkowy kontekst:",
  "p_ai_intro": "Narzędzie wykorzystuje system <strong>Profili Tłumaczeń</strong> (ScriptableObject). Dzięki temu ustawienia usług tłumaczeń są przechowywane w pojedynczych zasobach profili, co pozwala na łatwe przełączanie konfiguracji.",
  "p_api_snippets_intro": "Plik <code>LocalizationManager.cs</code> zapewnia solidne API do zarządzania lokalizacją w czasie działania. Poniżej znajdują się kluczowe metody, których będziesz używać w swoich skryptach.",
  "p_assets_1": "Ta zakładka jest w całości poświęcona lokalizacji zasobów nietekstowych.",
  "p_async_api": "Podczas korzystania z Addressables zasoby nie są ładowane natychmiast. Musisz używać asynchronicznego API, aby zapobiec spadkom liczby klatek.",
  "p_bridge_description": "Narzędzie zawiera generator klas statycznych do dostępu do kluczy, co pozwala na używanie silnie typowanych referencji zamiast „magic stringów”. Pomaga to zapobiegać błędom typograficznym i umożliwia autouzupełnianie w IDE.",
  "p_bridge_usage_title": "Przykład użycia:",
  "p_components_intro": "Te komponenty są „mostem” między Twoimi obiektami w scenie a bazą danych tłumaczeń. „Słuchają” na zmiany języka i automatycznie podstawiają prawidłowy tekst lub zasób.",
  "p_content_1": "Tutaj mówisz narzędziu, gdzie dokładnie szukać tekstu. Interfejs został całkowicie przeprojektowany dla lepszej użyteczności.",
  "p_custom_ai": "Typ usługi <strong>Custom AI</strong> pozwala na podłączenie dowolnego LLM przez REST API.",
  "p_custom_asset_provider_1": "Opracowanie niestandardowego dostawcy umożliwia zintegrowanie własnego systemu zarządzania zasobami (np. niestandardowego ładowarki chmurowej, specyficznego wewnętrznego systemu pakietowania lub repozytorium zasobów opartego na bazie danych) bezpośrednio z przepływem pracy lokalizacji.",
  "p_custom_asset_provider_intro": "System Dostawcy Zasobów abstrahuje sposób, w jaki zasoby (Sprite’y, Audio, Prefab’y itp.) są ładowane w czasie działania. Używa <strong>Rejestru Wtyczek</strong>, który automatycznie wykrywa każdą implementację klasy <code>IAssetProvider</code> oznaczoną atrybutem <code>[AssetProviderPlugin]</code>. Umożliwia to płynną integrację własnych systemów ładowania (np. ładowarki chmurowe lub wewnętrzne pakowanie) bez modyfikacji podstawowego zestawu narzędzi.",
  "p_custom_attributes_description": "Oprócz wywołań funkcji, możesz oznaczyć dowolne pole typu string w swoich skryptach jako lokalizowalne za pomocą atrybutów niestandardowych. Domyślnie narzędzie rozpoznaje <code>[LocalizableField]</code>, ale możesz dodać dowolną nazwę atrybutu (taką jak <code>[Header]</code> lub <code>[Tooltip]</code>) do listy <strong>Attributes to Scan</strong>.",
  "p_custom_parser_1": "Możesz łatwo rozszerzyć system, aby obsługiwał niestandardowe komponenty, tworząc własną klasę parsera.",
  "p_editor_1": "Otwierany przez <strong>Tools -> Localization -> Translation Table Editor</strong>. Jest to główne narzędzie do ręcznej edycji tłumaczeń.",
  "p_example_attribute_1": "Najpotężniejszy sposób lokalizacji zmiennych skryptu. Działa z polami <strong>private, protected i public</strong>. Parser rekurencyjnie obsługuje <strong>tablice, listy</strong> oraz <strong>zagnieżdżone klasy serializowalne</strong>. Może nawet generować klucze dla innych atrybutów (takich jak <code>[Header]</code> lub <code>[Tooltip]</code>) jeśli jest skonfigurowany w Ustawieniach.",
  "p_example_components_1": "Projekt zawiera gotowe do użycia skrypty, które służą jako doskonałe przykłady.",
  "p_example_components_updated": "Kod uległ zmianie. Ładowanie języka (zwłaszcza przy użyciu Addressables) jest teraz asynchroniczne.",
  "p_example_function_1": "Użyj funkcji <code>_()</code> dla dynamicznego tekstu, który zmienia się podczas rozgrywki. Metoda, która aktualizuje interfejs użytkownika, powinna być oznaczona atrybutem <code>[OnLanguageChange]</code>, aby była wywoływana automatycznie po zmianie języka. W tym celu do obiektu zostanie automatycznie dodany komponent <code>LocalizedBehaviour</code>.",
  "p_example_plurals_1": "Narzędzie używa teraz dokładniejszych reguł dla różnych grup językowych.",
  "p_font_glyph_manager_access": "Dostęp poprzez <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "To narzędzie jest kompleksowym rozwiązaniem do lokalizacji gier i aplikacji w Unity. Automatyzuje proces zbierania tekstu i zasobów, zarządzania tłumaczeniami za pomocą potężnego interfejsu, integrowania z usługami tłumaczeń maszynowych (w tym Custom AI) oraz dynamicznego aktualizowania zlokalizowanej zawartości w grze.",
  "p_live_updates_guide": "System Live Updates pozwala Twojej grze pobierać nowe tłumaczenia ze zdalnego serwera lub Google Sheet w czasie działania, bez konieczności tworzenia nowej kompilacji.",
  "p_localizedasset_1": "Używany do zamiany zasobów w zależności od języka. Automatycznie wykrywa typ komponentu. Obsługuje: <ul><li><strong>2D:</strong> Sprite'y (<code>Image</code>, <code>SpriteRenderer</code>), Tekstury (<code>RawImage</code>).</li><li><strong>Audio/Wideo:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Animacja:</strong> <code>MeshFilter</code> (Meshes), <code>Renderer</code> (Materiały), <code>Animator</code> (Kontroler), <code>PlayableDirector</code> (Timeline).</li></ul>",
  "p_localizedasset_2": "Dla komponentów z opcją <strong>Play on Awake</strong> (jak <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> poprawnie przechwytuje auto-odtwarzanie, zamienia zasób, a następnie rozpoczyna odtwarzanie, aby uniknąć odtwarzania niezlokalizowanej zawartości.",
  "p_localizedasset_updated": "Komponent obsługuje teraz ładowanie asynchroniczne. Pamiętaj, że może wystąpić niewielkie opóźnienie przy zmianie języka, jeśli zasoby są ładowane z chmury/dysku (Addressables).",
  "p_localizedbehaviour_1": "Komponent narzędziowy, który pozwala Twoim skryptom reagować na zmiany języka. Automatycznie znajduje i wywołuje metody oznaczone atrybutem <code>[OnLanguageChange]</code>.",
  "p_localizeddropdown_1": "Dodawany do <code>Dropdown</code> i <code>TMP_Dropdown</code> w celu tłumaczenia ich opcji.",
  "p_localizedprefab_1": "Komponent do lokalizacji całych prefabów. Działa niedestrukcyjnie: nie modyfikuje oryginalnego prefabu, ale tworzy instancję zlokalizowanej wersji jako obiekt podrzędny, wyłączając wszystkie skrypty (<code>MonoBehaviour</code>), renderery (<code>Renderer</code>) i collidery (<code>Collider</code>) na oryginalnym obiekcie. Zapobiega to podwójnemu wykonywaniu logiki i artefaktom wizualnym. Dla poprawnego działania w runtime, jego kolejność wykonania jest ustawiona na -100 (<code>[DefaultExecutionOrder(-100)]</code>), aby zapewnić, że uruchomi się przed innymi skryptami.",
  "p_localizedtext_1": "Główny komponent do wyświetlania przetłumaczonego tekstu. Jest umieszczany na obiektach z <code>Text</code>, <code>TMP_Text</code> i <code>TextMesh</code>.",
  "p_migration_custom": "Możesz tworzyć własne profile migracji, aby obsługiwać niestandardowe systemy lub konkretne konfiguracje projektu. Każdy profil zawiera listę <strong>Zasad</strong>, które definiują, jak komponenty i ich pola powinny być konwertowane. Zasady są sprawdzane w kolejności ich <strong>Priorytetu</strong>.",
  "p_migration_custom_advanced": "Profile migracji oferują zaawansowane ustawienia do precyzyjnego dostrajania procesu importu i wykrywania:",
  "p_migration_google_sheet": "Możesz importować bezpośrednio z adresu URL Google Sheet bez pobierania plików.",
  "p_migration_import_csv": "Narzędzie obsługuje standardowe pliki CSV (rozdzielane przecinkami). Pierwszy wiersz musi być nagłówkiem.",
  "p_migration_stubs": "Częstym problemem podczas migracji jest to, że usunięcie starej wtyczki (np. I2) przerywa kompilację, uniemożliwiając Unity skompilowanie samego narzędzia migracji.",
  "p_migration_tool_access": "Dostęp poprzez <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Narzędzie do przechodzenia z innych systemów lokalizacji (I2 Localization, Unity Localization).",
  "p_preview_1": "Bezpośrednio pod nagłówkiem znajduje się rozwijana lista <strong>Preview Language</strong>. Ta potężna funkcja pozwala zobaczyć, jak lokalizacja będzie wyglądała w dowolnym języku bezpośrednio w oknie <strong>Sceny</strong> lub <strong>Trybie Prefabu</strong>, bez uruchamiania gry.",
  "p_preview_overlay": "Dla jeszcze szybszych iteracji możesz przełączać języki bezpośrednio z widoku sceny, używając dedykowanego <strong>Localization Preview Overlay</strong>.",
  "p_report_1": "Po każdym parsowaniu ten raport pokazuje pełny obraz statusu Twojej lokalizacji.",
  "p_safety_caps": "Aby zapobiec przypadkowym wysokim kosztom lub dużym kontrolom ruchu:",
  "p_script_parsing_rules_description": "Narzędzie można skonfigurować tak, aby rozpoznawało klucze lokalizacyjne używane w niestandardowych funkcjach lub nawet w konkurencyjnych systemach (takich jak I2 Localization) bez modyfikowania istniejącego kodu. Osiąga się to poprzez definiowanie wzorców regex, których skaner używa do wyodrębniania kluczy ze skryptów.",
  "p_script_parsing_rules_usage": "W zakładce <strong>Content</strong>, w sekcji <strong>Script Parsing Rules</strong>, możesz dodać reguły, które pasują do Twoich konkretnych wywołań funkcji. Na przykład, aby wspierać <code>I2.Loc.Get(\"key\")</code>, możesz dodać regułę ze wzorcem, który przechwytuje ciąg znaków w nawiasach.",
  "p_settings_1": "Twoje centrum kontroli. Tutaj definiujesz globalne zasady dla całego procesu lokalizacji.",
  "p_tms_intro": "Narzędzie teraz obsługuje synchronizację z popularnymi systemami zarządzania tłumaczeniami. Możesz przesyłać klucze źródłowe i pobierać tłumaczenia bezpośrednio w Unity.",
  "p_tms_setup": "1. Przejdź do <strong>Settings -> TMS Integration</strong>.<br>2. Wybierz swojego dostawcę usług.<br>3. Wprowadź klucze API i identyfikatory projektów.<br>4. Użyj przycisków <strong>Push</strong> (Upload Keys) i <strong>Pull</strong> (Download Translations) w oknie ustawień.",
  "p_tutorials_1": "Zakładka Samouczki zawiera interaktywne przewodniki krok po kroku, które pomogą Ci opanować funkcje narzędzia bezpośrednio w edytorze Unity.",
  "p_uitklocalization_1": "Dodane do obiektów z <code>UIDocument</code>. Obsługuje lokalizację <strong>Etykiet, Przycisków, HelpBox, Foldout, ProgressBar (tytuł), TextField (etykieta i podpowiedź), DropdownField (etykieta i wybory), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), oraz podpowiedzi (Tooltips)</strong> na dowolnym elemencie. Identyfikatory są stabilne przy zmianie nazw, jeśli ID są ustawione w UI Builderze.",
  "p_window_footer": "Wyświetla bieżący status, postęp operacji w tle oraz wersję narzędzia.",
  "p_window_header": "Górny pasek zapewnia globalny dostęp do kontroli podglądu i narzędzi pomocniczych, które pozostają dostępne niezależnie od wybranej zakładki.",
  "p_window_sidebar": "Panel boczny obsługuje nawigację pomiędzy różnymi zakładkami funkcjonalnymi oraz narzędziami globalnego wyszukiwania.",
  "page_title": "Dokumentacja Narzędzia Lokalizacji Unity",
  "q_faq_addressables_1": "Włączyłem tryb Addressables, ale zasoby się nie ładują. Co powinienem sprawdzić?",
  "q_faq_addressables_2": "Jak dodać obsługę DeepL/Google?",
  "q_faq_addressables_3": "Migrator pokazuje błędy kompilacji po usunięciu I2/UnityLoc. Jak to naprawić?",
  "q_faq_audio_smart_update": "Jak narzędzie oszczędza kredyty API przy regenerowaniu plików audio?",
  "q_faq_components_1": "Komponent LocalizedPrefab wyłącza MonoBehaviours na oryginalnym obiekcie. Co jeśli oryginalny obiekt ma skrypt, który tworzy inne obiekty lub subskrybuje zdarzenia w Awake()?",
  "q_faq_components_2": "Jeśli oryginalny prefab (LocalizedPrefab) ma Rigidbody lub inny komponent fizyki, czy zostanie on wyłączony? Czy wpłynie to na fizykę, jeśli zlokalizowany prefab go nie ma?",
  "q_faq_components_3": "Komponent LocalizedAsset przechowuje nazwę komponentu docelowego jako ciąg znaków (_targetComponentTypeName). Co się stanie, jeśli zmienię nazwę niestandardowego skryptu komponentu lub przeniosę go do innego zestawu (Assembly Definition)? Czy LocalizedAsset przestanie dla niego działać?",
  "q_faq_components_4": "Jeśli na tym samym GameObject znajdują się dwa komponenty Image, skąd LocalizedAsset wie, który z nich zlokalizować? Czy będzie działać z obydwoma, czy tylko z pierwszym, który znajdzie?",
  "q_faq_components_5": "Dokumentacja podaje, że LocalizedPrefab ma kolejność wykonania -100. Co jeśli mam inny skrypt z kolejnością wykonania -110, który próbuje znaleźć obiekt podrzędny utworzony przez LocalizedPrefab w swoim Awake()? Czy LocalizedPrefab zdążył już utworzyć swoją instancję na czas?",
  "q_faq_components_6": "Komponent LocalizedText ma opcję isStyleOnly. Jeśli ją włączę, a następnie wywołam w kodzie myLocalizedText.SetFormattedText(\"new_key\"), czy tekst się zmieni, czy tylko styl (czcionka/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour automatycznie znajduje metody z atrybutem [OnLanguageChange]. Czy znajdzie metody prywatne i chronione, czy muszą być publiczne?",
  "q_faq_components_8": "Komponent LocalizedAsset przechwytuje Play on Awake. Co się stanie, jeśli inny skrypt na tym samym obiekcie spróbuje uzyskać dostęp do zasobu (np. audioSource.clip.length) w Awake() lub Start() przed zamianą go przez LocalizedAsset? Czy możliwe jest NullReferenceException lub użycie starego zasobu?",
  "q_faq_custom_keys_attribute": "Czy mogę używać własnego atrybutu dla kluczy zamiast [LocalizableField]?",
  "q_faq_custom_provider_1": "Dlaczego mój niestandardowy dostawca nie pojawia się w rozwijanej liście Ustawień?",
  "q_faq_editor_1": "Co ma wyższy priorytet dla walidacji placeholderów: dyrektywa @placeholders: w komentarzu, czy placeholdery znalezione w tekście języka źródłowego? Na przykład, jeśli tekst źródłowy ma {name}, a komentarz mówi @placeholders: {username}.",
  "q_faq_editor_2": "Jeśli zrobię literówkę w dyrektywie (np. @placeholder: zamiast @placeholders:), czy zostanie ona zignorowana, czy narzędzie zgłosi ostrzeżenie?",
  "q_faq_editor_3": "System automatycznego zapisywania tworzy pliki w folderze Backups/AutoSaves. Czy te pliki zostaną automatycznie usunięte po pomyślnym ręcznym zapisie lub zamknięciu okna?",
  "q_faq_editor_4": "Jeśli zmienię szerokości kolumn w edytorze, czy te ustawienia zostaną zapisane między sesjami Unity?",
  "q_faq_editor_5": "Czy wyskakujące okienko edycji tekstu (MultiLineEditWindow) obsługuje własny stos Cofnij/Ponów (poprzez Ctrl+Z) dla zmian wprowadzonych w jego obrębie?",
  "q_faq_examples_1": "Co się stanie, jeśli nazwy właściwości w typie anonimowym przekazanym do funkcji _() nie będą pasować do placeholderów w ciągu znaków? Na przykład, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Czy wystąpi błąd, czy placeholder po prostu nie zostanie zastąpiony?",
  "q_faq_examples_2": "Atrybut [LocalizableField] działa dla pól prywatnych. Czy będzie działać dla pól statycznych?",
  "q_faq_examples_3": "Jeśli umieszczę atrybut [OnLanguageChange] na metodzie z parametrami (np. void UpdateUI(string newLang)), co się stanie? Czy wystąpi błąd kompilacji, czy ostrzeżenie w runtime?",
  "q_faq_examples_4": "Używam _(\"apple_count\", count). Jeśli dla bieżącego języka nie ma klucza apple_count_one (dla count = 1), którą formę wybierze system? Czy użyje apple_count_other jako awaryjnej?",
  "q_faq_examples_5": "Funkcja _(\"key\", new { username = \"Alex\" }) używa typu anonimowego. Czy nie spowoduje to nadmiernego „obciążenia” dla garbage collector (GC) przy częstych wywołaniach w metodzie Update() w porównaniu do przekazania wstępnie utworzonego Dictionary<string, object>?",
  "q_faq_examples_6": "Moja metoda oznaczona [OnLanguageChange] nie jest wywoływana. Dlaczego?",
  "q_faq_extending_1": "Czy mój niestandardowy parser zostanie wywołany automatycznie po każdym Update Keys? Czy muszę go gdzieś zarejestrować, czy wystarczy mieć w projekcie klasę, która implementuje ITextComponentParser?",
  "q_faq_extending_2": "Co jeśli w moim niestandardowym parserze wystąpi wyjątek? Czy przerwie on cały proces parsowania, czy narzędzie bezpiecznie przejdzie do innych parserów?",
  "q_faq_installation_1": "Co się stanie, jeśli mój projekt ma już pakiet com.unity.nuget.newtonsoft-json z innego zasobu? Czy instalator zależności spróbuje go zaktualizować czy zignorować?",
  "q_faq_installation_2": "Przypadkowo kliknąłem „Pomiń na razie” i zaznaczyłem „Nie pytaj ponownie” dla opcjonalnych zależności (np. dla obsługi CSV). Jak mogę ponownie wywołać okno instalatora, aby je zainstalować?",
  "q_faq_installation_3": "Narzędzie nie utworzyło pliku LocalizationSettings.asset w Assets/Resources. Dlaczego tak się stało i czy mogę go utworzyć ręcznie poprzez menu Assets -> Create?",
  "q_faq_installation_4": "Czy mogę przenieść plik LocalizationSettings.asset do innego folderu Resources, na przykład Assets/MyGame/Resources? Czy narzędzie nadal go znajdzie?",
  "q_faq_installation_5": "Instalator zależności zawiesił się lub zgłosił błąd. Czy mogę zainstalować zależności (Newtonsoft Json, Editor Coroutines) ręcznie poprzez Unity Package Manager?",
  "q_faq_notes_1": "Dokumentacja zaleca dodanie LanguageSelector do listy ignorowania. Co dokładnie się zepsuje, jeśli o tym zapomnę? Czy zostaną utworzone dodatkowe klucze dla „Option A, Option B”?",
  "q_faq_notes_2": "Jeśli zapomnę dodać pusty LocalizedText z zaznaczonym polem isStyleOnly na Label wewnątrz TMP_Dropdown używanego przez LanguageSelector, czy czcionka się nie zmieni? Dlaczego jest to konieczne?",
  "q_faq_notes_3": "Wywoływanie _() w metodzie Update() jest niezalecane. Ale co jeśli muszę aktualizować tekst w każdej klatce (np. stoper)? Jaki jest najbardziej wydajny sposób, buforując tylko ciąg formatujący?",
  "q_faq_tts_voices": "Jak przypisać konkretne głosy do postaci?",
  "q_faq_window_actions_1": "Co się stanie, jeśli połączenie internetowe zostanie utracone podczas masowego auto-tłumaczenia? Czy narzędzie ponowi próbę wysłania nieudanej partii zgodnie z Polityką Ponawiania, czy proces zostanie całkowicie przerwany?",
  "q_faq_window_actions_2": "Jeśli zaimportuję plik CSV, który zawiera klucze już istniejące w projekcie, ale z pustymi wartościami dla niektórych języków, czy te puste wartości zastąpią moje istniejące tłumaczenia, czy zostaną zignorowane?",
  "q_faq_window_actions_3": "Sekcja „Strefa Zagrożenia” umożliwia usunięcie wszystkich komponentów. Czy usunie ona komponenty z prefabów, które znajdują się w folderach nieokreślonych w Folderach Prefabów na zakładce Zawartość?",
  "q_faq_window_actions_4": "Podczas importowania z Google Sheets, jak powinienem sformatować kolumnę komentarzy, aby działała walidacja placeholderów za pomocą dyrektywy @placeholders:?",
  "q_faq_window_actions_5": "Czy narzędzie może importować dane z wielu arkuszy jednego dokumentu Google Sheets, czy działa tylko z jednym arkuszem na GID?",
  "q_faq_window_assets_1": "Co jeśli mam dwa zasoby o tym samym kluczu, ale różnych typach w tym samym folderze skanowania (np. sound_effect_en.mp3 i sound_effect_en.wav)? Który z nich trafi do tabeli zasobów?",
  "q_faq_window_assets_2": "Jeśli kliknę Scan Assets & Analyze Project, a w scenie jest obiekt Image, dla którego już istnieje zlokalizowany sprite, ale sam obiekt Image nie ma jeszcze komponentu LocalizedAsset, czy narzędzie doda komponent i automatycznie wstawi klucz?",
  "q_faq_window_assets_3": "Czy mogę używać tej samej Reguły Nazewnictwa dla różnych kategorii zasobów, jeśli mają różne Foldery Skanowania? Czy spowoduje to konflikty?",
  "q_faq_window_assets_4": "Jeśli lokalizowalny zasób (np. button_ok_en.png) nie znajduje się w katalogu głównym Foldera Skanowania, ale w podfolderze, czy skaner go znajdzie?",
  "q_faq_window_content_1": "Co jeśli dodam do Scen do Parsowania scenę, która nie jest uwzględniona w Build Settings? Czy wpłynie to na coś poza samym procesem parsowania?",
  "q_faq_window_content_2": "Dodałem obiekt do Ignoruj Konkretne Obiekty (tymczasowa lista). Jeśli utworzę prefab z tego obiektu, czy instancja tego prefabu również zostanie zignorowana?",
  "q_faq_window_content_3": "Jeśli dodam komponent TMPro.TMP_Text do Parsing Ignores -> Ignore Component Types, ale w scenie jest obiekt z LocalizedText, który już odwołuje się do tego TMP_Text, co się stanie przy następnym Update Keys? Czy klucz zostanie usunięty?",
  "q_faq_window_content_4": "Dokumentacja mówi, że „Przypnij” zapisuje pełną ścieżkę do obiektu i zepsuje się, jeśli zostanie on przemianowany. Co jeśli utworzę prefab z obiektu, a następnie zmienię nazwę oryginalnego obiektu — czy „Przypnij” będzie nadal działać dla instancji prefabu?",
  "q_faq_window_content_5": "Jeśli użyję „Przypnij” dla obiektu podrzędnego wewnątrz instancji prefabu, jaka ścieżka zostanie zapisana: względna do korzenia prefabu czy korzenia sceny? Czy będzie działać w innych scenach?",
  "q_faq_window_preview_1": "Otworzyłem prefab w Trybie Prefabu, zastosowałem Podgląd w Edytorze i nacisnąłem Ctrl+S. Czy tymczasowe dane podglądu zostaną zapisane w zasobie prefabu? Jak LocalizationPreviewProtector obsługuje ten przypadek?",
  "q_faq_window_preview_2": "Jeśli włączę Podgląd w Edytorze i edytor Unity się zawiesi, a plik Temp/localization_preview_recovery.json zostanie uszkodzony (np. pusty lub nieprawidłowy JSON), co się stanie przy następnym uruchomieniu?",
  "q_faq_window_preview_3": "W trybie Podglądu w Edytorze dla LocalizedPrefab tworzona jest tymczasowa instancja. Czy metody Awake() i Start() zostaną wykonane na tej instancji? Czy może to powodować błędy, jeśli nie są one zaprojektowane do uruchamiania w Edit Mode?",
  "q_faq_window_report_1": "Przycisk „Find” wyszukuje obiekt asynchronicznie. Co się stanie, jeśli uruchomię wyszukiwanie, a następnie natychmiast kliknę Update Keys? Czy wyszukiwanie zostanie przerwane?",
  "q_faq_window_report_2": "Jeśli klucz jest używany w wielu miejscach (np. na dwóch różnych przyciskach w różnych scenach), jak zostanie to wyświetlone w raporcie w kategorii „Duplicates”?",
  "q_faq_window_report_3": "Jeśli kliknę „Find” dla klucza, który jest używany tylko w kodzie (poprzez funkcję _()), co się stanie? Czy narzędzie będzie w stanie znaleźć i podświetlić skrypt C#?",
  "q_faq_window_settings_1": "Mogę zmienić Tryb Generowania Kluczy z UseTextAsKey na AutoGenerateKeysOnly w trakcie projektu. Co dokładnie stanie się z moimi istniejącymi tłumaczeniami? Czy zostaną zmapowane do nowych kluczy?",
  "q_faq_window_settings_2": "Jeśli dodam do listy Obsługiwanych Języków język z kodem, który nie ma reguł pluralizacji (np. „kz” dla kazachskiego), która reguła zostanie użyta domyślnie?",
  "q_faq_window_settings_3": "Co jeśli określę Ścieżkę Tłumaczeń nie w StreamingAssets, ale w regularnym folderze, takim jak Assets/MyTranslations? Czy pliki json zostaną uwzględnione w buildzie gry?",
  "q_faq_window_settings_4": "Klucz API do auto-tłumaczenia jest przechowywany w EditorPrefs. Jeśli pracuję nad projektem na dwóch różnych komputerach, czy muszę wprowadzić klucz na każdej maszynie osobno?",
  "tip_best_practice": "<strong>Profesjonalna wskazówka:</strong> Jeśli potrzebujesz zlokalizować właściwość, utwórz pole wspierające za pomocą <code>[LocalizableField]</code> i udostępnij właściwość osobno.",
  "toc_search_placeholder": "Szukaj w dokumentacji...",
  "toc_title": "Spis Treści",
  "toggle_notes_title": "Przełącz Notatki",
  "warning_box_components": "<strong>Ważna Uwaga:</strong> Wszystkie opisane poniżej komponenty są dodawane do obiektów gry automatycznie podczas parsowania (po kliknięciu przycisku <code>Aktualizuj Klucze</code>). Nie musisz ich dodawać ręcznie.",
  "warning_tms_overwrite": "<strong>Ostrzeżenie:</strong> Pobieranie z TMS nadpisze lokalne tłumaczenia dla pasujących kluczy. Upewnij się, że Twój TMS jest jedynym źródłem prawdy."
}