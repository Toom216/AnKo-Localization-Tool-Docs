{
    "page_title": "Dokumentacja Narzędzia Lokalizacyjnego Unity",
    "toc_title": "Spis treści",
    "toc_search_placeholder": "Przeszukaj dokumentację...",
    "nav_introduction": "1. Wprowadzenie",
    "nav_quick_start": "2. Szybki start",
    "nav_components": "3. Główne komponenty",
    "nav_loc_tool_window": "4. Okno \"Localization Tool\"",
    "nav_translation_editor": "5. Edytor tłumaczeń",
    "nav_usage_examples": "6. Przykłady użycia",
    "nav_important_notes": "7. Ważne uwagi",
    "nav_extending": "8. Rozszerzanie funkcjonalności",
    "nav_faq": "9. FAQ i rozwiązywanie problemów",
    "nav_key_features": "Kluczowe funkcje",
    "nav_installation": "2.1. Instalacja",
    "nav_initial_setup": "2.2. Wstępna konfiguracja",
    "nav_localizedtext": "3.1. LocalizedText",
    "nav_localizedasset": "3.2. LocalizedAsset",
    "nav_localizedprefab": "3.3. LocalizedPrefab",
    "nav_uitklocalization": "3.4. UITKLocalization",
    "nav_localizeddropdown": "3.5. LocalizedDropdown",
    "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
    "nav_context_menu": "3.7. Menu kontekstowe",
    "nav_in_editor_preview": "4.1. Podgląd w edytorze",
    "nav_tab_settings": "4.2. Zakładka \"Ustawienia\"",
    "nav_tab_content": "4.3. Zakładka \"Zawartość\"",
    "nav_tab_actions": "4.4. Zakładka \"Akcje\"",
    "nav_tab_assets": "4.5. Zakładka \"Zasoby\"",
    "nav_tab_report": "4.6. Zakładka \"Raport\"",
    "nav_example_components": "6.1. Gotowe komponenty",
    "nav_example_attribute": "6.2. Atrybut [LocalizableField]",
    "nav_example_function": "6.3. Funkcja _()",
    "nav_example_plurals": "6.4. Liczba mnoga i płeć",
    "nav_custom_parser": "8.1. Tworzenie parsera niestandardowego",
    "nav_faq_installation": "9.1. Instalacja i szybki start",
    "nav_faq_components": "9.2. Główne komponenty",
    "nav_faq_window": "9.3. Okno \"Localization Tool\"",
    "nav_faq_window_actions": "9.3. Okno \"Localization Tool\" - Zakładka \"Akcje\"",
    "nav_faq_window_assets": "9.3. Okno \"Localization Tool\" - Zakładka \"Zasoby\"",
    "nav_faq_window_report": "9.3. Okno \"Localization Tool\" - Zakładka \"Raport\"",
    "nav_faq_editor": "9.4. Edytor tłumaczeń",
    "nav_faq_examples": "9.5. Przykłady użycia i kod",
    "nav_faq_notes": "9.6. Ważne niuanse i ostrzeżenia",
    "nav_faq_extending": "9.7. Rozszerzanie funkcjonalności",
    "h1_introduction": "Wprowadzenie",
    "p_intro_1": "To narzędzie jest kompleksowym rozwiązaniem do lokalizacji gier i aplikacji w Unity. Automatyzuje proces zbierania tekstów i zasobów, zarządzania tłumaczeniami za pomocą potężnego interfejsu, integracji z usługami tłumaczenia maszynowego oraz dynamicznej aktualizacji zlokalizowanej zawartości w grze.",
    "h2_key_features": "Kluczowe funkcje",
    "li_feature_1": "<strong>Zaawansowane parsowanie:</strong> Automatyczne skanowanie scen, prefabrykatów, UI Toolkit (UXML) i skryptów C#, w tym pól oznaczonych atrybutem <code>[LocalizableField]</code>, a także zagnieżdżonych klas i list.",
    "li_feature_2": "<strong>Lokalizacja dowolnych zasobów:</strong> Zarządzaj sprite'ami, dźwiękiem, prefabrykatami, materiałami itp.",
    "li_feature_3": "<strong>Potężny edytor tłumaczeń:</strong> Scentralizowany interfejs z automatycznym zapisem, pełnym wsparciem dla Cofnij/Ponów i inteligentnym grupowaniem kluczy.",
    "li_feature_4": "<strong>Tłumaczenie maszynowe:</strong> Integracja z DeepL, Google Translate i Microsoft Translator z elastycznymi ustawieniami (rozmiar partii, liczba ponownych prób) dla każdej usługi.",
    "li_feature_5": "<strong>Elastyczny import/eksport:</strong> Obsługa formatów CSV, XML, YAML, XLIFF oraz bezpośredni import z Arkuszy Google.",
    "li_feature_6": "<strong>Podgląd na żywo w edytorze:</strong> Podglądaj dowolny język bez uruchamiania gry.",
    "li_feature_7": "<strong>Obsługa liczby mnogiej i płci:</strong> Poprawne obsługiwanie form liczby mnogiej (z zasadami dla języków słowiańskich, arabskich i innych) oraz płci.",
    "li_feature_8": "<strong>Pełne wsparcie RTL:</strong> Poprawne wyświetlanie języków pisanych od prawej do lewej.",
    "li_feature_9": "<strong>Aktualizacje na żywo:</strong> Wczytuj aktualne tłumaczenia ze zdalnego serwera przy uruchomieniu gry.",
    "li_feature_10": "<strong>Menedżer kopii zapasowych:</strong> Wbudowane narzędzie do tworzenia i przywracania kopii zapasowych.",
    "h1_quick_start": "Szybki start i konfiguracja",
    "h2_installation": "2.1. Instalacja",
    "li_install_1": "Skopiuj zasób do folderu projektu Unity.",
    "li_install_2": "Narzędzie automatycznie sprawdzi niezbędne zależności. Potwierdź instalację w wyświetlonym oknie dialogowym.",
    "li_install_3": "Wymagane zależności (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) są niezbędne do podstawowej funkcjonalności.",
    "li_install_4": "Opcjonalne zależności (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) włączają dodatkowe funkcje.",
    "li_install_5": "Kliknij <strong>Zainstaluj wybrane</strong>, aby zainstalować zalecane pakiety.",
    "li_install_6": "Po instalacji otwórz główne okno narzędzia za pomocą menu <strong>Tools -> Localization Tool</strong>.",
    "h2_initial_setup": "2.2. Wstępna konfiguracja",
    "li_setup_1": "<strong>Utwórz ustawienia:</strong> Przy pierwszym otwarciu narzędzie utworzy plik <code>LocalizationSettings.asset</code> w folderze <code>Assets/Resources</code>.",
    "li_setup_2": "<strong>Skonfiguruj języki:</strong> W zakładce <strong>Ustawienia</strong> w sekcji <strong>Zarządzanie językami</strong> upewnij się, że Twój główny język (np. <code>en</code> dla angielskiego) jest wybrany jako <strong>Język źródłowy</strong>. Włącz wszystkie języki, które planujesz obsługiwać.",
    "li_setup_3": "<strong>Określ zawartość do parsowania:</strong> W zakładce <strong>Zawartość</strong> dodaj wszystkie sceny do analizy do listy <strong>Sceny do sparsowania</strong>. Jeśli używasz prefabrykatów z tekstem, upewnij się, że ich foldery są dodane do <strong>Folderów prefabrykatów</strong>.",
    "li_setup_4": "<strong>Pierwsze uruchomienie parsera:</strong> Przejdź do zakładki <strong>Akcje</strong> i kliknij przycisk <code>Aktualizuj klucze</code>. Narzędzie przeskanuje Twój projekt, utworzy pliki tłumaczeń i automatycznie doda niezbędne komponenty (<code>LocalizedText</code>, <code>LocalizedAsset</code> itp.) do obiektów gry.",
    "h1_components": "Główne komponenty (przypisywane automatycznie)",
    "warning_box_components": "<strong>Ważna uwaga:</strong> Wszystkie opisane poniżej komponenty są dodawane do obiektów gry automatycznie podczas parsowania (po kliknięciu przycisku <code>Aktualizuj klucze</code>). Nie musisz dodawać ich ręcznie.",
    "p_components_intro": "Te komponenty są \"mostem\" między Twoimi obiektami na scenie a bazą danych tłumaczeń. \"Nasłuchują\" zmian języka i automatycznie podstawiają odpowiedni tekst lub zasób.",
    "h2_localizedtext": "3.1. LocalizedText",
    "p_localizedtext_1": "Główny komponent do wyświetlania przetłumaczonego tekstu. Umieszczany jest na obiektach z <code>Text</code>, <code>TMP_Text</code> i <code>TextMesh</code>.",
    "li_localizedtext_1": "<code>localizationKey</code>: Klucz używany do znalezienia tłumaczenia. Generowany automatycznie.",
    "li_localizedtext_2": "<code>isStyleOnly</code>: Jeśli <code>true</code>, komponent zastosuje tylko style (czcionkę, RTL), ale nie zmieni samego tekstu. Przydatne dla elementów, których tekst jest zarządzany przez inny skrypt (np. <code>LanguageSelector</code>).",
    "li_localizedtext_3": "<code>originalSourceText</code>: Oryginalny tekst w języku bazowym. Używany jako rezerwa.",
    "h2_localizedasset": "3.2. LocalizedAsset",
    "p_localizedasset_1": "Służy do zamiany zasobów (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code> itp.). Automatycznie wykrywa typ komponentu docelowego na obiekcie (<code>Image</code>, <code>AudioSource</code>) i zastępuje jego zasób.",
    "p_localizedasset_2": "Dla komponentów z opcją <strong>Play on Awake</strong> (jak <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> poprawnie przechwytuje automatyczne odtwarzanie, zamienia zasób, a następnie rozpoczyna odtwarzanie, aby uniknąć odtwarzania niezlokalizowanej zawartości.",
    "h2_localizedprefab": "3.3. LocalizedPrefab",
    "p_localizedprefab_1": "Komponent do lokalizacji całych prefabrykatów. Działa niedestrukcyjnie: nie modyfikuje oryginalnego prefabrykatu, ale tworzy instancję zlokalizowanej wersji jako obiekt potomny, wyłączając wszystkie skrypty (<code>MonoBehaviour</code>), renderery (<code>Renderer</code>) i collidery (<code>Collider</code>) na oryginalnym obiekcie. Zapobiega to podwójnemu wykonywaniu logiki i artefaktom wizualnym. Dla poprawnego działania w czasie rzeczywistym, jego kolejność wykonywania jest ustawiona na -100 (<code>[DefaultExecutionOrder(-100)]</code>), aby zapewnić jego uruchomienie przed innymi skryptami.",
    "h2_uitklocalization": "3.4. UITKLocalization",
    "p_uitklocalization_1": "Dodawany do obiektów z <code>UIDocument</code> i zarządza lokalizacją wszystkich elementów tekstowych w dokumencie UI Toolkit (UXML).",
    "h2_localizeddropdown": "3.5. LocalizedDropdown",
    "p_localizeddropdown_1": "Dodawany do <code>Dropdown</code> i <code>TMP_Dropdown</code> w celu przetłumaczenia ich opcji.",
    "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
    "p_localizedbehaviour_1": "Komponent narzędziowy, który pozwala Twoim skryptom reagować na zmiany języka. Automatycznie znajduje i wywołuje metody oznaczone atrybutem <code>[OnLanguageChange]</code>.",
    "h2_context_menu": "3.7. Menu kontekstowe \"Analizuj pod kątem lokalizacji\"",
    "p_context_menu_1": "Aby szybko dodać <code>LocalizedAsset</code> do obiektu, możesz kliknąć prawym przyciskiem myszy na żądanym komponencie (np. <code>Image</code>, <code>AudioSource</code>) w inspektorze i wybrać <strong>Analizuj pod kątem lokalizacji</strong>. Narzędzie samo doda i skonfiguruje komponent. (Jest to opcjonalne, ale może być używane do ręcznego dodawania).",
    "h1_loc_tool_window": "Okno \"Localization Tool\"",
    "h2_in_editor_preview": "4.1. Podgląd w edytorze",
    "p_preview_1": "Bezpośrednio pod nagłówkiem znajduje się rozwijana lista <strong>Język podglądu</strong>. Ta potężna funkcja pozwala zobaczyć, jak lokalizacja będzie wyglądać w dowolnym języku bezpośrednio w oknie <strong>Scena</strong>, bez uruchamiania gry.",
    "li_preview_1": "<strong>Jak to działa:</strong> Wybierz język z listy, a narzędzie natychmiast zastosuje odpowiednie tłumaczenia, czcionki, ustawienia RTL i zasoby do wszystkich lokalizowalnych obiektów w aktywnej scenie.",
    "li_preview_2": "<strong>Placeholdery:</strong> Jeśli w zakładce <strong>Ustawienia</strong> wybrany jest styl symboli zastępczych (np. <strong>Akcenty</strong> lub <strong>Nawiasy</strong>), te symbole zastępcze będą wyświetlane w trybie podglądu zamiast rzeczywistych tłumaczeń. Jest to idealne do testowania układu i znajdowania niezlokalizowanych elementów.",
    "li_preview_3": "<strong>Bezpieczeństwo:</strong> Wszystkie zmiany wprowadzone w trybie podglądu są tymczasowe. Narzędzie automatycznie przywróci wszystko do pierwotnego stanu po wybraniu \"<strong>Przywróć oryginał</strong>\", zamknięciu okna, zmianie sceny lub przed zapisaniem sceny/prefabrykatu (dzięki komponentowi <code>LocalizationPreviewProtector</code>).",
    "li_preview_4": "<strong>Ochrona przed awarią:</strong> Wbudowany system <code>PreviewCrashProtector</code> automatycznie przywróci oryginalny stan obiektów, jeśli edytor Unity ulegnie awarii podczas aktywnego podglądu.",
    "h2_tab_settings": "4.2. Zakładka \"Ustawienia\"",
    "p_settings_1": "Twoje centrum sterowania. Tutaj definiujesz globalne zasady dla całego procesu lokalizacji.",
    "li_settings_1": "<strong>Tryb generowania kluczy:</strong> Wybierz, w jaki sposób będą tworzone klucze.<ul><li><code>UseTextAsKey</code>: Sam tekst staje się kluczem. Idealny do prototypów. Wada: jeśli zmienisz tekst źródłowy, klucz się zmieni, a wszystkie jego tłumaczenia zostaną utracone.</li><li><code>AutoGenerateKeysOnly</code>: Klucz jest generowany na podstawie hierarchii i nazwy obiektu. Niezawodny w produkcji. Zaleta: tłumaczenia nie psują się po zmianie tekstu.</li><li><code>UseTextAsKeyWithCustomPriority</code> i <code>AutoGenerateWithCustomKeys</code>: Tryby hybrydowe, które pozwalają ustawić niestandardowe klucze w kodzie za pomocą atrybutu <code>[LocalizableField(\"mój_własny_klucz\")]</code>.</li><li><strong>Bezpieczna migracja:</strong> Możesz zmienić tryb w dowolnym momencie. Narzędzie automatycznie zmigruje wszystkie istniejące tłumaczenia do nowego systemu kluczy.</li></ul>",
    "li_settings_2": "<strong>Zarządzanie językami:</strong> Skonfiguruj listę języków. Dla języków ze znakami specjalnymi przypisz odpowiedni <strong>Zasób czcionki</strong>. Włącz opcję <strong>RTL</strong> dla języków pisanych od prawej do lewej.",
    "li_settings_3": "<strong>Ustawienia ogólne:</strong><ul><li><code>Parse Prefabs</code>: Włącza parsowanie prefabrykatów.</li><li><code>Split files by language</code>: Określa, jak przechowywać tłumaczenia (jeden duży plik lub jeden plik na język).</li><li><code>Translations Path</code>: Ścieżka do przechowywania plików tłumaczeń <code>.json</code>. Ważne: folder musi znajdować się wewnątrz <code>Assets/StreamingAssets/</code>.</li></ul>",
    "li_settings_4": "<strong>Debugowanie i testowanie:</strong><ul><li><code>Placeholder Style</code>: Wybierz styl wyświetlania symboli zastępczych w trybie podglądu.</li></ul>",
    "li_settings_5": "<strong>Aktualizacje na żywo:</strong> Ustawienia wczytywania tłumaczeń ze zdalnego serwera.",
    "li_settings_6": "<strong>Klucz API środowiska uruchomieniowego:</strong> Sekcja do bezpiecznego przechowywania klucza API, który może być potrzebny w skompilowanej grze (przechowywany w zaszyfrowanej formie).",
    "h2_tab_content": "4.3. Zakładka \"Zawartość\"",
    "p_content_1": "Tutaj informujesz narzędzie, gdzie dokładnie ma szukać tekstu.",
    "li_content_1": "<strong>Sceny do sparsowania:</strong> Przeciągnij i upuść tutaj wszystkie sceny do analizy.",
    "li_content_2": "<strong>Foldery prefabrykatów:</strong> Określ foldery z prefabrykatami.",
    "li_content_3": "<strong>Teksty dynamiczne:</strong> Wprowadź tutaj ciągi znaków, które są tworzone wyłącznie w kodzie (np. \"Koniec gry\").",
    "li_content_4": "<strong>Ignorowanie parsowania:</strong> Określ skrypty, komponenty lub obiekty do zignorowania.",
    "li_content_5": "<strong>Przypnij:</strong> Ta funkcja pozwala \"przypiąć\" obiekt ze sceny do listy ignorowanych. Zamiast tymczasowego odwołania do obiektu, narzędzie zapisze jego pełną ścieżkę w hierarchii, dzięki czemu ignorowanie będzie trwałe między sesjami (pamiętaj jednak, że zmiana nazwy obiektu lub jego rodzica zerwie to połączenie).",
    "h2_tab_actions": "4.4. Zakładka \"Akcje\"",
    "p_actions_1": "Główna zakładka robocza.",
    "li_actions_1": "<strong>Aktualizuj klucze:</strong> Uruchamia parser, który aktualizuje pliki tłumaczeń.",
    "li_actions_2": "<strong>Otwórz edytor tłumaczeń:</strong> Otwiera osobne, wygodniejsze okno do edycji wszystkich tłumaczeń.",
    "li_actions_3": "<strong>Zarządzanie danymi:</strong> Służy do wymiany danych z tłumaczami (Eksport/Import do CSV/XML/YAML/XLIFF, import z Arkuszy Google).",
    "li_actions_4": "<strong>Automatyczne tłumaczenie:</strong> Automatycznie wypełnia wszystkie puste ciągi tłumaczeń. Nowe ustawienia pozwalają zarządzać rozmiarem partii (<strong>Rozmiar partii</strong>) i polityką ponawiania (<strong>Polityka ponawiania</strong>) dla każdej usługi (DeepL, Google, Microsoft) osobno. Narzędzie śledzi liczbę przetłumaczonych znaków i ostrzega o potencjalnym przekroczeniu limitu.",
    "li_actions_5": "<strong>Strefa niebezpieczna:</strong> Zawiera przyciski do całkowitego usunięcia wszystkich komponentów lokalizacyjnych z projektu. Używaj z ostrożnością!",
    "h2_tab_assets": "4.5. Zakładka \"Zasoby\"",
    "p_assets_1": "Ta zakładka jest w całości poświęcona lokalizacji zasobów nietekstowych.",
    "li_assets_1": "<strong>Utwórz strukturę folderów (opcjonalnie):</strong> W sekcji <strong>2. Generowanie folderów zasobów</strong> kliknij <strong>Utwórz foldery zasobów teraz</strong>.",
    "li_assets_2": "<strong>Skonfiguruj kategorie i zasady nazewnictwa:</strong> W sekcji <strong>3. Kategorie zasobów i skanowanie</strong> upewnij się, że <strong>Zasada nazewnictwa</strong> (<code>{key}_{lang}</code>) pasuje do Twoich plików (np. <code>przycisk_ok_pl.png</code>).",
    "li_assets_3": "<strong>Umieść swoje zasoby:</strong> Umieść zlokalizowane zasoby w folderach.",
    "li_assets_4": "<strong>Skanuj zasoby:</strong> W sekcji <strong>4. Automatyzacja</strong> kliknij <strong>Skanuj zasoby i aktualizuj tabele</strong>. Proces czyszczenia stał się bezpieczniejszy: teraz usuwane są tylko stare pliki tabel (<code>.asset</code>), a nie cały folder.",
    "li_assets_5": "<strong>Połącz zasoby z obiektami:</strong> Kliknij <strong>Analizuj projekt i dołącz komponenty</strong>.",
    "h2_tab_report": "4.6. Zakładka \"Raport\"",
    "p_report_1": "Po każdym parsowaniu ten raport pokazuje pełny obraz stanu Twojej lokalizacji.",
    "li_report_1": "<strong>Kategorie:</strong> Wszystkie klucze, Dodane, Zaktualizowane (tekst zmieniony), Usunięte, Duplikaty, Zmigrowane, Pominięte (niezmienione).",
    "li_report_2": "<strong>Wyszukiwanie zaawansowane:</strong> Kliknij przycisk <strong>Znajdź</strong> obok dowolnego wpisu, aby natychmiast znaleźć odpowiedni obiekt w projekcie. Wyszukiwanie działa asynchronicznie, nie blokując edytora, i przeszukuje wszystkie sceny i prefabrykaty. Jeśli klucz jest używany w wielu miejscach, pojawi się rozwijana lista ze wszystkimi źródłami.",
    "h1_translation_editor": "Edytor tabeli tłumaczeń",
    "p_editor_1": "Otwierany za pomocą <strong>Tools -> Localization -> Translation Table Editor</strong>. Jest to główne narzędzie do ręcznej edycji tłumaczeń.",
    "li_editor_1": "<strong>Inteligentne grupowanie:</strong> Klucze dla liczby mnogiej i płci (np. <code>apple_count_one</code>, <code>apple_count_few</code>) są automatycznie łączone w zwijane grupy.",
    "li_editor_2": "<strong>Zaawansowana edycja:</strong> Kliknij na komórkę, aby otworzyć okno podręczne <strong>MultiLineEditWindow</strong>. Pokazuje ono tekst źródłowy do porównania, pozwala szybko go skopiować i sprawdza w czasie rzeczywistym niedopasowania symboli zastępczych (np. <code>{username}</code>), podświetlając brakujące lub dodatkowe.",
    "li_editor_3": "<strong>Walidacja symboli zastępczych za pomocą komentarzy:</strong> Możesz jawnie określić, które symbole zastępcze powinny znajdować się w tłumaczeniu, dodając specjalną dyrektywę do komentarza klucza, na przykład: <code>@placeholders: {username}, {score}</code>. <strong>MultiLineEditWindow</strong> użyje tej listy jako głównego źródła prawdy.",
    "li_editor_4": "<strong>Nawigacja i zarządzanie:</strong> Poruszaj się po tabeli za pomocą pasków przewijania lub przytrzymując środkowy przycisk myszy. Zmieniaj szerokość kolumn, przeciągając separatory. Zapisz zmiany za pomocą <code>Ctrl+S</code>.",
    "li_editor_5": "<strong>Pełne Cofnij/Ponów:</strong> Cały stos działań (zmiany tekstu, dodawanie/usuwanie kluczy) jest w pełni obsługiwany za pomocą <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.",
    "li_editor_6": "<strong>Kopie zapasowe i autozapis:</strong> Użyj przycisku <strong>Zarządzaj kopiami zapasowymi</strong>. Narzędzie automatycznie zapisuje również sesję co kilka minut. W przypadku awarii zostaniesz poproszony o przywrócenie zmian.",
    "h1_usage_examples": "Przykłady użycia",
    "h2_example_components": "6.1. Gotowe komponenty i przykłady",
    "p_example_components_1": "Projekt zawiera gotowe do użycia skrypty, które służą jako doskonałe przykłady.",
    "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Gotowy komponent do tworzenia listy rozwijanej interfejsu użytkownika do przełączania języków. Automatycznie znajduje wszystkie dostępne języki i zarządza ich przełączaniem.<br><strong>Jak używać:</strong> Po prostu dodaj komponent <code>LanguageSelector</code> do swojej sceny (np. do pustego obiektu GameObject) i określ swój <code>TMP_Dropdown</code> w inspektorze.",
    "li_example_components_2": "<strong>Przykłady kodu:</strong> Aby nauczyć się zaawansowanych technik, takich jak praca z <code>[LocalizableField]</code>, funkcją <code>_()</code>, liczbą mnogą i płcią, przestudiuj pliki <code>StatPurchaseTest.cs</code> i <code>TestLocalization.cs</code>. Wyraźnie demonstrują one implementację wszystkich głównych funkcji narzędzia w kodzie.",
    "h2_example_attribute": "6.2. Atrybut [LocalizableField]",
    "p_example_attribute_1": "Preferowana metoda dla tekstów, które są częścią konfiguracji komponentu w inspektorze. Parser może teraz pracować z ciągami znaków, listami/tablicami ciągów znaków, a nawet polami w zagnieżdżonych klasach <code>[System.Serializable]</code>.",
    "code_example_attribute": "using Ankonoanko.Localization; // Wymagane dla [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // Parser znajdzie to pole i utworzy dla niego klucz\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"Nie udało ci się ukończyć zadania.\";\n    \n    // Możesz ustawić niestandardowy klucz\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Czy jesteś gotów na przygodę?\";\n    \n    // Działa z listami\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Znajdź skarb\" };\n    \n    // A nawet z zagnieżdżonymi klasami!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
    "h2_example_function": "6.3. Funkcja _() i atrybut [OnLanguageChange]",
    "p_example_function_1": "Użyj funkcji <code>_()</code> dla tekstu dynamicznego, który zmienia się podczas rozgrywki. Metoda aktualizująca interfejs użytkownika powinna być oznaczona atrybutem <code>[OnLanguageChange]</code>, aby była wywoływana automatycznie po zmianie języka. W tym celu do obiektu zostanie automatycznie dodany komponent <code>LocalizedBehaviour</code>.",
    "code_example_function": "// Aby użyć krótkiego wywołania _(), dodaj te linie\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Wymagane dla [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Początkowa aktualizacja\n    }\n    \n    // Ta metoda będzie wywoływana automatycznie po zmianie języka\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Indeksowane symbole zastępcze (jak w string.Format)\n        // Klucz: \"score_label\", Tekst w pliku: \"Wynik: {0}\"\n        scoreText.text = _(\"score_label\", score); // Wynik: \"Wynik: 100\"\n        \n        // 2. Nazwane symbole zastępcze (zalecane dla czytelności)\n        // Klucz: \"welcome_message\", Tekst: \"Witaj, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // W złożonych przypadkach lub dla wysokiej wydajności\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
    "h2_example_plurals": "6.4. Liczba mnoga i płeć",
    "p_example_plurals_1": "Narzędzie używa teraz dokładniejszych zasad dla różnych grup językowych.",
    "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Klucze: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Teksty: \"{0} jabłko\", \"{0} jabłka\", \"{0} jabłek\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatycznie wybiera poprawną formę\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Klucze: \"user_greeted_male\", \"user_greeted_female\"\n        // Teksty: \"On przybył.\", \"Ona przybyła.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
    "h1_important_notes": "Ważne uwagi i ostrzeżenia",
    "li_notes_1": "<strong>Kopie zapasowe:</strong> Przed globalnymi operacjami (<code>Aktualizuj klucze</code>, import danych), zawsze twórz kopię zapasową za pomocą <strong>Edytor tabeli tłumaczeń -> Zarządzaj kopiami zapasowymi</strong>.",
    "li_notes_2": "<strong>Bezpieczeństwo klucza API:</strong> Klucz do pracy w edytorze jest przechowywany lokalnie na Twojej maszynie (w <code>EditorPrefs</code>) i nie trafia do repozytorium. W przypadku kluczy potrzebnych w kompilacji gry użyj sekcji <strong>Klucz API środowiska uruchomieniowego</strong>.",
    "li_notes_3": "<strong>Folder <code>StreamingAssets</code>:</strong> Pliki tłumaczeń muszą znajdować się w podfolderze <code>Assets/StreamingAssets/</code>, aby zostały uwzględnione w kompilacji gry.",
    "li_notes_4": "<strong>\"Odporność na błędy\":</strong> Narzędzie automatycznie chroni Cię przed przypadkowym zapisaniem tymczasowych danych z trybu podglądu do sceny lub prefabrykatu.",
    "li_notes_5": "<strong>Wydajność:</strong> Wywołanie <code>_()</code> jest szybkie, ale w pętlach, które działają w każdej klatce (np. w <code>Update</code>), staraj się buforować wynik w zmiennej.",
    "li_notes_6": "<strong>Wykluczenie <code>LanguageSelector</code> z parsowania:</strong> Obiekt z komponentem <code>LanguageSelector</code> i jego <code>TMP_Dropdown</code> muszą być dodane do listy <strong>Ignoruj określone obiekty</strong> w zakładce <strong>Zawartość</strong>. Jest to konieczne, aby zapobiec tworzeniu przez parser dodatkowych kluczy dla opcji listy rozwijanej, ponieważ skrypt <code>LanguageSelector</code> wypełnia je dynamicznie w czasie wykonywania. Ignorowanie zapobiega konfliktom i utrzymuje pliki tłumaczeń w czystości.",
    "li_notes_7": "<strong>Czcionki dla <code>LanguageSelector</code>:</strong> Aby wybrany język w <code>TMP_Dropdown</code> poprawnie aktualizował swoją czcionkę, ręcznie dodaj pusty komponent <code>LocalizedText</code> do podrzędnego obiektu <strong>Label</strong> listy rozwijanej i zaznacz pole <code>isStyleOnly</code>.",
    "h1_extending": "Rozszerzanie funkcjonalności",
    "h2_custom_parser": "8.1. Tworzenie niestandardowego parsera",
    "p_custom_parser_1": "Możesz łatwo rozszerzyć system o obsługę niestandardowych komponentów, tworząc własną klasę parsera.",
    "li_custom_parser_1": "Utwórz nowy skrypt C# w folderze <strong>Editor</strong> swojego projektu.",
    "li_custom_parser_2": "Skopiuj do niego poniższy szablon.",
    "li_custom_parser_3": "Zmodyfikuj logikę, aby pasowała do Twojego komponentu.",
    "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// SZABLON do tworzenia parsera dla niestandardowego komponentu.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Sprawdź, czy obiekt ma potrzebny nam niestandardowy komponent.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Wyjdź, jeśli komponent nie został znaleziony\n        }\n        \n        // 2. Pobierz tekst z pól niestandardowego komponentu.\n        string titleText = component.Title;\n        \n        // 3. Sprawdź, czy tekst jest prawidłowy do lokalizacji.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Wygeneruj klucz i źródło za pomocą pomocników z TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Zwróć wynik.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Powtórz dla innych pól...\n        // (można dodać sufiks, aby klucze były unikalne)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
    "h1_faq": "FAQ i rozwiązywanie problemów",
    "h2_faq_installation": "9.1. Instalacja i szybki start",
    "q_faq_installation_1": "Co się stanie, jeśli mój projekt ma już pakiet com.unity.nuget.newtonsoft-json z innego zasobu? Czy instalator zależności spróbuje go zaktualizować czy zignorować?",
    "a_faq_installation_1": "Instalator sprawdza istnienie typu Newtonsoft.Json.JsonConvert. Jeśli typ istnieje, uznaje zależność za spełnioną i nie będzie próbował instalować ani aktualizować pakietu. Ma to na celu zapobieganie konfliktom wersji.",
    "q_faq_installation_2": "Przypadkowo kliknąłem \"Pomiń na razie\" i zaznaczyłem \"Nie pytaj ponownie\" dla opcjonalnych zależności (np. do obsługi CSV). Jak mogę ponownie wywołać okno instalatora, aby je zainstalować?",
    "a_faq_installation_2": "Możesz ręcznie uruchomić sprawdzanie zależności w dowolnym momencie za pomocą menu Tools -> Localization -> Check Dependencies. Zresetuje to flagę \"Nie pytaj ponownie\" i ponownie pokaże okno ze wszystkimi brakującymi pakietami opcjonalnymi.",
    "q_faq_installation_3": "Narzędzie nie utworzyło pliku LocalizationSettings.asset w Assets/Resources. Dlaczego mogło się tak stać i czy mogę go utworzyć ręcznie za pomocą menu Assets -> Create?",
    "a_faq_installation_3": "Może się tak zdarzyć, jeśli nie masz folderu Assets/Resources. Narzędzie spróbuje go utworzyć, ale uprawnienia systemu plików mogą na to nie pozwolić. Tak, możesz utworzyć zasób ręcznie: kliknij prawym przyciskiem myszy w folderze Resources, wybierz Create -> Localization -> Settings. Narzędzie znajdzie go automatycznie.",
    "q_faq_installation_4": "Czy mogę przenieść plik LocalizationSettings.asset do innego folderu Resources, na przykład Assets/MyGame/Resources? Czy narzędzie go nadal znajdzie?",
    "a_faq_installation_4": "Tak. Narzędzie używa Resources.Load(), które wyszukuje zasób po nazwie we wszystkich folderach o nazwie Resources w Twoim projekcie. Ważne jest, aby plik zachował swoją nazwę LocalizationSettings.asset.",
    "q_faq_installation_5": "Instalator zależności zawiesił się lub wyświetlił błąd. Czy mogę zainstalować zależności (Newtonsoft Json, Editor Coroutines) ręcznie za pomocą Unity Package Manager?",
    "a_faq_installation_5": "Tak. Możesz otworzyć Window -> Package Manager, kliknąć ikonę \"+\" i wybrać \"Add package by name...\". Wprowadź nazwy pakietów: com.unity.nuget.newtonsoft-json i com.unity.editorcoroutines.",
    "h2_faq_components": "9.2. Główne komponenty",
    "q_faq_components_1": "Komponent LocalizedPrefab wyłącza MonoBehaviours na oryginalnym obiekcie. Co jeśli oryginalny obiekt ma skrypt, który tworzy inne obiekty lub subskrybuje zdarzenia w Awake()? Czy ten kod zostanie wykonany?",
    "a_faq_components_1": "Nie, nie zostanie. Wyłączenie MonoBehaviour uniemożliwia wywołanie wszystkich \"magicznych\" metod Unity, w tym Awake(), OnEnable() i Start(). Jest to celowe, aby uniknąć podwójnego wykonywania logiki. Cała inicjalizacja powinna odbywać się w skryptach na zlokalizowanych wersjach prefabrykatu.",
    "q_faq_components_2": "Jeśli oryginalny prefabrykat (LocalizedPrefab) ma Rigidbody lub inny komponent fizyczny, czy zostanie on wyłączony? Czy wpłynie to na fizykę, jeśli zlokalizowany prefabrykat go nie ma?",
    "a_faq_components_2": "Tak, zachowanie fizyczne oryginalnego obiektu zostanie zneutralizowane. Komponent LocalizedPrefab znajduje wszystkie komponenty Rigidbody i Rigidbody2D na swoim GameObject i ustawia ich właściwość isKinematic na true. To skutecznie usuwa je z dynamicznych obliczeń fizycznych, zapobiegając niepożądanym zachowaniom, takim jak spadanie niewidzialnego obiektu lub reagowanie na kolizje. Mimo to zaleca się, aby zlokalizowana wersja prefabrykatu zawierała wszystkie niezbędne komponenty fizyczne do poprawnego działania.",
    "q_faq_components_3": "Komponent LocalizedAsset przechowuje nazwę komponentu docelowego jako ciąg znaków (_targetComponentTypeName). Co się stanie, jeśli zmienię nazwę niestandardowego skryptu komponentu lub przeniosę go do innego zespołu (Assembly Definition)? Czy LocalizedAsset przestanie dla niego działać?",
    "a_faq_components_3": "Tak, przestanie działać. Komponent przechowuje pełną nazwę typu, w tym przestrzeń nazw i zespół. Zmiana nazwy skryptu lub przeniesienie go do innego .asmdef zmieni tę nazwę, a LocalizedAsset nie będzie w stanie znaleźć komponentu docelowego. Będziesz musiał uruchomić kolejną analizę za pomocą Analyze Project & Attach Components, aby zaktualizować nazwę.",
    "q_faq_components_4": "Jeśli na tym samym GameObject znajdują się dwa komponenty Image, skąd LocalizedAsset wie, który z nich zlokalizować? Czy zadziała z oboma, czy tylko z pierwszym, który znajdzie?",
    "a_faq_components_4": "LocalizedAsset jest tworzony dla konkretnej instancji komponentu. Przechowuje odwołanie do tego komponentu w kodzie. Jeśli ręcznie dodasz drugi LocalizedAsset i użyjesz menu kontekstowego \"Analizuj pod kątem lokalizacji\", aby wskazać drugi obraz, będziesz mieć dwa komponenty LocalizedAsset, z których każdy zarządza własnym obrazem. Automatyczny analizator utworzy komponent tylko dla pierwszego obrazu z lokalizowalnym zasobem, który znajdzie.",
    "q_faq_components_5": "Dokumentacja podaje, że LocalizedPrefab ma kolejność wykonywania -100. Co jeśli mam inny skrypt z kolejnością wykonywania -110, który próbuje znaleźć obiekt podrzędny utworzony przez LocalizedPrefab w swoim Awake()? Czy LocalizedPrefab zdąży utworzyć swoją instancję?",
    "a_faq_components_5": "Tak, zdąży. LocalizedPrefab tworzy instancję zlokalizowanego prefabrykatu w swojej metodzie OnEnable(). Kolejność wykonywania Unity gwarantuje, że wszystkie metody Awake() są wykonywane przed wszystkimi metodami OnEnable(). Zatem Twój skrypt z kolejnością -110 wykona swoje Awake(), następnie LocalizedPrefab z kolejnością -100 wykona swoje Awake(), a dopiero potem ich metody OnEnable() zostaną wywołane w kolejności. Twój skrypt nie znajdzie obiektu, ponieważ nie zostanie on jeszcze utworzony.",
    "q_faq_components_6": "Komponent LocalizedText ma opcję isStyleOnly. Jeśli ją włączę, a następnie wywołam w kodzie myLocalizedText.SetFormattedText(\"nowy_klucz\"), czy zmieni się tekst, czy tylko styl (czcionka/RTL)?",
    "a_faq_components_6": "Zmieni się zarówno klucz, jak i tekst. Wywołanie SetFormattedText programowo zastępuje zachowanie isStyleOnly dla tej konkretnej aktualizacji. Opcja isStyleOnly ma na celu uniemożliwienie komponentowi reagowania na globalne zmiany języka, ale zawsze zareaguje na bezpośrednią zmianę klucza za pomocą kodu.",
    "q_faq_components_7": "LocalizedBehaviour automatycznie znajduje metody z atrybutem [OnLanguageChange]. Czy znajdzie metody prywatne i chronione, czy muszą być publiczne?",
    "a_faq_components_7": "Znajdzie metody z dowolnym modyfikatorem dostępu (public, private, protected, internal). Refleksja w Unity pozwala na wykrycie wszystkich metod instancji niezależnie od ich poziomu dostępu.",
    "q_faq_components_8": "Komponent LocalizedAsset przechwytuje Play on Awake. Co się stanie, jeśli inny skrypt na tym samym obiekcie spróbuje uzyskać dostęp do zasobu (np. audioSource.clip.length) w Awake() lub Start() przed jego zamianą przez LocalizedAsset? Czy możliwe jest NullReferenceException lub użycie starego zasobu?",
    "a_faq_components_8": "Możliwe jest użycie starego (niezlokalizowanego) zasobu. LocalizedAsset wykonuje zamianę w swoim OnEnable(). Metody Awake() wszystkich skryptów są wykonywane przed OnEnable(). Jeśli Twój skrypt uzyska dostęp do audioSource.clip w Awake(), otrzyma oryginalny klip. Jeśli uzyska do niego dostęp w Start(), wynik będzie zależał od kolejności wykonywania skryptów. Aby zagwarantować dostęp do zlokalizowanego zasobu, ustaw późniejszą kolejność wykonywania dla swojego skryptu lub uzyskaj dostęp do zasobu w metodzie oznaczonej [OnLanguageChange].",
    "h2_faq_window": "9.3. Okno \"Localization Tool\"",
    "h3_faq_window_preview": "Podgląd w edytorze",
    "q_faq_window_preview_1": "Otworzyłem prefabrykat w trybie prefabrykatu, zastosowałem podgląd w edytorze i nacisnąłem Ctrl+S. Czy tymczasowe dane podglądu zostaną zapisane w zasobie prefabrykatu? Jak LocalizationPreviewProtector radzi sobie z tym przypadkiem?",
    "a_faq_window_preview_1": "Nie, nie zostaną zapisane. LocalizationPreviewProtector przechwytuje zdarzenie zapisywania zasobu (OnWillSaveAssets) i automatycznie wywołuje RevertEditorPreview() przed zapisaniem zmian na dysku przez Unity. W ten sposób prefabrykat zostanie zapisany w swoim oryginalnym, niezlokalizowanym stanie.",
    "q_faq_window_preview_2": "Jeśli włączę podgląd w edytorze i edytor Unity ulegnie awarii, a plik Temp/localization_preview_recovery.json zostanie uszkodzony (np. pusty lub nieprawidłowy JSON), co się stanie przy następnym uruchomieniu?",
    "a_faq_window_preview_2": "PreviewCrashProtector jest opakowany w blok try-catch. Jeśli deserializacja JSON nie powiedzie się, do konsoli zostanie zapisany błąd o niemożności odzyskania, a proces zakończy się cicho. Twoja scena pozostanie w \"uszkodzonym\" stanie, w jakim była w momencie awarii. W takim przypadku będziesz musiał ręcznie wybrać \"Przywróć oryginał\" w oknie narzędzia, aby wymusić cofnięcie zmian.",
    "q_faq_window_preview_3": "W trybie podglądu w edytorze dla LocalizedPrefab tworzona jest tymczasowa instancja. Czy na tej instancji zostaną wykonane metody Awake() i Start()? Czy może to spowodować błędy, jeśli nie są one zaprojektowane do uruchamiania w trybie edycji?",
    "a_faq_window_preview_3": "Tak, zostaną. PrefabUtility.InstantiatePrefab w trybie edycji wywołuje Awake() i OnEnable(). Jeśli te metody zawierają logikę, która nie powinna działać w edytorze (np. dostęp do singletonów, które istnieją tylko w trybie odtwarzania), może to spowodować błędy. Zaleca się użycie if (Application.isPlaying) lub #if UNITY_EDITOR do ochrony takiego kodu.",
    "h3_faq_window_settings": "Zakładka \"Ustawienia\"",
    "q_faq_window_settings_1": "Mogę zmienić tryb generowania kluczy z UseTextAsKey na AutoGenerateKeysOnly w trakcie projektu. Co dokładnie stanie się z moimi istniejącymi tłumaczeniami? Czy zostaną zmapowane na nowe klucze?",
    "a_faq_window_settings_1": "Tak, zostaną. Przy zmianie trybu narzędzie wykonuje \"bezpieczną migrację\": ponownie parsuje cały projekt, tworzy nowe klucze zgodnie z nowymi zasadami, ale mapuje stare i nowe klucze poprzez oryginalny tekst. Następnie przenosi wszystkie istniejące tłumaczenia i komentarze ze starych kluczy na nowe. Twoje tłumaczenia nie zostaną utracone.",
    "q_faq_window_settings_2": "Jeśli dodam język z kodem, który nie ma zasad pluralizacji (np. \"kz\" dla kazachskiego) do listy obsługiwanych języków, która zasada zostanie użyta domyślnie?",
    "a_faq_window_settings_2": "Zostanie użyta DefaultPluralRule, która jest odpowiednia dla języka angielskiego i większości języków europejskich (formy dla \"jeden\" i \"inny\").",
    "q_faq_window_settings_3": "Co jeśli podam ścieżkę do tłumaczeń nie w StreamingAssets, ale w zwykłym folderze, np. Assets/MyTranslations? Czy pliki json zostaną uwzględnione w kompilacji gry?",
    "a_faq_window_settings_3": "Nie, nie zostaną. Tylko zasoby znajdujące się w folderze StreamingAssets lub Resources mają gwarancję uwzględnienia w kompilacji. Jeśli podasz inną ścieżkę, lokalizacja będzie działać w edytorze, ale nie będzie działać w skompilowanej grze, ponieważ pliki tłumaczeń nie będą częścią kompilacji.",
    "q_faq_window_settings_4": "Klucz API do automatycznego tłumaczenia jest przechowywany w EditorPrefs. Jeśli pracuję nad projektem na dwóch różnych komputerach, czy muszę wprowadzać klucz na każdej maszynie osobno?",
    "a_faq_window_settings_4": "Tak. EditorPrefs to lokalna pamięć masowa dla każdego komputera. Będziesz musiał wprowadzić klucz API na każdej maszynie, z której planujesz korzystać z funkcji automatycznego tłumaczenia.",
    "h3_faq_window_content": "Zakładka \"Zawartość\"",
    "q_faq_window_content_1": "Co jeśli dodam scenę do scen do sparsowania, która nie jest uwzględniona w ustawieniach kompilacji? Czy wpłynie to na cokolwiek innego niż sam proces parsowania?",
    "a_faq_window_content_1": "Nie, nie wpłynie. Lista scen do sparsowania służy wyłącznie do poinformowania narzędzia, które sceny ma otworzyć i przeanalizować pod kątem tekstu. Nie jest w żaden sposób powiązana ze scenami, które znajdą się w ostatecznej kompilacji Twojej gry.",
    "q_faq_window_content_2": "Dodałem obiekt do ignorowania określonych obiektów (lista tymczasowa). Jeśli zrobię z tego obiektu prefabrykat, czy instancja tego prefabrykatu również będzie ignorowana?",
    "a_faq_window_content_2": "Nie, nie będzie. Lista tymczasowa przechowuje bezpośrednie odwołanie do obiektu na scenie. Kiedy tworzysz prefabrykat, jest to nowy zasób. Jego instancje są różnymi obiektami, a zasada ignorowania nie będzie do nich stosowana. Aby trwale ignorować prefabrykaty, muszą one zostać dodane do listy ignorowanych jako zasób prefabrykatu.",
    "q_faq_window_content_3": "Jeśli dodam komponent TMPro.TMP_Text do ignorowania parsowania -> ignoruj typy komponentów, ale na scenie jest obiekt z LocalizedText, który już odwołuje się do tego TMP_Text, co się stanie przy następnej aktualizacji kluczy? Czy klucz zostanie usunięty?",
    "a_faq_window_content_3": "Tak, zostanie. Po kliknięciu Aktualizuj klucze parser ponownie skanuje cały projekt. Zobaczy, że typ TMPro.TMP_Text powinien być ignorowany i nie wygeneruje dla niego klucza. Podczas procesu porównywania starych i nowych kluczy ustali, że stary klucz nie jest już używany i oznaczy go jako \"Usunięty\".",
    "q_faq_window_content_4": "Dokumentacja mówi, że \"Przypnij\" zapisuje pełną ścieżkę do obiektu i zerwie się po jego zmianie nazwy. Co jeśli zrobię prefabrykat z obiektu, a następnie zmienię nazwę oryginalnego obiektu — czy \"Przypnij\" będzie nadal działać dla instancji prefabrykatu?",
    "a_faq_window_content_4": "Nie, nie będzie. \"Przypnij\" zapisuje bezwzględną ścieżkę w hierarchii sceny w momencie kliknięcia przycisku (np. Canvas/Panel/Button). Ta ścieżka nie jest powiązana z logiką prefabrykatu. Instancje prefabrykatu będą miały tę samą ścieżkę, ale jeśli zmienisz nazwę obiektu nadrzędnego na scenie, \"Przypnij\" przestanie działać zarówno dla oryginału, jak i dla instancji.",
    "q_faq_window_content_5": "Jeśli użyję \"Przypnij\" dla obiektu podrzędnego wewnątrz instancji prefabrykatu, jaka ścieżka zostanie zapisana: względna do korzenia prefabrykatu czy korzenia sceny? Czy zadziała w innych scenach?",
    "a_faq_window_content_5": "Zostanie zapisana pełna ścieżka od korzenia sceny. Na przykład MyPrefab(Clone)/Content/Icon. Ta \"przypięta\" ścieżka będzie działać tylko w scenie, w której ją utworzyłeś. W innych scenach taka ścieżka prawdopodobnie nie zostanie znaleziona.",
    "h3_faq_window_actions": "Zakładka \"Akcje\"",
    "h3_faq_window_assets": "Zakładka \"Zasoby\"",
    "h3_faq_window_report": "Zakładka \"Raport\"",
    "h2_faq_editor": "9.4. Edytor tłumaczeń",
    "h2_faq_examples": "9.5. Przykłady użycia i kod",
    "h2_faq_notes": "9.6. Ważne niuanse i ostrzeżenia",
    "h2_faq_extending": "9.7. Rozszerzanie funkcjonalności",
    "q_faq_window_actions_1": "Co się stanie, jeśli połączenie internetowe zostanie utracone podczas wsadowego automatycznego tłumaczenia? Czy narzędzie ponowi próbę nieudanej partii zgodnie z polityką ponawiania, czy proces zostanie całkowicie przerwany?",
    "a_faq_window_actions_1": "Narzędzie spróbuje ponownie wysłać dokładną partię, która się nie powiodła, zgodnie z ustawieniami polityki ponawiania (liczba prób i opóźnienie). Jeśli wszystkie próby dla tej partii nie powiodą się, proces tłumaczenia dla bieżącego języka zostanie przerwany, a do konsoli zostanie zapisany błąd. Tłumaczenie dla następnych języków w kolejce nie rozpocznie się.",
    "q_faq_window_actions_2": "Jeśli zaimportuję plik CSV, który zawiera klucze, które już istnieją w projekcie, ale z pustymi wartościami dla niektórych języków, czy te puste wartości zastąpią moje istniejące tłumaczenia, czy zostaną zignorowane?",
    "a_faq_window_actions_2": "Puste wartości zastąpią istniejące tłumaczenia. Proces importu traktuje plik CSV jako \"źródło prawdy\". Jeśli wartość dla klucza welcome_message w kolumnie ru jest pusta, bieżące rosyjskie tłumaczenie dla tego klucza zostanie nadpisane.",
    "q_faq_window_actions_3": "Sekcja \"Strefa niebezpieczna\" pozwala na usunięcie wszystkich komponentów. Czy usunie komponenty z prefabrykatów, które znajdują się w folderach nieokreślonych w folderach prefabrykatów na zakładce Zawartość?",
    "a_faq_window_actions_3": "Tak, usunie. Funkcje w \"Strefie niebezpiecznej\" skanują wszystkie prefabrykaty w projekcie (AssetDatabase.FindAssets(\"t:Prefab\")), a nie tylko te określone na liście parsowania, aby zapewnić jak najpełniejsze czyszczenie.",
    "q_faq_window_actions_4": "Podczas importowania z Arkuszy Google, jak powinienem sformatować kolumnę komentarzy do walidacji symboli zastępczych za pomocą dyrektywy @placeholders:, aby działała?",
    "a_faq_window_actions_4": "W dokumencie Arkuszy Google kolumna musi mieć tytuł \"Developer Notes\". W komórkach tej kolumny możesz pisać komentarze jak zwykle. Aby określić symbole zastępcze, po prostu dodaj linię taką jak @placeholders: {username}, {score} w tekście komentarza. Narzędzie automatycznie rozpozna tę dyrektywę po imporcie.",
    "q_faq_window_actions_5": "Czy narzędzie może importować dane z wielu arkuszy jednego dokumentu Arkuszy Google, czy działa tylko z jednym arkuszem na GID?",
    "a_faq_window_actions_5": "Narzędzie działa tylko z jednym arkuszem na raz. Adres URL importu zawiera parametr gid=..., który jednoznacznie identyfikuje konkretny arkusz w dokumencie. Aby zaimportować dane z innego arkusza, musisz skopiować jego adres URL (z innym gid) i ponownie przeprowadzić import.",
    "q_faq_window_assets_1": "Co jeśli mam dwa zasoby o tym samym kluczu, ale różnych typach w tym samym folderze skanowania (np. sound_effect_pl.mp3 i sound_effect_pl.wav)? Który z nich znajdzie się w tabeli zasobów?",
    "a_faq_window_assets_1": "Skaner zasobów wczytuje je, określając oczekiwany typ (AssetDatabase.LoadAssetAtPath(path, expectedType)). Dla kategorii AudioClip będzie wyszukiwał i wczytywał tylko pliki, które Unity rozpoznaje jako AudioClips. Jeśli oba pliki są prawidłowymi klipami audio, ten, który zostanie przetworzony jako ostatni, zostanie uwzględniony w tabeli, skutecznie nadpisując poprzedni. Zaleca się unikanie takich duplikatów.",
    "q_faq_window_assets_2": "Jeśli kliknę Skanuj zasoby i analizuj projekt, a na scenie jest obiekt Image, dla którego istnieje już zlokalizowany sprite, ale sam obiekt Image nie ma jeszcze komponentu LocalizedAsset, czy narzędzie doda komponent i automatycznie wstawi klucz?",
    "a_faq_window_assets_2": "Tak, dokładnie tak to działa. \"Analizuj projekt\" znajduje komponent Image, patrzy na nazwę przypisanego do niego sprite'a (np. icon_play_pl), wyodrębnia z niego klucz (icon_play) i język (pl), a następnie dodaje komponent LocalizedAsset do tego obiektu GameObject i wpisuje w nim klucz icon_play.",
    "q_faq_window_assets_3": "Czy mogę używać tej samej zasady nazewnictwa dla różnych kategorii zasobów, jeśli mają one różne foldery skanowania? Czy spowoduje to konflikty?",
    "a_faq_window_assets_3": "Tak, możesz. Nie będzie konfliktów, ponieważ dla każdej kategorii tworzona jest osobna tabela zasobów (LocalizedAssetTable). Klucze z kategorii \"Sprites\" nie pokrywają się z kluczami z kategorii \"AudioClips\", nawet jeśli mają taką samą nazwę.",
    "q_faq_window_assets_4": "Jeśli lokalizowalny zasób (np. przycisk_ok_pl.png) nie znajduje się w katalogu głównym folderu skanowania, ale w podfolderze, czy skaner go znajdzie?",
    "a_faq_window_assets_4": "Tak, znajdzie. Skaner używa opcji SearchOption.AllDirectories, co oznacza, że rekurencyjnie sprawdzi wszystkie podfoldery w określonym folderze skanowania.",
    "q_faq_window_report_1": "Przycisk \"Znajdź\" wyszukuje obiekt asynchronicznie. Co jeśli rozpocznę wyszukiwanie, a następnie natychmiast kliknę Aktualizuj klucze? Czy wyszukiwanie zostanie przerwane?",
    "a_faq_window_report_1": "Tak, zostanie przerwane. Każda nowa akcja wymagająca blokowania interfejsu użytkownika (jak Aktualizuj klucze) zatrzyma bieżącą korutynę wyszukiwania. Pojawi się okno dialogowe z prośbą o zatrzymanie bieżącego wyszukiwania w celu rozpoczęcia nowego.",
    "q_faq_window_report_2": "Jeśli klucz jest używany w wielu miejscach (np. na dwóch różnych przyciskach w różnych scenach), jak zostanie to wyświetlone w raporcie w kategorii \"Duplikaty\"?",
    "a_faq_window_report_2": "Kategoria \"Duplikaty\" pokaże wszystkie źródła dla tego klucza. Zobaczysz jeden wpis dla klucza, a pole \"Źródło\" wyświetli listę wszystkich ścieżek (w scenie 1 i scenie 2). Przycisk \"Znajdź\" w tym przypadku otworzy listę rozwijaną, pozwalającą wybrać, do którego obiektu chcesz przejść.",
    "q_faq_window_report_3": "Jeśli kliknę \"Znajdź\" dla klucza, który jest używany tylko w kodzie (za pomocą funkcji _()), co się stanie? Czy narzędzie będzie w stanie znaleźć i podświetlić skrypt C#?",
    "a_faq_window_report_3": "Tak. System wyszukiwania jest specjalnie przeszkolony do rozpoznawania źródeł takich jak skrypt MyScript.cs. Po kliknięciu \"Znajdź\" wyszuka zasób MyScript.cs w projekcie i podświetli (ping) go w oknie Projektu.",
    "q_faq_editor_1": "Co ma wyższy priorytet przy walidacji symboli zastępczych: dyrektywa @placeholders: w komentarzu czy symbole zastępcze znalezione w tekście języka źródłowego? Na przykład, jeśli tekst źródłowy ma {name}, a komentarz mówi @placeholders: {username}.",
    "a_faq_editor_1": "Dyrektywa @placeholders: w komentarzu ma priorytet. Jest uważana za jawną instrukcję od dewelopera i \"źródło prawdy\". W Twoim przykładzie edytor będzie wymagał {username} w tłumaczeniu i zignoruje {name} z tekstu źródłowego.",
    "q_faq_editor_2": "Jeśli zrobię literówkę w dyrektywie (np. @placeholder: zamiast @placeholders:), czy zostanie ona zignorowana, czy narzędzie wyświetli ostrzeżenie?",
    "a_faq_editor_2": "Zostanie po prostu zignorowana. Narzędzie szuka dokładnego dopasowania @placeholders:. Jeśli dyrektywa jest błędnie napisana, zostanie potraktowana jako część zwykłego komentarza, a walidacja będzie działać po staremu - na podstawie symboli zastępczych z tekstu źródłowego.",
    "q_faq_editor_3": "System autozapisu tworzy pliki w folderze Backups/AutoSaves. Czy te pliki zostaną automatycznie usunięte po udanym ręcznym zapisie lub zamknięciu okna?",
    "a_faq_editor_3": "Tak. Po udanym ręcznym zapisie lub normalnym zamknięciu okna (gdy zapisujesz zmiany), wszystkie pliki autozapisu są usuwane, aby uniknąć monitu o odzyskanie przy następnym uruchomieniu. Pozostają tylko w przypadku awarii edytora.",
    "q_faq_editor_4": "Jeśli zmienię szerokość kolumn w edytorze, czy te ustawienia zostaną zapisane między sesjami Unity?",
    "a_faq_editor_4": "Tak. Szerokość kolumn jest zapisywana w EditorPrefs za każdym razem, gdy zamykasz okno edytora tłumaczeń i zostanie przywrócona przy następnym otwarciu.",
    "q_faq_editor_5": "Czy okno podręczne edycji tekstu (MultiLineEditWindow) obsługuje własny stos Cofnij/Ponów (za pomocą Ctrl+Z) dla zmian dokonanych w nim?",
    "a_faq_editor_5": "Tak. MultiLineEditWindow ma własny tymczasowy stos Cofnij/Ponów, który działa, gdy okno jest otwarte. Pozwala to cofać i ponawiać zmiany tekstu w tym oknie. Po zapisaniu wyniku (przez zamknięcie okna), ta zmiana jest rejestrowana jako pojedyncza akcja w globalnym stosie Cofnij/Ponów głównego edytora.",
    "q_faq_examples_1": "Co się stanie, jeśli nazwy właściwości w typie anonimowym przekazanym do funkcji _() nie pasują do symboli zastępczych w ciągu znaków? Na przykład _(\"Witaj, {username}\", new { user_name = \"Bob\" }). Czy wystąpi błąd, czy symbol zastępczy po prostu nie zostanie zastąpiony?",
    "a_faq_examples_1": "Nie będzie błędu. Symbol zastępczy {username} po prostu nie zostanie zastąpiony, a w rezultacie otrzymasz ciąg znaków \"Witaj, {username}\". Zastąpienie następuje tylko przy dokładnym dopasowaniu nazwy.",
    "q_faq_examples_2": "Atrybut [LocalizableField] działa dla pól prywatnych. Czy zadziała dla pól statycznych?",
    "a_faq_examples_2": "Tak, zadziała. Parser używa refleksji do znajdowania pól z flagami BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, więc znajdzie i przetworzy pola statyczne.",
    "q_faq_examples_3": "Jeśli umieszczę atrybut [OnLanguageChange] na metodzie z parametrami (np. void UpdateUI(string newLang)), co się stanie? Czy wystąpi błąd kompilacji czy ostrzeżenie w czasie wykonywania?",
    "a_faq_examples_3": "Nie będzie błędu kompilacji, ale w konsoli Unity w czasie wykonywania pojawi się ostrzeżenie od LocalizedBehaviour. Poinformuje ono, że znalazło metodę z atrybutem, ale ją zignorowało, ponieważ metoda ma parametry. Taka metoda nie zostanie wywołana.",
    "q_faq_examples_4": "Używam _(\"apple_count\", count). Jeśli dla bieżącego języka nie ma klucza apple_count_one (dla count = 1), którą formę wybierze system? Czy użyje apple_count_other jako rezerwy?",
    "a_faq_examples_4": "Tak. Jeśli określona forma (_one, _few itp.) nie zostanie znaleziona, system spróbuje użyć klucza z sufiksem _other jako rezerwy. Jeśli ten również nie zostanie znaleziony, zostanie użyte tłumaczenie dla klucza podstawowego apple_count.",
    "q_faq_examples_5": "Funkcja _(\"klucz\", new { username = \"Alex\" }) używa typu anonimowego. Czy nie spowoduje to nadmiernego \"obciążenia\" garbage collectora (GC) przy częstych wywołaniach w metodzie Update() w porównaniu z przekazywaniem wcześniej utworzonego Dictionary<string, object>?",
    "a_faq_examples_5": "Tak, spowoduje. Każde wywołanie new { ... } alokuje pamięć na zarządzanej stercie, co tworzy dodatkową pracę dla garbage collectora. W przypadku tekstu, który jest aktualizowany w każdej klatce (w Update lub LateUpdate), znacznie wydajniej jest utworzyć Dictionary<string, object> raz w Start(), a w Update() tylko aktualizować jego wartości przed przekazaniem go do funkcji _().",
    "q_faq_notes_1": "Dokumentacja zaleca dodanie LanguageSelector do listy ignorowanych. Co dokładnie się zepsuje, jeśli o tym zapomnę? Czy zostaną utworzone dodatkowe klucze dla \"Opcja A, Opcja B\"?",
    "a_faq_notes_1": "Tak. Jeśli nie dodasz LanguageSelector do listy ignorowanych, parser potraktuje jego TMP_Dropdown jako zwykłą listę rozwijaną. Znajdzie domyślne \"Opcja A, Opcja B, Opcja C\", które tworzy Unity, i doda dla nich klucze do plików tłumaczeń. Spowoduje to zaśmiecenie plików niepotrzebnymi kluczami, ponieważ LanguageSelector i tak usunie te opcje w czasie wykonywania i utworzy własne.",
    "q_faq_notes_2": "Jeśli zapomnę dodać pusty LocalizedText z zaznaczonym polem isStyleOnly na etykiecie wewnątrz TMP_Dropdown używanego przez LanguageSelector, czy czcionka się nie zmieni? Dlaczego jest to konieczne?",
    "a_faq_notes_2": "Tak, czcionka się nie zmieni. Jest to konieczne, ponieważ LanguageSelector bezpośrednio zmienia właściwość label.text. Bez LocalizedText na tym obiekcie system lokalizacji nie wie, że ten element wymaga zastosowania stylów (czcionki, RTL) po zmianie języka. Pusty LocalizedText z isStyleOnly służy jako \"znacznik\" dla systemu, mówiący: \"Obserwuj ten obiekt i stosuj do niego style, ale nie ruszaj jego tekstu\".",
    "q_faq_notes_3": "Wywoływanie _() w metodzie Update() nie jest zalecane. Ale co, jeśli muszę aktualizować tekst w każdej klatce (np. timer)? Jaki jest najwydajniejszy sposób, aby to zrobić, buforując tylko ciąg formatujący?",
    "a_faq_notes_3": "Najwydajniejszym podejściem jest buforowanie ciągu formatującego w Start() lub w metodzie [OnLanguageChange] i używanie zwykłego string.Format w Update(). Przykład: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Unika to wyszukiwania klucza w słowniku w każdej klatce, co jest znacznie szybsze.",
    "q_faq_extending_1": "Czy mój niestandardowy parser będzie wywoływany automatycznie po każdej aktualizacji kluczy? Czy muszę go gdzieś rejestrować, czy wystarczy, że mam w projekcie klasę implementującą ITextComponentParser?",
    "a_faq_extending_1": "Wystarczy sama klasa. Kiedy TextParser działa, używa refleksji, aby znaleźć wszystkie klasy w projekcie, które implementują interfejs ITextComponentParser i automatycznie wywołuje ich metodę Parse() dla każdego obiektu GameObject. Nie jest wymagana żadna ręczna rejestracja.",
    "q_faq_extending_2": "Co jeśli w moim niestandardowym parserze wystąpi wyjątek? Czy przerwie to cały proces parsowania, czy narzędzie bezpiecznie będzie kontynuować z innymi parserami?",
    "a_faq_extending_2": "Wyjątek w twoim niestandardowym parserze przerwie proces. Główna pętla parsowania nie obejmuje wywołań niestandardowych parserów blokiem try-catch. Jeśli twoja metoda Parse() zgłosi nieobsłużony wyjątek,",
    "toggle_notes_title": "Przełącz notatki",
    "mindmap_toggle_title": "Pokaż mapę myśli",
    "on_this_page_title": "Na tej stronie",
    "my_notes_title": "Moje notatki",
    "no_notes_message_new": "Najedź na tekst, aby dodać notatkę.",
    "notes_add_title": "Dodaj notatkę do tego bloku",
    "notes_placeholder": "Twoja notatka...",
    "notes_close_title": "Zamknij",
    "notes_goto_title": "Przejdź do tekstu",
    "notes_edit_title": "Edytuj notatkę",
    "notes_delete_title": "Usuń notatkę",
    "notes_edit_text": "Edytuj",
    "copy_code_copy": "Kopiuj",
    "copy_code_copied": "Skopiowano!",
    "copy_code_error": "Błąd",
    "error_loading_title": "Błąd ładowania",
    "error_loading_message": "Sprawdź połączenie i odśwież stronę.",
    "lightbox_aria_close": "Zamknij przeglądarkę obrazów",
    "lightbox_image_alt": "Powiększony widok",
    "mindmap_preset_full": "Pełny widok",
    "mindmap_preset_quick_start": "Szybki start",
    "mindmap_preset_dev": "Przepływ pracy dewelopera",
    "mindmap_preset_translator": "Przepływ pracy tłumacza",
    "mindmap_edge_configure": "1. Konfiguruj",
    "mindmap_edge_specify_content": "2. Określ zawartość",
    "mindmap_edge_parse_project": "3. Parsuj projekt",
    "mindmap_edge_creates_components": "Tworzy komponenty",
    "mindmap_edge_generates": "Generuje",
    "mindmap_edge_opens": "Otwiera",
    "mindmap_edge_manages_assets": "Zarządza zasobami dla",
    "mindmap_edge_defines_rules": "Definiuje zasady dla",
    "mindmap_edge_reports_on": "Raportuje o",
    "mindmap_edge_enables_reaction": "Umożliwia reakcję przez",
    "mindmap_edge_processed_by": "Przetwarzane przez",
    "mindmap_edge_edited_in": "Edytowane w",
    "mindmap_edge_extends": "Rozszerza",
    "mindmap_edge_warns_about": "Ostrzega o",
    "mindmap_edge_relates_to": "Odnosi się do",
    "mindmap_edge_recommends_for": "Zaleca dla",
    "mindmap_edge_see_faq": "Zobacz FAQ"
}