{
  "a_faq_addressables_1": "Assurez-vous que le package Addressables est installé, que les paramètres sont créés et que vous avez cliqué sur \"Scan Assets & Generate Tables\" pour enregistrer les clés dans les groupes.",
  "a_faq_addressables_2": "Créez un <code>Translation Profile</code> dans le dossier des ressources, sélectionnez le type de service, entrez la clé API et attribuez ce profil dans la fenêtre <code>Settings</code>.",
  "a_faq_addressables_3": "Dans la fenêtre Migration (onglets Composants / Import), il y a un bouton \"Enable Stubs\" qui active la fonctionnalité Emergency Stubs. Cela crée des classes factices de remplacement pour I2 Localization ou Unity Localization afin que votre projet puisse être compilé immédiatement après la suppression de ces plugins. La fonctionnalité fonctionne en basculant le symbole de définition ANKO_ENABLE_MIGRATION_STUBS. Cela empêche les erreurs \"The type name 'Localize' could not be found\" et vous donne le temps de refactoriser correctement votre code pour utiliser le nouveau système. Enable Stubs vous permet de corriger les erreurs de compilation après la suppression de l'ancien plugin de localisation. Dans la version 2.0, le système de migration a été étendu avec <strong>Migration Profiles</strong>, permettant des règles de transition plus robustes depuis d'autres plugins.",
  "a_faq_audio_smart_update": "L'outil utilise le regroupement intelligent avec hachage MD5 pour ne régénérer les fichiers audio que lorsque le texte source a changé. Il calcule un hachage MD5 de votre contenu textuel et le compare aux fichiers audio précédemment générés. Si le texte n'a pas changé, il saute la régénération, économisant ainsi vos crédits API. Cela empêche les appels API inutiles et réduit les coûts lors de la régénération audio. L'outil hache votre texte et ne régénère les fichiers audio que si le texte source a changé, économisant ainsi vos crédits API.",
  "a_faq_components_1": "Non, il ne le sera pas. La désactivation d'un MonoBehaviour empêche l'appel de toutes les méthodes \"magiques\" d'Unity, y compris Awake(), OnEnable() et Start(). C'est intentionnel pour éviter l'exécution d'une double logique. Toute l'initialisation doit avoir lieu dans des scripts sur les versions localisées du prefab.",
  "a_faq_components_2": "Oui, le comportement physique de l'objet original sera neutralisé. Le composant LocalizedPrefab trouve tous les composants Rigidbody et Rigidbody2D sur son GameObject et définit leur propriété isKinematic sur true. Cela les retire effectivement des calculs de physique dynamique, empêchant un comportement indésirable comme un objet invisible qui tombe ou réagit aux collisions. Il est toujours recommandé que la version localisée du prefab contienne tous les composants physiques nécessaires pour un comportement correct.",
  "a_faq_components_3": "Oui, cela le fera. Le composant stocke le nom complet du type, y compris l'espace de noms et l'assembly. Renommer le script ou le déplacer vers un autre .asmdef changera ce nom, et LocalizedAsset ne pourra pas trouver le composant cible. Vous devrez lancer une autre analyse via Analyser le projet & Attacher les composants pour mettre à jour le nom.",
  "a_faq_components_4": "Un LocalizedAsset est créé pour une instance de composant spécifique. Il détient une référence à ce composant dans le code. Si vous ajoutez manuellement un deuxième LocalizedAsset et utilisez le menu contextuel \"Analyze for Localization\" pour cibler la deuxième Image, vous aurez deux composants LocalizedAsset, chacun gérant sa propre Image. L'analyseur automatique ne créera un composant que pour la première Image avec une ressource localisable qu'il trouve.",
  "a_faq_components_5": "Oui, il le fera. LocalizedPrefab crée l'instance du prefab localisé dans sa méthode OnEnable(). L'ordre d'exécution d'Unity garantit que toutes les méthodes Awake() sont exécutées avant toutes les méthodes OnEnable(). Ainsi, votre script avec l'ordre -110 exécutera son Awake(), puis LocalizedPrefab avec l'ordre -100 exécutera son Awake(), et ce n'est qu'après cela que leurs méthodes OnEnable() seront appelées dans l'ordre. Votre script ne trouvera pas l'objet car il n'aura pas encore été créé.",
  "a_faq_components_6": "La clé et le texte changeront. L'appel de SetFormattedText par programmation annule le comportement isStyleOnly pour cette mise à jour spécifique. L'option isStyleOnly est destinée à empêcher le composant de réagir aux changements de langue globaux, mais il réagira toujours à un changement de clé direct via le code.",
  "a_faq_components_7": "Il trouvera les méthodes avec n'importe quel modificateur d'accès (public, private, protected, internal). La réflexion dans Unity permet la découverte de toutes les méthodes d'instance quel que soit leur niveau d'accès.",
  "a_faq_components_8": "L'utilisation de l'ancienne ressource (non localisée) est possible. LocalizedAsset effectue l'échange dans son OnEnable(). Les méthodes Awake() de tous les scripts sont exécutées avant OnEnable(). Si votre script accède à audioSource.clip dans Awake(), il obtiendra le clip original. S'il y accède dans Start(), le résultat dépendra de l'ordre d'exécution du script. Pour garantir l'accès à la ressource localisée, définissez un ordre d'exécution ultérieur pour votre script ou accédez à la ressource dans une méthode marquée de [OnLanguageChange].",
  "a_faq_custom_keys_attribute": "Oui. Dans l'onglet **Content Tab** sous 'Attributes to Scan', vous pouvez ajouter n'importe quel nom d'attribut (par exemple, <code>[Header]</code>, <code>[TermsPopup]</code>). L'analyseur traitera tout champ de chaîne avec cet attribut comme localisable.",
  "a_faq_custom_provider_1": "Assurez-vous que votre classe implémente <code>IAssetProvider</code>, n'est PAS abstraite, et est marquée avec l'attribut <code>[AssetProviderPlugin]</code>. Vérifiez également la console pour d'éventuelles erreurs liées à la réflexion lors du démarrage, car l'outil analyse toutes les assemblées à la recherche de fournisseurs.",
  "a_faq_editor_1": "La directive @placeholders: dans le commentaire a la priorité. Elle est considérée comme une instruction explicite du développeur et la \"source de vérité\". Dans votre exemple, l'éditeur exigera {username} dans la traduction et ignorera {name} du texte source.",
  "a_faq_editor_2": "Elle sera simplement ignorée. L'outil recherche une correspondance exacte de @placeholders:. Si la directive est mal orthographiée, elle sera traitée comme faisant partie d'un commentaire régulier, et la validation fonctionnera à l'ancienne - basée sur les placeholders du texte source.",
  "a_faq_editor_3": "Oui. Lors d'une sauvegarde manuelle réussie ou d'une fermeture normale de la fenêtre (lorsque vous enregistrez les modifications), tous les fichiers de sauvegarde automatique sont supprimés pour éviter de demander la récupération au prochain lancement. Ils ne restent qu'en cas de plantage de l'éditeur.",
  "a_faq_editor_4": "Oui. La largeur des colonnes est enregistrée dans EditorPrefs chaque fois que vous fermez la fenêtre de l'éditeur de traduction et sera restaurée la prochaine fois que vous l'ouvrirez.",
  "a_faq_editor_5": "Oui. La MultiLineEditWindow a sa propre pile Annuler/Rétablir temporaire qui fonctionne tant que la fenêtre est ouverte. Cela vous permet d'annuler et de rétablir les modifications de texte dans cette fenêtre. Une fois que vous enregistrez le résultat (en fermant la fenêtre), cette modification est enregistrée comme une action unique dans la pile Annuler/Rétablir globale de l'éditeur principal.",
  "a_faq_examples_1": "Il n'y aura pas d'erreur. Le placeholder {username} ne sera tout simplement pas remplacé, et vous obtiendrez la chaîne \"Hello, {username}\" en conséquence. Le remplacement ne se produit qu'avec une correspondance de nom exacte.",
  "a_faq_examples_2": "Oui, il le fera. L'analyseur utilise la réflexion pour trouver les champs avec les drapeaux BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, il trouvera et traitera donc les champs statiques.",
  "a_faq_examples_3": "Il n'y aura pas d'erreur de compilation, mais un avertissement de LocalizedBehaviour apparaîtra dans la console Unity au moment de l'exécution. Il signalera qu'il a trouvé une méthode avec l'attribut mais l'a ignorée car la méthode a des paramètres. Une telle méthode ne sera pas appelée.",
  "a_faq_examples_4": "Oui. Si une forme spécifique (_one, _few, etc.) n'est pas trouvée, le système essaiera d'utiliser la clé avec le suffixe _other comme solution de repli. Si celle-ci n'est pas non plus trouvée, la traduction pour la clé de base apple_count sera utilisée.",
  "a_faq_examples_5": "Oui, il le fera. Chaque appel à new { ... } alloue de la mémoire sur le tas géré, ce qui crée un travail supplémentaire pour le ramasse-miettes. Pour le texte qui est mis à jour à chaque image (dans Update ou LateUpdate), il est nettement plus performant de créer un Dictionary<string, object> une fois dans Start(), et de ne mettre à jour ses valeurs dans Update() qu'avant de le transmettre à la fonction _().",
  "a_faq_examples_6": "Vérifiez si votre méthode a des paramètres. L'attribut <code>[OnLanguageChange]</code> ne fonctionne que sur les méthodes **sans paramètres** (par exemple, <code>void UpdateUI()</code>). Si votre méthode nécessite des arguments, enveloppez-la dans une méthode sans paramètres.",
  "a_faq_extending_1": "Avoir la classe suffit. Lorsque TextParser s'exécute, il utilise la réflexion pour trouver toutes les classes du projet qui implémentent l'interface ITextComponentParser et appelle automatiquement leur méthode Parse() pour chaque GameObject. Aucune inscription manuelle n'est requise.",
  "a_faq_extending_2": "Une exception dans votre analyseur personnalisé interrompra le processus. La boucle d'analyse principale n'enveloppe pas les appels aux analyseurs personnalisés dans un bloc try-catch. Si votre méthode Parse() lève une exception non gérée,",
  "a_faq_installation_1": "L'installateur vérifie l'existence du type Newtonsoft.Json.JsonConvert. Si le type existe, il considère la dépendance satisfaite et ne tentera pas d'installer ou de mettre à jour le package. Ceci est fait pour éviter les conflits de version.",
  "a_faq_installation_2": "Vous pouvez déclencher manuellement une vérification des dépendances à tout moment via le menu Tools -> Localization -> Check Dependencies. Cela réinitialisera le drapeau \"Don't ask again\" et affichera à nouveau la fenêtre avec tous les packages optionnels manquants.",
  "a_faq_installation_3": "Cela peut se produire si vous n'avez pas de dossier Assets/Resources. L'outil essaiera de le créer, mais les autorisations du système de fichiers peuvent l'en empêcher. Oui, vous pouvez créer la ressource manuellement : faites un clic droit dans le dossier Resources, sélectionnez Create -> Localization -> Settings. L'outil le trouvera automatiquement.",
  "a_faq_installation_4": "Oui. L'outil utilise Resources.Load(), qui recherche une ressource par nom dans tous les dossiers nommés Resources de votre projet. L'important est que le fichier conserve son nom LocalizationSettings.asset.",
  "a_faq_installation_5": "Oui. Vous pouvez ouvrir Window -> Package Manager, cliquer sur l'icône \"+\" et sélectionner \"Add package by name...\". Entrez les noms des packages : com.unity.nuget.newtonsoft-json et com.unity.editorcoroutines.",
  "a_faq_notes_1": "Oui. Si vous n'ajoutez pas LanguageSelector à la liste d'ignorés, l'analyseur traitera son TMP_Dropdown comme une liste déroulante ordinaire. Il trouvera le \"Option A, Option B, Option C\" par défaut qu'Unity crée et ajoutera des clés pour eux à vos fichiers de traduction. Cela encombrera vos fichiers de clés inutiles, car LanguageSelector supprimera ces options au moment de l'exécution et créera les siennes de toute façon.",
  "a_faq_notes_2": "Oui, la police ne changera pas. C'est nécessaire car LanguageSelector modifie directement la propriété label.text. Sans un LocalizedText sur cet objet, le système de localisation ne sait pas que cet élément a besoin de styles (police, RTL) appliqués lorsque la langue change. Un LocalizedText vide avec isStyleOnly sert de \"marqueur\" pour le système, disant : \"Surveillez cet objet et appliquez-lui des styles, mais ne touchez pas à son texte\".",
  "a_faq_notes_3": "L'approche la plus performante consiste à mettre en cache la chaîne de format dans Start() ou dans une méthode [OnLanguageChange], et à utiliser string.Format régulier dans Update(). Exemple : private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Cela évite de rechercher la clé dans le dictionnaire à chaque image, ce qui est nettement plus rapide.",
  "a_faq_runtime_api_key_distinction": "<strong>Q : Quelle est la différence entre les « Translation Service Keys » et la « Runtime API Key » ?</strong><br>A : Les <strong>Translation Service Keys</strong> (OpenAI, DeepL) sont utilisées dans le <strong>Unity Editor</strong> pour générer des traductions. Elles sont stockées dans le registre de votre ordinateur (EditorPrefs) et ne sont PAS incluses dans la build.<br>La <strong>Runtime API Key</strong> est utilisée par le <strong>Game Build</strong> pour récupérer les mises à jour en direct. Elle EST incluse dans la build (chiffrée).",
  "a_faq_tts_voices": "Dans votre **Translation Profile** (Inspecteur), utilisez la liste 'Voice Mappings'. Vous pouvez mapper un modèle Regex (par exemple <code>^hero_.*</code>) à un ID de voix spécifique. Le générateur choisira automatiquement la bonne voix en fonction du nom de la clé.",
  "a_faq_window_actions_1": "L'outil tentera de renvoyer le lot exact qui a échoué, selon les paramètres de la Politique de Réessai (nombre de tentatives et délai). Si toutes les tentatives pour ce lot échouent, le processus de traduction pour la langue actuelle sera interrompu, et une erreur sera enregistrée dans la console. La traduction pour les langues suivantes dans la file d'attente ne démarrera pas.",
  "a_faq_window_actions_2": "Les valeurs vides remplaceront les traductions existantes. Le processus d'importation considère le fichier CSV comme la \"source de vérité\". Si la valeur pour la clé welcome_message dans la colonne ru est vide, la traduction russe actuelle pour cette clé sera écrasée.",
  "a_faq_window_actions_3": "Oui, elle le fera. Les fonctions de la \"Danger Zone\" analysent tous les prefabs du projet (AssetDatabase.FindAssets(\"t:Prefab\")), et pas seulement ceux spécifiés dans la liste d'analyse, pour assurer le nettoyage le plus complet possible.",
  "a_faq_window_actions_4": "Dans votre document Google Sheets, la colonne doit être intitulée \"Developer Notes\". Dans les cellules de cette colonne, vous pouvez écrire des commentaires comme d'habitude. Pour spécifier des placeholders, ajoutez simplement une ligne comme @placeholders: {username}, {score} dans le texte du commentaire. L'outil reconnaîtra automatiquement cette directive lors de l'importation.",
  "a_faq_window_actions_5": "L'outil ne fonctionne qu'avec une seule feuille à la fois. L'URL d'importation comprend un paramètre gid=..., qui identifie de manière unique une feuille spécifique dans le document. Pour importer des données à partir d'une autre feuille, vous devez copier son URL (avec un GID différent) et effectuer à nouveau l'importation.",
  "a_faq_window_assets_1": "Le scanneur de ressources les charge en spécifiant le type attendu (AssetDatabase.LoadAssetAtPath(path, expectedType)). Pour la catégorie AudioClip, il ne recherchera et ne chargera que les fichiers qu'Unity reconnaît comme AudioClips. Si les deux fichiers sont des clips audio valides, celui qui est traité en dernier sera inclus dans la table, écrasant effectivement le précédent. Il est recommandé d'éviter de tels doublons.",
  "a_faq_window_assets_2": "Oui, c'est exactement comme ça que ça fonctionne. \"Analyze Project\" trouve le composant Image, regarde le nom du sprite qui lui est attribué (par exemple, icon_play_en), en extrait la clé (icon_play) et la langue (en), puis ajoute un composant LocalizedAsset à ce GameObject et y écrit la clé icon_play.",
  "a_faq_window_assets_3": "Oui, vous pouvez. Il n'y aura pas de conflits, car une table de ressources séparée (LocalizedAssetTable) est créée pour chaque catégorie. Les clés de la catégorie \"Sprites\" ne se chevauchent pas avec les clés de la catégorie \"AudioClips\", même si elles portent le même nom.",
  "a_faq_window_assets_4": "Oui, il le fera. Le scanneur utilise l'option SearchOption.AllDirectories, ce qui signifie qu'il vérifiera récursivement tous les sous-dossiers du Dossier d'Analyse que vous spécifiez.",
  "a_faq_window_content_1": "Non, cela n'affectera rien. La liste Scenes to Parse est utilisée exclusivement pour indiquer à l'outil quelles scènes ouvrir et analyser pour le texte. Elle n'est en aucun cas liée aux scènes qui se retrouveront dans la construction finale de votre jeu.",
  "a_faq_window_content_2": "Non, elle ne le sera pas. La liste temporaire stocke une référence directe à l'objet dans la scène. Lorsque vous créez un prefab, c'est une nouvelle ressource. Ses instances sont des objets différents, et la règle d'ignorance ne s'appliquera pas à elles. Pour ignorer définitivement les prefabs, ils doivent être ajoutés à la liste d'ignorés en tant que ressource prefab.",
  "a_faq_window_content_3": "Oui, elle le sera. Lorsque vous cliquez sur Update Keys, l'analyseur rescane l'ensemble du projet. Il verra que le type TMPro.TMP_Text doit être ignoré et ne générera pas de clé pour celui-ci. Pendant le processus de comparaison des anciennes et des nouvelles clés, il déterminera que l'ancienne clé n'est plus utilisée et la marquera comme \"Removed\".",
  "a_faq_window_content_4": "Non, il ne le fera pas. \"Pin\" enregistre le chemin absolu dans la hiérarchie de la scène au moment où le bouton est cliqué (par exemple, Canvas/Panel/Button). Ce chemin n'est pas lié à la logique des prefabs. Les instances de prefab auront le même chemin, mais si vous renommez l'objet parent dans la scène, \"Pin\" cessera de fonctionner à la fois pour l'original et pour les instances.",
  "a_faq_window_content_5": "Le chemin complet à partir de la racine de la scène sera enregistré. Par exemple, MyPrefab(Clone)/Content/Icon. Ce chemin \"épinglé\" ne fonctionnera que dans la scène où vous l'avez créé. Dans d'autres scènes, un tel chemin est peu probable d'être trouvé.",
  "a_faq_window_preview_1": "Non, cela ne sera pas enregistré. PreviewSafetyBridge intercepte l'événement d'enregistrement des assets (OnWillSaveAssets) et appelle automatiquement RevertEditorPreview() avant que Unity n'écrive les modifications sur le disque. Ainsi, le prefab sera enregistré dans son état original, non localisé.",
  "a_faq_window_preview_2": "PreviewRecoveryService gère la récupération après plantage. Si Unity plante, le service détecte le fichier de sauvegarde au prochain lancement et tente de restaurer l'état de la scène. Si la récupération automatique échoue, vous devrez peut-être sélectionner manuellement \"Revert to Original\" dans la fenêtre de l'outil.",
  "a_faq_window_preview_3": "Oui, elles le seront. PrefabUtility.InstantiatePrefab en Mode Édition appelle Awake() et OnEnable(). Si ces méthodes contiennent une logique qui ne devrait pas s'exécuter dans l'éditeur (par exemple, accéder à des singletons qui n'existent qu'en Mode Lecture), cela pourrait provoquer des erreurs. Il est recommandé d'utiliser if (Application.isPlaying) ou #if UNITY_EDITOR pour protéger un tel code.",
  "a_faq_window_report_1": "Oui, elle sera interrompue. Toute nouvelle action qui nécessite un blocage de l'interface utilisateur (comme Update Keys) arrêtera la coroutine de recherche en cours. Une boîte de dialogue apparaîtra, vous invitant à arrêter la recherche actuelle pour en démarrer une nouvelle.",
  "a_faq_window_report_2": "La catégorie \"Duplicates\" affichera toutes les sources pour cette clé. Vous verrez une entrée pour la clé, et le champ \"Source\" listera tous les chemins (dans la scène 1 et la scène 2). Le bouton \"Find\" dans ce cas ouvrira une liste déroulante, vous permettant de choisir à quel objet naviguer.",
  "a_faq_window_report_3": "Oui. Le système de recherche est spécifiquement formé pour reconnaître les sources comme le script MyScript.cs. Lorsque vous cliquez sur \"Find\", il recherchera la ressource MyScript.cs dans le projet et la surlignera (ping) dans la fenêtre Projet.",
  "a_faq_window_settings_1": "Oui, elles le seront. Lors du changement de mode, l'outil effectue une \"migration sûre\" : il ré-analyse l'ensemble du projet, crée de nouvelles clés selon les nouvelles règles, mais mappe les anciennes et les nouvelles clés via le texte original. Il transfère ensuite toutes vos traductions et commentaires existants des anciennes clés vers les nouvelles. Vos traductions ne seront pas perdues.",
  "a_faq_window_settings_2": "La règle DefaultPluralRule sera utilisée, qui convient à l'anglais et à la plupart des langues européennes (formes pour \"one\" et \"other\").",
  "a_faq_window_settings_3": "Non, ils ne le seront pas. Seules les ressources situées dans un dossier StreamingAssets ou Resources sont garanties d'être incluses dans la construction. Si vous spécifiez un chemin différent, la localisation fonctionnera dans l'éditeur mais ne fonctionnera pas dans le jeu compilé, car les fichiers de traduction ne feront pas partie de la construction.",
  "a_faq_window_settings_4": "Oui. EditorPrefs est un stockage local pour chaque ordinateur. Vous devrez saisir la <strong>Translation Service API Key</strong> (pour l'utilisation dans l'Editor comme OpenAI/DeepL) sur chaque machine. En revanche, la <strong>Runtime API Key</strong> (utilisée dans les builds) est stockée dans les paramètres du projet et partagée via le contrôle de version (chiffrée).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\"key\") calls\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "Copié !",
  "copy_code_copy": "Copier",
  "copy_code_error": "Erreur",
  "error_loading_message": "Veuillez vérifier votre connexion et actualiser.",
  "error_loading_title": "Erreur de Chargement",
  "h1_ai_audio": "Audio IA / Synthèse Vocale (Text-to-Speech)",
  "h1_ai_profiles": "Profils IA & Traduction",
  "h1_api_snippets": "API & Extraits de code",
  "h1_components": "Composants de Base (attribués automatiquement)",
  "h1_extending": "Extension des Fonctionnalités",
  "h1_faq": "FAQ et Dépannage",
  "h1_font_glyph_manager": "Gestionnaire de Polices et de Glyphes",
  "h1_important_notes": "Notes Importantes et Avertissements",
  "h1_introduction": "Introduction",
  "h1_loc_tool_window": "Fenêtre \"Localization Tool\"",
  "h1_migration_tool": "Outil de Migration",
  "h1_quick_start": "Démarrage Rapide et Configuration",
  "h1_tms": "Intégration TMS externe (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Éditeur de Table de Traduction",
  "h1_usage_examples": "Exemples d'Utilisation",
  "h2_ai_assistant": "Commandes de l'assistant IA",
  "h2_ai_audio_setup": "Configuration",
  "h2_ai_audio_usage": "Utilisation",
  "h2_ai_context": "Contexte & glossaire",
  "h2_ai_profiles_overview": "Profils de traduction",
  "h2_async_api": "API asynchrone (Addressables)",
  "h2_backup_manager": "Gestionnaire de sauvegardes",
  "h2_bridge_generation": "Générer des ponts C# (accès fortement typé)",
  "h2_custom_ai": "IA personnalisée & modèles",
  "h2_custom_asset_provider": "Création d'un fournisseur d'actifs personnalisé",
  "h2_custom_attributes": "Analyse des attributs personnalisés",
  "h2_custom_parser": "Création d'un analyseur personnalisé",
  "h2_example_attribute": "[LocalizableField] Attribut",
  "h2_example_components": "Composants prêts à l'emploi et exemples",
  "h2_example_components_updated": "LanguageSelector.cs Mis à Jour",
  "h2_example_function": "Fonction _() et attribut [OnLanguageChange]",
  "h2_example_plurals": "Pluriels et genre",
  "h2_faq_addressables": "Addressables et Migration",
  "h2_faq_audio": "Audio IA / Synthèse Vocale (Text-to-Speech)",
  "h2_faq_components": "Composants de base",
  "h2_faq_editor": "Éditeur de traduction",
  "h2_faq_examples": "Exemples d'utilisation & code",
  "h2_faq_extending": "Extension des fonctionnalités",
  "h2_faq_installation": "Installation & démarrage rapide",
  "h2_faq_notes": "Nuances importantes & avertissements",
  "h2_faq_window": "Fenêtre \"Outil de localisation\"",
  "h2_font_glyph_manager_features": "Fonctionnalités",
  "h2_in_editor_preview": "Aperçu dans l'éditeur & Prefab",
  "h2_initial_setup": "Configuration initiale",
  "h2_installation": "Installation",
  "h2_key_features": "Fonctionnalités Clés",
  "h2_live_updates_guide": "Guide des mises à jour en direct",
  "h2_localizedasset": "LocalizedAsset",
  "h2_localizedasset_updated": "Chargement Asynchrone de LocalizedAsset",
  "h2_localizedbehaviour": "LocalizedBehaviour",
  "h2_localizeddropdown": "LocalizedDropdown",
  "h2_localizedprefab": "LocalizedPrefab",
  "h2_localizedtext": "LocalizedText",
  "h2_migration_custom": "Création de profils personnalisés",
  "h2_migration_google_sheets": "Clé Google Sheets",
  "h2_migration_import_formats": "Formats d'importation (CSV & Google Sheets)",
  "h2_migration_stubs": "Migration sécurisée & Stubs d'urgence",
  "h2_migration_tool_features": "Fonctionnalités",
  "h2_migration_workflow": "Guide du flux de travail de migration",
  "h2_preview_overlay": "Superposition de la vue de scène",
  "h2_safety_caps": "Limites & quotas de sécurité",
  "h2_script_parsing_rules": "Règles d'analyse des scripts (compatibilité)",
  "h2_tab_actions": "Onglet \"Actions\"",
  "h2_tab_assets": "Onglet \"Assets\"",
  "h2_tab_content": "Onglet \"Contenu\"",
  "h2_tab_report": "Onglet \"Rapport\"",
  "h2_tab_settings": "Onglet \"Paramètres\"",
  "h2_tab_tutorials": "\"Tutoriels\" Onglet",
  "h2_tms_setup": "Configuration et utilisation",
  "h2_tms_supported": "Services pris en charge",
  "h2_uitklocalization": "UITKLocalization",
  "h2_visual_debugging_guide": "Débogage visuel",
  "h2_window_footer": "Pied de fenêtre (Barre d'état)",
  "h2_window_header": "En-tête de fenêtre & Barre d'outils",
  "h2_window_sidebar": "Menu principal (Barre latérale)",
  "h3_actions_autotranslate": "Traduction automatique",
  "h3_actions_danger": "Zone dangereuse",
  "h3_actions_data": "Gestion des données",
  "h3_actions_editor": "Éditeur de traduction",
  "h3_actions_parsing": "Analyse",
  "h3_actions_tms_integration": "Services externes (TMS)",
  "h3_assets_automation": "Automatisation",
  "h3_assets_categories": "Catégories d'actifs",
  "h3_assets_folder_gen": "Génération de dossiers",
  "h3_assets_loading": "Stratégie de chargement",
  "h3_assets_storage": "Configuration du stockage",
  "h3_attribute_cheat_sheet": "Référence rapide : Ce qu'il faut faire et ne pas faire",
  "h3_attribute_features": "Types et fonctionnalités pris en charge",
  "h3_attribute_limitations": "Limitations",
  "h3_content_components_ignore": "Types de composants à ignorer",
  "h3_content_dynamic_keys": "Préfixes de clés dynamiques",
  "h3_content_dynamic_texts": "Textes dynamiques",
  "h3_content_objects_ignore": "Objets à ignorer",
  "h3_content_prefabs": "Dossiers de Prefab",
  "h3_content_regex": "Modèles Regex ignorés",
  "h3_content_scenes": "Scènes à analyser",
  "h3_content_script_rules": "Règles d'analyse de script",
  "h3_content_scripts_ignore": "Scripts à ignorer",
  "h3_custom_provider_steps": "Étapes d'implémentation",
  "h3_faq_window_actions": "Onglet \"Actions\"",
  "h3_faq_window_assets": "Onglet \"Assets\" (Ressources)",
  "h3_faq_window_content": "Onglet \"Content\" (Contenu)",
  "h3_faq_window_preview": "Aperçu dans l'Éditeur",
  "h3_faq_window_report": "Onglet \"Report\" (Rapport)",
  "h3_faq_window_settings": "Onglet \"Settings\" (Paramètres)",
  "h3_mode_auto": "AutoGenerateKeysOnly (Standard)",
  "h3_mode_hybrid": "Modes hybrides (priorité personnalisée)",
  "h3_mode_text": "UseTextAsKey (Simplifié)",
  "h3_report_all_keys": "Toutes les clés",
  "h3_settings_debugging": "Débogage",
  "h3_settings_general": "Paramètres généraux",
  "h3_settings_keygen": "Génération de clés",
  "h3_settings_languages": "Gestion des langues",
  "h3_settings_liveupdates": "Mises à jour en direct",
  "h3_settings_pseudo": "Paramètres de pseudo-localisation",
  "h3_settings_runtimeapi": "API d'exécution",
  "h3_settings_tools": "Outils généraux & de développement",
  "h3_tutorials_list": "Liste des tutoriels",
  "lbl_not_supported": "NON pris en charge",
  "lbl_supported": "Entièrement pris en charge",
  "li_actions_1": "<strong>Parsing :</strong><ul><li><strong>Update Keys :</strong> Analyse complète du projet définie par les paramètres de l'onglet 'Content'.</li><li><strong>Scan Selected Assets :</strong> Analyse **UNIQUEMENT** les fichiers/dossiers actuellement sélectionnés dans la Vue Projet. Plus sûr pour les mises à jour partielles car il désactive automatiquement 'Remove Missing Keys'.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor :</strong> Ouvre une fenêtre séparée, plus pratique pour éditer toutes les traductions.",
  "li_actions_3": "<strong>Gestion des données :</strong> Utilisez pour échanger des données avec les traducteurs (Export/Import vers CSV/XML/YAML/XLIFF, import depuis Google Sheets). <strong>Google Sheets :</strong> Prend en charge les liens 'Edit' et les URL 'Publish to Web' (vérifiez le paramètre GID).",
  "li_actions_4": "<strong>Auto-Translation :</strong> Remplit automatiquement toutes les chaînes de traduction vides à l'aide du <strong>Translation Profile</strong> actif.",
  "li_actions_5": "<strong>Danger Zone :</strong> Contient des boutons pour supprimer complètement tous les composants de localisation du projet. À utiliser avec prudence !",
  "li_ai_1": "<strong>Créer un Profil :</strong> Clic droit dans la Vue Projet -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Services :</strong> Prend en charge DeepL, Google Translate, Microsoft Azure et <strong>l'IA Personnalisée</strong>.",
  "li_ai_3": "<strong>Paramètres :</strong> Chaque profil stocke sa propre clé API, ses limites (taille de lot, max. de caractères) et ses paramètres de modèle.",
  "li_ai_4": "<strong>AIPresetsGenerator :</strong> Utilisez le générateur intégré pour créer rapidement des profils pour les services populaires (OpenAI, Gemini, Claude, Ollama).",
  "li_ai_audio_generate": "Dans l'<strong>Éditeur de Table de Traduction</strong>, sélectionnez les lignes/cellules -> Clic droit -> <strong>Generate Audio</strong>.",
  "li_ai_audio_hash": "<strong>Mise à Jour Intelligente et Hachage :</strong> L'outil calcule un hachage MD5 de votre contenu textuel et ne régénère les fichiers audio que si le texte source a changé, économisant ainsi vos crédits API. Il détecte si la traduction a changé depuis la dernière génération audio. L'éditeur met en évidence ces lignes avec une icône 'Obsolète' (jaune), vous permettant de mettre à jour **UNIQUEMENT** les lignes modifiées. Cette fonctionnalité de regroupement intelligent empêche les appels API inutiles et réduit les coûts lors de la régénération audio. L'outil hache votre texte et ne régénère les fichiers audio que si le texte source a changé, économisant ainsi vos crédits API.",
  "li_ai_audio_profile": "Dans <strong>Settings</strong>, sélectionnez le <strong>Active Audio Profile</strong> (par exemple, OpenAI TTS ou ElevenLabs).",
  "li_ai_audio_save": "Les fichiers sont enregistrés dans le dossier spécifié dans le profil.",
  "li_ai_audio_voice_mapping": "<strong>Correspondance de voix (Multi‑locuteur) :</strong> Attribuez différentes voix d'IA à différents personnages automatiquement. Utilisez la liste <strong>Correspondances de voix</strong> pour associer des motifs Regex (par ex. <code>^hero_.*</code>) à des ID de voix spécifiques. L'outil sélectionnera automatiquement la bonne voix en fonction du nom de la clé lors de la génération audio.",
  "li_ai_provider_settings": "<strong>Paramètres du fournisseur :</strong> Chaque service permet de configurer les clés API, les modèles (p. ex., GPT-4o, Sonnet) et les paramètres spécifiques à la voix (Stabilité, Similarité).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt; :</strong> Utilisez ceci pour charger les assets Addressables de manière asynchrone. Il renvoie un <code>Task&lt;T&gt;</code>.",
  "li_api_gender_method": "GetGendered : GetGendered(string baseKey, Gender gender) renvoie une traduction spécifique au genre.",
  "li_api_plural_method": "<strong>GetPlural :</strong> <code>GetPlural(string baseKey, double count)</code> renvoie la forme plurielle correcte selon les règles propres à chaque langue.",
  "li_api_set_lang_method": "<strong>SetLanguage :</strong> Une coroutine (<code>IEnumerator</code>) pour changer la langue. Utilisez toujours <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Créer une structure de dossiers (facultatif) :</strong> Dans la section <strong>2. Asset Folder Generation</strong>, cliquez sur <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Configurer les catégories et les règles de nommage :</strong> Dans la section <strong>3. Asset Categories & Scanning</strong>, assurez-vous que la <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) correspond à vos fichiers (par exemple, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Placez vos ressources :</strong> Mettez les ressources localisées dans les dossiers.",
  "li_assets_4": "<strong>Analyser les ressources :</strong> Dans la section <strong>4. Automation</strong>, cliquez sur <strong>Scan Assets & Update Tables</strong>. Le processus de nettoyage est devenu plus sûr : seuls les anciens fichiers de table (<code>.asset</code>) sont supprimés, et non le dossier entier.",
  "li_assets_5": "<strong>Lier les ressources aux objets :</strong> Cliquez sur <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Addressables Integration :</strong> Si le mode <strong>Addressables</strong> est activé, les ressources seront automatiquement enregistrées dans les groupes Addressables avec des adresses sous la forme <code>{Category}/{Language}/{Key}</code> pendant l'analyse.",
  "li_assets_addressables_naming": "<strong>Convention de Nommage :</strong> Lors de l'analyse, l'outil définit automatiquement les Adresses Addressable au format <code>{Category}/{Language}/{Key}</code>. **Ne renommez pas** ces adresses manuellement, car le LocalizationManager se base sur ce format spécifique pour charger les ressources au moment de l'exécution.",
  "li_assets_auto_folders": "<strong>Génération automatique de dossiers :</strong> Si activé, l'outil créera automatiquement la structure de répertoires nécessaire pour toutes les langues prises en charge lors de la première localisation d'assets.",
  "li_assets_folder_gen": "<strong>Génération de dossiers :</strong> Crée automatiquement la structure de dossiers pour les assets localisés selon vos règles.",
  "li_assets_storage_path": "<strong>Chemin de stockage des assets :</strong> Définissez le répertoire racine pour tous les assets localisés (Sprites, Audio, etc.). Utilisez la variable <code>{lang}</code> pour spécifier la façon dont les dossiers par langue sont structurés.",
  "li_assistant_1": "<strong>Configurable :</strong> Définissez des commandes dans votre Profil de Traduction (par exemple, \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\").",
  "li_assistant_2": "<strong>Traitement par Lots :</strong> Sélectionnez plusieurs cellules pour appliquer la commande à toutes en même temps.",
  "li_assistant_3": "<strong>Commandes personnalisées :</strong> Définissez vos propres invites dans l'inspecteur <strong>Profil de traduction</strong> (Liste de <code>AIAssistantCommand</code>). Chaque commande possède un <strong>Label</strong> (apparaît dans le menu contextuel) et un <strong>Prompt</strong> (les instructions envoyées à l'IA, par ex., \"Réécrire en style pirate\").",
  "li_attr_feat_1": "<strong>Collections :</strong> Prend en charge <code>List&lt;string&gt;</code> et <code>string[]</code>. Les clés sont générées avec les suffixes <code>_0</code>, <code>_1</code>, etc. Vous pouvez même utiliser une clé personnalisée sur le champ de liste lui-même pour préfixer tous les éléments.",
  "li_attr_feat_2": "<strong>Modificateurs d'accès :</strong> Fonctionne avec les champs <code>private</code>, <code>protected</code>, <code>internal</code> et <code>public</code>.",
  "li_attr_feat_3": "<strong>Attributs personnalisés :</strong> Dans les paramètres de l'<em>onglet Contenu</em>, vous pouvez ajouter <code>HeaderAttribute</code>, <code>TooltipAttribute</code> ou tout nom d'attribut personnalisé. L'analyseur traitera alors les champs avec ces attributs (par exemple, <code>[Header(\"Text\")]</code>) comme des chaînes localisables !",
  "li_attr_feat_4": "<strong>Objets imbriqués :</strong> Analyse récursivement les champs à l'intérieur des classes ou des structs marqués avec <code>[System.Serializable]</code>. Cela inclut les instances uniques et les listes d'objets imbriqués.",
  "li_attr_feat_5": "<strong>Chaînes formatées :</strong> Prend en charge les chaînes interpolées (<code>$\"Text {0}\"</code>), les chaînes verbatim (<code>@\"Text\"</code>), et la concaténation (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Les propriétés sont prises en charge :</strong> L'analyseur parcourt à la fois les <code>Fields</code> et les <code>Properties</code>. Un getter est requis.",
  "li_attr_limit_2": "<strong>Dictionnaires :</strong> <code>Dictionary&lt;T, string&gt;</code> n'est pas directement pris en charge pour l'analyse.",
  "li_attr_limit_3": "<strong>Champs statiques :</strong> Pris en charge via l'analyse statique (regex) dans les fichiers de code, mais il est généralement recommandé d'utiliser des champs d'instance pour une détection robuste sur les GameObjects.",
  "li_backup_desc": "Suivez les modifications et restaurez les versions précédentes de vos traductions.",
  "li_backup_rollback": "<strong>Rollback :</strong> Restaurez instantanément les clés sélectionnées ou l'ensemble du tableau à un état antérieur.",
  "li_backup_snapshots": "<strong>Snapshots :</strong> Crée des points de restauration nommés avant les opérations en masse.",
  "li_cheat_base_private": "<strong>Champs privés de base :</strong> Pris en charge (le scanner lit directement les fichiers de classe de base)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, tableaux <code>string[]</code>",
  "li_cheat_concatenation": "<strong>Concaténation de chaînes :</strong> <code>\"A\" + \"B\"</code> (Pris en charge)",
  "li_cheat_constructor_args": "<strong>Arguments de Constructeur Complexes :</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>Dictionnaires</strong> (Non sérialisables par l'inspecteur Unity naturellement)",
  "li_cheat_headers": "Attributs comme <code>[Header(\"...\")]</code> (Entièrement pris en charge)",
  "li_cheat_nested_lists": "<strong>Listes d'objets imbriqués</strong> (par ex. <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Variables & Constants:</strong> <code>const string s = \"Value\";</code> or <code>static string</code> (Pris en charge, Roslyn résout les valeurs depuis le même fichier)",
  "li_cheat_private": "<code>private</code> / <code>protected</code> champs (Pris en charge)",
  "li_cheat_properties": "<strong>Propriétés :</strong> <code>{ get; set; }</code> (Auto‑properties et propriétés complètes prises en charge)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Pris en charge s'ils sont référencés)",
  "li_cheat_serializable": "Classes imbriquées <code>[Serializable]</code> (Éléments d'inventaire, nœuds de dialogue)",
  "li_cheat_static": "<strong>Champs statiques :</strong> <code>public static string</code> (Entièrement pris en charge)",
  "li_cheat_structs": "<strong>Structs & Records :</strong> Pris en charge (analyse récursive)",
  "li_cheat_ternary": "<strong>Logique/Ternaire :</strong> <code>cond ? \"A\" : \"B\"</code> (Le parseur ne peut pas déterminer la valeur)",
  "li_cheat_unattached": "<strong>Scripts détachés :</strong> Pris en charge (le scanner lit tous les fichiers .cs du projet)",
  "li_content_1": "<strong>Scenes to Parse :</strong> Faites glisser et déposez toutes les scènes à analyser ici.",
  "li_content_2": "<strong>Prefab Folders :</strong> Spécifiez les dossiers contenant les prefabs. Prend désormais en charge la pagination et la recherche pour les grands projets.",
  "li_content_3": "<strong>Dynamic Texts :</strong> Entrez ici les chaînes qui sont créées exclusivement dans le code (par exemple, \"Game Over\").",
  "li_content_4": "<strong>Types de composants à ignorer :</strong> Spécifiez les types de composants Unity qui doivent être ignorés lors de l'analyse.",
  "li_content_5": "<strong>Épingler à ignorer :</strong> Cette fonctionnalité vous permet d'\"épingler\" un objet de la scène à la liste d'ignorés de façon permanente.",
  "li_content_6": "<strong>Scripts à ignorer :</strong> Ajoutez des scripts C# spécifiques OU des dossiers entiers pour les exclure de l'analyse.",
  "li_content_7": "<strong>Préfixes de clés dynamiques :</strong> Liste de préfixes pour les clés (par ex., <code>Item_</code>) qui ne seront pas supprimés lors du nettoyage.",
  "li_content_dynamic_keys": "<strong>Préfixes de clés dynamiques :</strong> Définissez des préfixes (par ex., <code>quest_item_</code>) qui doivent être reconnus comme potentiellement dynamiques. Cela aide l'outil à distinguer les libellés UI statiques des clés générées par les données.",
  "li_content_dynamic_texts": "<strong>Règles de texte dynamique :</strong> Configurez des modèles pour le texte mis à jour dynamiquement via le code. Cela empêche le scanner de créer des clés redondantes pour le texte qui change à l'exécution.",
  "li_content_regex_example": "<strong>Exemple de wrapper personnalisé :</strong> Si vous utilisez une fonction personnalisée comme <code>MyGame.Loc(\"KEY\")</code>, ajoutez une règle d'analyse de script avec l'expression régulière : <code>\\\\bMyGame\\\\.Loc\\\\s*\\\\(\\\\s*\\\"([^\\\"]*)\\\"</code>.",
  "li_content_regex_presets": "<strong>Modèles d'expression régulière ignorés :</strong> Cliquez sur <strong>'Add Common Pattern'</strong> pour exclure rapidement le contenu dynamique tel que les URL, les e‑mails, etc.",
  "li_content_scanner": "<strong>Analyseur de code Roslyn :</strong> Un moteur d'analyse statique approfondie qui comprend les arbres de syntaxe C# pour une détection fiable des clés.",
  "li_content_scanner_details_1": "<strong>Détection d'appels intelligents :</strong> trouve automatiquement les appels <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> et <code>GetTranslation(\"Text\")</code>. Il impose le mode <strong>Text-As-Key</strong> pour ces appels afin d'assurer le bon fonctionnement des fonctionnalités d'exécution telles que la pluralisation et le genre.",
  "li_content_scanner_details_2": "<strong>Résolution de constantes :</strong> L'analyseur est suffisamment intelligent pour résoudre les variables de chaîne `const` ou `static readonly`. Si vous utilisez <code>_ (MyConst)</code>, il trouvera la valeur de `MyConst` (si définie dans la même classe) et l'utilisera comme texte source.",
  "li_content_scanner_details_3": "<strong>Attributs et métadonnées :</strong> Il analyse tout champ ou propriété avec `[LocalizableField]`, `[Header]` ou `[Tooltip]` (si configuré). Il gère les <strong>Tableaux</strong>, les <strong>Listes</strong> et même les <strong>Classes sérialisables imbriquées</strong> de façon récursive.",
  "li_content_scanner_details_4": "<strong>Prise en charge moderne de C# :</strong> Prise en charge complète de la syntaxe C# 9.0+, y compris les expressions typées cible <code>new()</code>, la création implicite de tableaux et les chaînes interpolées (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Attributs à analyser :</strong> Définissez des attributs personnalisés (comme <code>[Header]</code> ou <code>[Tooltip]</code>) que l'analyseur doit reconnaître comme sources de chaînes localisables.",
  "li_content_script_rules_bridge_name": "<strong>Nom de la classe de pont :</strong> Vous permet de définir le nom de la classe statique générée.",
  "li_content_script_rules_bridges": "<strong>Générer des ponts C# :</strong> Crée automatiquement une classe statique (par ex. <code>AnkoLoc</code>) offrant un accès fortement typé à toutes les clés, éliminant les chaînes magiques et permettant l’autocomplétion dans l’IDE.",
  "li_context_1": "<strong>Developer Notes :</strong> Les commentaires de la table de traduction sont transmis à l'IA comme contexte.",
  "li_context_2": "<strong>Object Path :</strong> S'il n'y a pas de commentaire, le chemin de la hiérarchie de l'objet (par exemple, <code>MainMenu/Canvas/StartButton</code>) est utilisé comme contexte de repli.",
  "li_context_3": "<strong>Glossary :</strong> Vous pouvez charger un glossaire CSV dans le profil pour imposer des traductions spécifiques pour les termes et les noms.",
  "li_context_4": "<strong>Description du projet :</strong> Décrivez le cadre et le public de votre jeu pour aider l'IA à comprendre le contexte général.",
  "li_context_5": "<strong>Ton & style :</strong> Définissez le personnage souhaité (par ex., « Friendly », « Professional », « Pirate ») et les règles de formatage.",
  "li_context_glossary": "<strong>Gestionnaire de dictionnaire :</strong> Interagissez directement avec le glossaire pour « Ajouter », « Modifier » ou « Supprimer » des termes. Prend en charge la sensibilité à la casse et les types « Ne pas traduire ».",
  "li_context_optimization": "<strong>Optimisation des tokens :</strong> Le système compacte intelligemment le contexte et réutilise le cache afin de minimiser l'utilisation des tokens et les coûts.",
  "li_custom_ai_1": "<strong>GenericAIService :</strong> Une implémentation flexible qui peut communiquer avec les API compatibles OpenAI (y compris les LLM locaux via Ollama).",
  "li_custom_ai_2": "<strong>Modèles & Authentification :</strong> Personnalisez entièrement la requête. <ul><li><strong>Auth :</strong> Configurez <code>Auth Header Key</code> (par ex. <code>Authorization</code>) et <code>Format</code> (par ex. <code>Bearer {0}</code>). Prend en charge la clé API dans les paramètres de requête.</li><li><strong>Modèle de corps :</strong> Utilisez un modèle JSON avec des espaces réservés comme <code>{model}</code> et <code>{prompt}</code> pour le texte, ou <code>{input}</code> et <code>{voice}</code> pour l’audio.</li><li><strong>Chemin de réponse :</strong> Définissez le chemin JSON vers le résultat (par ex. <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Fonctionnalités de Sécurité Intégrées :</strong> Répare automatiquement les balises de formatage cassées (comme <ph0>) souvent renvoyées par les modèles d'IA, assurant des traductions fiables et cohérentes.",
  "li_custom_parser_1": "Créez un nouveau script C# dans le dossier **Editor** de votre projet.",
  "li_custom_parser_2": "Copiez le modèle ci-dessous dedans.",
  "li_custom_parser_3": "Modifiez la logique pour qu'elle corresponde à votre composant.",
  "li_custom_provider_manual_reg": "<strong>Enregistrement manuel :</strong> Pour les scénarios avancés (comme l'injection DI ou l'initialisation paresseuse), vous pouvez enregistrer manuellement votre fournisseur via <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> lors de l'initialisation.",
  "li_custom_provider_step_1": "<strong>Implémenter l'interface :</strong> Créez une nouvelle classe qui implémente <code>IAssetProvider</code>. Vous devrez définir comment charger les actifs avec <code>Load&lt;T&gt;</code> (synchrone) et <code>LoadAsync&lt;T&gt;</code> (asynchrone) en utilisant l'API de votre système.",
  "li_custom_provider_step_2": "<strong>Définir le cycle de vie :</strong> Implémentez <code>Initialize</code>, <code>Dispose</code> et <code>UnloadAll</code>. Ces méthodes sont appelées par le <code>LocalizationManager</code> lors du changement de langue ou du nettoyage des ressources.",
  "li_custom_provider_step_3": "<strong>Sécurité linguistique :</strong> La méthode <code>SetCurrentLanguage</code> est appelée chaque fois que la langue active change. Utilisez-la pour mettre à jour les chemins internes ou récupérer à nouveau les métadonnées des actifs.",
  "li_custom_provider_step_4": "<strong>Découverte automatique (recommandée) :</strong> Décorez votre classe avec l'attribut <code>[AssetProviderPlugin]</code>. Cela rend votre fournisseur immédiatement visible dans le menu déroulant <strong>Onglet Paramètres -&gt; Stratégie de chargement des actifs</strong>.",
  "li_editor_1": "<strong>Regroupement Intelligent :</strong> Les clés pour les pluriels et le genre (par exemple, <code>apple_count_one</code>, <code>apple_count_few</code>) sont automatiquement combinées en groupes réductibles.",
  "li_editor_2": "<strong>Édition Avancée :</strong> Cliquez sur une cellule pour ouvrir la fenêtre contextuelle <strong>MultiLineEditWindow</strong>. Elle affiche le texte source pour comparaison et valide les placeholders.",
  "li_editor_3": "<strong>Sélection avancée :</strong> Prend en charge des modes de sélection flexibles : cellules individuelles, lignes entières ou colonnes spécifiques (langues). Utilisez <code>Ctrl+Click</code> et <code>Shift+Click</code> pour des sélections complexes.",
  "li_editor_4": "<strong>Actions de masse :</strong> Execute operations on thousands of cells at once. Right-click your selection to: <ul><li><strong>Auto-traduction :</strong> Remplir les traductions manquantes en utilisant le profil IA actif.</li><li><strong>Remplir depuis la source :</strong> Réinitialiser rapidement les traductions.</li><li><strong>Basculer le verrouillage :</strong> Protéger les traductions « perfectes » contre les écrasements accidentels.</li><li><strong>Générer l’audio :</strong> Traiter par lots le TTS pour les phrases sélectionnées.</li></ul>",
  "li_editor_5": "<strong>Navigation haute performance :</strong> L'éditeur utilise une vue virtualisée 'MultiColumnListView' pour un défilement fluide avec plus de 10 k clés. Prend en charge la navigation au clavier (flèches/Tab) et des raccourcis puissants : <code>Ctrl+S</code> (Enregistrer), <code>Ctrl+Z/Y</code> (Annuler/Rétablir), <code>Ctrl+F</code> (Focaliser la recherche).",
  "li_editor_6": "<strong>Préréglages de recherche avancée :</strong> Audit your project using specialized filters: <ul><li><strong>Statut :</strong> Non traduit (actuel/toute langue), Identique à la source, Verrouillé.</li><li><strong>Contenu :</strong> Contient des commentaires, Contient/manque des espaces réservés, Présente des problèmes de longueur (détectés automatiquement).</li><li><strong>Structure :</strong> Pluriel, Genre, ou les deux.</li><li><strong>Audio :</strong> Audio manquant, Obsolète (hash ne correspond pas).</li></ul>",
  "li_editor_7": "<strong>Gestion intelligente de l’audio :</strong> Suit la « fraîcheur » de vos fichiers TTS. Si vous modifiez le texte de traduction, un <strong>Indicateur jaune (Obsolète)</strong> apparaît, indiquant que le hash du fichier audio ne correspond plus au texte. Un clic régénère uniquement les fichiers périmés.",
  "li_editor_8": "<strong>Mécanisme de verrouillage :</strong> Explanation: <ul><li><strong>Cellules/Lignes verrouillées :</strong> Empêche toute modification par <strong>Auto-traduction</strong>, <strong>Import CSV/Google</strong> ou <strong>Remplir depuis la source</strong>.</li><li><strong>Cas d'utilisation :</strong> Verrouiller les traductions « Gold » qui ont été vérifiées manuellement par des locuteurs natifs.</li><li><strong>Contrôle en masse :</strong> Verrouiller des langues entières ou des fonctionnalités spécifiques (comme les noms de personnages) à l'échelle du projet.</li></ul>",
  "li_editor_layout": "<strong>Disposition dynamique multi-panneaux :</strong> Utilisez le système à 3 panneaux pour épingler les colonnes « fixes » (comme les clés) à gauche tout en faisant défiler plus de 20 langues au centre. Basculez la visibilité des colonnes via le menu contextuel de l'en-tête.",
  "li_editor_regex": "<strong>Recherche Regex :</strong> La fenêtre principale et l'éditeur de tableau prennent en charge les <strong>expressions régulières</strong>. Si votre requête contient des symboles comme <code>* + ? ^ $ [ ] ( ) { } | .</code>, elle est automatiquement interprétée comme une regex (par ex., <code>^item_.*</code> pour trouver toutes les clés commençant par 'item_').",
  "li_editor_structure": "<strong>Tables et groupes :</strong> Les données sont organisées en tables (fichiers) et affichées comme groupes (dossiers) dans l'éditeur pour une meilleure navigation.",
  "li_editor_ui_test": "<strong>Tests UI intégrés :</strong> <ul><li><strong>Curseur d'expansion de longueur :</strong> Simulez l'expansion du texte (0 % - 100 %) pour voir comment votre UI gère les langues plus longues comme l'allemand ou le russe sans quitter l'éditeur.</li><li><strong>Rendu de texte enrichi :</strong> Basculez le rendu des balises (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) pour vérifier le style sans lancer le jeu.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code> :</strong> Un composant prêt à l'emploi pour créer une liste déroulante d'interface utilisateur pour le changement de langue. Il trouve automatiquement toutes les langues disponibles et gère leur commutation.<br><strong>Comment l'utiliser :</strong> Ajoutez simplement le composant <code>LanguageSelector</code> à votre scène (par exemple, sur un GameObject vide) et spécifiez votre <code>TMP_Dropdown</code> dans l'inspecteur.",
  "li_example_components_2": "<strong>Exemples de Code :</strong> Pour apprendre des techniques avancées telles que travailler avec <code>[LocalizableField]</code>, la fonction <code>_()</code>, les pluriels et le genre, étudiez les fichiers <code>StatPurchaseTest.cs</code> et <code>TestLocalization.cs</code>. Ils démontrent clairement l'implémentation de toutes les principales fonctionnalités de l'outil dans le code.",
  "li_example_components_new": "<strong>Nouveau (v2.0) :</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Retourne <code>IEnumerator</code>. Doit être utilisé avec yield.",
  "li_example_components_old": "<strong>Ancien :</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (void synchrone) - <strong>Obsolète</strong>. Utilisez la version Coroutine.",
  "li_feature_1": "<strong>Analyse Avancée :</strong> Balayage automatique des scènes, prefabs, UI Toolkit (UXML) et scripts C#, y compris les champs marqués de l'attribut <code>[LocalizableField]</code>, ainsi que les classes et listes imbriquées.",
  "li_feature_10": "<strong>Gestionnaire de Sauvegardes :</strong> Un outil intégré pour créer et restaurer des sauvegardes.",
  "li_feature_11": "<strong>Alimenté par l'IA :</strong> Support pour OpenAI, Anthropic (Claude), Google Gemini et LLM locaux (Ollama) via des profils personnalisables.",
  "li_feature_12": "<strong>Synthèse Vocale (TTS) :</strong> Génération de fichiers audio pour les chaînes localisées à l'aide de l'IA (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Outils de Migration :</strong> Outils pour la transition automatique depuis les plugins I2 Localization et Unity Localization.",
  "li_feature_14": "<strong>Gestionnaire de Polices et de Glyphes :</strong> Outil d'analyse des caractères utilisés et de recherche des glyphes manquants dans les polices.",
  "li_feature_15": "<strong>Débogage Visuel :</strong> Icônes dans la hiérarchie et étiquettes dans la Vue Scène pour un débogage rapide.",
  "li_feature_2": "<strong>Localisation de Toute Ressource :</strong> Gestion des sprites, audio, prefabs, matériaux, etc.",
  "li_feature_3": "<strong>Éditeur de traduction puissant :</strong> Une interface centralisée avec sauvegarde automatique, prise en charge complète Annuler/Rétablir, regroupement intelligent des clés et actions de sélection multiple.",
  "li_feature_4": "<strong>IA & traduction automatique :</strong> Système de profils prenant en charge DeepL, Google, Microsoft et <strong>IA personnalisée (OpenAI, Gemini, Claude, Ollama)</strong> avec prise en compte du contexte.",
  "li_feature_5": "<strong>Import/Export Flexible :</strong> Support des formats CSV, XML, YAML, XLIFF et importation directe depuis Google Sheets.",
  "li_feature_6": "<strong>Aperçu en Direct :</strong> Prévisualisez n'importe quelle langue dans la Vue Scène ou le <strong>Mode Prefab</strong> sans exécuter le jeu.",
  "li_feature_7": "<strong>Prise en charge du pluriel et du genre :</strong> Prise en charge complète du CLDR (v43). Inclut les règles pour <strong>Asiatique</strong> (Aucune), <strong>Anglais/Germanique</strong> (Singulier, Autre), <strong>Français</strong> (Singulier 0-1), <strong>Slave</strong> (Singulier, Quelques, Plusieurs - RU, UK, PL), <strong>Arabe</strong>, <strong>Celtique</strong>, <strong>Baltique</strong> (LT, LV), et plus.",
  "li_feature_8": "<strong>Support RTL Complet :</strong> Affichage correct des langues de droite à gauche.",
  "li_feature_9": "<strong>Mises à Jour en Direct :</strong> Chargez les traductions à jour depuis un serveur distant au démarrage du jeu.",
  "li_feature_tool_translation": "<strong>Interface entièrement traduite :</strong> L'interface de l'outil est localisable. Vous pouvez changer la langue de l'éditeur via le menu déroulant dans l'<strong>en-tête de la fenêtre principale</strong>.",
  "li_font_global": "<strong>Rapport global :</strong> Génère un rapport de tous les glyphes manquants dans toutes les langues.",
  "li_font_glyph_analyze": "Analyse toutes les traductions et vérifie si la police attribuée (TMP_FontAsset) prend en charge tous les caractères utilisés.",
  "li_font_glyph_copy": "Permet de copier tous les caractères uniques des langues pour la génération d'atlas de polices. Inclut des <strong>filtres pour exclure ASCII, les chiffres et la ponctuation</strong> afin d'optimiser l'espace texture.",
  "li_font_glyph_missing": "Affiche une liste des glyphes manquants.",
  "li_font_glyph_workflow": "<strong>Flux de Travail pour TMP :</strong> 1. Exécutez l'analyse (Scan). 2. Sélectionnez une langue avec des glyphes manquants. 3. Cliquez sur <strong>'Copy Character Set'</strong>. 4. Ouvrez Window -> TextMeshPro -> Font Asset Creator. 5. Collez le contenu du presse-papiers dans le champ 'Character Sequence (Custom Range)' pour générer un atlas contenant exactement les caractères dont votre jeu a besoin.",
  "li_font_unicode": "<strong>Plages Unicode :</strong> Affichez les plages Unicode spécifiques utilisées dans vos traductions (par ex., Latin de base, Cyrillique) pour optimiser les actifs de police.",
  "li_footer_status": "<strong>Statut & Progrès :</strong> Retour d'information en temps réel sur les tâches d'analyse, d'importation ou de génération IA.",
  "li_header_lang_selector": "<strong>Langue de l'éditeur :</strong> Changez la langue de l'interface de l'outil. L'UI de l'outil est entièrement localisable.",
  "li_header_preview_btn": "<strong>Bascule d'aperçu :</strong> Activez ou désactivez rapidement l'aperçu dans l'éditeur. Utilisez le bouton 'Revert' pour restaurer les valeurs originales de la scène.",
  "li_header_toolbar_buttons": "<strong>Barre d'outils globale :</strong> Accès direct à la Documentation, Discord, Settings Asset, Dependency Checker, et la page Review.",
  "li_install_1": "<strong>IMPORTANT (mise à jour v2.0) :</strong> Si vous passez de v1.x, vous <strong>DEVEZ supprimer</strong> l'ancien dossier `Ankonoanko` avant l'importation. La version 2.0 nécessite une installation propre en raison des changements de namespace.",
  "li_install_2": "L'outil vérifiera automatiquement les dépendances nécessaires. Confirmez l'installation dans la boîte de dialogue qui apparaît.",
  "li_install_3": "Les dépendances requises (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) sont nécessaires pour les fonctionnalités de base.",
  "li_install_4": "Les dépendances optionnelles (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) activent des fonctionnalités supplémentaires.",
  "li_install_5": "Cliquez sur <strong>Install Selected</strong> pour installer les packages recommandés.",
  "li_install_6": "Après l'installation, ouvrez la fenêtre principale de l'outil via le menu <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Si vous prévoyez d'utiliser le chargement asynchrone des ressources, installez le package <strong>Addressables</strong> via le Gestionnaire de Paquets.",
  "li_live_updates_1": "<strong>Activer :</strong> dans les Paramètres, cochez « Enable Live Updates ».",
  "li_live_updates_2": "<strong>Source :</strong> Fournissez une <code>Live Update URL</code> renvoyant un dictionnaire JSON, ou une <code>Google Sheet URL</code>.",
  "li_live_updates_3": "<strong>Cache :</strong> Les traductions sont mises en cache localement à <code>liveUpdateCachePath</code> pour garantir que le jeu fonctionne hors ligne.",
  "li_live_updates_4": "<strong>Sécurité :</strong> Utilisez la <strong>clé API d'exécution</strong> (chiffrée) si votre serveur nécessite une authentification.",
  "li_localizedtext_1": "<code>localizationKey</code> : la clé utilisée pour trouver la traduction. Peut être générée automatiquement ou assignée manuellement.",
  "li_localizedtext_2": "<code>isStyleOnly</code> : si <code>true</code>, le composant n'appliquera que les styles (police, RTL) mais ne modifiera pas le texte lui‑même. Crucial pour les éléments de texte dynamiques (par ex. texte mis à jour via des appels `_()` dans les scripts).",
  "li_localizedtext_3": "<code>originalSourceText</code> : Le texte original dans la langue de base. Utilisé comme solution de repli.",
  "li_localizedtext_key_override": "<strong>Remplacement manuel de clé :</strong> Vous pouvez cliquer sur l'icône 'Edit' à côté de la clé pour saisir manuellement une clé. Utilisez 'X' pour revenir à la génération automatique. Cela fonctionne pour <code>LocalizedText</code>, <code>LocalizedDropdown</code> (pour chaque option individuellement), et <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>Recherche dans la table :</strong> Cliquez sur l'icône de loupe pour ouvrir instantanément la Table de traduction et focaliser sur cette clé spécifique.",
  "li_migration_csv_details_1": "<strong>Filtrage intelligent :</strong> L'importateur ignore automatiquement les lignes qui ressemblent à des chemins d'actifs (par ex. <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>) afin de garder votre base de données texte propre.",
  "li_migration_csv_details_2": "<strong>Colonne 'Type' :</strong> Si une colonne 'Type' existe (format I2), seules les lignes marquées comme 'Text' ou avec un type vide sont importées. Pour importer des actifs, utilisez les profils de migration pour les mapper à <code>LocalizedAsset</code>.",
  "li_migration_csv_req_1": "<strong>Colonne clé :</strong> Doit être nommée <code>Key</code> (insensible à la casse) ou définie dans votre profil de migration.",
  "li_migration_csv_req_2": "<strong>Colonnes de langue :</strong> Toute colonne non marquée comme ignorée est traitée comme un code de langue (par ex., 'en', 'ja', 'English'). L'outil tente de faire correspondre approximativement ces codes aux langues de votre projet.",
  "li_migration_csv_req_3": "<strong>Commentaires :</strong> Les colonnes nommées <code>Desc</code>, <code>Description</code> ou <code>Comment</code> sont importées comme notes développeur. Cette liste est configurable dans le <strong>Migration Profile</strong>.",
  "li_migration_custom_1": "Clic droit dans la Vue Projet -> Créer -> Anko Localization -> Profil de migration.",
  "li_migration_custom_2": "<strong>Règles :</strong> Définissez des règles de conversion (si [Source Component] avec [Context Filter], alors convertir en [Target Component]). Les règles prennent en charge <strong>Priority</strong> (les nombres supérieurs sont traités en premier), <strong>Harvest Assets</strong> (extraction et enregistrement automatiques des assets référencés comme les Sprites ou l'Audio), et <strong>Context Filtering</strong> pour distinguer plusieurs composants sur le même objet.",
  "li_migration_fallback_keys": "<strong>Champs de clé de secours :</strong> Spécifiez des noms de champs supplémentaires à vérifier lors de l'extraction des clés à partir des composants hérités. Utile si votre ancien système utilise des noms de propriétés non standard pour les clés.",
  "li_migration_gs_1": "<strong>Accès :</strong> La feuille doit être partagée ('Toute personne disposant du lien peut la voir') ou publiée sur le Web.",
  "li_migration_gs_2": "<strong>Onglets de feuille (GID) :</strong> L'URL doit inclure le paramètre <code>gid=...</code>. Cela indique à l'outil exactement quel onglet lire (par ex. <code>gid=0</code> est généralement le premier onglet/feuille).",
  "li_migration_ignored_headers": "<strong>En-têtes CSV ignorés :</strong> Définissez les colonnes qui doivent être ignorées lors de l'importation (par ex., 'Type', 'Description'). Cela empêche l'outil de traiter les colonnes de métadonnées comme des données linguistiques.",
  "li_migration_legacy_components": "<strong>Composants hérités supplémentaires :</strong> Listez manuellement les noms de composants que l'outil doit détecter comme « legacy » pendant l'analyse de migration, même si aucune règle de conversion directe n'est définie.",
  "li_migration_profile_details": "<strong>Paramètres avancés du profil :</strong><ul><li><code>CsvKeyHeader</code> : Le nom d'en-tête pour la colonne Clé.</li><li><code>CsvCommentHeaders</code> : Liste des en-têtes à traiter comme notes/commentaires développeur.</li><li><code>IgnoredCsvHeaders</code> : Colonnes à ignorer (métadonnées comme 'Type' ou 'Status') pour éviter qu'elles soient interprétées comme langues.</li><li><code>AssetExtensions</code> : Types de fichiers reconnus comme assets lors de l'analyse.</li><li><code>FallbackKeyFields</code> : Noms de champs supplémentaires à vérifier si le champ clé principal est vide.</li></ul>",
  "li_migration_rule_fields": "<strong>Configuration de règle :</strong><ul><li><code>Priority</code> : Les valeurs supérieures sont traitées en premier. Utilisez ceci pour gérer les cas spécifiques avant les génériques.</li><li><code>Context Filter</code> : Applique la règle uniquement si un composant spécifique (par ex. <code>Text</code>) est présent sur le même objet.</li><li><code>Harvest Assets</code> : Si activé, extrait l'asset actuel (par ex. Sprite) du composant hérité et l'enregistre dans la table d'assets.</li><li><code>Asset Field Path</code> : Chemin vers le champ contenant la référence d'asset à récolter.</li><li><code>Additional Data Path</code> : Utilisé pour les composants complexes comme les Dropdowns afin de récolter plusieurs valeurs/options.</li></ul>",
  "li_migration_stubs_1": "<strong>Problème :</strong> Vous supprimez les anciens actifs du plugin. Unity détecte des scripts manquants (par ex. le composant <code>Localize</code> manquant). L'éditeur passe en mode d'erreur de compilation.",
  "li_migration_stubs_2": "<strong>Solution:</strong> La fonctionnalité 'Emergency Stubs' génère des classes légères et vides avec exactement les mêmes noms et espaces de noms que l'ancien plugin. Cela satisfait le compilateur.",
  "li_migration_stubs_3": "<strong>Flux de travail :</strong> 1. Cliquez sur <strong>Enable Emergency Stubs</strong> (cela ajoute <code>ANKO_ENABLE_MIGRATION_STUBS</code> à vos Paramètres de projet). 2. Supprimez le dossier du vieux plugin. 3. Unity recompilé avec succès en utilisant des classes factices. 4. Exécutez le <strong>Component Converter</strong> pour remplacer les stubs par les composants officiels. 5. Cliquez sur <strong>Disable Stubs</strong> une fois le refactoring terminé.",
  "li_migration_tool_converter": "<strong>Étape 2 : Convertisseur de Composants :</strong> Analysez les scènes et les prefabs. Remplace automatiquement les anciens composants (par exemple, <code>Localize</code>) par <code>LocalizedText</code> / <code>LocalizedAsset</code>, en transférant les clés.",
  "li_migration_tool_fields": "<strong>Profile Settings:</strong> Le type 'Source Plugin' configurable et les règles de 'Asset Mapping' assurent le transfert correct des textures et de l'audio.",
  "li_migration_tool_import": "<strong>Étape 1 : Importation de Données :</strong> Importez des fichiers CSV (I2) ou XLIFF (Unity Loc) pour créer une base de données de clés.",
  "li_migration_tool_profiles": "<strong>Migration Profiles:</strong> Créez des profils personnalisés pour mapper les assets et les paramètres des plugins tiers (I2, Unity Loc).",
  "li_migration_tool_safemode": "<strong>Mode sans échec & Stubs d'urgence :</strong> Les composants sont désactivés plutôt que supprimés. Inclut la fonctionnalité critique <strong>Emergency Stubs</strong> (activée via le symbole de définition <code>ANKO_ENABLE_MIGRATION_STUBS</code>) : génère des classes factices de remplacement pour I2 Localization ou Unity Localization afin que votre projet puisse se compiler immédiatement après la suppression de ces plugins. Cela empêche les erreurs \"The type name 'Localize' could not be found\" et vous donne le temps de refactoriser correctement votre code pour utiliser le nouveau système. Enable Stubs vous permet de corriger les erreurs de compilation après la suppression de l'ancien plugin de localisation.",
  "li_migration_tool_setup": "<strong>Étape 0 : Configuration :</strong> Configurez les noms des composants (par exemple, <code>Localize</code> pour I2) et les champs où la clé est stockée. Des préréglages sont disponibles.",
  "li_migration_workflow_1": "<strong>1. Backup:</strong> Commitez votre projet dans le contrôle de version (Git) ou créez une sauvegarde de fichiers avant de commencer.",
  "li_migration_workflow_2": "<strong>2. Enable Stubs:</strong> Ouvrez l'outil de migration -> l'onglet 'Safe Mode'. Cliquez sur <strong>Enable Emergency Stubs</strong> pour votre système cible (I2/UnityLoc). Cela crée des classes factices légères dans votre projet.",
  "li_migration_workflow_3": "<strong>3. Remove Old Plugin:</strong> Supprimez le dossier de l'ancien plugin (par ex., 'Assets/Plugins/I2'). Unity recompilera. Grâce aux Stubs, vous ne recevrez <strong>NOT</strong> d'erreurs 'Type not found', préservant toutes vos références de composants sur les prefabs.",
  "li_migration_workflow_4": "<strong>4. Import Data:</strong> Dans l'onglet 'Import Data', chargez votre CSV/XLIFF source. Vérifiez l'aperçu et cliquez sur <strong>Import</strong>. Cela remplit les tables de traduction AnKo.",
  "li_migration_workflow_5": "<strong>5. Convert Components:</strong> Dans l'onglet 'Component Converter', sélectionnez 'Entire Project' et cliquez sur <strong>Scan & Convert</strong>. L'outil remplace les anciens stubs par des composants 'LocalizedText'/'LocalizedAsset', transférant les clés.",
  "li_migration_workflow_6": "<strong>6. Cleanup:</strong> Une fois tout fonctionnel, cliquez sur <strong>Disable Stubs</strong> et laissez Unity recompilier à nouveau.",
  "li_notes_1": "<strong>Sauvegardes :</strong> Créez toujours une sauvegarde via <strong>Translation Table Editor -> Manage Backups</strong> avant des changements majeurs. Les sauvegardes sont stockées dans le dossier <code>LocalizationBackups</code> **à la racine du projet (en dehors du dossier Assets)** pour garder votre projet Unity propre et réduire les temps d'importation.",
  "li_notes_2": "<strong>Sécurité de la Clé API :</strong> La clé pour travailler dans l'éditeur est stockée localement sur votre machine (dans <code>EditorPrefs</code>) et n'entre pas dans le référentiel. Pour les clés nécessaires dans la construction du jeu, utilisez la section <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Dossier <code>StreamingAssets</code> :</strong> Les fichiers de traduction doivent se trouver dans un sous-dossier de <code>Assets/StreamingAssets/</code> pour être inclus dans la construction du jeu.",
  "li_notes_4": "<strong>\"Éviter les erreurs\" :</strong> L'outil vous protège automatiquement contre l'enregistrement accidentel de données temporaires du mode aperçu dans une scène ou un prefab.",
  "li_notes_5": "<strong>Performances :</strong> L'appel <code>_()</code> est rapide, mais dans les boucles qui s'exécutent à chaque image (par exemple, dans <code>Update</code>), essayez de mettre en cache le résultat dans une variable.",
  "li_notes_6": "<strong>Exclusion de <code>LanguageSelector</code> de l'analyse :</strong> L'objet avec le composant <code>LanguageSelector</code> et son <code>TMP_Dropdown</code> doivent être ajoutés à la liste <strong>Ignore Specific Objects</strong> dans l'onglet <strong>Content</strong>. Cela est nécessaire pour empêcher l'analyseur de créer des clés supplémentaires pour les options de la liste déroulante, car le script <code>LanguageSelector</code> les peuple dynamiquement au moment de l'exécution. L'ignorer empêche les conflits et maintient la propreté des fichiers de traduction.",
  "li_notes_7": "<strong>Polices pour <code>LanguageSelector</code> :</strong> Pour que la langue sélectionnée dans le <code>TMP_Dropdown</code> mette correctement à jour sa police, ajoutez manuellement un composant <code>LocalizedText</code> vide à l'objet enfant <strong>Label</strong> du Dropdown et cochez la case <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Code et Addressables :</strong> Si vous passez en mode <strong>Addressables (Async)</strong>, vous **DEVEZ** utiliser <code>GetLocalizedAssetAsync<T>()</code> dans vos scripts. L'appel du synchrone <code>GetLocalizedAsset<T>()</code> renverra null et enregistrera un avertissement pour éviter les gels du thread principal.",
  "li_notes_addressables_sync_warning": "<strong>Synchrone vs Asynchrone :</strong> Si vous passez en mode <strong>Addressables (Async)</strong>, vous **DEVEZ** mettre à jour votre code pour utiliser <code>GetLocalizedAssetAsync<T>()</code>. L'appel de la méthode synchrone renverra null et enregistrera un avertissement pour éviter de geler le thread principal.",
  "li_preview_1": "<strong>Comment ça fonctionne :</strong> Sélectionnez une langue dans la liste, et l'outil appliquera instantanément les traductions, les polices, les paramètres RTL et les ressources correspondants à tous les objets localisables de la scène active ou du prefab ouvert.",
  "li_preview_2": "<strong>Placeholders :</strong> Si un style de placeholder (par exemple, <strong>Accents</strong> ou <strong>Brackets</strong>) est sélectionné dans l'onglet <strong>Settings</strong>, ces placeholders seront affichés en mode aperçu au lieu des traductions réelles. C'est idéal pour tester la mise en page et trouver les éléments non localisés.",
  "li_preview_3": "<strong>Sécurité :</strong> Toutes les modifications effectuées en mode aperçu sont temporaires. L'outil rétablira automatiquement tout à son état d'origine lorsque vous sélectionnez \"<strong>Revert to Original</strong>\", fermez la fenêtre, changez de scène ou avant de sauvegarder une scène/un prefab (grâce au composant <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Protection contre les plantages :</strong> Le système sauvegarde automatiquement l'état de la scène dans le dossier <code>Library</code> avant l'aperçu. Si Unity se bloque ou si vous quittez de force pendant l'aperçu, l'outil détecte le fichier de récupération au prochain lancement et propose de restaurer l'état original de la scène.",
  "li_preview_overlay_1": "<strong>Access:</strong> L'overlay apparaît automatiquement dans la Vue Scène. Vous pouvez le basculer via le menu Unity Overlay (touche <code>Space</code> dans la Vue Scène).",
  "li_preview_overlay_2": "<strong>Functionality:</strong> Fournit un menu déroulant pour changer rapidement la langue d'aperçu actuelle sans ouvrir la fenêtre principale.",
  "li_report_1": "<strong>Catégories :</strong> Toutes les Clés, Ajoutées, Mises à jour (texte modifié), Supprimées, Duplicatas, Migrées, Ignorées (inchangées).",
  "li_report_2": "<strong>Recherche Avancée :</strong> Cliquez sur le bouton <strong>Find</strong> à côté de n'importe quelle entrée pour trouver instantanément l'objet correspondant dans le projet. La recherche fonctionne de manière asynchrone, ne bloquant pas l'éditeur, et recherche dans toutes les scènes et prefabs.",
  "li_report_all_keys": "<strong>Toutes les clés :</strong> Une liste de toutes les clés de localisation détectées dans le projet avec des options de recherche et de filtrage.",
  "li_report_btn_clear": "<strong>Effacer le rapport :</strong> Supprime tous les résultats d'analyse de la mémoire de la session en cours.",
  "li_report_btn_copy_all": "<strong>Copier toutes les clés :</strong> Copie toutes les clés de localisation de la catégorie actuelle dans le presse‑papier du système.",
  "li_report_btn_load_last": "<strong>Charger la dernière analyse :</strong> Restaure instantanément les résultats de la dernière analyse du projet sans rescanner.",
  "li_report_btn_save": "<strong>Enregistrer le rapport :</strong> Exporte les résultats d'analyse actuels vers un fichier texte ou CSV pour une documentation ou un audit externe.",
  "li_report_source_filter": "<strong>Filtre source :</strong> Restreint les résultats selon leur origine (par ex. n'afficher que les clés trouvées dans les Scripts, Scènes ou Prefabs).",
  "li_safety_global_limit": "<strong>Global Monthly Limit:</strong> Le <code>monthlyCharLimit</code> (par défaut : 500 000 caractères) agit comme un disjoncteur pour toutes les requêtes. Vous pouvez activer/désactiver les avertissements via <code>enableApiLimitWarning</code>.",
  "li_safety_profile_limit": "<strong>Profile Limits:</strong> Chaque Translation Profile permet de définir son propre 'Max Chars Per Request' et 'Batch Size'.",
  "li_settings_1": "<strong>Mode de génération de clé :</strong> Définit la stratégie de création d'identifiants uniques pour votre texte :<ul><li><code>AutoGenerateKeysOnly</code> <strong>(Par défaut - Recommandé)</strong> : Génère des clés basées sur le nom de la scène/prefab et la hiérarchie d'objets (ex. <code>scene_Menu_BtnPlay_682412</code>). Idéal pour les grands projets car cela garantit l'unicité et est insensible aux changements de texte.</li><li><code>UseTextAsKey</code> : Utilise le texte source lui‑même comme clé (ex. \"Start Game\" → <code>Start Game</code>). Idéal pour le prototypage rapide où les clés doivent être lisibles par l'homme.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Hybride)</strong> : Le mode le plus flexible. Il vérifie d'abord si un composant possède déjà une clé assignée manuellement ou un <code>[LocalizableField(key=\"...\")]</code>. Si aucune clé n'existe, il génère une clé hiérarchique. <em>Utilisez ceci pour préserver le travail existant tout en automatisant le nouveau contenu.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Hybride)</strong> : Comme ci‑dessus, mais revient au texte lui‑même si aucune clé manuelle n'est trouvée. Respecte les composants et données existants.</li><li><code>Manual</code> : L'analyseur ne crée jamais de nouvelles clés. Il ne met à jour que les objets qui possèdent déjà un composant de localisation avec une clé. Parfait pour un contrôle manuel strict.</li></ul>",
  "li_settings_10": "<strong>Dev Tools :</strong> Au bas de l'onglet Paramètres, vous trouverez des boutons utilitaires comme <strong>Clear Saved Language Pref</strong> (réinitialise la langue sauvegardée dans PlayerPrefs afin que le jeu démarre à nouveau avec la langue par défaut).",
  "li_settings_11": "<strong>Technical Dropdown Options :</strong> Une liste de valeurs de chaîne (par défaut : 'Option A', 'Option B', 'Option C') que l'analyseur <strong>ignorera</strong> lors de l'analyse des Dropdowns. Cela permet de garder votre table de traduction propre du texte de placeholder d'interface utilisateur par défaut d'Unity.",
  "li_settings_2": "<strong>Language Management :</strong><ul><li><strong>Source Language :</strong> La langue utilisée dans vos scènes/prefabs Unity (langue de développement).</li><li><strong>Default Language :</strong> La langue sélectionnée au premier lancement du jeu si la langue système de l'utilisateur n'est pas prise en charge.</li><li><strong>List :</strong> Gérez les langues prises en charge, attribuez des <strong>Font Assets</strong> spécifiques et activez le support <strong>RTL</strong>.</li></ul>",
  "li_settings_3": "<strong>Paramètres généraux :</strong> Configuration du comportement à l'échelle du projet :<ul><li><code>Translations Save Path</code> : Le répertoire racine où sont stockés les fichiers de traduction <code>.json</code>. Pour un accès en jeu, il doit être situé dans <code>Assets/Resources</code> ou <code>Assets/StreamingAssets</code>.</li><li><code>Safe Mode</code> : Une couche de protection qui bloque les opérations (comme Auto‑Translate) si des incohérences du projet ou des dépendances manquantes sont détectées.</li><li><code>Remove Missing Keys</code> : Si activé, l'analyseur supprimera automatiquement les entrées de la base de données qui ne sont plus présentes dans aucune scène ou prefab lors de la mise à jour du projet.</li><li><code>Parse Inactive Objects</code> : Détermine si l'outil doit analyser et localiser les GameObjects désactivés ou masqués.</li><li><code>Parse All Prefabs</code> : Analyse chaque prefab du projet. Si désactivé, seuls les prefabs dans les dossiers spécifiés dans l'onglet <strong>Content</strong> sont traités.</li><li><code>Fill Comments By Paths</code> : Remplit automatiquement le champ 'Comment' du tableau de traduction avec le chemin hiérarchique de l'objet dans la scène/prefab.</li><li><code>Split Files by Language</code> : Divise la base de données de traduction en plusieurs fichiers (ex. <code>en.json</code>, <code>ja.json</code>). Hautement recommandé pour les grands projets afin de réduire la charge mémoire à l'exécution.</li><li><code>Allow Empty Source/Keys</code> : Permet à l'outil d'enregistrer et de suivre les objets même si leur texte source est vide. Utile pour le texte dynamique défini uniquement via le code.</li><li><code>Attach to Regex-Ignored Text</code> : Contraint l'outil à ajouter des composants de localisation aux objets dont le texte correspond à une expression régulière d'exclusion (comme les nombres), permettant une substitution manuelle.</li><li><code>Find Settings Asset</code> : Un bouton utilitaire qui localise et sélectionne instantanément le fichier <code>LocalizationSettings.asset</code> dans la fenêtre Projet.</li></ul>",
  "li_settings_4": "<strong>Débogage & Tests :</strong><ul><li><code>Placeholder Style</code> : Choisissez le style d'affichage des espaces réservés en mode aperçu.</li><li><code>Pseudo-Localization</code> : Sélectionnez <strong>'Custom Pseudo'</strong> pour afficher les paramètres avancés de test de mise en page (Facteur d'expansion, Accents et Délimiteurs).</li></ul>",
  "li_settings_5": "<strong>Live Updates :</strong> Paramètres pour le chargement des traductions à partir d'un serveur distant.",
  "li_settings_6": "<strong>Runtime API Key:</strong> Stocke en toute sécurité votre clé API pour les <strong>Live Updates</strong> (récupération de nouvelles traductions en jeu). Ceci diffère des clés du service de traduction utilisées dans l'éditeur. La clé est <strong>obfuscated</strong> (cryptée) dans le build pour empêcher une extraction facile via recherche de chaîne, mais rappelez‑vous : aucun secret côté client n'est 100 % sécurisé.",
  "li_settings_7": "<strong>Asset Loading Strategy:</strong> Choix entre <code>Resources (Legacy)</code>, <code>Addressables (Async)</code> et <code>Custom</code>. Avertissement : changer ce mode nécessite un nouveau scan du projet. Le mode Addressables est fortement recommandé pour le mobile et le WebGL afin de réduire l'utilisation de la mémoire.",
  "li_settings_8": "<strong>Auto‑traduction :</strong> Utilise le système <strong>Translation Profiles</strong> pour la localisation pilotée par IA. La configuration comprend :<ul><li><code>Text & Audio Profiles</code> : Sélectionnez ou créez des profils ScriptableObject pour configurer différents services (ex. OpenAI, DeepL, Google).</li><li><code>Presets Folder</code> : Le répertoire où sont stockés vos préréglages et profils de traduction.</li><li><code>Target Languages</code> : Une liste de toutes les langues du projet avec statut en temps réel, barres de progression et compte de caractères pour le profil sélectionné.</li><li><code>Start Auto Translation</code> : Lance le processus pour toutes les langues sélectionnées en utilisant les profils spécifiés.</li></ul>",
  "li_settings_9": "<strong>Améliorations du débogage :</strong><ul><li><code>Show Hierarchy Icons</code> : Affiche des icônes d'état (Coche verte / Avertissement jaune) dans la hiérarchie. <strong>Performance optimisée :</strong> Utilise le cache pour garantir zéro latence même dans les grandes scènes.</li><li><code>Show Scene View Labels</code> : Débogage visuel directement dans la Vue de scène. Les libellés sont interactifs : clic droit sur n'importe quel libellé de scène pour copier instantanément la clé de localisation dans le presse‑papier.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Règle de structure de dossiers :</strong> Définit comment les sous‑dossiers sont organisés lors de la génération d'assets localisés (ex. <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Nom de la classe de pont :</strong> Vous permet de personnaliser le nom de la classe statique générée (par défaut <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Mode sans échec :</strong> Garantit que les opérations critiques ne s'exécutent pas si elles risquent de provoquer des états de projet incohérents.",
  "li_settings_lang_culture_fallback": "<strong>Utiliser le repli culturel :</strong> Si un dialecte régional spécifique (ex. <code>en-AU</code>) est absent, l'outil tentera d'utiliser la langue de base (<code>en</code>) avant de recourir à la <strong>Default Language</strong>.",
  "li_settings_lang_follow_system": "<strong>Suivre la langue du système :</strong> Change automatiquement la langue du jeu pour correspondre à la langue du système d'exploitation du joueur lors du premier lancement.",
  "li_settings_live_updates_security": "<strong>Security:</strong> les clés API runtime sont chiffrées (AES) dans le build pour empêcher une extraction accidentelle. Utilisez toujours HTTPS.",
  "li_settings_pseudo_accents": "<strong>Utiliser les accents :</strong> Remplace les caractères standards par leurs versions accentuées (ex. <code>å</code>, <code>é</code>). Utilisez ceci pour vous assurer que vos polices supportent tous les glyphes requis.",
  "li_settings_pseudo_brackets": "<strong>Ajouter des crochets :</strong> Enveloppe le texte dans <code>[ ]</code> pour vérifier le début et la fin des chaînes localisées, aidant à identifier les problèmes de troncature ou de concaténation.",
  "li_settings_pseudo_expand_length": "<strong>Étendre la longueur :</strong> Simule l'expansion du texte courante dans des langues comme l'allemand ou le russe en ajoutant des caractères de fin.",
  "li_settings_pseudo_expansion_factor": "<strong>Facteur d'expansion :</strong> Multiplicateur pour la simulation de la longueur du texte (ex. 2.0 doublera la longueur du texte).",
  "li_settings_pseudo_prefix": "<strong>Préfixe personnalisé :</strong> Ajoute une chaîne spécifique (ex. <code>PSEUDO-</code>) au début de chaque texte localisé.",
  "li_settings_pseudo_suffix": "<strong>Suffixe personnalisé :</strong> Ajoute une chaîne spécifique à la fin de chaque texte localisé.",
  "li_settings_return_source": "<strong>Retourner la source si manquante :</strong> Si activé, le système renverra le texte dans la langue source (ou la clé elle‑même) si aucune traduction n'est trouvée pour la langue actuelle.",
  "li_settings_tms_timeout": "<strong>Délai d'attente TMS :</strong> Spécifie le temps d'attente maximal (en secondes) pour les requêtes réseau vers les services TMS externes.",
  "li_settings_tool_check_deps": "<strong>Vérifier les dépendances :</strong> Re‑analyse le projet pour les paquets requis (comme Newtonsoft) et les intégrations optionnelles.",
  "li_settings_tool_cleanup": "<strong>Nettoyage complet du projet :</strong> Un outil destructif qui supprime tous les composants et données Anko Localization du projet (à utiliser avec prudence !).",
  "li_settings_tool_clear_prefs": "<strong>Effacer les préférences de langue :</strong> Réinitialise la langue enregistrée dans PlayerPrefs, forçant le jeu à utiliser la langue par défaut ou du système au prochain lancement.",
  "li_settings_tool_font_manager": "<strong>Gestionnaire de polices :</strong> Ouvre le Gestionnaire de polices & glyphes pour analyser les caractères manquants et générer des assets de police optimisés.",
  "li_settings_tool_migration": "<strong>Outil de migration :</strong> Facilite le déplacement des données et composants depuis I2 Localization ou Unity Localization.",
  "li_settings_tool_test_center": "<strong>Centre de test de localisation :</strong> Un outil de diagnostic pour vérifier la santé du projet, détecter les références cassées et garantir l'intégrité de la localisation.",
  "li_setup_1": "<strong>Créer les Paramètres :</strong> Lors de la première ouverture, l'outil créera un fichier <code>LocalizationSettings.asset</code> dans le dossier <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Configurer les langues et le mode :</strong> Dans l'onglet <strong>Settings</strong>, assurez‑vous que votre <strong>Source Language</strong> est correct. Vérifiez également le <strong>Key Generation Mode</strong> (la valeur par défaut est <code>AutoGenerateKeysOnly</code>, qui est recommandée pour la plupart des projets).",
  "li_setup_3": "<strong>Spécifier le Contenu à Analyser :</strong> Dans l'onglet <strong>Content</strong>, ajoutez toutes les scènes à analyser à la liste <strong>Scenes to Parse</strong>. Si vous utilisez des prefabs avec du texte, assurez-vous que leurs dossiers sont ajoutés à <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Première Exécution de l'Analyseur :</strong> Allez dans l'onglet <strong>Actions</strong> et cliquez sur le bouton <code>Update Keys</code>. L'outil analysera votre projet, créera des fichiers de traduction et ajoutera automatiquement les composants nécessaires (<code>LocalizedText</code>, <code>LocalizedAsset</code>, etc.) aux objets du jeu.",
  "li_setup_5": "<strong>Paramètres et Builds (CRITIQUE) :</strong> L'outil ajoute automatiquement <code>LocalizationSettings.asset</code> à <code>Project Settings -> Player -> Preloaded Assets</code>. <br>⚠️ <strong>Vérification de Sécurité :</strong> Si les paramètres sont manquants dans Preloaded Assets et ne se trouvent pas dans un dossier Resources, l'outil <strong>bloquera la construction</strong> avec une <code>BuildFailedException</code> pour empêcher le jeu de planter au démarrage.",
  "li_sidebar_presets": "<strong>Préréglages de recherche :</strong> Filtres prédéfinis pour des tâches courantes comme trouver les chaînes non traduites ou les clés avec des espaces réservés manquants.",
  "li_sidebar_search": "<strong>Recherche globale :</strong> Recherchez des clés ou du texte spécifiques dans toutes les tables de votre projet.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Nécessite l'ID du projet et la clé API. Prend en charge le téléchargement du XLIFF source et le téléchargement des traductions sous forme d'archive ZIP. <em>Avancé :</em> <code>File Name</code> (le chemin cible dans Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Nécessite une clé API. Intégration simple et rapide pour les petits projets. <em>Avancé :</em> <code>Import/Export Params</code> (permet d'ajouter des paramètres supplémentaires à l'API Loco comme <code>&tag=v1</code> ou <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Gestion de localisation de niveau entreprise. <em>Avancé :</em> <code>Update Translations/Descriptions</code> indicateurs pour contrôler si Phrase écrase les données existantes lors du téléchargement.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Prend en charge les slugs d'organisation/projet et l'authentification par jeton API. <em>Avancé :</em> <code>Resource Slug</code> (crée automatiquement la ressource si elle n'existe pas).",
  "li_tutorials_1": "<strong>Apprentissage interactif :</strong> Les guides mettent en évidence des éléments UI spécifiques et attendent vos actions.",
  "li_tutorials_2": "<strong>Leçons disponibles :</strong>",
  "li_tutorials_editor": "<strong>Éditeur de traduction :</strong> Fonctionnalités avancées de l'éditeur de type feuille de calcul.",
  "li_tutorials_list": "<strong>Tutorial List:</strong> Accédez aux guides interactifs pour les principales fonctionnalités de l'outil.",
  "li_tutorials_migration": "<strong>Migration :</strong> Comment passer d'autres systèmes de localisation (I2, Unity Localization).",
  "li_tutorials_quickstart": "<strong>Démarrage rapide :</strong> Configuration de base pour le texte et les assets.",
  "li_tutorials_size": "<strong>Tutorial Size:</strong> Ajuste l'échelle de l'interface et le niveau de détail des guides interactifs (Compact à Extra Large). Situé dans l'en-tête de l'onglet Tutoriels.",
  "li_vis_debug_1": "<strong>Hierarchy Icons:</strong> Repérez instantanément les problèmes (Missing Key, Missing Component). Optimisé pour n'avoir aucun impact sur les performances.",
  "li_vis_debug_2": "<strong>Scene View Labels:</strong> Affiche la clé sur chaque objet localisé. <strong>Right-click</strong> une étiquette pour 'Copy Key' ou 'Select Object'.",
  "li_vis_debug_3": "<strong>Overlays:</strong> Utilisez l'overlay de la vue scène (touche Espace) pour changer instantanément les langues d'aperçu.",
  "lightbox_aria_close": "Fermer la visionneuse d'images",
  "lightbox_image_alt": "Vue agrandie",
  "mindmap_edge_configure": "1. Configurer",
  "mindmap_edge_creates_components": "Crée des Composants",
  "mindmap_edge_defines_rules": "Définit des règles pour",
  "mindmap_edge_edited_in": "Édité dans",
  "mindmap_edge_enables_reaction": "Active la réaction via",
  "mindmap_edge_extends": "Étend",
  "mindmap_edge_generates": "Génère",
  "mindmap_edge_manages_assets": "Gère les ressources pour",
  "mindmap_edge_opens": "Ouvre",
  "mindmap_edge_parse_project": "3. Analyser le Projet",
  "mindmap_edge_processed_by": "Traité par",
  "mindmap_edge_recommends_for": "Recommande pour",
  "mindmap_edge_relates_to": "Se rapporte à",
  "mindmap_edge_reports_on": "Rapports sur",
  "mindmap_edge_see_faq": "Voir FAQ",
  "mindmap_edge_specify_content": "2. Spécifier le Contenu",
  "mindmap_edge_warns_about": "Avertit de",
  "mindmap_node_ai_ecosystem": "Écosystème IA",
  "mindmap_node_async_code": "Asynchrone / Addressables",
  "mindmap_node_dev_tools": "Outils & utilitaires",
  "mindmap_node_tms_integration": "Intégration TMS",
  "mindmap_preset_ai": "IA & automatisation",
  "mindmap_preset_dev": "Flux de Travail du Développeur",
  "mindmap_preset_full": "Vue Complète",
  "mindmap_preset_quick_start": "Démarrage Rapide",
  "mindmap_preset_tools": "Outils & intégrations",
  "mindmap_preset_translator": "Flux de Travail du Traducteur",
  "mindmap_toggle_title": "Afficher la Carte Mentale",
  "my_notes_title": "Mes Notes",
  "no_notes_message_new": "Passez la souris sur le texte pour ajouter une note.",
  "notes_add_title": "Ajouter une note à ce bloc",
  "notes_close_title": "Fermer",
  "notes_delete_title": "Supprimer la note",
  "notes_edit_text": "Modifier",
  "notes_edit_title": "Modifier la note",
  "notes_goto_title": "Aller au texte",
  "notes_placeholder": "Votre note...",
  "on_this_page_title": "Sur Cette Page",
  "p_actions_1": "L'onglet de travail principal.",
  "p_ai_assistant": "Dans l'Éditeur de Table de Traduction, vous pouvez maintenant exécuter des commandes d'IA personnalisées sur les cellules sélectionnées via le menu contextuel (Clic droit -> AI: ...).",
  "p_ai_audio_economy": "<strong>Économie de Coûts :</strong> L'outil calcule un hachage MD5 de votre texte et ne régénère les fichiers audio que si le texte source a changé, économisant ainsi vos crédits API. Si vous modifiez une traduction, le système marque uniquement ce fichier audio spécifique comme 'Obsolète'. Utilisez 'Generate Missing/Outdated' pour régénérer uniquement ce qui a changé, économisant des crédits API. L'outil hache votre texte et ne régénère les fichiers audio que si le texte source a changé, économisant vos crédits API grâce au regroupement intelligent.",
  "p_ai_context": "Pour améliorer la qualité de la traduction, l'IA reçoit désormais un contexte supplémentaire :",
  "p_ai_intro": "L'outil utilise un système de <strong>Translation Profile</strong> (ScriptableObject). Cela conserve les paramètres du service de traduction dans des assets de profil individuels, vous permettant de changer facilement de configuration.",
  "p_api_snippets_intro": "The <code>LocalizationManager.cs</code> provides a robust API for runtime localization management. Below are the key methods you'll use in your scripts.",
  "p_assets_1": "Cet onglet est entièrement dédié à la localisation des ressources non textuelles.",
  "p_async_api": "Lors de l'utilisation d'Addressables, les assets ne sont pas chargés instantanément. Vous devez utiliser l'API asynchrone pour éviter les chutes de framerate.",
  "p_bridge_description": "L'outil comprend un générateur de classe statique pour l'accès aux clés, vous permettant d'utiliser des références fortement typées au lieu de chaînes magiques. Cela aide à prévenir les fautes de frappe et active l'autocomplétion de l'IDE.",
  "p_bridge_usage_title": "Exemple d'utilisation :",
  "p_components_intro": "Ces composants sont le \"pont\" entre vos objets dans la scène et la base de données de traduction. Ils \"écoutent\" les changements de langue et substituent automatiquement le texte ou la ressource correcte.",
  "p_content_1": "Ici, vous indiquez à l'outil où chercher exactement le texte. L'interface a été entièrement repensée pour une meilleure convivialité.",
  "p_custom_ai": "Le type de service <strong>Custom AI</strong> vous permet de connecter n'importe quel LLM via l'API REST.",
  "p_custom_asset_provider_1": "Développer un fournisseur personnalisé vous permet d'intégrer votre propre système de gestion d'actifs (par ex., un chargeur cloud personnalisé, un système d'empaquetage interne spécifique, ou un référentiel d'actifs basé sur une base de données) directement dans le flux de travail de localisation.",
  "p_custom_asset_provider_intro": "Le système de fournisseur d'actifs abstrait la façon dont les actifs (Sprites, Audio, Prefabs, etc.) sont chargés à l'exécution. Il utilise un <strong>Plugin Registry</strong> qui découvre automatiquement toute implémentation de classe de <code>IAssetProvider</code> marquée avec l'attribut <code>[AssetProviderPlugin]</code>. Cela permet une intégration transparente de systèmes de chargement personnalisés (comme les chargeurs cloud ou le regroupement interne) sans modifier l'outil de base.",
  "p_custom_attributes_description": "En plus des appels de fonction, vous pouvez marquer tout champ de chaîne dans vos scripts comme localisable en utilisant des attributs personnalisés. Par défaut, l'outil reconnaît <code>[LocalizableField]</code>, mais vous pouvez ajouter n'importe quel nom d'attribut (comme <code>[Header]</code> ou <code>[Tooltip]</code>) à la liste <strong>Attributes to Scan</strong>.",
  "p_custom_parser_1": "Vous pouvez facilement étendre le système pour prendre en charge des composants personnalisés en créant votre propre classe d'analyseur.",
  "p_editor_1": "S'ouvre via <strong>Tools -> Localization -> Translation Table Editor</strong>. C'est l'outil principal pour l'édition manuelle des traductions.",
  "p_example_attribute_1": "La façon la plus puissante de localiser les variables de script. Elle fonctionne avec les champs <strong>privés, protégés et publics</strong>. Le parseur gère récursivement les <strong>Tableaux, Listes</strong>, et les <strong>Classes sérialisables imbriquées</strong>. Il peut même générer des clés pour d&#39;autres attributs (comme <code>[Header]</code> ou <code>[Tooltip]</code>) si configuré dans les paramètres.",
  "p_example_components_1": "Le projet comprend des scripts prêts à l'emploi qui servent d'excellents exemples.",
  "p_example_components_updated": "Le code a changé. Le chargement de la langue (surtout lors de l'utilisation d'Addressables) est maintenant asynchrone.",
  "p_example_function_1": "Utilisez la fonction <code>_()</code> pour le texte dynamique qui change pendant le jeu. La méthode qui met à jour l'interface utilisateur doit être marquée de l'attribut <code>[OnLanguageChange]</code> afin qu'elle soit appelée automatiquement lorsque la langue est changée. Un composant <code>LocalizedBehaviour</code> sera automatiquement ajouté à l'objet à cet effet.",
  "p_example_plurals_1": "L'outil utilise désormais des règles plus précises pour différents groupes de langues.",
  "p_font_glyph_manager_access": "Accès via <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "Cet outil est une solution complète pour la localisation de jeux et d'applications dans Unity. Il automatise le processus de collecte de texte et de ressources, gère les traductions via une interface puissante, s'intègre aux services de traduction automatique (y compris l'IA personnalisée) et met à jour dynamiquement le contenu localisé dans le jeu.",
  "p_live_updates_guide": "Le système de mises à jour en direct permet à votre jeu de récupérer de nouvelles traductions depuis un serveur distant ou une Google Sheet à l'exécution, sans nécessiter une nouvelle construction.",
  "p_localizedasset_1": "Utilisé pour échanger des ressources en fonction de la langue. Détecte automatiquement le type de composant. Prend en charge : <ul><li><strong>2D :</strong> Sprites (<code>Image</code>, <code>SpriteRenderer</code>), Textures (<code>RawImage</code>).</li><li><strong>Audio/Vidéo :</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Animation :</strong> <code>MeshFilter</code> (Meshes), <code>Renderer</code> (Materials), <code>Animator</code> (Controller), <code>PlayableDirector</code> (Timeline).</li></ul>",
  "p_localizedasset_2": "Pour les composants avec l'option <strong>Play on Awake</strong> (comme <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> intercepte correctement la lecture automatique, échange la ressource, puis démarre la lecture pour éviter de lire du contenu non localisé.",
  "p_localizedasset_updated": "Le composant prend désormais en charge le chargement asynchrone. Notez qu'il peut y avoir un léger délai lors du changement de langue si les ressources sont chargées depuis le cloud/disque (Addressables).",
  "p_localizedbehaviour_1": "Un composant utilitaire qui permet à vos scripts de réagir aux changements de langue. Il trouve et appelle automatiquement les méthodes marquées de l'attribut <code>[OnLanguageChange]</code>.",
  "p_localizeddropdown_1": "Ajouté aux <code>Dropdown</code> et <code>TMP_Dropdown</code> pour traduire leurs options.",
  "p_localizedprefab_1": "Un composant pour localiser des prefabs entiers. Il fonctionne de manière non destructive : il ne modifie pas le prefab original mais crée une instance de la version localisée en tant qu'objet enfant, désactivant tous les scripts (<code>MonoBehaviour</code>), les rendus (<code>Renderer</code>) et les colliders (<code>Collider</code>) sur l'objet original. Cela empêche l'exécution d'une double logique et les artefacts visuels. Pour un fonctionnement correct au moment de l'exécution, son ordre d'exécution est défini sur -100 (<code>[DefaultExecutionOrder(-100)]</code>) pour s'assurer qu'il s'exécute avant les autres scripts.",
  "p_localizedtext_1": "Le composant principal pour afficher le texte traduit. Il est placé sur les objets avec <code>Text</code>, <code>TMP_Text</code> et <code>TextMesh</code>.",
  "p_migration_custom": "Vous pouvez créer vos propres profils de migration pour prendre en charge des systèmes personnalisés ou des configurations de projet spécifiques. Chaque profil contient une liste de <strong>Règles</strong> qui définissent comment les composants et leurs champs doivent être convertis. Les règles sont vérifiées selon l'ordre de leur <strong>Priorité</strong>.",
  "p_migration_custom_advanced": "Les profils de migration offrent des paramètres avancés pour affiner le processus d'importation et de détection :",
  "p_migration_google_sheet": "Vous pouvez importer directement depuis une URL Google Sheet sans télécharger de fichiers.",
  "p_migration_import_csv": "L'outil prend en charge les fichiers CSV standard (séparés par des virgules). La première ligne doit être l'en-tête.",
  "p_migration_stubs": "Un problème courant lors de la migration est que la suppression de l'ancien plugin (par ex. I2) casse la construction, empêchant Unity de compiler l'outil de migration lui‑même.",
  "p_migration_tool_access": "Accès via <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Outil pour la transition à partir d'autres systèmes de localisation (I2 Localization, Unity Localization).",
  "p_preview_1": "Juste en dessous de l'en-tête se trouve la liste déroulante <strong>Preview Language</strong>. Cette fonctionnalité puissante vous permet de voir à quoi ressemblera la localisation dans n'importe quelle langue directement dans la fenêtre <strong>Scene</strong> ou le <strong>Mode Prefab</strong>, sans exécuter le jeu.",
  "p_preview_overlay": "Pour une itération encore plus rapide, vous pouvez changer de langue directement depuis la vue Scène en utilisant le <strong>Overlay de prévisualisation de localisation</strong> dédié.",
  "p_report_1": "Après chaque analyse, ce rapport montre l'image complète de l'état de votre localisation.",
  "p_safety_caps": "Pour éviter des coûts élevés accidentels ou de gros contrôles de trafic :",
  "p_script_parsing_rules_description": "L'outil peut être configuré pour reconnaître les clés de localisation utilisées dans des fonctions personnalisées ou même dans des systèmes concurrents (comme I2 Localization) sans modifier votre code existant. Cela est réalisé en définissant des modèles regex que le scanner utilise pour extraire les clés de vos scripts.",
  "p_script_parsing_rules_usage": "Dans l'onglet <strong>Content</strong>, sous <strong>Script Parsing Rules</strong>, vous pouvez ajouter des règles qui correspondent à vos appels de fonction spécifiques. Par exemple, pour prendre en charge <code>I2.Loc.Get(\"key\")</code>, vous pouvez ajouter une règle avec un motif qui capture la chaîne à l'intérieur des parenthèses.",
  "p_settings_1": "Votre centre de contrôle. Ici, vous définissez les règles globales pour l'ensemble du processus de localisation.",
  "p_tms_intro": "L'outil prend désormais en charge la synchronisation avec les systèmes de gestion de traduction populaires. Vous pouvez pousser les clés sources et récupérer les traductions directement dans Unity.",
  "p_tms_setup": "1. Accédez à <strong>Actions -> Services externes</strong>.<br>2. Sélectionnez votre fournisseur de services.<br>3. Saisissez les clés API et les identifiants de projet.<br>4. Utilisez les boutons <strong>Push</strong> (Téléverser les clés) et <strong>Pull</strong> (Télécharger les traductions) dans la fenêtre des paramètres.",
  "p_tutorials_1": "L'onglet Tutoriels fournit des guides interactifs étape par étape pour vous aider à maîtriser les fonctionnalités de l'outil directement dans l'éditeur Unity.",
  "p_uitklocalization_1": "Ajouté aux objets avec un <code>UIDocument</code>. Prend en charge la localisation de <strong>Labels, Buttons, HelpBox, Foldout, ProgressBar (title), TextField (label & placeholder), DropdownField (label & choices), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), and Tooltips</strong> sur tout élément. Les identifiants restent stables lors des renommages si les ID sont définis dans UI Builder.",
  "p_window_footer": "Affiche le statut actuel, la progression des opérations en arrière-plan et la version de l'outil.",
  "p_window_header": "La barre supérieure offre un accès global aux contrôles d'aperçu et aux outils utilitaires qui persistent quel que soit l'onglet sélectionné.",
  "p_window_sidebar": "La barre latérale gère la navigation entre les différents onglets fonctionnels et les outils de recherche globale.",
  "page_title": "Documentation de l'Outil de Localisation Unity",
  "q_faq_addressables_1": "J'ai activé le mode Addressables, mais les ressources ne se chargent pas. Que dois-je vérifier ?",
  "q_faq_addressables_2": "Comment ajouter le support pour DeepL/Google ?",
  "q_faq_addressables_3": "Le migreur affiche des erreurs de compilation après la suppression d'I2/UnityLoc. Comment puis-je résoudre ce problème ?",
  "q_faq_audio_smart_update": "Comment l'outil économise-t-il les crédits API lors de la régénération des fichiers audio ?",
  "q_faq_components_1": "Le composant LocalizedPrefab désactive les MonoBehaviours sur l'objet original. Que se passe-t-il si l'objet original possède un script qui crée d'autres objets ou s'abonne à des événements dans Awake() ?",
  "q_faq_components_2": "Si le prefab original (LocalizedPrefab) a un Rigidbody ou un autre composant physique, sera-t-il désactivé ? Cela affectera-t-il la physique si le prefab localisé ne l'a pas ?",
  "q_faq_components_3": "Le composant LocalizedAsset stocke le nom du composant cible sous forme de chaîne (_targetComponentTypeName). Que se passe-t-il si je renomme un script de composant personnalisé ou le déplace vers un autre assembly (Assembly Definition) ? LocalizedAsset cessera-t-il de fonctionner pour celui-ci ?",
  "q_faq_components_4": "S'il y a deux composants Image sur le même GameObject, comment LocalizedAsset sait-il lequel localiser ? Fonctionnera-t-il avec les deux ou seulement le premier qu'il trouve ?",
  "q_faq_components_5": "La documentation indique que LocalizedPrefab a un ordre d'exécution de -100. Que se passe-t-il si j'ai un autre script avec un ordre d'exécution de -110 qui essaie de trouver un objet enfant créé par LocalizedPrefab dans son Awake() ? LocalizedPrefab aura-t-il instancié son instance à temps ?",
  "q_faq_components_6": "Le composant LocalizedText a une option isStyleOnly. Si je l'active, puis que j'appelle myLocalizedText.SetFormattedText(\"new_key\") dans le code, le texte changera-t-il, ou seulement le style (police/RTL) ?",
  "q_faq_components_7": "LocalizedBehaviour trouve automatiquement les méthodes avec l'attribut [OnLanguageChange]. Trouverat-il les méthodes privées et protégées, ou doivent-elles être publiques ?",
  "q_faq_components_8": "Le composant LocalizedAsset intercepte Play on Awake. Que se passe-t-il si un autre script sur le même objet essaie d'accéder à la ressource (par exemple, audioSource.clip.length) dans Awake() ou Start() avant que LocalizedAsset ne l'ait échangée ? Une NullReferenceException ou l'utilisation de l'ancienne ressource est-elle possible ?",
  "q_faq_custom_keys_attribute": "Puis-je utiliser mon propre attribut pour les clés au lieu de [LocalizableField] ?",
  "q_faq_custom_provider_1": "Pourquoi mon fournisseur personnalisé n'apparaît-il pas dans le menu déroulant des paramètres ?",
  "q_faq_editor_1": "Qu'est-ce qui a la priorité la plus élevée pour la validation des placeholders : la directive @placeholders: dans le commentaire ou les placeholders trouvés dans le texte source de la langue ? Par exemple, si le texte source a {name} et que le commentaire dit @placeholders: {username}.",
  "q_faq_editor_2": "Si je fais une faute de frappe dans la directive (par exemple, @placeholder: au lieu de @placeholders:), sera-t-elle ignorée ou l'outil émettra-t-il un avertissement ?",
  "q_faq_editor_3": "Le système de sauvegarde automatique crée des fichiers dans le dossier Backups/AutoSaves. Ces fichiers seront-ils automatiquement supprimés après une sauvegarde manuelle réussie ou la fermeture de la fenêtre ?",
  "q_faq_editor_4": "Si je modifie la largeur des colonnes dans l'éditeur, ces paramètres seront-ils enregistrés entre les sessions Unity ?",
  "q_faq_editor_5": "La fenêtre contextuelle d'édition de texte (MultiLineEditWindow) prend-elle en charge sa propre pile Annuler/Rétablir (via Ctrl+Z) pour les modifications effectuées à l'intérieur ?",
  "q_faq_examples_1": "Que se passe-t-il si les noms de propriété dans le type anonyme passé à la fonction _() ne correspondent pas aux placeholders dans la chaîne ? Par exemple, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Y aura-t-il une erreur, ou le placeholder ne sera-t-il tout simplement pas remplacé ?",
  "q_faq_examples_2": "L'attribut [LocalizableField] fonctionne pour les champs privés. Fonctionnera-t-il pour les champs statiques ?",
  "q_faq_examples_3": "Si je mets l'attribut [OnLanguageChange] sur une méthode avec des paramètres (par exemple, void UpdateUI(string newLang)), que se passera-t-il ? Y aura-t-il une erreur de compilation ou un avertissement d'exécution ?",
  "q_faq_examples_4": "J'utilise _(\"apple_count\", count). S'il n'y a pas de clé apple_count_one pour la langue actuelle (pour count = 1), quelle forme le système choisira-t-il ? Utiliserat-il apple_count_other comme solution de repli ?",
  "q_faq_examples_5": "La fonction _(\"key\", new { username = \"Alex\" }) utilise un type anonyme. Cela ne créera-t-il pas une \"charge\" excessive sur le ramasse-miettes (GC) avec des appels fréquents dans une méthode Update() par rapport au passage d'un Dictionary<string, object> pré-créé ?",
  "q_faq_examples_6": "Ma méthode marquée de [OnLanguageChange] n'est pas appelée. Pourquoi ?",
  "q_faq_extending_1": "Mon analyseur personnalisé sera-t-il appelé automatiquement après chaque Update Keys ? Dois-je l'enregistrer quelque part, ou suffit-il d'avoir une classe qui implémente ITextComponentParser dans le projet ?",
  "q_faq_extending_2": "Que se passe-t-il si une exception se produit dans mon analyseur personnalisé ? Cela interrompra-t-il l'ensemble du processus d'analyse, ou l'outil continuera-t-il en toute sécurité avec d'autres analyseurs ?",
  "q_faq_installation_1": "Que se passe-t-il si mon projet a déjà le package com.unity.nuget.newtonsoft-json provenant d'une autre ressource ? L'installateur de dépendances essaiera-t-il de le mettre à jour ou de l'ignorer ?",
  "q_faq_installation_2": "J'ai cliqué accidentellement sur \"Skip for Now\" et coché \"Don't ask again\" pour les dépendances optionnelles (par exemple, pour le support CSV). Comment puis-je faire apparaître à nouveau la fenêtre d'installation pour les installer ?",
  "q_faq_installation_3": "L'outil n'a pas créé LocalizationSettings.asset dans Assets/Resources. Pourquoi cela aurait-il pu se produire, et puis-je le créer manuellement via le menu Assets -> Create ?",
  "q_faq_installation_4": "Puis-je déplacer le fichier LocalizationSettings.asset vers un autre dossier Resources, par exemple Assets/MyGame/Resources ? L'outil le trouvera-t-il toujours ?",
  "q_faq_installation_5": "L'installateur de dépendances a gelé ou a donné une erreur. Puis-je installer les dépendances (Newtonsoft Json, Editor Coroutines) manuellement via le Gestionnaire de Paquets Unity ?",
  "q_faq_notes_1": "La documentation recommande d'ajouter LanguageSelector à la liste d'ignorés. Qu'est-ce qui se brisera exactement si j'oublie de le faire ? Des clés supplémentaires seront-elles créées pour \"Option A, Option B\" ?",
  "q_faq_notes_2": "Si j'oublie d'ajouter un LocalizedText vide avec la case à cocher isStyleOnly activée sur le Label à l'intérieur du TMP_Dropdown utilisé par LanguageSelector, la police ne changera-t-elle pas ? Pourquoi est-ce nécessaire ?",
  "q_faq_notes_3": "L'appel de _() dans la méthode Update() n'est pas recommandé. Mais que se passe-t-il si je dois mettre à jour le texte à chaque image (par exemple, un minuteur) ? Quelle est la manière la plus performante de le faire, en mettant en cache uniquement la chaîne de format ?",
  "q_faq_tts_voices": "Comment attribuer des voix spécifiques aux personnages ?",
  "q_faq_window_actions_1": "Que se passe-t-il si la connexion Internet est perdue pendant une traduction automatique par lots ? L'outil réessayera-t-il le lot échoué selon la Politique de Réessai, ou le processus sera-t-il complètement interrompu ?",
  "q_faq_window_actions_2": "Si j'importe un fichier CSV qui contient des clés qui existent déjà dans le projet mais avec des valeurs vides pour certaines langues, ces valeurs vides remplaceront-elles mes traductions existantes ou seront-elles ignorées ?",
  "q_faq_window_actions_3": "La section \"Danger Zone\" permet de supprimer tous les composants. Supprimera-t-elle les composants des prefabs qui se trouvent dans des dossiers non spécifiés dans les Prefab Folders de l'onglet Content ?",
  "q_faq_window_actions_4": "Lors de l'importation à partir de Google Sheets, comment dois-je formater la colonne des commentaires pour que la validation des placeholders à l'aide de la directive @placeholders: fonctionne ?",
  "q_faq_window_actions_5": "L'outil peut-il importer des données à partir de plusieurs feuilles d'un même document Google Sheets, ou ne fonctionne-t-il qu'avec une seule feuille par GID ?",
  "q_faq_window_assets_1": "Que se passe-t-il si j'ai deux ressources avec la même clé mais des types différents dans le même dossier d'analyse (par exemple, sound_effect_en.mp3 et sound_effect_en.wav) ? Lequel se retrouvera dans la table des ressources ?",
  "q_faq_window_assets_2": "Si je clique sur Scan Assets & Analyze Project, et qu'il y a un objet Image dans la scène pour lequel un sprite localisé existe déjà, mais que l'objet Image lui-même n'a pas encore de composant LocalizedAsset, l'outil ajoutera-t-il le composant et insérera-t-il automatiquement la clé ?",
  "q_faq_window_assets_3": "Puis-je utiliser la même Règle de Nommage pour différentes catégories de ressources si elles ont des Dossiers d'Analyse différents ? Cela causera-t-il des conflits ?",
  "q_faq_window_assets_4": "Si une ressource localisable (par exemple, button_ok_en.png) ne se trouve pas à la racine du Dossier d'Analyse, mais dans un sous-dossier, le scanneur la trouvera-t-il ?",
  "q_faq_window_content_1": "Que se passe-t-il si j'ajoute une scène à Scenes to Parse qui n'est pas incluse dans les Build Settings ? Cela affectera-t-il quelque chose d'autre que le processus d'analyse lui-même ?",
  "q_faq_window_content_2": "J'ai ajouté un objet à Ignore Specific Objects (la liste temporaire). Si je fais un prefab de cet objet, l'instance de ce prefab sera-t-elle également ignorée ?",
  "q_faq_window_content_3": "Si j'ajoute le composant TMPro.TMP_Text à Parsing Ignores -> Ignore Component Types, mais qu'il y a un objet dans la scène avec un LocalizedText qui référence déjà ce TMP_Text, que se passera-t-il lors de la prochaine mise à jour des clés (Update Keys) ? La clé sera-t-elle supprimée ?",
  "q_faq_window_content_4": "La documentation indique que \"Pin\" enregistre le chemin complet de l'objet et se brisera s'il est renommé. Que se passe-t-il si je fais un prefab à partir de l'objet, puis renomme l'objet original – \"Pin\" continuera-t-il de fonctionner pour les instances de prefab ?",
  "q_faq_window_content_5": "Si j'utilise \"Pin\" pour un objet enfant à l'intérieur d'une instance de prefab, quel chemin sera enregistré : relatif à la racine du prefab ou à la racine de la scène ? Cela fonctionnera-t-il dans d'autres scènes ?",
  "q_faq_window_preview_1": "J'ai ouvert un prefab en Mode Prefab, appliqué l'Aperçu dans l'Éditeur et appuyé sur Ctrl+S. Les données d'aperçu temporaires seront-elles enregistrées dans la ressource prefab ? Comment LocalizationPreviewProtector gère-t-il ce cas ?",
  "q_faq_window_preview_2": "Si j'active l'Aperçu dans l'Éditeur et que l'éditeur Unity plante, et que le fichier Temp/localization_preview_recovery.json est corrompu (par exemple, JSON vide ou invalide), que se passera-t-il au prochain lancement ?",
  "q_faq_window_preview_3": "En mode Aperçu dans l'Éditeur pour LocalizedPrefab, une instance temporaire est créée. Les méthodes Awake() et Start() seront-elles exécutées sur cette instance ? Cela pourrait-il provoquer des erreurs si elles ne sont pas conçues pour s'exécuter en Mode Édition ?",
  "q_faq_window_report_1": "Le bouton \"Find\" recherche l'objet de manière asynchrone. Que se passe-t-il si je lance une recherche et que je clique immédiatement sur Update Keys ? La recherche sera-t-elle interrompue ?",
  "q_faq_window_report_2": "Si une clé est utilisée à plusieurs endroits (par exemple, sur deux boutons différents dans des scènes différentes), comment cela sera-t-il affiché dans le rapport sous la catégorie \"Duplicates\" ?",
  "q_faq_window_report_3": "Si je clique sur \"Find\" pour une clé qui n'est utilisée que dans le code (via la fonction _()), que se passera-t-il ? L'outil sera-t-il capable de trouver et de surligner le script C# ?",
  "q_faq_window_settings_1": "Je peux changer le Mode de Génération de Clé de UseTextAsKey à AutoGenerateKeysOnly en milieu de projet. Que se passera-t-il exactement avec mes traductions existantes ? Seront-elles mappées aux nouvelles clés ?",
  "q_faq_window_settings_2": "Si j'ajoute une langue avec un code qui n'a pas de règles de pluralisation (par exemple, \"kz\" pour le Kazakh) à la liste des Langues Prises en Charge, quelle règle sera utilisée par défaut ?",
  "q_faq_window_settings_3": "Que se passe-t-il si je spécifie le Translations Path non pas dans StreamingAssets, mais dans un dossier ordinaire comme Assets/MyTranslations ? Les fichiers json seront-ils inclus dans la construction du jeu ?",
  "q_faq_window_settings_4": "La clé API de traduction automatique est stockée dans EditorPrefs. Si je travaille sur le projet sur deux ordinateurs différents, dois-je saisir la clé sur chaque machine séparément ?",
  "tip_best_practice": "<strong>Conseil de pro :</strong> Si vous devez localiser une propriété, créez un champ de support avec <code>[LocalizableField]</code> et exposez la propriété séparément.",
  "toc_search_placeholder": "Rechercher dans la documentation...",
  "toc_title": "Table des Matières",
  "toggle_notes_title": "Basculer les Notes",
  "warning_box_components": "<strong>Note Importante :</strong> Tous les composants décrits ci-dessous sont ajoutés aux objets du jeu automatiquement lors de l'analyse (lorsque vous cliquez sur le bouton <code>Update Keys</code>). Vous n'avez pas besoin de les ajouter manuellement.",
  "warning_tms_overwrite": "<strong>Warning:</strong> Le tirage depuis le TMS écrasera les traductions locales pour les clés correspondantes. Assurez-vous que votre TMS est la source unique de vérité."
}