{
    "page_title": "Documentation de l'outil de localisation Unity",
    "toc_title": "Table des matières",
    "toc_search_placeholder": "Rechercher dans la documentation...",
    "nav_introduction": "1. Introduction",
    "nav_quick_start": "2. Démarrage rapide",
    "nav_components": "3. Composants principaux",
    "nav_loc_tool_window": "4. Fenêtre \"Outil de localisation\"",
    "nav_translation_editor": "5. Éditeur de traduction",
    "nav_usage_examples": "6. Exemples d'utilisation",
    "nav_important_notes": "7. Remarques importantes",
    "nav_extending": "8. Extension des fonctionnalités",
    "nav_faq": "9. FAQ et dépannage",
    "nav_key_features": "Fonctionnalités clés",
    "nav_installation": "2.1. Installation",
    "nav_initial_setup": "2.2. Configuration initiale",
    "nav_localizedtext": "3.1. LocalizedText",
    "nav_localizedasset": "3.2. LocalizedAsset",
    "nav_localizedprefab": "3.3. LocalizedPrefab",
    "nav_uitklocalization": "3.4. UITKLocalization",
    "nav_localizeddropdown": "3.5. LocalizedDropdown",
    "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
    "nav_context_menu": "3.7. Menu contextuel",
    "nav_in_editor_preview": "4.1. Aperçu dans l'éditeur",
    "nav_tab_settings": "4.2. Onglet \"Paramètres\"",
    "nav_tab_content": "4.3. Onglet \"Contenu\"",
    "nav_tab_actions": "4.4. Onglet \"Actions\"",
    "nav_tab_assets": "4.5. Onglet \"Assets\"",
    "nav_tab_report": "4.6. Onglet \"Rapport\"",
    "nav_example_components": "6.1. Composants prêts à l'emploi",
    "nav_example_attribute": "6.2. Attribut [LocalizableField]",
    "nav_example_function": "6.3. Fonction _()",
    "nav_example_plurals": "6.4. Pluriels et genre",
    "nav_custom_parser": "8.1. Création d'un analyseur",
    "nav_faq_installation": "9.1. Installation et démarrage rapide",
    "nav_faq_components": "9.2. Composants principaux",
    "nav_faq_window": "9.3. Fenêtre \"Outil de localisation\"",
    "nav_faq_window_actions": "9.3. Fenêtre \"Outil de localisation\" - Onglet \"Actions\"",
    "nav_faq_window_assets": "9.3. Fenêtre \"Outil de localisation\" - Onglet \"Assets\"",
    "nav_faq_window_report": "9.3. Fenêtre \"Outil de localisation\" - Onglet \"Rapport\"",
    "nav_faq_editor": "9.4. Éditeur de traduction",
    "nav_faq_examples": "9.5. Exemples d'utilisation et code",
    "nav_faq_notes": "9.6. Nuances importantes et avertissements",
    "nav_faq_extending": "9.7. Extension des fonctionnalités",
    "h1_introduction": "Introduction",
    "p_intro_1": "Cet outil est une solution complète pour la localisation de jeux et d'applications dans Unity. Il automatise le processus de collecte de texte et d'assets, la gestion des traductions via une interface puissante, l'intégration avec des services de traduction automatique et la mise à jour dynamique du contenu localisé dans le jeu.",
    "h2_key_features": "Fonctionnalités clés",
    "li_feature_1": "<strong>Analyse avancée :</strong> Analyse automatique des scènes, des prefabs, de l'UI Toolkit (UXML) et des scripts C#, y compris les champs marqués avec l'attribut <code>[LocalizableField]</code>, ainsi que les classes et listes imbriquées.",
    "li_feature_2": "<strong>Localisation de n'importe quel asset :</strong> Gérez les sprites, l'audio, les prefabs, les matériaux, etc.",
    "li_feature_3": "<strong>Éditeur de traduction puissant :</strong> Une interface centralisée avec sauvegarde automatique, prise en charge complète d'Annuler/Rétablir et regroupement intelligent des clés.",
    "li_feature_4": "<strong>Traduction automatique :</strong> Intégration avec DeepL, Google Translate et Microsoft Translator avec des paramètres flexibles (taille du lot, nombre de tentatives) pour chaque service.",
    "li_feature_5": "<strong>Import/Export flexible :</strong> Prise en charge de CSV, XML, YAML, XLIFF et importation directe depuis Google Sheets.",
    "li_feature_6": "<strong>Aperçu en direct dans l'éditeur :</strong> Prévisualisez n'importe quelle langue sans lancer le jeu.",
    "li_feature_7": "<strong>Prise en charge du pluriel et du genre :</strong> Gestion correcte des formes plurielles (avec des règles pour les langues slaves, arabes et autres) et du genre.",
    "li_feature_8": "<strong>Prise en charge complète du RTL :</strong> Affichage correct des langues de droite à gauche.",
    "li_feature_9": "<strong>Mises à jour en direct :</strong> Chargez les traductions à jour depuis un serveur distant au démarrage du jeu.",
    "li_feature_10": "<strong>Gestionnaire de sauvegardes :</strong> Un outil intégré pour créer et restaurer des sauvegardes.",
    "h1_quick_start": "Démarrage rapide et configuration",
    "h2_installation": "2.1. Installation",
    "li_install_1": "Copiez l'asset dans le dossier de votre projet Unity.",
    "li_install_2": "L'outil vérifiera automatiquement les dépendances nécessaires. Confirmez l'installation dans la boîte de dialogue qui apparaît.",
    "li_install_3": "Les dépendances requises (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) sont nécessaires pour les fonctionnalités de base.",
    "li_install_4": "Les dépendances optionnelles (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) activent des fonctionnalités supplémentaires.",
    "li_install_5": "Cliquez sur <strong>Installer la sélection</strong> pour installer les packages recommandés.",
    "li_install_6": "Après l'installation, ouvrez la fenêtre principale de l'outil via le menu <strong>Tools -> Localization Tool</strong>.",
    "h2_initial_setup": "2.2. Configuration initiale",
    "li_setup_1": "<strong>Créer les paramètres :</strong> À la première ouverture, l'outil créera un fichier <code>LocalizationSettings.asset</code> dans le dossier <code>Assets/Resources</code>.",
    "li_setup_2": "<strong>Configurer les langues :</strong> Dans l'onglet <strong>Paramètres</strong> sous <strong>Gestion des langues</strong>, assurez-vous que votre langue principale (par exemple, <code>fr</code> pour le français) est sélectionnée comme <strong>Langue source</strong>. Activez toutes les langues que vous prévoyez de prendre en charge.",
    "li_setup_3": "<strong>Spécifier le contenu à analyser :</strong> Dans l'onglet <strong>Contenu</strong>, ajoutez toutes les scènes à analyser à la liste <strong>Scènes à analyser</strong>. Si vous utilisez des prefabs avec du texte, assurez-vous que leurs dossiers sont ajoutés aux <strong>Dossiers de prefabs</strong>.",
    "li_setup_4": "<strong>Première exécution de l'analyseur :</strong> Allez dans l'onglet <strong>Actions</strong> et cliquez sur le bouton <code>Mettre à jour les clés</code>. L'outil analysera votre projet, créera des fichiers de traduction et ajoutera automatiquement les composants nécessaires (<code>LocalizedText</code>, <code>LocalizedAsset</code>, etc.) aux objets de jeu.",
    "h1_components": "Composants principaux (assignés automatiquement)",
    "warning_box_components": "<strong>Remarque importante :</strong> Tous les composants décrits ci-dessous sont ajoutés automatiquement aux objets de jeu lors de l'analyse (lorsque vous cliquez sur le bouton <code>Mettre à jour les clés</code>). Vous n'avez pas besoin de les ajouter manuellement.",
    "p_components_intro": "Ces composants sont le \"pont\" entre vos objets dans la scène et la base de données de traduction. Ils \"écoutent\" les changements de langue et substituent automatiquement le bon texte ou asset.",
    "h2_localizedtext": "3.1. LocalizedText",
    "p_localizedtext_1": "Le composant principal pour afficher le texte traduit. Il est placé sur des objets avec <code>Text</code>, <code>TMP_Text</code> et <code>TextMesh</code>.",
    "li_localizedtext_1": "<code>localizationKey</code> : La clé utilisée pour trouver la traduction. Générée automatiquement.",
    "li_localizedtext_2": "<code>isStyleOnly</code> : Si <code>true</code>, le composant n'appliquera que les styles (police, RTL) mais ne changera pas le texte lui-même. Utile pour les éléments dont le texte est géré par un autre script (par exemple, <code>LanguageSelector</code>).",
    "li_localizedtext_3": "<code>originalSourceText</code> : Le texte original dans la langue de base. Utilisé comme solution de secours.",
    "h2_localizedasset": "3.2. LocalizedAsset",
    "p_localizedasset_1": "Utilisé pour échanger des assets (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code>, etc.). Il détecte automatiquement le type de composant cible sur l'objet (<code>Image</code>, <code>AudioSource</code>) et remplace sa ressource.",
    "p_localizedasset_2": "Pour les composants avec l'option <strong>Play on Awake</strong> (comme <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> intercepte correctement la lecture automatique, échange l'asset, puis lance la lecture pour éviter de lire du contenu non localisé.",
    "h2_localizedprefab": "3.3. LocalizedPrefab",
    "p_localizedprefab_1": "Un composant pour localiser des prefabs entiers. Il fonctionne de manière non destructive : il ne modifie pas le prefab d'origine mais crée une instance de la version localisée en tant qu'objet enfant, désactivant tous les scripts (<code>MonoBehaviour</code>), les renderers (<code>Renderer</code>) et les colliders (<code>Collider</code>) sur l'objet d'origine. Cela empêche la double exécution de la logique et les artefacts visuels. Pour un fonctionnement correct à l'exécution, son ordre d'exécution est défini sur -100 (<code>[DefaultExecutionOrder(-100)]</code>) pour s'assurer qu'il s'exécute avant les autres scripts.",
    "h2_uitklocalization": "3.4. UITKLocalization",
    "p_uitklocalization_1": "Ajouté aux objets avec un <code>UIDocument</code> et gère la localisation de tous les éléments de texte dans le document UI Toolkit (UXML).",
    "h2_localizeddropdown": "3.5. LocalizedDropdown",
    "p_localizeddropdown_1": "Ajouté à <code>Dropdown</code> et <code>TMP_Dropdown</code> pour traduire leurs options.",
    "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
    "p_localizedbehaviour_1": "Un composant utilitaire qui permet à vos scripts de réagir aux changements de langue. Il trouve et appelle automatiquement les méthodes marquées avec l'attribut <code>[OnLanguageChange]</code>.",
    "h2_context_menu": "3.7. Menu contextuel \"Analyser pour la localisation\"",
    "p_context_menu_1": "Pour ajouter rapidement un <code>LocalizedAsset</code> à un objet, vous pouvez faire un clic droit sur le composant souhaité (par exemple, <code>Image</code>, <code>AudioSource</code>) dans l'inspecteur et sélectionner <strong>Analyser pour la localisation</strong>. L'outil ajoutera et configurera le composant lui-même. (Ceci est optionnel mais peut être utilisé pour un ajout manuel).",
    "h1_loc_tool_window": "Fenêtre \"Outil de localisation\"",
    "h2_in_editor_preview": "4.1. Aperçu dans l'éditeur",
    "p_preview_1": "Juste en dessous de l'en-tête se trouve la liste déroulante <strong>Langue d'aperçu</strong>. Cette fonctionnalité puissante vous permet de voir à quoi ressemblera la localisation dans n'importe quelle langue directement dans la fenêtre <strong>Scène</strong>, sans lancer le jeu.",
    "li_preview_1": "<strong>Comment ça marche :</strong> Sélectionnez une langue dans la liste, et l'outil appliquera instantanément les traductions, polices, paramètres RTL et assets correspondants à tous les objets localisables dans la scène active.",
    "li_preview_2": "<strong>Espaces réservés :</strong> Si un style d'espace réservé (par exemple, <strong>Accents</strong> ou <strong>Crochets</strong>) est sélectionné dans l'onglet <strong>Paramètres</strong>, ces espaces réservés seront affichés en mode aperçu au lieu des traductions réelles. C'est idéal pour tester la mise en page et trouver les éléments non localisés.",
    "li_preview_3": "<strong>Sécurité :</strong> Toutes les modifications apportées en mode aperçu sont temporaires. L'outil rétablira automatiquement tout à son état d'origine lorsque vous sélectionnerez \"<strong>Revenir à l'original</strong>\", fermerez la fenêtre, changerez de scène ou avant d'enregistrer une scène/prefab (grâce au composant <code>LocalizationPreviewProtector</code>).",
    "li_preview_4": "<strong>Protection contre les plantages :</strong> Le système intégré <code>PreviewCrashProtector</code> restaurera automatiquement l'état d'origine des objets si l'éditeur Unity plante pendant qu'un aperçu est actif.",
    "h2_tab_settings": "4.2. Onglet \"Paramètres\"",
    "p_settings_1": "Votre centre de contrôle. Ici, vous définissez les règles globales pour l'ensemble du processus de localisation.",
    "li_settings_1": "<strong>Mode de génération de clé :</strong> Choisissez comment les clés seront créées.<ul><li><code>UseTextAsKey</code> : Le texte lui-même devient la clé. Idéal pour les prototypes. Inconvénient : si vous changez le texte source, la clé change et toutes ses traductions seront perdues.</li><li><code>AutoGenerateKeysOnly</code> : La clé est générée en fonction de la hiérarchie et du nom de l'objet. Fiable pour la production. Avantage : les traductions ne se cassent pas lorsque le texte est modifié.</li><li><code>UseTextAsKeyWithCustomPriority</code> et <code>AutoGenerateWithCustomKeys</code> : Modes hybrides qui vous permettent de définir des clés personnalisées dans le code via l'attribut <code>[LocalizableField(\"ma_cle_personnalisee\")]</code>.</li><li><strong>Migration sécurisée :</strong> Vous pouvez changer de mode à tout moment. L'outil migrera automatiquement toutes les traductions existantes vers le nouveau système de clés.</li></ul>",
    "li_settings_2": "<strong>Gestion des langues :</strong> Configurez la liste des langues. Pour les langues avec des caractères spéciaux, attribuez l'<strong>Asset de police</strong> approprié. Activez l'option <strong>RTL</strong> pour les langues de droite à gauche.",
    "li_settings_3": "<strong>Paramètres généraux :</strong><ul><li><code>Analyser les prefabs</code> : Active l'analyse des prefabs.</li><li><code>Diviser les fichiers par langue</code> : Détermine comment stocker les traductions (un grand fichier ou un fichier par langue).</li><li><code>Chemin des traductions</code> : Le chemin pour stocker les fichiers de traduction <code>.json</code>. Important : le dossier doit se trouver à l'intérieur de <code>Assets/StreamingAssets/</code>.</li></ul>",
    "li_settings_4": "<strong>Débogage et test :</strong><ul><li><code>Style d'espace réservé</code> : Choisissez le style pour afficher les espaces réservés en mode aperçu.</li></ul>",
    "li_settings_5": "<strong>Mises à jour en direct :</strong> Paramètres pour charger les traductions depuis un serveur distant.",
    "li_settings_6": "<strong>Clé API d'exécution :</strong> Une section pour stocker en toute sécurité une clé API qui pourrait être nécessaire dans le jeu compilé (stockée sous forme chiffrée).",
    "h2_tab_content": "4.3. Onglet \"Contenu\"",
    "p_content_1": "Ici, vous indiquez à l'outil où chercher exactement le texte.",
    "li_content_1": "<strong>Scènes à analyser :</strong> Faites glisser et déposez toutes les scènes à analyser ici.",
    "li_content_2": "<strong>Dossiers de prefabs :</strong> Spécifiez les dossiers avec les prefabs.",
    "li_content_3": "<strong>Textes dynamiques :</strong> Entrez ici les chaînes de caractères qui sont créées exclusivement dans le code (par exemple, \"Game Over\").",
    "li_content_4": "<strong>Exclusions de l'analyse :</strong> Spécifiez les scripts, composants ou objets à ignorer.",
    "li_content_5": "<strong>Épingler :</strong> Cette fonctionnalité vous permet d'\"épingler\" un objet de la scène à la liste d'exclusion. Au lieu d'une référence temporaire à l'objet, l'outil enregistrera son chemin complet dans la hiérarchie, rendant l'exclusion persistante entre les sessions (mais notez que renommer l'objet ou son parent cassera ce lien).",
    "h2_tab_actions": "4.4. Onglet \"Actions\"",
    "p_actions_1": "L'onglet de travail principal.",
    "li_actions_1": "<strong>Mettre à jour les clés :</strong> Exécute l'analyseur, qui met à jour vos fichiers de traduction.",
    "li_actions_2": "<strong>Ouvrir l'éditeur de traduction :</strong> Ouvre une fenêtre séparée et plus pratique pour éditer toutes les traductions.",
    "li_actions_3": "<strong>Gestion des données :</strong> Utiliser pour échanger des données avec les traducteurs (Export/Import vers CSV/XML/YAML/XLIFF, importation depuis Google Sheets).",
    "li_actions_4": "<strong>Traduction automatique :</strong> Remplit automatiquement toutes les chaînes de traduction vides. Les nouveaux paramètres vous permettent de gérer la taille du lot (<strong>Taille du lot</strong>) et la politique de nouvelle tentative (<strong>Politique de nouvelle tentative</strong>) pour chaque service (DeepL, Google, Microsoft) séparément. L'outil suit le nombre de caractères traduits et avertit des dépassements de limite potentiels.",
    "li_actions_5": "<strong>Zone de danger :</strong> Contient des boutons pour supprimer complètement tous les composants de localisation du projet. À utiliser avec prudence !",
    "h2_tab_assets": "4.5. Onglet \"Assets\"",
    "p_assets_1": "Cet onglet est entièrement dédié à la localisation des ressources non textuelles.",
    "li_assets_1": "<strong>Créer une structure de dossiers (facultatif) :</strong> Dans la section <strong>2. Génération de dossiers d'assets</strong>, cliquez sur <strong>Créer les dossiers d'assets maintenant</strong>.",
    "li_assets_2": "<strong>Configurer les catégories et les règles de nommage :</strong> Dans la section <strong>3. Catégories d'assets et analyse</strong>, assurez-vous que la <strong>Règle de nommage</strong> (<code>{key}_{lang}</code>) correspond à vos fichiers (par exemple, <code>bouton_ok_fr.png</code>).",
    "li_assets_3": "<strong>Placez vos assets :</strong> Mettez les assets localisés dans les dossiers.",
    "li_assets_4": "<strong>Analyser les assets :</strong> Dans la section <strong>4. Automatisation</strong>, cliquez sur <strong>Analyser les assets et mettre à jour les tables</strong>. Le processus de nettoyage est devenu plus sûr : désormais, seuls les anciens fichiers de table (<code>.asset</code>) sont supprimés, et non le dossier entier.",
    "li_assets_5": "<strong>Lier les assets aux objets :</strong> Cliquez sur <strong>Analyser le projet et attacher les composants</strong>.",
    "h2_tab_report": "4.6. Onglet \"Rapport\"",
    "p_report_1": "Après chaque analyse, ce rapport montre une image complète de l'état de votre localisation.",
    "li_report_1": "<strong>Catégories :</strong> Toutes les clés, Ajoutées, Mises à jour (texte modifié), Supprimées, Doublons, Migrées, Ignorées (inchangées).",
    "li_report_2": "<strong>Recherche avancée :</strong> Cliquez sur le bouton <strong>Trouver</strong> à côté de n'importe quelle entrée pour trouver instantanément l'objet correspondant dans le projet. La recherche fonctionne de manière asynchrone, ne bloquant pas l'éditeur, et recherche dans toutes les scènes et prefabs. Si une clé est utilisée à plusieurs endroits, une liste déroulante avec toutes les sources apparaîtra.",
    "h1_translation_editor": "Éditeur de table de traduction",
    "p_editor_1": "S'ouvre via <strong>Tools -> Localization -> Translation Table Editor</strong>. C'est l'outil principal pour l'édition manuelle des traductions.",
    "li_editor_1": "<strong>Regroupement intelligent :</strong> Les clés pour les pluriels et le genre (par exemple, <code>apple_count_one</code>, <code>apple_count_few</code>) sont automatiquement combinées en groupes réductibles.",
    "li_editor_2": "<strong>Édition avancée :</strong> Cliquez sur une cellule pour ouvrir la fenêtre contextuelle <strong>MultiLineEditWindow</strong>. Elle affiche le texte source pour comparaison, vous permet de le copier rapidement et vérifie les incohérences d'espaces réservés (par exemple, <code>{username}</code>) en temps réel, mettant en évidence ceux qui manquent ou sont en trop.",
    "li_editor_3": "<strong>Validation des espaces réservés via les commentaires :</strong> Vous pouvez spécifier explicitement quels espaces réservés doivent se trouver dans la traduction en ajoutant une directive spéciale au commentaire de la clé, par exemple : <code>@placeholders: {username}, {score}</code>. La <strong>MultiLineEditWindow</strong> utilisera cette liste comme source principale de vérité.",
    "li_editor_4": "<strong>Navigation et gestion :</strong> Naviguez dans la table avec les barres de défilement ou en maintenant le bouton du milieu de la souris. Modifiez la largeur des colonnes en faisant glisser les séparateurs. Enregistrez les modifications avec <code>Ctrl+S</code>.",
    "li_editor_5": "<strong>Annuler/Rétablir complet :</strong> L'ensemble de la pile d'actions (modifications de texte, ajout/suppression de clés) est entièrement pris en charge via <code>Ctrl+Z</code> / <code>Ctrl+Y</code>.",
    "li_editor_6": "<strong>Sauvegardes et sauvegarde automatique :</strong> Utilisez le bouton <strong>Gérer les sauvegardes</strong>. L'outil enregistre également automatiquement votre session toutes les quelques minutes. En cas de plantage, il vous sera proposé de restaurer vos modifications.",
    "h1_usage_examples": "Exemples d'utilisation",
    "h2_example_components": "6.1. Composants et exemples prêts à l'emploi",
    "p_example_components_1": "Le projet comprend des scripts prêts à l'emploi qui servent d'excellents exemples.",
    "li_example_components_1": "<strong><code>LanguageSelector.cs</code> :</strong> Un composant prêt à l'emploi pour créer une liste déroulante d'interface utilisateur pour le changement de langue. Il trouve automatiquement toutes les langues disponibles et gère leur changement.<br><strong>Comment l'utiliser :</strong> Ajoutez simplement le composant <code>LanguageSelector</code> à votre scène (par exemple, sur un GameObject vide) et spécifiez votre <code>TMP_Dropdown</code> dans l'inspecteur.",
    "li_example_components_2": "<strong>Exemples de code :</strong> Pour apprendre des techniques avancées telles que le travail avec <code>[LocalizableField]</code>, la fonction <code>_()</code>, les pluriels et le genre, étudiez les fichiers <code>StatPurchaseTest.cs</code> et <code>TestLocalization.cs</code>. Ils démontrent clairement la mise en œuvre de toutes les principales fonctionnalités de l'outil dans le code.",
    "h2_example_attribute": "6.2. Attribut [LocalizableField]",
    "p_example_attribute_1": "La méthode préférée pour les textes qui font partie de la configuration d'un composant dans l'inspecteur. L'analyseur peut maintenant travailler avec des chaînes, des listes/tableaux de chaînes, et même des champs dans des classes imbriquées <code>[System.Serializable]</code>.",
    "code_example_attribute": "using Ankonoanko.Localization; // Requis pour [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // L'analyseur trouvera ce champ et créera une clé pour lui\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"Vous avez échoué la quête.\";\n    \n    // Vous pouvez définir une clé personnalisée\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Êtes-vous prêt pour une aventure ?\";\n    \n    // Fonctionne avec les listes\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Trouver le trésor\" };\n    \n    // Et même avec des classes imbriquées !\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
    "h2_example_function": "6.3. Fonction _() et attribut [OnLanguageChange]",
    "p_example_function_1": "Utilisez la fonction <code>_()</code> pour le texte dynamique qui change pendant le jeu. La méthode qui met à jour l'interface utilisateur doit être marquée avec l'attribut <code>[OnLanguageChange]</code> afin qu'elle soit appelée automatiquement lors du changement de langue. Un composant <code>LocalizedBehaviour</code> sera automatiquement ajouté à l'objet à cet effet.",
    "code_example_function": "// Pour utiliser l'appel court _(), ajoutez ces lignes\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Requis pour [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Mise à jour initiale\n    }\n    \n    // Cette méthode sera appelée automatiquement lorsque la langue change\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Espaces réservés indexés (comme dans string.Format)\n        // Clé : \"score_label\", Texte dans le fichier : \"Score : {0}\"\n        scoreText.text = _(\"score_label\", score); // Résultat : \"Score : 100\"\n        \n        // 2. Espaces réservés nommés (recommandé pour la lisibilité)\n        // Clé : \"welcome_message\", Texte : \"Bienvenue, {username} !\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Pour les cas complexes ou haute performance\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
    "h2_example_plurals": "6.4. Pluriels et genre",
    "p_example_plurals_1": "L'outil utilise maintenant des règles plus précises pour différents groupes linguistiques.",
    "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Clés : \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Textes : \"{0} pomme\", \"{0} pommes\", \"{0} pommes\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Sélectionne automatiquement la forme correcte\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Clés : \"user_greeted_male\", \"user_greeted_female\"\n        // Textes : \"Il est arrivé.\", \"Elle est arrivée.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
    "h1_important_notes": "Remarques importantes et avertissements",
    "li_notes_1": "<strong>Sauvegardes :</strong> Avant les opérations globales (<code>Mettre à jour les clés</code>, importation de données), créez toujours une sauvegarde via <strong>Éditeur de table de traduction -> Gérer les sauvegardes</strong>.",
    "li_notes_2": "<strong>Sécurité de la clé API :</strong> La clé pour travailler dans l'éditeur est stockée localement sur votre machine (dans <code>EditorPrefs</code>) et n'est pas incluse dans le dépôt. Pour les clés nécessaires dans la version du jeu, utilisez la section <strong>Clé API d'exécution</strong>.",
    "li_notes_3": "<strong>Dossier <code>StreamingAssets</code> :</strong> Les fichiers de traduction doivent se trouver dans un sous-dossier de <code>Assets/StreamingAssets/</code> pour être inclus dans la version du jeu.",
    "li_notes_4": "<strong>\"Protection contre les erreurs\" :</strong> L'outil vous protège automatiquement contre l'enregistrement accidentel de données temporaires du mode aperçu dans une scène ou un prefab.",
    "li_notes_5": "<strong>Performance :</strong> L'appel <code>_()</code> est rapide, mais dans les boucles qui s'exécutent à chaque image (par exemple, dans <code>Update</code>), essayez de mettre en cache le résultat dans une variable.",
    "li_notes_6": "<strong>Exclusion de <code>LanguageSelector</code> de l'analyse :</strong> L'objet avec le composant <code>LanguageSelector</code> et son <code>TMP_Dropdown</code> doivent être ajoutés à la liste <strong>Ignorer les objets spécifiques</strong> dans l'onglet <strong>Contenu</strong>. Ceci est nécessaire pour empêcher l'analyseur de créer des clés supplémentaires pour les options du menu déroulant, car le script <code>LanguageSelector</code> les remplit dynamiquement à l'exécution. L'ignorer prévient les conflits et garde les fichiers de traduction propres.",
    "li_notes_7": "<strong>Polices pour <code>LanguageSelector</code> :</strong> Pour que la langue sélectionnée dans le <code>TMP_Dropdown</code> mette à jour correctement sa police, ajoutez manuellement un composant <code>LocalizedText</code> vide à l'objet enfant <strong>Label</strong> du Dropdown et cochez la case <code>isStyleOnly</code>.",
    "h1_extending": "Extension des fonctionnalités",
    "h2_custom_parser": "8.1. Création d'un analyseur personnalisé",
    "p_custom_parser_1": "Vous pouvez facilement étendre le système pour prendre en charge des composants personnalisés en créant votre propre classe d'analyseur.",
    "li_custom_parser_1": "Créez un nouveau script C# dans le dossier <strong>Editor</strong> de votre projet.",
    "li_custom_parser_2": "Copiez le modèle ci-dessous dedans.",
    "li_custom_parser_3": "Modifiez la logique pour qu'elle corresponde à votre composant.",
    "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// MODÈLE pour créer un analyseur pour un composant personnalisé.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Vérifiez si l'objet a le composant personnalisé dont nous avons besoin.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Sortir si le composant n'est pas trouvé\n        }\n        \n        // 2. Obtenez le texte des champs du composant personnalisé.\n        string titleText = component.Title;\n        \n        // 3. Vérifiez si le texte est valide pour la localisation.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Générez la clé et la source à l'aide des aides de TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Retournez le résultat.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Répétez pour les autres champs...\n        // (un suffixe peut être ajouté pour rendre les clés uniques)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
    "h1_faq": "FAQ et dépannage",
    "h2_faq_installation": "9.1. Installation et démarrage rapide",
    "q_faq_installation_1": "Que se passe-t-il si mon projet a déjà le paquet com.unity.nuget.newtonsoft-json d'un autre asset ? L'installateur de dépendances essaiera-t-il de le mettre à jour ou de l'ignorer ?",
    "a_faq_installation_1": "L'installateur vérifie l'existence du type Newtonsoft.Json.JsonConvert. Si le type existe, il considère la dépendance satisfaite et n'essaiera pas d'installer ou de mettre à jour le paquet. Ceci est fait pour éviter les conflits de version.",
    "q_faq_installation_2": "J'ai accidentellement cliqué sur \"Ignorer pour l'instant\" et coché \"Ne plus demander\" pour les dépendances optionnelles (par exemple, pour le support CSV). Comment puis-je faire réapparaître la fenêtre de l'installateur pour les installer ?",
    "a_faq_installation_2": "Vous pouvez déclencher manuellement une vérification des dépendances à tout moment via le menu Tools -> Localization -> Check Dependencies. Cela réinitialisera l'indicateur \"Ne plus demander\" et affichera à nouveau la fenêtre avec tous les paquets optionnels manquants.",
    "q_faq_installation_3": "L'outil n'a pas créé LocalizationSettings.asset dans Assets/Resources. Pourquoi cela aurait-il pu se produire, et puis-je le créer manuellement via le menu Assets -> Create ?",
    "a_faq_installation_3": "Cela peut arriver si vous n'avez pas de dossier Assets/Resources. L'outil essaiera de le créer, mais les autorisations du système de fichiers pourraient l'en empêcher. Oui, vous pouvez créer l'asset manuellement : faites un clic droit dans le dossier Resources, sélectionnez Create -> Localization -> Settings. L'outil le trouvera automatiquement.",
    "q_faq_installation_4": "Puis-je déplacer le fichier LocalizationSettings.asset vers un autre dossier Resources, par exemple, Assets/MyGame/Resources ? L'outil le trouvera-t-il toujours ?",
    "a_faq_installation_4": "Oui. L'outil utilise Resources.Load(), qui recherche un asset par son nom dans tous les dossiers nommés Resources de votre projet. L'important est que le fichier conserve son nom LocalizationSettings.asset.",
    "q_faq_installation_5": "L'installateur de dépendances s'est figé ou a donné une erreur. Puis-je installer les dépendances (Newtonsoft Json, Editor Coroutines) manuellement via le Unity Package Manager ?",
    "a_faq_installation_5": "Oui. Vous pouvez ouvrir Window -> Package Manager, cliquer sur l'icône \"+\", et sélectionner \"Add package by name...\". Entrez les noms des paquets : com.unity.nuget.newtonsoft-json et com.unity.editorcoroutines.",
    "h2_faq_components": "9.2. Composants principaux",
    "q_faq_components_1": "Le composant LocalizedPrefab désactive les MonoBehaviours sur l'objet original. Que se passe-t-il si l'objet original a un script qui crée d'autres objets ou s'abonne à des événements dans Awake() ? Ce code sera-t-il exécuté ?",
    "a_faq_components_1": "Non, il ne le sera pas. La désactivation d'un MonoBehaviour empêche l'appel de toutes les méthodes \"magiques\" de Unity, y compris Awake(), OnEnable() et Start(). C'est intentionnel pour éviter l'exécution de logique en double. Toute initialisation doit se produire dans des scripts sur les versions localisées du prefab.",
    "q_faq_components_2": "Si le prefab original (LocalizedPrefab) a un Rigidbody ou un autre composant de physique, sera-t-il désactivé ? Cela affectera-t-il la physique si le prefab localisé ne l'a pas ?",
    "a_faq_components_2": "Oui, le comportement physique de l'objet original sera neutralisé. Le composant LocalizedPrefab trouve tous les composants Rigidbody et Rigidbody2D sur son GameObject et définit leur propriété isKinematic sur true. Cela les retire efficacement des calculs physiques dynamiques, empêchant tout comportement indésirable comme la chute d'un objet invisible ou sa réaction aux collisions. Il est toujours recommandé que la version localisée du prefab contienne tous les composants physiques nécessaires pour un comportement correct.",
    "q_faq_components_3": "Le composant LocalizedAsset stocke le nom du composant cible sous forme de chaîne (_targetComponentTypeName). Que se passe-t-il si je renomme un script de composant personnalisé ou le déplace vers un autre assembly (Assembly Definition) ? LocalizedAsset cessera-t-il de fonctionner pour lui ?",
    "a_faq_components_3": "Oui, il cessera de fonctionner. Le composant stocke le nom complet du type, y compris l'espace de noms et l'assembly. Le renommage du script ou son déplacement vers un autre .asmdef changera ce nom, et LocalizedAsset ne pourra pas trouver le composant cible. Vous devrez exécuter une autre analyse via Analyser le projet et attacher les composants pour qu'il mette à jour le nom.",
    "q_faq_components_4": "S'il y a deux composants Image sur le même GameObject, comment LocalizedAsset sait-il lequel localiser ? Fonctionnera-t-il avec les deux ou seulement le premier qu'il trouve ?",
    "a_faq_components_4": "Un LocalizedAsset est créé pour une instance de composant spécifique. Il détient une référence à ce composant dans le code. Si vous ajoutez manuellement un deuxième LocalizedAsset et utilisez le menu contextuel \"Analyser pour la localisation\" pour cibler la deuxième Image, vous aurez deux composants LocalizedAsset, chacun gérant sa propre Image. L'analyseur automatique ne créera un composant que pour la première Image avec un asset localisable qu'il trouve.",
    "q_faq_components_5": "La documentation indique que LocalizedPrefab a un ordre d'exécution de -100. Que se passe-t-il si j'ai un autre script avec un ordre d'exécution de -110 qui essaie de trouver un objet enfant créé par LocalizedPrefab dans son Awake() ? LocalizedPrefab aura-t-il instancié son instance à temps ?",
    "a_faq_components_5": "Oui, il le fera. LocalizedPrefab crée l'instance du prefab localisé dans sa méthode OnEnable(). L'ordre d'exécution de Unity garantit que toutes les méthodes Awake() sont exécutées avant toutes les méthodes OnEnable(). Ainsi, votre script avec l'ordre -110 exécutera son Awake(), puis LocalizedPrefab avec l'ordre -100 exécutera son Awake(), et seulement après cela leurs méthodes OnEnable() seront appelées dans l'ordre. Votre script ne trouvera pas l'objet car il n'aura pas encore été créé.",
    "q_faq_components_6": "Le composant LocalizedText a une option isStyleOnly. Si je l'active et que j'appelle ensuite myLocalizedText.SetFormattedText(\"new_key\") dans le code, le texte changera-t-il, ou seulement le style (police/RTL) ?",
    "a_faq_components_6": "La clé et le texte changeront tous les deux. L'appel de SetFormattedText par programme outrepasse le comportement de isStyleOnly pour cette mise à jour spécifique. L'option isStyleOnly est destinée à empêcher le composant de réagir aux changements de langue globaux, mais il réagira toujours à un changement de clé direct via le code.",
    "q_faq_components_7": "LocalizedBehaviour trouve automatiquement les méthodes avec l'attribut [OnLanguageChange]. Trouvera-t-il les méthodes privées et protégées, ou doivent-elles être publiques ?",
    "a_faq_components_7": "Il trouvera les méthodes avec n'importe quel modificateur d'accès (public, private, protected, internal). La réflexion dans Unity permet la découverte de toutes les méthodes d'instance quel que soit leur niveau d'accès.",
    "q_faq_components_8": "Le composant LocalizedAsset intercepte Play on Awake. Que se passe-t-il si un autre script sur le même objet essaie d'accéder à l'asset (par exemple, audioSource.clip.length) dans Awake() ou Start() avant que LocalizedAsset ne l'ait échangé ? Une NullReferenceException ou l'utilisation de l'ancien asset est-elle possible ?",
    "a_faq_components_8": "L'utilisation de l'ancien asset (non localisé) est possible. LocalizedAsset effectue l'échange dans son OnEnable(). Les méthodes Awake() de tous les scripts sont exécutées avant OnEnable(). Si votre script accède à audioSource.clip dans Awake(), il obtiendra le clip original. S'il y accède dans Start(), le résultat dépendra de l'ordre d'exécution du script. Pour garantir l'accès à l'asset localisé, définissez un ordre d'exécution ultérieur pour votre script ou accédez à l'asset dans une méthode marquée avec [OnLanguageChange].",
    "h2_faq_window": "9.3. Fenêtre \"Outil de localisation\"",
    "h3_faq_window_preview": "Aperçu dans l'éditeur",
    "q_faq_window_preview_1": "J'ai ouvert un prefab en mode Prefab, appliqué l'aperçu dans l'éditeur et appuyé sur Ctrl+S. Les données d'aperçu temporaires seront-elles enregistrées dans l'asset du prefab ? Comment LocalizationPreviewProtector gère-t-il ce cas ?",
    "a_faq_window_preview_1": "Non, elles ne seront pas enregistrées. LocalizationPreviewProtector intercepte l'événement d'enregistrement de l'asset (OnWillSaveAssets) et appelle automatiquement RevertEditorPreview() avant que Unity n'écrive les modifications sur le disque. Ainsi, le prefab sera enregistré dans son état original et non localisé.",
    "q_faq_window_preview_2": "Si j'active l'aperçu dans l'éditeur et que l'éditeur Unity plante, et que le fichier Temp/localization_preview_recovery.json est corrompu (par exemple, vide ou JSON invalide), que se passera-t-il au prochain lancement ?",
    "a_faq_window_preview_2": "PreviewCrashProtector est encapsulé dans un bloc try-catch. Si la désérialisation JSON échoue, une erreur sera consignée dans la console concernant l'incapacité à récupérer, et le processus se terminera silencieusement. Votre scène restera dans l'état \"cassé\" où elle se trouvait au moment du plantage. Dans ce cas, vous devrez sélectionner manuellement \"Revenir à l'original\" dans la fenêtre de l'outil pour forcer un retour en arrière des modifications.",
    "q_faq_window_preview_3": "En mode aperçu dans l'éditeur pour LocalizedPrefab, une instance temporaire est créée. Les méthodes Awake() et Start() seront-elles exécutées sur cette instance ? Cela pourrait-il causer des erreurs si elles ne sont pas conçues pour s'exécuter en mode édition ?",
    "a_faq_window_preview_3": "Oui, elles le seront. PrefabUtility.InstantiatePrefab en mode édition appelle Awake() et OnEnable(). Si ces méthodes contiennent une logique qui ne doit pas s'exécuter dans l'éditeur (par exemple, accéder à des singletons qui n'existent qu'en mode lecture), cela pourrait causer des erreurs. Il est recommandé d'utiliser if (Application.isPlaying) ou #if UNITY_EDITOR pour protéger un tel code.",
    "h3_faq_window_settings": "Onglet \"Paramètres\"",
    "q_faq_window_settings_1": "Je peux changer le mode de génération de clé de UseTextAsKey à AutoGenerateKeysOnly en cours de projet. Qu'arrivera-t-il exactement à mes traductions existantes ? Seront-elles mappées sur les nouvelles clés ?",
    "a_faq_window_settings_1": "Oui, elles le seront. Lors du changement de mode, l'outil effectue une \"migration sécurisée\" : il ré-analyse l'ensemble du projet, crée de nouvelles clés selon les nouvelles règles, mais mappe les anciennes et les nouvelles clés via le texte original. Il transfère ensuite toutes vos traductions et commentaires existants des anciennes clés vers les nouvelles. Vos traductions ne seront pas perdues.",
    "q_faq_window_settings_2": "Si j'ajoute une langue avec un code qui n'a pas de règles de pluralisation (par exemple, \"kz\" pour le kazakh) à la liste des langues prises en charge, quelle règle sera utilisée par défaut ?",
    "a_faq_window_settings_2": "La DefaultPluralRule sera utilisée, qui convient à l'anglais et à la plupart des langues européennes (formes pour \"one\" et \"other\").",
    "q_faq_window_settings_3": "Que se passe-t-il si je spécifie le chemin des traductions non pas dans StreamingAssets, mais dans un dossier ordinaire comme Assets/MyTranslations ? Les fichiers json seront-ils inclus dans la version du jeu ?",
    "a_faq_window_settings_3": "Non, ils ne le seront pas. Seuls les assets situés dans un dossier StreamingAssets ou Resources sont garantis d'être inclus dans la version. Si vous spécifiez un chemin différent, la localisation fonctionnera dans l'éditeur mais ne fonctionnera pas dans le jeu compilé, car les fichiers de traduction ne feront pas partie de la version.",
    "q_faq_window_settings_4": "La clé API de traduction automatique est stockée dans EditorPrefs. Si je travaille sur le projet sur deux ordinateurs différents, dois-je entrer la clé sur chaque machine séparément ?",
    "a_faq_window_settings_4": "Oui. EditorPrefs est un stockage local pour chaque ordinateur. Vous devrez entrer la clé API sur chaque machine à partir de laquelle vous prévoyez d'utiliser la fonctionnalité de traduction automatique.",
    "h3_faq_window_content": "Onglet \"Contenu\"",
    "q_faq_window_content_1": "Que se passe-t-il si j'ajoute une scène à Scènes à analyser qui n'est pas incluse dans les paramètres de construction ? Cela affectera-t-il autre chose que le processus d'analyse lui-même ?",
    "a_faq_window_content_1": "Non, cela ne le fera pas. La liste Scènes à analyser est utilisée exclusivement pour indiquer à l'outil quelles scènes ouvrir et analyser pour le texte. Elle n'est en aucun cas liée aux scènes qui se retrouveront dans la version finale de votre jeu.",
    "q_faq_window_content_2": "J'ai ajouté un objet à Ignorer les objets spécifiques (la liste temporaire). Si je fais un prefab de cet objet, l'instance de ce prefab sera-t-elle également ignorée ?",
    "a_faq_window_content_2": "Non, elle ne le sera pas. La liste temporaire stocke une référence directe à l'objet dans la scène. Lorsque vous créez un prefab, c'est un nouvel asset. Ses instances sont des objets différents, et la règle d'ignorance ne s'appliquera pas à eux. Pour ignorer en permanence les prefabs, ils doivent être ajoutés à la liste d'ignorance en tant qu'asset de prefab.",
    "q_faq_window_content_3": "Si j'ajoute le composant TMPro.TMP_Text à Exclusions de l'analyse -> Ignorer les types de composants, mais qu'il y a un objet dans la scène avec un LocalizedText qui référence déjà ce TMP_Text, que se passera-t-il lors de la prochaine mise à jour des clés ? La clé sera-t-elle supprimée ?",
    "a_faq_window_content_3": "Oui, elle le sera. Lorsque vous cliquez sur Mettre à jour les clés, l'analyseur ré-analyse l'ensemble du projet. Il verra que le type TMPro.TMP_Text doit être ignoré et ne générera pas de clé pour lui. Au cours du processus de comparaison des anciennes et des nouvelles clés, il déterminera que l'ancienne clé n'est plus utilisée et la marquera comme \"Supprimée\".",
    "q_faq_window_content_4": "La documentation dit que \"Épingler\" enregistre le chemin complet de l'objet et se cassera s'il est renommé. Que se passe-t-il si je fais un prefab de l'objet puis que je renomme l'objet original — \"Épingler\" continuera-t-il à fonctionner pour les instances du prefab ?",
    "a_faq_window_content_4": "Non, il ne le fera pas. \"Épingler\" enregistre le chemin absolu dans la hiérarchie de la scène au moment où le bouton est cliqué (par exemple, Canvas/Panel/Button). Ce chemin n'est pas lié à la logique des prefabs. Les instances de prefabs auront le même chemin, mais si vous renommez l'objet parent dans la scène, \"Épingler\" cessera de fonctionner à la fois pour l'original et pour les instances.",
    "q_faq_window_content_5": "Si j'utilise \"Épingler\" pour un objet enfant à l'intérieur d'une instance de prefab, quel chemin sera enregistré : relatif à la racine du prefab ou à la racine de la scène ? Fonctionnera-t-il dans d'autres scènes ?",
    "a_faq_window_content_5": "Le chemin complet depuis la racine de la scène sera enregistré. Par exemple, MyPrefab(Clone)/Content/Icon. Ce chemin \"épinglé\" ne fonctionnera que dans la scène où vous l'avez créé. Dans d'autres scènes, un tel chemin a peu de chances d'être trouvé.",
    "h3_faq_window_actions": "Onglet \"Actions\"",
    "h3_faq_window_assets": "Onglet \"Assets\"",
    "h3_faq_window_report": "Onglet \"Rapport\"",
    "h2_faq_editor": "9.4. Éditeur de traduction",
    "h2_faq_examples": "9.5. Exemples d'utilisation et code",
    "h2_faq_notes": "9.6. Nuances importantes et avertissements",
    "h2_faq_extending": "9.7. Extension des fonctionnalités",
    "q_faq_window_actions_1": "Que se passe-t-il si la connexion Internet est perdue lors d'une traduction automatique par lots ? L'outil réessaiera-t-il le lot qui a échoué selon la politique de nouvelle tentative, ou le processus sera-t-il complètement interrompu ?",
    "a_faq_window_actions_1": "L'outil tentera de renvoyer le lot exact qui a échoué, selon les paramètres de la politique de nouvelle tentative (nombre de tentatives et délai). Si toutes les tentatives pour ce lot échouent, le processus de traduction pour la langue actuelle sera interrompu, et une erreur sera consignée dans la console. La traduction pour les langues suivantes dans la file d'attente ne commencera pas.",
    "q_faq_window_actions_2": "Si j'importe un fichier CSV qui contient des clés qui existent déjà dans le projet mais avec des valeurs vides pour certaines langues, ces valeurs vides remplaceront-elles mes traductions existantes ou seront-elles ignorées ?",
    "a_faq_window_actions_2": "Les valeurs vides remplaceront les traductions existantes. Le processus d'importation considère le fichier CSV comme la \"source de vérité\". Si la valeur de la clé welcome_message dans la colonne fr est vide, la traduction française actuelle pour cette clé sera écrasée.",
    "q_faq_window_actions_3": "La section \"Zone de danger\" permet de supprimer tous les composants. Supprimera-t-elle les composants des prefabs qui se trouvent dans des dossiers non spécifiés dans les dossiers de prefabs de l'onglet Contenu ?",
    "a_faq_window_actions_3": "Oui, elle le fera. Les fonctions de la \"Zone de danger\" analysent tous les prefabs du projet (AssetDatabase.FindAssets(\"t:Prefab\")), pas seulement ceux spécifiés dans la liste d'analyse, pour assurer le nettoyage le plus complet possible.",
    "q_faq_window_actions_4": "Lors de l'importation depuis Google Sheets, comment dois-je formater la colonne des commentaires pour que la validation des espaces réservés à l'aide de la directive @placeholders: fonctionne ?",
    "a_faq_window_actions_4": "Dans votre document Google Sheets, la colonne doit être intitulée \"Developer Notes\". Dans les cellules de cette colonne, vous pouvez écrire des commentaires comme d'habitude. Pour spécifier des espaces réservés, ajoutez simplement une ligne comme @placeholders: {username}, {score} dans le texte du commentaire. L'outil reconnaîtra automatiquement cette directive lors de l'importation.",
    "q_faq_window_actions_5": "L'outil peut-il importer des données de plusieurs feuilles d'un seul document Google Sheets, ou ne fonctionne-t-il qu'avec une seule feuille par GID ?",
    "a_faq_window_actions_5": "L'outil ne fonctionne qu'avec une seule feuille à la fois. L'URL d'importation inclut un paramètre gid=..., qui identifie de manière unique une feuille spécifique dans le document. Pour importer des données d'une autre feuille, vous devez copier son URL (avec un gid différent) et effectuer à nouveau l'importation.",
    "q_faq_window_assets_1": "Que se passe-t-il si j'ai deux assets avec la même clé mais des types différents dans le même dossier d'analyse (par exemple, sound_effect_fr.mp3 et sound_effect_fr.wav) ? Lequel finira dans la table des assets ?",
    "a_faq_window_assets_1": "L'analyseur d'assets les charge en spécifiant le type attendu (AssetDatabase.LoadAssetAtPath(path, expectedType)). Pour la catégorie AudioClip, il ne recherchera et ne chargera que les fichiers que Unity reconnaît comme des AudioClips. Si les deux fichiers sont des clips audio valides, celui qui est traité en dernier sera inclus dans la table, écrasant de fait le précédent. Il est recommandé d'éviter de tels doublons.",
    "q_faq_window_assets_2": "Si je clique sur Analyser les assets et analyser le projet, et qu'il y a un objet Image dans la scène pour lequel un sprite localisé existe déjà, mais que l'objet Image lui-même n'a pas encore de composant LocalizedAsset, l'outil ajoutera-t-il le composant et insérera-t-il automatiquement la clé ?",
    "a_faq_window_assets_2": "Oui, c'est exactement comme ça que ça marche. \"Analyser le projet\" trouve le composant Image, regarde le nom du sprite qui lui est assigné (par exemple, icon_play_fr), en extrait la clé (icon_play) et la langue (fr), puis ajoute un composant LocalizedAsset à ce GameObject et y écrit la clé icon_play.",
    "q_faq_window_assets_3": "Puis-je utiliser la même règle de nommage pour différentes catégories d'assets si elles ont des dossiers d'analyse différents ? Cela causera-t-il des conflits ?",
    "a_faq_window_assets_3": "Oui, vous le pouvez. Il n'y aura pas de conflits, car une table d'assets distincte (LocalizedAssetTable) est créée pour chaque catégorie. Les clés de la catégorie \"Sprites\" ne se chevauchent pas avec les clés de la catégorie \"AudioClips\", même si elles sont nommées de la même manière.",
    "q_faq_window_assets_4": "Si un asset localisable (par exemple, button_ok_fr.png) n'est pas à la racine du dossier d'analyse, mais dans un sous-dossier, l'analyseur le trouvera-t-il ?",
    "a_faq_window_assets_4": "Oui, il le fera. L'analyseur utilise l'option SearchOption.AllDirectories, ce qui signifie qu'il vérifiera récursivement tous les sous-dossiers dans le dossier d'analyse que vous spécifiez.",
    "q_faq_window_report_1": "Le bouton \"Trouver\" recherche l'objet de manière asynchrone. Que se passe-t-il si je lance une recherche et que je clique immédiatement sur Mettre à jour les clés ? La recherche sera-t-elle interrompue ?",
    "a_faq_window_report_1": "Oui, elle sera interrompue. Toute nouvelle action qui nécessite le blocage de l'interface utilisateur (comme Mettre à jour les clés) arrêtera la coroutine de recherche en cours. Une boîte de dialogue apparaîtra, vous invitant à arrêter la recherche en cours pour en lancer une nouvelle.",
    "q_faq_window_report_2": "Si une clé est utilisée à plusieurs endroits (par exemple, sur deux boutons différents dans des scènes différentes), comment cela sera-t-il affiché dans le rapport sous la catégorie \"Doublons\" ?",
    "a_faq_window_report_2": "La catégorie \"Doublons\" affichera toutes les sources pour cette clé. Vous verrez une entrée pour la clé, et le champ \"Source\" listera tous les chemins (dans la scène 1 et la scène 2). Le bouton \"Trouver\" dans ce cas ouvrira une liste déroulante, vous permettant de choisir vers quel objet naviguer.",
    "q_faq_window_report_3": "Si je clique sur \"Trouver\" pour une clé qui n'est utilisée que dans le code (via la fonction _()), que se passera-t-il ? L'outil sera-t-il capable de trouver et de mettre en évidence le script C# ?",
    "a_faq_window_report_3": "Oui. Le système de recherche est spécifiquement entraîné pour reconnaître des sources comme le script MyScript.cs. Lorsque vous cliquez sur \"Trouver\", il recherchera l'asset MyScript.cs dans le projet et le mettra en évidence (ping) dans la fenêtre Projet.",
    "q_faq_editor_1": "Qu'est-ce qui a la plus haute priorité pour la validation des espaces réservés : la directive @placeholders: dans le commentaire ou les espaces réservés trouvés dans le texte de la langue source ? Par exemple, si le texte source a {name} et que le commentaire dit @placeholders: {username}.",
    "a_faq_editor_1": "La directive @placeholders: dans le commentaire a la priorité. Elle est considérée comme une instruction explicite du développeur et la \"source de vérité\". Dans votre exemple, l'éditeur exigera {username} dans la traduction et ignorera {name} du texte source.",
    "q_faq_editor_2": "Si je fais une faute de frappe dans la directive (par exemple, @placeholder: au lieu de @placeholders:), sera-t-elle ignorée ou l'outil émettra-t-il un avertissement ?",
    "a_faq_editor_2": "Elle sera simplement ignorée. L'outil recherche une correspondance exacte de @placeholders:. Si la directive est mal orthographiée, elle sera traitée comme une partie d'un commentaire ordinaire, et la validation fonctionnera à l'ancienne - en se basant sur les espaces réservés du texte source.",
    "q_faq_editor_3": "Le système de sauvegarde automatique crée des fichiers dans le dossier Backups/AutoSaves. Ces fichiers seront-ils automatiquement supprimés après une sauvegarde manuelle réussie ou la fermeture de la fenêtre ?",
    "a_faq_editor_3": "Oui. Lors d'une sauvegarde manuelle réussie ou d'une fermeture normale de la fenêtre (lorsque vous enregistrez les modifications), tous les fichiers de sauvegarde automatique sont supprimés pour éviter de demander une récupération au prochain lancement. Ils ne restent qu'en cas de plantage de l'éditeur.",
    "q_faq_editor_4": "Si je modifie la largeur des colonnes dans l'éditeur, ces paramètres seront-ils enregistrés entre les sessions Unity ?",
    "a_faq_editor_4": "Oui. La largeur des colonnes est enregistrée dans EditorPrefs chaque fois que vous fermez la fenêtre de l'éditeur de traduction et sera restaurée la prochaine fois que vous l'ouvrirez.",
    "q_faq_editor_5": "La fenêtre contextuelle d'édition de texte (MultiLineEditWindow) prend-elle en charge sa propre pile Annuler/Rétablir (via Ctrl+Z) pour les modifications apportées à l'intérieur ?",
    "a_faq_editor_5": "Oui. La MultiLineEditWindow a sa propre pile Annuler/Rétablir temporaire qui fonctionne tant que la fenêtre est ouverte. Cela vous permet d'annuler et de rétablir les modifications de texte dans cette fenêtre. Une fois que vous enregistrez le résultat (en fermant la fenêtre), cette modification est enregistrée comme une seule action dans la pile Annuler/Rétablir globale de l'éditeur principal.",
    "q_faq_examples_1": "Que se passe-t-il si les noms de propriété dans le type anonyme passé à la fonction _() ne correspondent pas aux espaces réservés dans la chaîne ? Par exemple, _(\"Bonjour, {username}\", new { user_name = \"Bob\" }). Y aura-t-il une erreur, ou l'espace réservé ne sera-t-il tout simplement pas remplacé ?",
    "a_faq_examples_1": "Il n'y aura pas d'erreur. L'espace réservé {username} ne sera tout simplement pas remplacé, et vous obtiendrez la chaîne \"Bonjour, {username}\" comme résultat. Le remplacement ne se produit qu'avec une correspondance de nom exacte.",
    "q_faq_examples_2": "L'attribut [LocalizableField] fonctionne pour les champs privés. Fonctionnera-t-il pour les champs statiques ?",
    "a_faq_examples_2": "Oui, il le fera. L'analyseur utilise la réflexion pour trouver les champs avec les indicateurs BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, donc il trouvera et traitera les champs statiques.",
    "q_faq_examples_3": "Si je mets l'attribut [OnLanguageChange] sur une méthode avec des paramètres (par exemple, void UpdateUI(string newLang)), que se passera-t-il ? Y aura-t-il une erreur de compilation ou un avertissement à l'exécution ?",
    "a_faq_examples_3": "Il n'y aura pas d'erreur de compilation, mais un avertissement de LocalizedBehaviour apparaîtra dans la console Unity à l'exécution. Il signalera qu'il a trouvé une méthode avec l'attribut mais l'a ignorée car la méthode a des paramètres. Une telle méthode ne sera pas appelée.",
    "q_faq_examples_4": "J'utilise _(\"apple_count\", count). S'il n'y a pas de clé apple_count_one pour la langue actuelle (pour count = 1), quelle forme le système choisira-t-il ? Utilisera-t-il apple_count_other comme solution de secours ?",
    "a_faq_examples_4": "Oui. Si une forme spécifique (_one, _few, etc.) n'est pas trouvée, le système essaiera d'utiliser la clé avec le suffixe _other comme solution de secours. Si celle-ci n'est pas non plus trouvée, la traduction pour la clé de base apple_count sera utilisée.",
    "q_faq_examples_5": "La fonction _(\"key\", new { username = \"Alex\" }) utilise un type anonyme. Cela ne créera-t-il pas une \"charge\" excessive sur le ramasse-miettes (GC) avec des appels fréquents dans une méthode Update() par rapport à la transmission d'un Dictionary<string, object> pré-créé ?",
    "a_faq_examples_5": "Oui, c'est le cas. Chaque appel à new { ... } alloue de la mémoire sur le tas géré, ce qui crée un travail supplémentaire pour le ramasse-miettes. Pour le texte qui est mis à jour à chaque image (dans Update ou LateUpdate), il est nettement plus performant de créer un Dictionary<string, object> une fois dans Start(), et de ne mettre à jour ses valeurs que dans Update() avant de le passer à la fonction _().",
    "q_faq_notes_1": "La documentation recommande d'ajouter LanguageSelector à la liste d'ignorance. Qu'est-ce qui se cassera exactement si j'oublie de le faire ? Des clés supplémentaires seront-elles créées pour \"Option A, Option B\" ?",
    "a_faq_notes_1": "Oui. Si vous n'ajoutez pas LanguageSelector à la liste d'ignorance, l'analyseur traitera son TMP_Dropdown comme un menu déroulant ordinaire. Il trouvera les \"Option A, Option B, Option C\" par défaut que Unity crée et ajoutera des clés pour elles à vos fichiers de traduction. Cela encombrera vos fichiers de clés inutiles, car LanguageSelector supprimera ces options à l'exécution et créera les siennes de toute façon.",
    "q_faq_notes_2": "Si j'oublie d'ajouter un LocalizedText vide avec la case isStyleOnly cochée sur le Label à l'intérieur du TMP_Dropdown utilisé par LanguageSelector, la police ne changera-t-elle pas ? Pourquoi est-ce nécessaire ?",
    "a_faq_notes_2": "Oui, la police ne changera pas. C'est nécessaire car LanguageSelector modifie directement la propriété label.text. Sans un LocalizedText sur cet objet, le système de localisation ne sait pas que cet élément a besoin que des styles (police, RTL) soient appliqués lorsque la langue change. Un LocalizedText vide avec isStyleOnly sert de \"marqueur\" pour le système, disant : \"Surveillez cet objet et appliquez-lui des styles, mais ne touchez pas à son texte\".",
    "q_faq_notes_3": "L'appel de _() dans la méthode Update() n'est pas recommandé. Mais que faire si je dois mettre à jour le texte à chaque image (par exemple, un chronomètre) ? Quelle est la manière la plus performante de le faire, en ne mettant en cache que la chaîne de formatage ?",
    "a_faq_notes_3": "L'approche la plus performante consiste à mettre en cache la chaîne de formatage dans Start() ou dans une méthode [OnLanguageChange], et à utiliser string.Format ordinaire dans Update(). Exemple : private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Cela évite de rechercher la clé dans le dictionnaire à chaque image, ce qui est nettement plus rapide.",
    "q_faq_extending_1": "Mon analyseur personnalisé sera-t-il appelé automatiquement après chaque mise à jour des clés ? Dois-je l'enregistrer quelque part, ou suffit-il d'avoir une classe qui implémente ITextComponentParser dans le projet ?",
    "a_faq_extending_1": "Le simple fait d'avoir la classe suffit. Lorsque TextParser s'exécute, il utilise la réflexion pour trouver toutes les classes du projet qui implémentent l'interface ITextComponentParser et appelle automatiquement leur méthode Parse() pour chaque GameObject. Aucun enregistrement manuel n'est requis.",
    "q_faq_extending_2": "Que se passe-t-il si une exception se produit dans mon analyseur personnalisé ? Interrompra-t-elle tout le processus d'analyse, ou l'outil continuera-t-il en toute sécurité avec d'autres analyseurs ?",
    "a_faq_extending_2": "Une exception dans votre analyseur personnalisé interrompra le processus. La boucle d'analyse principale n'encapsule pas les appels aux analyseurs personnalisés dans un bloc try-catch. Si votre méthode Parse() lève une exception non gérée,",
    "toggle_notes_title": "Basculer les notes",
    "mindmap_toggle_title": "Afficher la carte mentale",
    "on_this_page_title": "Sur cette page",
    "my_notes_title": "Mes notes",
    "no_notes_message_new": "Passez la souris sur le texte pour ajouter une note.",
    "notes_add_title": "Ajouter une note à ce bloc",
    "notes_placeholder": "Votre note...",
    "notes_close_title": "Fermer",
    "notes_goto_title": "Aller au texte",
    "notes_edit_title": "Modifier la note",
    "notes_delete_title": "Supprimer la note",
    "notes_edit_text": "Modifier",
    "copy_code_copy": "Copier",
    "copy_code_copied": "Copié !",
    "copy_code_error": "Erreur",
    "error_loading_title": "Erreur de chargement",
    "error_loading_message": "Veuillez vérifier votre connexion et actualiser.",
    "lightbox_aria_close": "Fermer la visionneuse d'images",
    "lightbox_image_alt": "Vue agrandie",
    "mindmap_preset_full": "Vue complète",
    "mindmap_preset_quick_start": "Démarrage rapide",
    "mindmap_preset_dev": "Flux de travail du développeur",
    "mindmap_preset_translator": "Flux de travail du traducteur",
    "mindmap_edge_configure": "1. Configurer",
    "mindmap_edge_specify_content": "2. Spécifier le contenu",
    "mindmap_edge_parse_project": "3. Analyser le projet",
    "mindmap_edge_creates_components": "Crée des composants",
    "mindmap_edge_generates": "Génère",
    "mindmap_edge_opens": "Ouvre",
    "mindmap_edge_manages_assets": "Gère les assets pour",
    "mindmap_edge_defines_rules": "Définit les règles pour",
    "mindmap_edge_reports_on": "Rapporte sur",
    "mindmap_edge_enables_reaction": "Permet la réaction via",
    "mindmap_edge_processed_by": "Traité par",
    "mindmap_edge_edited_in": "Modifié dans",
    "mindmap_edge_extends": "Étend",
    "mindmap_edge_warns_about": "Avertit sur",
    "mindmap_edge_relates_to": "Se rapporte à",
    "mindmap_edge_recommends_for": "Recommande pour",
    "mindmap_edge_see_faq": "Voir la FAQ"
}