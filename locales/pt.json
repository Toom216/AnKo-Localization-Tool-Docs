{
  "a_faq_addressables_1": "Certifique-se de que o pacote Addressables esteja instalado, as configurações criadas e você clicou em \"Scan Assets & Generate Tables\" para registrar as chaves nos grupos.",
  "a_faq_addressables_2": "Crie um <code>Translation Profile</code> na pasta de ativos, selecione o tipo de serviço, insira a chave de API e atribua este perfil na janela <code>Settings</code>.",
  "a_faq_addressables_3": "Na janela de Migração (abas Componentes / Importar), há um botão \"Ativar Stubs\" que ativa o recurso Emergency Stubs. Isso cria classes de espaço reservado falsas para I2 Localization ou Unity Localization para que seu projeto possa compilar imediatamente após remover esses plugins. O recurso funciona alternando o símbolo de definição ANKO_ENABLE_MIGRATION_STUBS. Isso evita erros como \"O nome do tipo 'Localize' não pôde ser encontrado\" e lhe dá tempo para refatorar adequadamente seu código para usar o novo sistema. Ativar Stubs permite corrigir erros de compilação após excluir o antigo plugin de localização. Na v2.0, o sistema de migração foi expandido com <strong>Perfis de Migração</strong>, permitindo regras de transição mais robustas de outros plugins.",
  "a_faq_audio_smart_update": "A ferramenta usa agrupamento inteligente (smart batching) com hashing MD5 para regenerar arquivos de áudio apenas quando o texto fonte tiver mudado. Ela calcula um hash MD5 do seu conteúdo de texto e o compara com arquivos de áudio gerados anteriormente. Se o texto não mudou, ela ignora a regeneração, economizando seus créditos de API. Isso evita chamadas desnecessárias de API e reduz custos ao regenerar áudio. A ferramenta faz o hash do seu texto e só regenera arquivos de áudio se o texto fonte tiver mudado, economizando seus créditos de API.",
  "a_faq_components_1": "Não, não será. Desabilitar um MonoBehaviour impede que todos os métodos \"mágicos\" do Unity sejam chamados, incluindo Awake(), OnEnable() e Start(). Isso é intencional para evitar a execução de lógica duplicada. Toda a inicialização deve ocorrer em scripts nas versões localizadas do prefab.",
  "a_faq_components_2": "Sim, o comportamento de física do objeto original será neutralizado. O componente LocalizedPrefab encontra todos os componentes Rigidbody e Rigidbody2D em seu GameObject e define sua propriedade isKinematic como true. Isso os remove efetivamente dos cálculos de física dinâmica, evitando comportamentos indesejados, como um objeto invisível caindo ou reagindo a colisões. Ainda é recomendado que a versão localizada do prefab contenha todos os componentes de física necessários para o comportamento correto.",
  "a_faq_components_3": "Sim, acontecerá. O componente armazena o nome completo do tipo, incluindo o namespace e o assembly. Renomear o script ou movê‑lo para outro .asmdef alterará esse nome, e o LocalizedAsset não conseguirá encontrar o componente de destino. Será necessário executar outra análise via Analyze Project & Attach Components para que o nome seja atualizado.",
  "a_faq_components_4": "Um LocalizedAsset é criado para uma instância de componente específica. Ele mantém uma referência a esse componente em código. Se você adicionar manualmente um segundo LocalizedAsset e usar o menu de contexto \"Analyze for Localization\" para direcionar o segundo Image, você terá dois componentes LocalizedAsset, cada um gerenciando seu próprio Image. O analisador automático só criará um componente para o primeiro Image com um ativo localizável que ele encontrar.",
  "a_faq_components_5": "Sim, terá. LocalizedPrefab cria a instância do prefab localizado em seu método OnEnable(). A ordem de execução do Unity garante que todos os métodos Awake() sejam executados antes de todos os métodos OnEnable(). Assim, seu script com ordem -110 executará seu Awake(), então LocalizedPrefab com ordem -100 executará seu Awake(), e só depois disso seus métodos OnEnable() serão chamados em ordem. Seu script não encontrará o objeto porque ele ainda não terá sido criado.",
  "a_faq_components_6": "Tanto a chave quanto o texto mudarão. Chamar SetFormattedText programaticamente substitui o comportamento isStyleOnly para aquela atualização específica. A opção isStyleOnly é destinada a impedir que o componente reaja a mudanças globais de idioma, mas ele sempre reagirá a uma mudança direta de chave através de código.",
  "a_faq_components_7": "Ele encontrará métodos com qualquer modificador de acesso (public, private, protected, internal). A Reflexão no Unity permite a descoberta de todos os métodos de instância, independentemente do seu nível de acesso.",
  "a_faq_components_8": "O uso do ativo antigo (não localizado) é possível. LocalizedAsset executa a troca em seu OnEnable(). Os métodos Awake() de todos os scripts são executados antes de OnEnable(). Se seu script acessar audioSource.clip em Awake(), ele obterá o clipe original. Se ele o acessar em Start(), o resultado dependerá da ordem de execução do script. Para garantir o acesso ao ativo localizado, defina uma ordem de execução posterior para seu script ou acesse o ativo em um método marcado com [OnLanguageChange].",
  "a_faq_custom_keys_attribute": "Sim. Na <strong>Content Tab</strong> em 'Attributes to Scan', você pode adicionar qualquer nome de atributo (por exemplo, <code>[Header]</code>, <code>[TermsPopup]</code>). O parser tratará qualquer campo de string com esse atributo como localizável.",
  "a_faq_custom_provider_1": "Garanta que sua classe implemente <code>IAssetProvider</code>, NÃO seja abstrata e esteja marcada com o atributo <code>[AssetProviderPlugin]</code>. Além disso, verifique o console para quaisquer erros relacionados à reflexão durante a inicialização, pois a ferramenta escaneia todos os assemblies em busca de provedores.",
  "a_faq_editor_1": "A diretiva @placeholders: no comentário tem prioridade. Ela é considerada uma instrução explícita do desenvolvedor e a \"fonte da verdade\". No seu exemplo, o editor exigirá {username} na tradução e ignorará {name} do texto fonte.",
  "a_faq_editor_2": "Ela será simplesmente ignorada. A ferramenta procura por uma correspondência exata de @placeholders:. Se a diretiva estiver incorreta, ela será tratada como parte de um comentário regular, e a validação funcionará da maneira antiga - com base nos placeholders do texto fonte.",
  "a_faq_editor_3": "Sim. Após um salvamento manual bem-sucedido ou fechamento normal da janela (quando você salva as alterações), todos os arquivos de salvamento automático são excluídos para evitar o prompt de recuperação na próxima inicialização. Eles só permanecem em caso de crash do editor.",
  "a_faq_editor_4": "Sim. As larguras das colunas são salvas no EditorPrefs toda vez que você fecha a janela do editor de tradução e serão restauradas na próxima vez que você a abrir.",
  "a_faq_editor_5": "Sim. A MultiLineEditWindow tem sua própria pilha temporária de Desfazer/Refazer que funciona enquanto a janela está aberta. Isso permite que você desfaça e refaça alterações de texto dentro dessa janela. Assim que você salva o resultado (fechando a janela), essa alteração é registrada como uma única ação na pilha global de Desfazer/Refazer do editor principal.",
  "a_faq_examples_1": "Não haverá erro. O placeholder {username} simplesmente não será substituído, e você obterá a string \"Hello, {username}\" como resultado. A substituição só ocorre com uma correspondência exata de nome.",
  "a_faq_examples_2": "Sim, funcionará. O parser usa reflexão para encontrar campos com as flags BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, então ele encontrará e processará campos estáticos.",
  "a_faq_examples_3": "Não haverá erro de compilação, mas um aviso do LocalizedBehaviour aparecerá no console do Unity em tempo de execução. Ele relatará que encontrou um método com o atributo, mas o ignorou porque o método tem parâmetros. Tal método não será chamado.",
  "a_faq_examples_4": "Sim. Se uma forma específica (_one, _few, etc.) não for encontrada, o sistema tentará usar a chave com o sufixo _other como fallback. Se isso também não for encontrado, a tradução para a chave base apple_count será usada.",
  "a_faq_examples_5": "Sim, criará. Cada chamada para new { ... } aloca memória no heap gerenciado, o que cria trabalho extra para o coletor de lixo. Para texto que é atualizado a cada frame (em Update ou LateUpdate), é significativamente mais performático criar um Dictionary<string, object> uma vez em Start(), e apenas atualizar seus valores em Update() antes de passá-lo para a função _().",
  "a_faq_examples_6": "Verifique se seu método tem parâmetros. O atributo <code>[OnLanguageChange]</code> só funciona em métodos <strong>sem parâmetros</strong> (por exemplo, <code>void UpdateUI()</code>). Se seu método requer argumentos, envolva-o em um método sem parâmetros.",
  "a_faq_extending_1": "Basta ter a classe. Quando o TextParser é executado, ele usa reflexão para encontrar todas as classes no projeto que implementam a interface ITextComponentParser e chama automaticamente o método Parse() delas para cada GameObject. Nenhum registro manual é necessário.",
  "a_faq_extending_2": "Uma exceção no seu parser personalizado interromperá o processo. O loop principal de análise não envolve chamadas para parsers personalizados em um bloco try-catch. Se o seu método Parse() lançar uma exceção não tratada,",
  "a_faq_installation_1": "O instalador verifica a existência do tipo Newtonsoft.Json.JsonConvert. Se o tipo existir, ele considera a dependência satisfeita e não tentará instalar ou atualizar o pacote. Isso é feito para evitar conflitos de versão.",
  "a_faq_installation_2": "Você pode acionar manualmente uma verificação de dependência a qualquer momento através do menu Tools -> Localization -> Check Dependencies. Isso redefinirá a flag \"Don't ask again\" e mostrará a janela com todos os pacotes opcionais ausentes novamente.",
  "a_faq_installation_3": "Isso pode acontecer se você não tiver uma pasta Assets/Resources. A ferramenta tentará criá-la, mas as permissões do sistema de arquivos podem impedir. Sim, você pode criar o ativo manualmente: clique com o botão direito na pasta Resources, selecione Create -> Localization -> Settings. A ferramenta o encontrará automaticamente.",
  "a_faq_installation_4": "Sim. A ferramenta usa Resources.Load(), que procura por um ativo pelo nome em todas as pastas chamadas Resources em seu projeto. O importante é que o arquivo mantenha seu nome LocalizationSettings.asset.",
  "a_faq_installation_5": "Sim. Você pode abrir Window -> Package Manager, clicar no ícone \"+\" e selecionar \"Add package by name...\". Digite os nomes dos pacotes: com.unity.nuget.newtonsoft-json e com.unity.editorcoroutines.",
  "a_faq_notes_1": "Sim. Se você não adicionar LanguageSelector à lista de ignorados, o parser tratará seu TMP_Dropdown como um dropdown regular. Ele encontrará o padrão \"Option A, Option B, Option C\" que o Unity cria e adicionará chaves para eles em seus arquivos de tradução. Isso poluíra seus arquivos com chaves desnecessárias, pois o LanguageSelector removerá essas opções em tempo de execução e criará as suas de qualquer maneira.",
  "a_faq_notes_2": "Sim, a fonte não mudará. Isso é necessário porque o LanguageSelector altera diretamente a propriedade label.text. Sem um LocalizedText neste objeto, o sistema de localização não sabe que este elemento precisa de estilos (fonte, RTL) aplicados quando o idioma muda. Um LocalizedText vazio com isStyleOnly serve como um \"marcador\" para o sistema, dizendo: \"Observe este objeto e aplique estilos a ele, mas não toque em seu texto\".",
  "a_faq_notes_3": "A abordagem mais performática é armazenar a string de formato em cache em Start() ou em um método [OnLanguageChange], e usar string.Format regular em Update(). Exemplo: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Isso evita procurar a chave no dicionário a cada frame, o que é significativamente mais rápido.",
  "a_faq_runtime_api_key_distinction": "<strong>P: Qual é a diferença entre 'Chaves de Serviço de Tradução' e 'Chave de API de Tempo de Execução'?</strong><br>R: As <strong>Chaves de Serviço de Tradução</strong> (OpenAI, DeepL) são usadas no <strong>Unity Editor</strong> para gerar traduções. Elas são armazenadas no registro do seu computador (EditorPrefs) e NÃO são incluídas na build.<br>A <strong>Chave de API de Tempo de Execução</strong> é usada pela <strong>Build do Jogo</strong> para buscar Atualizações ao Vivo. Ela É incluída na build (criptografada).",
  "a_faq_tts_voices": "No seu <strong>Translation Profile</strong> (Inspector), use a lista 'Voice Mappings'. Você pode mapear um padrão Regex (por exemplo, <code>^hero_.*</code>) para um ID de Voz específico. O gerador escolherá automaticamente a voz correta com base no nome da chave.",
  "a_faq_window_actions_1": "A ferramenta tentará reenviar o lote exato que falhou, de acordo com as configurações da Retry Policy (número de tentativas e atraso). Se todas as tentativas para este lote falharem, o processo de tradução para o idioma atual será interrompido, e um erro será registrado no console. A tradução para os próximos idiomas na fila não será iniciada.",
  "a_faq_window_actions_2": "Valores vazios substituirão as traduções existentes. O processo de importação considera o arquivo CSV como a \"fonte da verdade\". Se o valor para a chave welcome_message na coluna ru estiver vazio, a tradução russa atual para esta chave será sobrescrita.",
  "a_faq_window_actions_3": "Sim, removerá. As funções na \"Danger Zone\" varrem todos os prefabs no projeto (AssetDatabase.FindAssets(\"t:Prefab\")), não apenas aqueles especificados na lista de análise, para garantir a limpeza mais completa possível.",
  "a_faq_window_actions_4": "No seu documento Google Sheets, a coluna deve ser intitulada \"Developer Notes\". Nas células desta coluna, você pode escrever comentários como de costume. Para especificar placeholders, basta adicionar uma linha como @placeholders: {username}, {score} no texto do comentário. A ferramenta reconhecerá automaticamente esta diretiva na importação.",
  "a_faq_window_actions_5": "A ferramenta só funciona com uma planilha por vez. O URL de importação inclui um parâmetro gid=..., que identifica exclusivamente uma planilha específica no documento. Para importar dados de outra planilha, você precisa copiar seu URL (com um gid diferente) e realizar a importação novamente.",
  "a_faq_window_assets_1": "O scanner de ativos os carrega especificando o tipo esperado (AssetDatabase.LoadAssetAtPath(path, expectedType)). Para a categoria AudioClip, ele só buscará e carregará arquivos que o Unity reconhece como AudioClips. Se ambos os arquivos forem clipes de áudio válidos, o que for processado por último será incluído na tabela, sobrescrevendo efetivamente o anterior. É recomendado evitar tais duplicatas.",
  "a_faq_window_assets_2": "Sim, é exatamente assim que funciona. \"Analyze Project\" encontra o componente Image, olha o nome do sprite atribuído a ele (por exemplo, icon_play_en), extrai a chave (icon_play) e o idioma (en) dele, e então adiciona um componente LocalizedAsset a esse GameObject e escreve a chave icon_play nele.",
  "a_faq_window_assets_3": "Sim, você pode. Não haverá conflitos, pois uma tabela de ativos separada (LocalizedAssetTable) é criada para cada categoria. As chaves da categoria \"Sprites\" não se sobrepõem às chaves da categoria \"AudioClips\", mesmo que tenham o mesmo nome.",
  "a_faq_window_assets_4": "Sim, encontrará. O scanner usa a opção SearchOption.AllDirectories, o que significa que ele verificará recursivamente todas as subpastas dentro da Scan Folder que você especificar.",
  "a_faq_window_content_1": "Não, não afetará. A lista Scenes to Parse é usada exclusivamente para informar à ferramenta quais cenas abrir e analisar em busca de texto. Ela não está de forma alguma relacionada às cenas que farão parte da build final do seu jogo.",
  "a_faq_window_content_2": "Não, não será. A lista temporária armazena uma referência direta ao objeto na cena. Ao criar um prefab, ele é um novo ativo. Suas instâncias são objetos diferentes, e a regra de ignorar não se aplicará a elas. Para ignorar prefabs permanentemente, eles devem ser adicionados à lista de ignorados como um ativo prefab.",
  "a_faq_window_content_3": "Sim, será. Ao clicar em Update Keys, o parser re-varre o projeto inteiro. Ele verá que o tipo TMPro.TMP_Text deve ser ignorado e não gerará uma chave para ele. Durante o processo de comparação de chaves antigas e novas, ele determinará que a chave antiga não está mais sendo usada e a marcará como \"Removed\" (Removida).",
  "a_faq_window_content_4": "Não, não continuará. \"Pin\" salva o caminho absoluto na hierarquia da cena no momento em que o botão é clicado (por exemplo, Canvas/Panel/Button). Este caminho não está relacionado à lógica do prefab. As instâncias do prefab terão o mesmo caminho, mas se você renomear o objeto pai na cena, o \"Pin\" deixará de funcionar tanto para o original quanto para as instâncias.",
  "a_faq_window_content_5": "O caminho completo a partir da raiz da cena será salvo. Por exemplo, MyPrefab(Clone)/Content/Icon. Este caminho \"fixado\" só funcionará na cena onde você o criou. Em outras cenas, é improvável que tal caminho seja encontrado.",
  "a_faq_window_preview_1": "Não, não será salvo. PreviewSafetyBridge intercepta o evento de salvamento de assets (OnWillSaveAssets) e automaticamente chama RevertEditorPreview() antes que a Unity grave as alterações no disco. Assim, o prefab será salvo em seu estado original, não localizado.",
  "a_faq_window_preview_2": "PreviewRecoveryService lida com a recuperação de falhas. Se a Unity travar, o serviço detecta o arquivo de backup no próximo lançamento e tenta restaurar o estado da cena. Se a recuperação automática falhar, você pode precisar selecionar manualmente \"Reverter para Original\" na janela da ferramenta.",
  "a_faq_window_preview_3": "Sim, serão. PrefabUtility.InstantiatePrefab no Edit Mode chama Awake() e OnEnable(). Se esses métodos contiverem lógica que não deve ser executada no editor (por exemplo, acessar singletons que só existem no Play Mode), isso pode causar erros. É recomendado usar if (Application.isPlaying) ou #if UNITY_EDITOR para proteger tal código.",
  "a_faq_window_report_1": "Sim, será interrompida. Qualquer nova ação que exija bloqueio de UI (como Update Keys) interromperá a corrotina de busca atual. Uma caixa de diálogo aparecerá, solicitando que você pare a busca atual para iniciar uma nova.",
  "a_faq_window_report_2": "A categoria \"Duplicates\" mostrará todas as fontes para essa chave. Você verá uma entrada para a chave, e o campo \"Source\" listará todos os caminhos (na cena 1 e na cena 2). O botão \"Find\" neste caso abrirá uma lista suspensa, permitindo que você escolha para qual objeto navegar.",
  "a_faq_window_report_3": "Sim. O sistema de busca é especificamente treinado para reconhecer fontes como script MyScript.cs. Ao clicar em \"Find\", ele buscará o ativo MyScript.cs no projeto e o destacará (ping) na janela Project.",
  "a_faq_window_settings_1": "Sim, serão. Ao mudar o modo, a ferramenta executa uma \"migração segura\": ela re-analisa todo o projeto, cria novas chaves de acordo com as novas regras, mas mapeia as chaves antigas e novas através do texto original. Em seguida, transfere todas as suas traduções e comentários existentes das chaves antigas para as novas. Suas traduções não serão perdidas.",
  "a_faq_window_settings_2": "Será usada a DefaultPluralRule, que é adequada para inglês e a maioria dos idiomas europeus (formas para \"one\" e \"other\").",
  "a_faq_window_settings_3": "Não, não serão. Apenas ativos localizados em uma pasta StreamingAssets ou Resources têm a garantia de serem incluídos na build. Se você especificar um caminho diferente, a localização funcionará no editor, mas não funcionará no jogo compilado, pois os arquivos de tradução não farão parte da build.",
  "a_faq_window_settings_4": "Sim. EditorPrefs é um armazenamento local para cada computador. Você precisará inserir a <strong>Chave de API do Serviço de Tradução</strong> (para uso no Editor como OpenAI/DeepL) em cada máquina. No entanto, a <strong>Chave de API de Tempo de Execução</strong> (usada em builds) é armazenada nas configurações do projeto e compartilhada via controle de versão (criptografada).",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Usando a classe gerada (Fortemente Tipada)\nstring text = AnkoLoc.MyKey;\n\n// Em vez de usar strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Usando atributos personalizados para varredura automática\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Encontrado automaticamente\n\n    [Header(\"Title\")] \n    // Se você adicionar \"Header\" aos Atributos para Escanear, este também será encontrado!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Classes Desanexadas e Bases (Não é necessário MonoBehaviour)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Campos herdados são escaneados!\n{\n    // 2. Campos Básicos (Público, Privado, Protegido)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Propriedades (Automáticas e Completas)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Estáticos e Constantes (Texto global)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolve estas referências durante a varredura:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. Concatenação e Interpolação de Strings (Calculado no tempo de análise)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Chaves e Atributos Personalizados\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Escaneado se 'Header' for adicionado aos Atributos para Escanear\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Coleções (Arrays, Listas, 'new' com tipo alvo)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Objetos Aninhados (Recursão Profunda)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // Lista de objetos!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Suportando funções personalizadas ou de terceiros\n// Antes: O scanner só vê chamadas _(\"key\")\nstring text = MyLegacySystem.Translate(\"old_key\");\nstring i2Text = LocalizationManager.GetTranslation(\"I2_KEY\");\n\n// Depois: Adicione uma Regra de Análise de Script com padrão regex\n// Estas chaves agora serão indexadas e gerenciadas automaticamente pela ferramenta!",
  "copy_code_copied": "Copiado!",
  "copy_code_copy": "Copiar",
  "copy_code_error": "Erro",
  "error_loading_message": "Verifique sua conexão e atualize.",
  "error_loading_title": "Erro de Carregamento",
  "h1_ai_audio": "Áudio AI / Text-to-Speech",
  "h1_ai_profiles": "Perfis de IA e Tradução",
  "h1_api_snippets": "API e Trechos de Código",
  "h1_components": "Componentes Principais (atribuídos automaticamente)",
  "h1_extending": "Estendendo a Funcionalidade",
  "h1_faq": "FAQ e Solução de Problemas",
  "h1_font_glyph_manager": "Gerenciador de Fontes e Glifos",
  "h1_important_notes": "Notas e Avisos Importantes",
  "h1_introduction": "Introdução",
  "h1_loc_tool_window": "Janela \"Localization Tool\"",
  "h1_migration_tool": "Ferramenta de Migração",
  "h1_quick_start": "Início Rápido e Configuração",
  "h1_tms": "Integração externa de TMS (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "Editor da Tabela de Tradução",
  "h1_usage_examples": "Exemplos de Uso",
  "h2_ai_assistant": "Comandos do Assistente de IA",
  "h2_ai_audio_setup": "Configuração",
  "h2_ai_audio_usage": "Uso",
  "h2_ai_context": "Contexto & Glossário",
  "h2_ai_profiles_overview": "Perfis de Tradução",
  "h2_async_api": "API Assíncrona (Addressables)",
  "h2_backup_manager": "Gerenciador de Backup",
  "h2_bridge_generation": "Gerar Pontes C# (Acesso Fortemente Tipado)",
  "h2_custom_ai": "IA Personalizada & Modelos",
  "h2_custom_asset_provider": "Criando um Provedor de Ativos Personalizado",
  "h2_custom_attributes": "Varredura de Atributos Personalizados",
  "h2_custom_parser": "Criando um Parser Personalizado",
  "h2_example_attribute": "Atributo [LocalizableField]",
  "h2_example_components": "Componentes Prontos e Exemplos",
  "h2_example_components_updated": "LanguageSelector.cs Atualizado",
  "h2_example_function": "Função _() e Atributo [OnLanguageChange]",
  "h2_example_plurals": "Plurais e Gênero",
  "h2_faq_addressables": "Addressables e Migração",
  "h2_faq_audio": "Áudio AI / Text-to-Speech",
  "h2_faq_components": "Componentes Principais",
  "h2_faq_editor": "Editor de Tradução",
  "h2_faq_examples": "Exemplos de Uso & Código",
  "h2_faq_extending": "Estendendo Funcionalidade",
  "h2_faq_installation": "Instalação & Início Rápido",
  "h2_faq_notes": "Nuances Importantes & Avisos",
  "h2_faq_window": "Janela \"Ferramenta de Localização\"",
  "h2_font_glyph_manager_features": "Recursos",
  "h2_in_editor_preview": "Pré-visualização no Editor & Prefab",
  "h2_initial_setup": "Configuração Inicial",
  "h2_installation": "Instalação",
  "h2_key_features": "Principais Recursos",
  "h2_live_updates_guide": "Guia de Atualizações ao Vivo",
  "h2_localizedasset": "Asset Localizado",
  "h2_localizedasset_updated": "Carregamento Assíncrono de LocalizedAsset",
  "h2_localizedbehaviour": "Comportamento Localizado",
  "h2_localizeddropdown": "Dropdown Localizado",
  "h2_localizedprefab": "Prefab Localizado",
  "h2_localizedtext": "Texto Localizado",
  "h2_migration_custom": "Criando Perfis Personalizados",
  "h2_migration_google_sheets": "Chave do Google Sheets",
  "h2_migration_import_formats": "Formatos de Importação (CSV e Google Sheets)",
  "h2_migration_stubs": "Migração Segura e Stubs de Emergência",
  "h2_migration_tool_features": "Recursos",
  "h2_migration_workflow": "Guia do Fluxo de Trabalho de Migração",
  "h2_preview_overlay": "Sobreposição da Visualização da Cena",
  "h2_safety_caps": "Limites e Cotas de Segurança",
  "h2_script_parsing_rules": "Regras de Análise de Script (Compatibilidade)",
  "h2_tab_actions": "Aba \"Ações\"",
  "h2_tab_assets": "Aba \"Recursos\"",
  "h2_tab_content": "Aba \"Conteúdo\"",
  "h2_tab_report": "Aba \"Relatório\"",
  "h2_tab_settings": "Aba \"Configurações\"",
  "h2_tab_tutorials": "Aba \"Tutoriais\"",
  "h2_tms_setup": "Configuração e Uso",
  "h2_tms_supported": "Serviços Suportados",
  "h2_uitklocalization": "Localização UITK",
  "h2_visual_debugging_guide": "Depuração Visual",
  "h2_window_footer": "Rodapé da Janela (Barra de Status)",
  "h2_window_header": "Cabeçalho da Janela e Barra de Ferramentas",
  "h2_window_sidebar": "Menu Principal (Barra Lateral)",
  "h3_actions_autotranslate": "Tradução Automática",
  "h3_actions_danger": "Zona de Perigo",
  "h3_actions_data": "Gerenciamento de Dados",
  "h3_actions_editor": "Editor de Tradução",
  "h3_actions_parsing": "Análise",
  "h3_actions_tms_integration": "Serviços Externos (TMS)",
  "h3_assets_automation": "Automação",
  "h3_assets_categories": "Categorias de Asset",
  "h3_assets_folder_gen": "Geração de Pastas",
  "h3_assets_loading": "Estratégia de Carregamento",
  "h3_assets_storage": "Configuração de Armazenamento",
  "h3_attribute_cheat_sheet": "Referência Rápida: O Que Fazer e o Que Não Fazer",
  "h3_attribute_features": "Tipos e Recursos Suportados",
  "h3_attribute_limitations": "Limitações",
  "h3_content_components_ignore": "Tipos de Componentes a Ignorar",
  "h3_content_dynamic_keys": "Prefixos de Chaves Dinâmicas",
  "h3_content_dynamic_texts": "Textos Dinâmicos",
  "h3_content_objects_ignore": "Objetos a Ignorar",
  "h3_content_prefabs": "Pastas de Prefab",
  "h3_content_regex": "Padrões Regex Ignorados",
  "h3_content_scenes": "Cenas a Analisar",
  "h3_content_script_rules": "Regras de Análise de Scripts",
  "h3_content_scripts_ignore": "Scripts a Ignorar",
  "h3_custom_provider_steps": "Etapas de Implementação",
  "h3_faq_window_actions": "Aba \"Actions\" (Ações)",
  "h3_faq_window_assets": "Aba \"Assets\" (Ativos)",
  "h3_faq_window_content": "Aba \"Content\" (Conteúdo)",
  "h3_faq_window_preview": "Pré-visualização em Editor",
  "h3_faq_window_report": "Aba \"Report\" (Relatório)",
  "h3_faq_window_settings": "Aba \"Settings\" (Configurações)",
  "h3_mode_auto": "AutoGerarChavesApenas (Padrão)",
  "h3_mode_hybrid": "Modos Híbridos (Prioridade Personalizada)",
  "h3_mode_text": "UsarTextoComoChave (Simplificado)",
  "h3_report_all_keys": "Todas as Chaves",
  "h3_settings_debugging": "Depuração",
  "h3_settings_general": "Configurações Gerais",
  "h3_settings_keygen": "Geração de Chaves",
  "h3_settings_languages": "Gerenciamento de Idiomas",
  "h3_settings_liveupdates": "Atualizações ao Vivo",
  "h3_settings_pseudo": "Configurações de Pseudo-Localização",
  "h3_settings_runtimeapi": "API em Tempo de Execução",
  "h3_settings_tools": "Ferramentas Gerais e de Desenvolvimento",
  "h3_tutorials_list": "Lista de Tutoriais",
  "lbl_not_supported": "NÃO Suportado",
  "lbl_supported": "Totalmente Suportado",
  "li_actions_1": "<strong>Análise (Parsing):</strong><ul><li><strong>Update Keys:</strong> Varredura completa do projeto definida pelas configurações da aba 'Content'.</li><li><strong>Scan Selected Assets:</strong> Varre APENAS os arquivos/pastas atualmente selecionados na Project View. Mais seguro para atualizações parciais, pois desabilita automaticamente 'Remove Missing Keys'.</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> Abre uma janela separada e mais conveniente para editar todas as traduções.",
  "li_actions_3": "<strong>Gerenciamento de Dados:</strong> Use para trocar dados com tradutores (Exportar/Importar para CSV/XML/YAML/XLIFF, importar do Google Sheets). <strong>Google Sheets:</strong> Suporta links 'Editar' e URLs 'Publicar na Web' (verifique o parâmetro GID).",
  "li_actions_4": "<strong>Tradução Automática:</strong> Preenche automaticamente todas as strings de tradução vazias usando o <strong>Translation Profile</strong> ativo.",
  "li_actions_5": "<strong>Zona de Perigo:</strong> Contém botões para remover completamente todos os componentes de localização do projeto. Use com cautela!",
  "li_ai_1": "<strong>Criar Perfil:</strong> Clique com o botão direito na Project view -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "<strong>Serviços:</strong> Suporta DeepL, Google Translate, Microsoft Azure e <strong>Custom AI</strong>.",
  "li_ai_3": "<strong>Configurações:</strong> Cada perfil armazena sua própria Chave de API, limites (tamanho do lote, máx. de caracteres) e configurações de modelo.",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> Use o gerador embutido para criar rapidamente perfis para serviços populares (OpenAI, Gemini, Claude, Ollama).",
  "li_ai_audio_generate": "No <strong>Translation Table Editor</strong>, selecione linhas/células -> Botão Direito -> <strong>Generate Audio</strong>.",
  "li_ai_audio_hash": "<strong>Atualização Inteligente e Hashing:</strong> A ferramenta calcula um hash MD5 do seu conteúdo de texto e só regenera arquivos de áudio se o texto fonte tiver mudado, economizando seus créditos de API. Ela detecta se a tradução mudou desde a última geração de áudio. O editor destaca essas linhas com um ícone 'Outdated' (amarelo), permitindo que você atualize APENAS as linhas alteradas. Este recurso de agrupamento inteligente evita chamadas desnecessárias de API e reduz custos ao regenerar áudio. A ferramenta faz o hash do seu texto e só regenera arquivos de áudio se o texto fonte tiver mudado, economizando seus créditos de API.",
  "li_ai_audio_profile": "Em <strong>Settings</strong>, selecione o <strong>Active Audio Profile</strong> (por exemplo, OpenAI TTS ou ElevenLabs).",
  "li_ai_audio_save": "Os arquivos são salvos na pasta especificada no perfil.",
  "li_ai_audio_voice_mapping": "<strong>Mapeamento de Voz (Multi-Falante):</strong> Atribua diferentes vozes de IA a diferentes personagens automaticamente. Use a lista <strong>Voice Mappings</strong> para vincular padrões Regex (ex.: <code>^hero_.*</code>) a IDs de Voz específicos. A ferramenta selecionará automaticamente a voz correta com base no nome da chave durante a geração de áudio.",
  "li_ai_provider_settings": "<strong>Configurações do Provedor:</strong> Cada serviço permite a configuração de Chaves de API, Modelos (por exemplo, GPT-4o, Sonnet) e parâmetros específicos de voz (Estabilidade, Similaridade).",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Use isso para carregar assets Addressables de forma assíncrona. Retorna um <code>Task&lt;T&gt;</code>.",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) retorna uma tradução específica de gênero.",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> retorna a forma plural correta com base nas regras específicas de cada idioma.",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> Uma coroutine (<code>IEnumerator</code>) para mudar o idioma. Sempre use <code>StartCoroutine()</code>.",
  "li_assets_1": "<strong>Crie uma estrutura de pastas (opcional):</strong> Na seção <strong>2. Asset Folder Generation</strong>, clique em <strong>Create Asset Folders Now</strong>.",
  "li_assets_2": "<strong>Configure categorias e regras de nomenclatura:</strong> Na seção <strong>3. Asset Categories & Scanning</strong>, certifique-se de que a <strong>Naming Rule</strong> (<code>{key}_{lang}</code>) corresponda aos seus arquivos (por exemplo, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Coloque seus ativos:</strong> Coloque os ativos localizados nas pastas.",
  "li_assets_4": "<strong>Varredura de ativos:</strong> Na seção <strong>4. Automation</strong>, clique em <strong>Scan Assets & Update Tables</strong>. O processo de limpeza se tornou mais seguro: agora apenas arquivos de tabela antigos (<code>.asset</code>) são excluídos, não a pasta inteira.",
  "li_assets_5": "<strong>Vincular ativos a objetos:</strong> Clique em <strong>Analyze Project & Attach Components</strong>.",
  "li_assets_6": "<strong>Integração Addressables:</strong> Se o modo <strong>Addressables</strong> estiver habilitado, os ativos serão registrados automaticamente em grupos Addressables com endereços no formato <code>{Category}/{Language}/{Key}</code> durante a varredura.",
  "li_assets_addressables_naming": "<strong>Convenção de Nomenclatura:</strong> Ao varrer, a ferramenta define automaticamente os Endereços Addressable para o formato <code>{Category}/{Language}/{Key}</code>. <strong>Não renomeie</strong> esses endereços manualmente, pois o LocalizationManager depende deste formato específico para carregar ativos em tempo de execução.",
  "li_assets_auto_folders": "<strong>Gerar Pastas Automaticamente:</strong> Se ativado, a ferramenta criará automaticamente a estrutura de diretórios necessária para todos os idiomas suportados durante a primeira localização de assets.",
  "li_assets_folder_gen": "<strong>Geração de Pastas:</strong> Crie automaticamente a estrutura de pastas para assets localizados de acordo com suas regras.",
  "li_assets_storage_path": "<strong>Caminho de Armazenamento de Asset:</strong> Define o diretório raiz para todos os assets localizados (Sprites, Áudio, etc.). Use a variável <code>{lang}</code> para especificar como as pastas por idioma são estruturadas.",
  "li_assistant_1": "<strong>Configurável:</strong> Defina comandos no seu Translation Profile (por exemplo, \"Fix Grammar\", \"Make Formal\", \"Shorten for UI\").",
  "li_assistant_2": "<strong>Processamento em Lote:</strong> Selecione várias células para aplicar o comando a todas elas de uma vez.",
  "li_assistant_3": "<strong>Comandos Personalizados:</strong> Defina seus próprios prompts no inspetor <strong>Translation Profile</strong> (Lista de <code>AIAssistantCommand</code>). Cada comando tem um <strong>Label</strong> (aparece no menu de contexto) e um <strong>Prompt</strong> (as instruções enviadas à IA, por exemplo, 'Reescreva em estilo pirata').",
  "li_attr_feat_1": "<strong>Coleções:</strong> Suporta <code>List&lt;string&gt;</code> e <code>string[]</code>. As chaves são geradas com sufixos <code>_0</code>, <code>_1</code>, etc. Você pode até usar uma chave personalizada no próprio campo da lista para prefixar todos os itens.",
  "li_attr_feat_2": "<strong>Modificadores de Acesso:</strong> Funciona com campos <code>private</code>, <code>protected</code>, <code>internal</code> e <code>public</code>.",
  "li_attr_feat_3": "<strong>Atributos Personalizados:</strong> Nas configurações da <em>Guia de Conteúdo</em>, você pode adicionar <code>HeaderAttribute</code>, <code>TooltipAttribute</code> ou qualquer nome de atributo personalizado. O analisador tratará então os campos com esses atributos (por exemplo, <code>[Header(\"Text\")]</code>) como strings localizáveis!",
  "li_attr_feat_4": "<strong>Objetos Aninhados:</strong> Verifica recursivamente campos dentro de classes ou structs marcados com <code>[System.Serializable]</code>. Isso inclui instâncias únicas e listas de objetos aninhados.",
  "li_attr_feat_5": "<strong>Strings Formatadas:</strong> Suporta strings interpoladas (<code>$\"Text {0}\"</code>), strings literais (<code>@\"Text\"</code>) e concatenação (<code>\"A\" + \"B\"</code>).",
  "li_attr_limit_1": "<strong>Propriedades são Suportadas:</strong> O parser escaneia tanto <code>Campos</code> quanto <code>Propriedades</code>. Um Getter é necessário.",
  "li_attr_limit_2": "<strong>Dicionários:</strong> <code>Dictionary&lt;T, string&gt;</code> não é diretamente suportado para análise.",
  "li_attr_limit_3": "<strong>Campos Estáticos:</strong> Suportados via análise estática (regex) em arquivos de código, mas geralmente é recomendado usar campos de instância para uma detecção robusta em GameObjects.",
  "li_backup_desc": "Rastreie alterações e restaure versões anteriores de suas traduções.",
  "li_backup_rollback": "<strong>Rollback:</strong> Reverter instantaneamente as chaves selecionadas ou a tabela inteira para um estado anterior.",
  "li_backup_snapshots": "<strong>Snapshots:</strong> Cria pontos de restauração nomeados antes de operações em massa.",
  "li_cheat_base_private": "<strong>Campos Privados da Base:</strong> Suportados (O Scanner lê arquivos de classes base diretamente)",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> Arrays",
  "li_cheat_concatenation": "<strong>Concatenação de Strings:</strong> <code>\"A\" + \"B\"</code> (Suportado)",
  "li_cheat_constructor_args": "<strong>Argumentos de Construtor Complexos:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>Dicionários</strong> (Não são serializáveis pelo inspetor do Unity naturalmente)",
  "li_cheat_headers": "Atributos como <code>[Header(\"...\")]</code> (Totalmente Suportados)",
  "li_cheat_nested_lists": "<strong>Listas de Objetos Aninhados</strong> (ex: <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>Variáveis e Constantes:</strong> <code>const string s = \"Value\";</code> ou <code>static string</code> (Suportado, Roslyn resolve valores do mesmo arquivo)",
  "li_cheat_private": "Campos <code>private</code> / <code>protected</code> (Suportados)",
  "li_cheat_properties": "<strong>Propriedades:</strong> <code>{ get; set; }</code> (Auto-propriedades e Propriedades Completas suportadas)",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong> (Suportados se referenciados)",
  "li_cheat_serializable": "Classes <code>[Serializable]</code> Aninhadas (Itens de inventário, nós de diálogo)",
  "li_cheat_static": "<strong>Campos Estáticos:</strong> <code>public static string</code> (Totalmente suportado)",
  "li_cheat_structs": "<strong>Structs e Records:</strong> Suportados (Escaneamento recursivo)",
  "li_cheat_ternary": "<strong>Lógica/Ternário:</strong> <code>cond ? \"A\" : \"B\"</code> (O analisador não consegue determinar o valor)",
  "li_cheat_unattached": "<strong>Scripts Não Anexados:</strong> Suportados (O Scanner lê todos os arquivos .cs no projeto)",
  "li_content_1": "<strong>Scenes to Parse:</strong> Arraste e solte todas as cenas para análise aqui.",
  "li_content_2": "<strong>Prefab Folders:</strong> Especifique pastas com prefabs. Agora suporta paginação e pesquisa para projetos grandes.",
  "li_content_3": "<strong>Dynamic Texts:</strong> Insira strings que são criadas exclusivamente em código aqui (por exemplo, \"Game Over\").",
  "li_content_4": "<strong>Tipos de Componentes a Ignorar:</strong> Especifique os tipos de Componentes Unity que devem ser ignorados durante a varredura.",
  "li_content_5": "<strong>Fixar para Ignorar:</strong> Este recurso permite \\\"pin\\\" um objeto da cena na lista de ignorados de forma persistente.",
  "li_content_6": "<strong>Scripts a Ignorar:</strong> Adicione scripts C# específicos OU pastas inteiras para excluí-los da análise.",
  "li_content_7": "<strong>Prefixos de Chaves Dinâmicas:</strong> Lista de prefixos para chaves (ex.: <code>Item_</code>) que não serão excluídos durante a limpeza.",
  "li_content_dynamic_keys": "<strong>Prefixos de Chaves Dinâmicas:</strong> Defina prefixos (ex.: <code>quest_item_</code>) que devem ser reconhecidos como potencialmente dinâmicos. Isso ajuda a ferramenta a distinguir entre rótulos de UI estáticos e chaves geradas por dados.",
  "li_content_dynamic_texts": "<strong>Regras de Texto Dinâmico:</strong> Configure padrões para textos que são atualizados dinamicamente via código. Isso impede que o scanner crie chaves redundantes para textos que mudam em tempo de execução.",
  "li_content_regex_example": "<strong>Exemplo de Wrapper Personalizado:</strong> Se você usar uma função personalizada como <code>MyGame.Loc(\"KEY\")</code>, adicione uma Regra de Análise de Script com a expressão regular: <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Padrões Regex Ignorados:</strong> Clique <strong>'Adicionar Padrão Comum'</strong> para excluir rapidamente conteúdo dinâmico como URLs, e-mails, etc.",
  "li_content_scanner": "<strong>Scanner de Código Roslyn:</strong> Um motor de análise estática profunda que entende árvores de sintaxe C# para detecção robusta de chaves.",
  "li_content_scanner_details_1": "<strong>Detecção Inteligente de Chamadas:</strong> encontra automaticamente chamadas <code>LocalizationManager._(\"Text\")</code>, <code>_(\"Text\")</code> e <code>GetTranslation(\"Text\")</code>. Ele aplica o modo <strong>Texto-Como-Chave</strong> para essas chamadas a fim de garantir que recursos de tempo de execução como Pluralização e Gênero funcionem corretamente.",
  "li_content_scanner_details_2": "<strong>Resolução de Constantes:</strong> O scanner é inteligente o suficiente para resolver variáveis de string `const` ou `static readonly`. Se você usar <code>_ (MyConst)</code>, ele encontrará o valor de `MyConst` (se definido na mesma classe) e o usará como texto de origem.",
  "li_content_scanner_details_3": "<strong>Atributo e Metadados:</strong> Ele escaneia qualquer campo ou propriedade com `[LocalizableField]`, `[Header]` ou `[Tooltip]` (se configurado). Ele lida com <strong>Arrays</strong>, <strong>Listas</strong> e até mesmo <strong>Classes Serializáveis Aninhadas</strong> recursivamente.",
  "li_content_scanner_details_4": "<strong>Suporte Moderno a C#:</strong> Suporte total à sintaxe C# 9.0+, incluindo expressões <code>new()</code> com tipo de destino, criação implícita de array e strings interpoladas (`$\"String {0}\"`).",
  "li_content_script_rules_attributes": "<strong>Atributos a Analisar:</strong> Defina atributos personalizados (como <code>[Header]</code> ou <code>[Tooltip]</code>) que o analisador deve reconhecer como fontes de strings localizáveis.",
  "li_content_script_rules_bridge_name": "<strong>Nome da Classe Bridge:</strong> Permite definir o nome da classe estática gerada.",
  "li_content_script_rules_bridges": "<strong>Gerar Bridges C#:</strong> Cria automaticamente uma classe estática (por exemplo, <code>AnkoLoc</code>) que fornece acesso tipado a todas as chaves, eliminando strings mágicas e habilitando o autocompletar da IDE.",
  "li_context_1": "<strong>Notas do Desenvolvedor:</strong> Comentários da tabela de tradução são passados para a IA como contexto.",
  "li_context_2": "<strong>Caminho do Objeto:</strong> Se não houver comentário, o caminho da hierarquia do objeto (por exemplo, <code>MainMenu/Canvas/StartButton</code>) é usado como contexto de fallback.",
  "li_context_3": "<strong>Glossário:</strong> Você pode carregar um glossário CSV no perfil para forçar traduções específicas para termos e nomes.",
  "li_context_4": "<strong>Descrição do Projeto:</strong> Descreva o cenário e o público do seu jogo para ajudar a IA a entender o contexto geral.",
  "li_context_5": "<strong>Tom e Estilo:</strong> Defina a persona desejada (por exemplo, 'Amigável', 'Profissional', 'Pirata') e as regras de formatação.",
  "li_context_glossary": "<strong>Gerenciador de Dicionário:</strong> Interaja diretamente com o glossário para 'Adicionar', 'Editar' ou 'Remover' termos. Suporta Sensibilidade a Maiúsculas e Minúsculas e tipos 'Não Traduzir'.",
  "li_context_optimization": "<strong>Otimização de Tokens:</strong> O sistema compacta inteligentemente o contexto e reutiliza o cache para minimizar o uso e os custos de tokens.",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> Uma implementação flexível que pode se comunicar com APIs compatíveis com OpenAI (incluindo LLMs locais via Ollama).",
  "li_custom_ai_2": "<strong>Modelos & Autenticação:</strong> Personalize totalmente a requisição. <ul><li><strong>Autenticação:</strong> Configure <code>Auth Header Key</code> (ex., <code>Authorization</code>) e <code>Format</code> (ex., <code>Bearer {0}</code>). Suporta chave de API em parâmetros de consulta.</li><li><strong>Modelo de Corpo:</strong> Use um modelo JSON com marcadores como <code>{model}</code> e <code>{prompt}</code> para texto, ou <code>{input}</code> e <code>{voice}</code> para áudio.</li><li><strong>Caminho da Resposta:</strong> Defina o caminho JSON para o resultado (ex., <code>choices[0].message.content</code>).</li></ul>",
  "li_custom_ai_3": "<strong>Recursos de Segurança Integrados:</strong> Repara automaticamente tags de formatação quebradas (como <ph0>) frequentemente retornadas por modelos de IA, garantindo traduções confiáveis e consistentes.",
  "li_custom_parser_1": "Crie um novo script C# na pasta <strong>Editor</strong> do seu projeto.",
  "li_custom_parser_2": "Copie o template abaixo para ele.",
  "li_custom_parser_3": "Modifique a lógica para corresponder ao seu componente.",
  "li_custom_provider_manual_reg": "<strong>Registro Manual:</strong> Para cenários avançados (como injeção de dependência ou inicialização tardia), você pode registrar manualmente seu provedor via <code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code> durante a inicialização.",
  "li_custom_provider_step_1": "<strong>Implemente a Interface:</strong> Crie uma nova classe que implemente <code>IAssetProvider</code>. Você precisará definir como <code>Load&lt;T&gt;</code> (síncrono) e <code>LoadAsync&lt;T&gt;</code> (assíncrono) assets usando a API do seu sistema.",
  "li_custom_provider_step_2": "<strong>Defina o Ciclo de Vida:</strong> Implemente <code>Initialize</code>, <code>Dispose</code> e <code>UnloadAll</code>. Esses métodos são chamados pelo <code>LocalizationManager</code> ao trocar de idioma ou limpar recursos.",
  "li_custom_provider_step_3": "<strong>Segurança de Idioma:</strong> O método <code>SetCurrentLanguage</code> é chamado sempre que o idioma ativo muda. Use isso para atualizar caminhos internos ou buscar novamente metadados de asset.",
  "li_custom_provider_step_4": "<strong>Auto-Descoberta (Recomendado):</strong> Decore sua classe com o atributo <code>[AssetProviderPlugin]</code>. Isso torna seu provedor instantaneamente visível no dropdown <strong>Aba de Configurações -> Estratégia de Carregamento de Assets</strong>.",
  "li_editor_1": "<strong>Agrupamento Inteligente:</strong> Chaves para plurais e gênero (por exemplo, <code>apple_count_one</code>, <code>apple_count_few</code>) são automaticamente combinadas em grupos recolhíveis.",
  "li_editor_2": "<strong>Edição Avançada:</strong> Clique em uma célula para abrir o popup <strong>MultiLineEditWindow</strong>. Ele mostra o texto fonte para comparação e valida placeholders.",
  "li_editor_3": "<strong>Seleção Avançada:</strong> Suporta modos de seleção flexíveis: células individuais, linhas inteiras ou colunas específicas (idiomas). Use <code>Ctrl+Click</code> e <code>Shift+Click</code> para seleções complexas.",
  "li_editor_4": "<strong>Ações em Massa:</strong> Execute operações em milhares de células de uma vez. Clique com o botão direito na sua seleção para: <ul><li><strong>Traduzir Automaticamente:</strong> Preencher traduções ausentes usando o Perfil de IA ativo.</li><li><strong>Preencher da Fonte:</strong> Reiniciar traduções rapidamente.</li><li><strong>Alternar Bloqueio:</strong> Proteger traduções 'perfeitas' contra sobrescritas acidentais.</li><li><strong>Gerar Áudio:</strong> Processar em lote TTS para frases selecionadas.</li></ul>",
  "li_editor_5": "<strong>Navegação de Alto Desempenho:</strong> O editor usa um 'MultiColumnListView' virtualizado para rolagem suave com mais de 10 mil chaves. Suporta navegação por teclado (Setas/Tab) e atalhos robustos: <code>Ctrl+S</code> (Salvar), <code>Ctrl+Z/Y</code> (Desfazer/Refazer), <code>Ctrl+F</code> (Foco na Pesquisa).",
  "li_editor_6": "<strong>Predefinições de Pesquisa Avançada:</strong> Audite seu projeto usando filtros especializados: <ul><li><strong>Status:</strong> Não Traduzido (Idioma Atual/Qualquer), Idêntico à Fonte, Bloqueado.</li><li><strong>Conteúdo:</strong> Tem Comentários, Tem/Faltam Placeholders, Tem Problemas de Comprimento (Detectado Automaticamente).</li><li><strong>Estrutura:</strong> Pluralizado, Com Gênero, ou Ambos.</li><li><strong>Áudio:</strong> Áudio Ausente, Desatualizado (Hash Incompatível).</li></ul>",
  "li_editor_7": "<strong>Gerenciamento Inteligente de Áudio:</strong> Acompanha a 'atualização' dos seus arquivos TTS. Se você editar o texto da tradução, um <strong>Indicador Amarelo (Desatualizado)</strong> aparece, indicando que o hash do arquivo de áudio não corresponde mais ao texto. Um clique regenera apenas os arquivos desatualizados.",
  "li_editor_8": "<strong>Mecanismo de Bloqueio:</strong> Explicação: <ul><li><strong>Células/Linhas Bloqueadas:</strong> Impede qualquer modificação por <strong>Tradução Automática</strong>, <strong>Importação de CSV/Google</strong>, ou <strong>Preencher da Fonte</strong>.</li><li><strong>Caso de Uso:</strong> Bloqueie traduções 'ouro' que foram verificadas manualmente por falantes nativos.</li><li><strong>Controle em Massa:</strong> Bloqueie idiomas inteiros ou recursos específicos (como nomes de personagens) em todo o projeto.</li></ul>",
  "li_editor_layout": "<strong>Layout Dinâmico de Vários Painéis:</strong> Use o sistema de 3 painéis para fixar colunas 'fixas' (como Chaves) no lado esquerdo enquanto rola por mais de 20 idiomas no meio. Alterne a visibilidade da coluna através do menu de contexto do cabeçalho.",
  "li_editor_regex": "<strong>Pesquisa Regex:</strong> Tanto a janela principal quanto o editor de tabela suportam <strong>Expressões Regulares</strong>. Se sua consulta contiver símbolos como <code>* + ? ^ $ [ ] ( ) { } | .</code>, ela é automaticamente tratada como uma Regex (por exemplo, <code>^item_.*</code> para encontrar todas as chaves que começam com 'item_').",
  "li_editor_structure": "<strong>Tabelas e Grupos:</strong> Os dados são organizados em Tabelas (Arquivos), exibidos como Grupos (Pastas) no editor para melhor navegação.",
  "li_editor_ui_test": "<strong>Testes de UI Incorporados:</strong> <ul><li><strong>Controle Deslizante de Expansão de Comprimento:</strong> Simule a expansão de texto (0% - 100%) para ver como sua UI lida com idiomas mais longos como alemão ou russo sem sair do editor.</li><li><strong>Renderizador de Rich Text:</strong> Alterne a renderização de tags (<code>&lt;b&gt;</code>, <code>&lt;color&gt;</code>) para verificar o estilo sem executar o jogo.</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Um componente pronto para criar uma lista suspensa de UI para troca de idioma. Ele encontra automaticamente todos os idiomas disponíveis e gerencia sua troca.<br><strong>Como usar:</strong> Basta adicionar o componente <code>LanguageSelector</code> à sua cena (por exemplo, em um GameObject vazio) e especificar seu <code>TMP_Dropdown</code> no inspector.",
  "li_example_components_2": "<strong>Exemplos de Código:</strong> Para aprender técnicas avançadas, como trabalhar com <code>[LocalizableField]</code>, a função <code>_()</code>, plurais e gênero, estude os arquivos <code>StatPurchaseTest.cs</code> e <code>TestLocalization.cs</code>. Eles demonstram claramente a implementação de todos os principais recursos da ferramenta em código.",
  "li_example_components_new": "<strong>Novo (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>. Retorna <code>IEnumerator</code>. Deve ser yielded.",
  "li_example_components_old": "<strong>Antigo:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code> (void síncrono) - <strong>Descontinuado</strong>. Use a versão Coroutine.",
  "li_feature_1": "<strong>Análise Avançada (Advanced Parsing):</strong> Varredura automática de cenas, prefabs, UI Toolkit (UXML) e scripts C#, incluindo campos marcados com o atributo <code>[LocalizableField]</code>, bem como classes e listas aninhadas.",
  "li_feature_10": "<strong>Gerenciador de Backup:</strong> Uma ferramenta embutida para criar e restaurar backups.",
  "li_feature_11": "<strong>Alimentado por IA:</strong> Suporte para OpenAI, Anthropic (Claude), Google Gemini e LLMs locais (Ollama) através de perfis personalizáveis.",
  "li_feature_12": "<strong>Text-to-Speech (TTS):</strong> Geração de arquivos de áudio para strings localizadas usando IA (OpenAI, ElevenLabs).",
  "li_feature_13": "<strong>Ferramentas de Migração:</strong> Ferramentas para transição automática dos plugins I2 Localization e Unity Localization.",
  "li_feature_14": "<strong>Gerenciador de Fontes e Glifos:</strong> Ferramenta para analisar caracteres utilizados e encontrar glifos ausentes em fontes.",
  "li_feature_15": "<strong>Depuração Visual:</strong> Ícones na hierarquia e rótulos na Scene View para depuração rápida.",
  "li_feature_2": "<strong>Localização de Qualquer Ativo:</strong> Gerencie sprites, áudio, prefabs, materiais, etc.",
  "li_feature_3": "<strong>Editor de Tradução Poderoso:</strong> Uma interface centralizada com salvamento automático, suporte completo a Desfazer/Refazer, agrupamento inteligente de chaves e ações de multi-seleção.",
  "li_feature_4": "<strong>IA e Tradução Automática:</strong> Sistema de perfil suportando DeepL, Google, Microsoft e <strong>IA Personalizada (OpenAI, Gemini, Claude, Ollama)</strong> com consciência de contexto.",
  "li_feature_5": "<strong>Importação/Exportação Flexível:</strong> Suporte para CSV, XML, YAML, XLIFF e importação direta do Google Sheets.",
  "li_feature_6": "<strong>Pré-visualização ao Vivo:</strong> Pré-visualize qualquer idioma na Scene View ou no <strong>Prefab Mode</strong> sem rodar o jogo.",
  "li_feature_7": "<strong>Suporte a Plural e Gênero:</strong> Suporte CLDR completo (v43). Inclui regras para <strong>Asiáticos</strong> (Nenhum), <strong>Inglês/Germânicos</strong> (Um, Outro), <strong>Francês</strong> (Um 0-1), <strong>Eslavos</strong> (Um, Poucos, Muitos - RU, UK, PL), <strong>Árabe</strong>, <strong>Célticos</strong>, <strong>Bálticos</strong> (LT, LV), e mais.",
  "li_feature_8": "<strong>Suporte Completo a RTL:</strong> Exibição correta de idiomas da direita para a esquerda.",
  "li_feature_9": "<strong>Atualizações ao Vivo:</strong> Carregue traduções atualizadas de um servidor remoto no início do jogo.",
  "li_feature_tool_translation": "<strong>UI Totalmente Traduzida:</strong> A interface da ferramenta é localizável. Você pode trocar o idioma do editor usando o dropdown no <strong>cabeçalho da Janela Principal</strong>.",
  "li_font_global": "<strong>Relatório Global:</strong> Gera um relatório de todos os glifos ausentes em todos os idiomas.",
  "li_font_glyph_analyze": "Analisa todas as traduções e verifica se a fonte atribuída (TMP_FontAsset) suporta todos os caracteres usados.",
  "li_font_glyph_copy": "Permite copiar todos os caracteres de idioma únicos para a geração do atlas de fonte. Inclui <strong>filtros para excluir ASCII, Números e Pontuação</strong> para otimizar o espaço da textura.",
  "li_font_glyph_missing": "Mostra uma lista de glifos ausentes.",
  "li_font_glyph_workflow": "<strong>Fluxo de Trabalho para TMP:</strong> 1. Execute a Varredura (Scan). 2. Selecione um idioma com glifos ausentes. 3. Clique em <strong>'Copy Character Set'</strong>. 4. Abra Window -> TextMeshPro -> Font Asset Creator. 5. Cole o conteúdo da área de transferência no campo 'Character Sequence (Custom Range)' para gerar um atlas contendo exatamente os caracteres que seu jogo precisa.",
  "li_font_unicode": "<strong>Intervalos Unicode:</strong> Visualize os intervalos Unicode específicos usados em suas traduções (por exemplo, Latim Básico, Cirílico) para otimizar os assets de fonte.",
  "li_footer_status": "<strong>Status & Progresso:</strong> Feedback em tempo real sobre tarefas de análise, importação ou geração de IA.",
  "li_header_lang_selector": "<strong>Linguagem do Editor:</strong> Troque o idioma da interface da ferramenta. A UI da ferramenta é totalmente localizável.",
  "li_header_preview_btn": "<strong>Alternar Pré-visualização:</strong> Ative ou desative rapidamente a pré-visualização no editor. Use o botão 'Reverter' para restaurar os valores originais da cena.",
  "li_header_toolbar_buttons": "<strong>Barra de Ferramentas Global:</strong> Acesso direto à Documentação, Discord, Asset de Configurações, Verificador de Dependências e página de Avaliação.",
  "li_install_1": "<strong>IMPORTANTE (Atualização v2.0):</strong> Se estiver atualizando da v1.x, você <strong>DEVE excluir</strong> a pasta `Ankonoanko` antiga antes de importar. A Versão 2.0 requer uma instalação limpa devido a mudanças de namespace.",
  "li_install_2": "A ferramenta verificará automaticamente as dependências necessárias. Confirme a instalação na caixa de diálogo que aparecer.",
  "li_install_3": "As dependências necessárias (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) são essenciais para a funcionalidade básica.",
  "li_install_4": "As dependências opcionais (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) ativam recursos adicionais.",
  "li_install_5": "Clique em <strong>Install Selected</strong> para instalar os pacotes recomendados.",
  "li_install_6": "Após a instalação, abra a janela principal da ferramenta através do menu <strong>Tools -> Localization Tool</strong>.",
  "li_install_7": "Se você planeja usar o carregamento assíncrono de ativos, instale o pacote <strong>Addressables</strong> via Package Manager.",
  "li_live_updates_1": "<strong>Habilitar:</strong> nas Configurações, marque 'Habilitar Atualizações Ao Vivo'.",
  "li_live_updates_2": "<strong>Fonte:</strong> Forneça uma <code>Live Update URL</code> retornando um dicionário JSON, ou uma <code>Google Sheet URL</code>.",
  "li_live_updates_3": "<strong>Cache:</strong> As traduções são armazenadas em cache localmente em <code>liveUpdateCachePath</code> para garantir que o jogo funcione offline.",
  "li_live_updates_4": "<strong>Segurança:</strong> Use a <strong>Chave API de Tempo de Execução</strong> (criptografada) se seu servidor exigir autenticação.",
  "li_localizedtext_1": "<code>localizationKey</code>: A chave usada para encontrar a tradução. Pode ser gerada automaticamente ou atribuída manualmente.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Se <code>true</code>, o componente aplicará apenas estilos (fonte, RTL) mas não alterará o texto em si. Crítico para elementos de texto dinâmicos (por exemplo, texto atualizado via chamadas `_()` em scripts).",
  "li_localizedtext_3": "<code>originalSourceText</code>: O texto original no idioma base. Usado como fallback.",
  "li_localizedtext_key_override": "<strong>Substituição Manual de Chave:</strong> Você pode clicar no ícone 'Edit' ao lado da chave para inserir uma chave manualmente. Use 'X' para reverter para a geração automática. Isso funciona para <code>LocalizedText</code>, <code>LocalizedDropdown</code> (para cada opção individualmente) e <code>UITKLocalization</code>.",
  "li_localizedtext_search_key": "<strong>Pesquisar na Tabela:</strong> Clique no ícone da lupa para abrir instantaneamente a Tabela de Tradução e focar naquela chave específica.",
  "li_migration_csv_details_1": "<strong>Filtragem Inteligente:</strong> O importador ignora automaticamente linhas que se parecem com caminhos de asset (por exemplo, <code>.png</code>, <code>.mp3</code>, <code>Assets/...</code>) para manter seu banco de dados de texto limpo.",
  "li_migration_csv_details_2": "<strong>Coluna 'Tipo':</strong> Se uma coluna 'Type' existir (formato I2), apenas as linhas marcadas como 'Text' ou com tipo vazio são importadas. Para importar assets, use os Perfis de Migração para mapeá-los para <code>LocalizedAsset</code>.",
  "li_migration_csv_req_1": "<strong>Coluna Chave:</strong> Deve ser nomeada <code>Key</code> (não sensível a maiúsculas/minúsculas) ou definida no seu Perfil de Migração.",
  "li_migration_csv_req_2": "<strong>Colunas de Idioma:</strong> Qualquer coluna não marcada como ignorada é tratada como um código de idioma (por exemplo, 'en', 'ja', 'English'). A ferramenta tenta fazer uma correspondência aproximada com os idiomas do seu projeto.",
  "li_migration_csv_req_3": "<strong>Comentários:</strong> Colunas nomeadas <code>Desc</code>, <code>Description</code> ou <code>Comment</code> são importadas como notas de desenvolvedor. Esta lista é configurável no <strong>Migration Profile</strong>.",
  "li_migration_custom_1": "Clique com o botão direito na Visualização do Projeto -> Criar -> Anko Localization -> Perfil de Migração.",
  "li_migration_custom_2": "<strong>Regras:</strong> Defina regras de conversão (se [Source Component] com [Context Filter], então converta para [Target Component]). As regras suportam <strong>Prioridade</strong> (números maiores são processados primeiro), <strong>Harvest Assets</strong> (extrai e registra automaticamente ativos referenciados como Sprites ou Áudio) e <strong>Context Filtering</strong> para distinguir entre múltiplos componentes no mesmo objeto.",
  "li_migration_fallback_keys": "<strong>Campos de Chave de Retorno:</strong> Especifique nomes de campos adicionais para verificar ao extrair chaves de componentes legados. Útil se seu sistema antigo usar nomes de propriedades não padrão para chaves.",
  "li_migration_gs_1": "<strong>Acesso:</strong> A planilha deve ser compartilhada ('Qualquer pessoa com o link pode visualizar') ou Publicada na Web.",
  "li_migration_gs_2": "<strong>Abas da Planilha (GID):</strong> A URL deve incluir o parâmetro <code>gid=...</code>. Isso informa à ferramenta exatamente qual aba ler (por exemplo, <code>gid=0</code> é geralmente a primeira aba/planilha).",
  "li_migration_ignored_headers": "<strong>Cabeçalhos CSV Ignorados:</strong> Defina colunas que devem ser ignoradas durante a importação (por exemplo, 'Tipo', 'Descrição'). Isso impede que a ferramenta trate colunas de metadados como dados de idioma.",
  "li_migration_legacy_components": "<strong>Componentes Legados Adicionais:</strong> Liste manualmente os nomes dos componentes que a ferramenta deve detectar como 'legados' durante a varredura de migração, mesmo que nenhuma regra de conversão direta seja definida.",
  "li_migration_profile_details": "<strong>Configurações Avançadas de Perfil:</strong><ul><li><code>CsvKeyHeader</code>: O nome do cabeçalho para a coluna de Chave.</li><li><code>CsvCommentHeaders</code>: Lista de cabeçalhos a serem tratados como notas/comentários de desenvolvedor.</li><li><code>IgnoredCsvHeaders</code>: Colunas a ignorar (metadados como 'Type' ou 'Status') para evitar que sejam tratadas como idiomas.</li><li><code>AssetExtensions</code>: Tipos de arquivo reconhecidos como ativos durante a varredura.</li><li><code>FallbackKeyFields</code>: Nomes de campos adicionais a verificar se o campo de chave principal está vazio.</li></ul>",
  "li_migration_rule_fields": "<strong>Configuração de Regra:</strong><ul><li><code>Priority</code>: Valores maiores são processados primeiro. Use isso para tratar casos específicos antes dos genéricos.</li><li><code>Context Filter</code>: Aplique a regra somente se um componente específico (ex., <code>Text</code>) estiver presente no mesmo objeto.</li><li><code>Harvest Assets</code>: Se habilitado, extrai o ativo atual (ex., Sprite) do componente legado e o registra na tabela de ativos.</li><li><code>Asset Field Path</code>: Caminho para o campo que contém a referência ao ativo para coleta.</li><li><code>Additional Data Path</code>: Usado para componentes complexos como Dropdowns para coletar múltiplos valores/opções.</li></ul>",
  "li_migration_stubs_1": "<strong>Problema:</strong> Você exclui os assets antigos do plugin. Unity detecta scripts ausentes (por exemplo, componente <code>Localize</code> ausente). O editor entra no modo de erro de compilação.",
  "li_migration_stubs_2": "<strong>Solução:</strong> O recurso 'Emergency Stubs' gera classes leves e vazias com os mesmos nomes e namespaces do plugin antigo. Isso satisfaz o compilador.",
  "li_migration_stubs_3": "<strong>Fluxo de Trabalho:</strong> 1. Clique <strong>Enable Emergency Stubs</strong> (isso adiciona <code>ANKO_ENABLE_MIGRATION_STUBS</code> às Configurações do Projeto). 2. Exclua a pasta do plugin antigo. 3. Unity recompila com sucesso usando classes falsas. 4. Execute o <strong>Component Converter</strong> para substituir os stubs por componentes oficiais. 5. Clique <strong>Disable Stubs</strong> quando a refatoração estiver concluída.",
  "li_migration_tool_converter": "<strong>Passo 2: Conversor de Componentes:</strong> Varra cenas e prefabs. Substitui automaticamente componentes antigos (por exemplo, <code>Localize</code>) por <code>LocalizedText</code> / <code>LocalizedAsset</code>, transferindo chaves.",
  "li_migration_tool_fields": "<strong>Configurações de Perfil:</strong> O tipo configurável de 'Plugin de Origem' e as regras de 'Mapeamento de Ativos' garantem a transferência correta de texturas e áudio.",
  "li_migration_tool_import": "<strong>Passo 1: Importação de Dados:</strong> Importe arquivos CSV (I2) ou XLIFF (Unity Loc) para criar um banco de dados de chaves.",
  "li_migration_tool_profiles": "<strong>Perfis de Migração:</strong> Crie perfis personalizados para mapear ativos e configurações de plugins de terceiros (I2, Unity Loc).",
  "li_migration_tool_safemode": "<strong>Modo Seguro & Stubs de Emergência:</strong> Os componentes são desativados ao invés de excluídos. Inclui o recurso crítico <strong>Emergency Stubs</strong> (ativado via o símbolo de definição <code>ANKO_ENABLE_MIGRATION_STUBS</code>): gera classes placeholder falsas para I2 Localization ou Unity Localization para que seu projeto compile imediatamente após remover esses plugins. Isso impede erros como \"The type name 'Localize' could not be found\" e lhe dá tempo para refatorar corretamente seu código para usar o novo sistema. \"Enable Stubs\" permite corrigir erros de compilação após excluir o plugin de localização antigo.",
  "li_migration_tool_setup": "<strong>Passo 0: Configuração:</strong> Configure nomes de componentes (por exemplo, <code>Localize</code> para I2) e campos onde a chave é armazenada. Presets estão disponíveis.",
  "li_migration_workflow_1": "<strong>1. Backup:</strong> Envie seu projeto para o controle de versão (Git) ou faça um backup de arquivo antes de começar.",
  "li_migration_workflow_2": "<strong>2. Habilitar Stubs:</strong> Abra a Ferramenta de Migração -> aba 'Modo de Segurança'. Clique em <strong>Habilitar Stubs de Emergência</strong> para o seu sistema de destino (I2/UnityLoc). Isso cria classes falsas leves em seu projeto.",
  "li_migration_workflow_3": "<strong>3. Remover Plugin Antigo:</strong> Exclua a pasta do plugin antigo (por exemplo, 'Assets/Plugins/I2'). O Unity irá recompilar. Graças aos Stubs, você <strong>NÃO</strong> receberá erros de 'Tipo não encontrado', preservando todas as suas referências de componentes em prefabs.",
  "li_migration_workflow_4": "<strong>4. Importar Dados:</strong> Na aba 'Importar Dados', carregue seu CSV/XLIFF de Origem. Verifique a prévia e clique em <strong>Importar</strong>. Isso preenche as tabelas de tradução AnKo.",
  "li_migration_workflow_5": "<strong>5. Converter Componentes:</strong> Na aba 'Conversor de Componentes', selecione 'Projeto Inteiro' e clique em <strong>Escanear & Converter</strong>. A ferramenta substitui os stubs antigos por componentes 'LocalizedText'/'LocalizedAsset', transferindo as chaves.",
  "li_migration_workflow_6": "<strong>6. Limpeza:</strong> Assim que tudo estiver funcionando, clique em <strong>Desabilitar Stubs</strong> e deixe o Unity recompilar novamente.",
  "li_notes_1": "<strong>Backups:</strong> Sempre crie um backup através de <strong>Translation Table Editor -> Manage Backups</strong> antes de grandes alterações. Os backups são armazenados na pasta <code>LocalizationBackups</code> <strong>na raiz do projeto (fora da pasta Assets)</strong> para manter seu projeto Unity limpo e reduzir os tempos de importação.",
  "li_notes_2": "<strong>Segurança da Chave de API:</strong> A chave para trabalhar no editor é armazenada localmente em sua máquina (em <code>EditorPrefs</code>) e não entra no repositório. Para chaves necessárias na build do jogo, use a seção <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Pasta <code>StreamingAssets</code>:</strong> Os arquivos de tradução devem estar em uma subpasta de <code>Assets/StreamingAssets/</code> para serem incluídos na build do jogo.",
  "li_notes_4": "<strong>\"À Prova de Falhas\":</strong> A ferramenta o protege automaticamente de salvar acidentalmente dados temporários do modo de pré-visualização em uma cena ou prefab.",
  "li_notes_5": "<strong>Desempenho:</strong> A chamada <code>_()</code> é rápida, mas em loops que rodam a cada frame (por exemplo, em <code>Update</code>), tente armazenar o resultado em cache em uma variável.",
  "li_notes_6": "<strong>Excluindo <code>LanguageSelector</code> da análise:</strong> O objeto com o componente <code>LanguageSelector</code> e seu <code>TMP_Dropdown</code> devem ser adicionados à lista <strong>Ignore Specific Objects</strong> na aba <strong>Content</strong>. Isso é necessário para evitar que o parser crie chaves extras para as opções do dropdown, pois o script <code>LanguageSelector</code> as preenche dinamicamente em tempo de execução. Ignorar evita conflitos e mantém os arquivos de tradução limpos.",
  "li_notes_7": "<strong>Fontes para <code>LanguageSelector</code>:</strong> Para que o idioma selecionado no <code>TMP_Dropdown</code> atualize corretamente sua fonte, adicione manualmente um componente <code>LocalizedText</code> vazio ao objeto <strong>Label</strong> filho do Dropdown e marque a caixa <code>isStyleOnly</code>.",
  "li_notes_addressables_code": "<strong>Código e Addressables:</strong> Se você mudar para o modo <strong>Addressables (Async)</strong>, você DEVE usar <code>GetLocalizedAssetAsync<T>()</code> em seus scripts. Chamar o síncrono <code>GetLocalizedAsset<T>()</code> retornará nulo e registrará um aviso para evitar travamentos do thread principal.",
  "li_notes_addressables_sync_warning": "<strong>Síncrono vs Assíncrono:</strong> Se você mudar para o modo <strong>Addressables (Async)</strong>, você DEVE atualizar seu código para usar <code>GetLocalizedAssetAsync<T>()</code>. Chamar o método síncrono retornará nulo e registrará um aviso para evitar o congelamento do thread principal.",
  "li_preview_1": "<strong>Como funciona:</strong> Selecione um idioma na lista, e a ferramenta aplicará instantaneamente as traduções, fontes, configurações RTL e ativos correspondentes a todos os objetos localizáveis na cena ativa ou prefab aberto.",
  "li_preview_2": "<strong>Placeholders:</strong> Se um estilo de placeholder (por exemplo, <strong>Accents</strong> ou <strong>Brackets</strong>) for selecionado na aba <strong>Settings</strong>, esses placeholders serão exibidos no modo de pré-visualização em vez das traduções reais. Isso é ideal para testar o layout e encontrar elementos não localizados.",
  "li_preview_3": "<strong>Segurança:</strong> Todas as alterações feitas no modo de pré-visualização são temporárias. A ferramenta reverterá automaticamente tudo para o estado original quando você selecionar \"<strong>Revert to Original</strong>\", fechar a janela, mudar de cena ou antes de salvar uma cena/prefab (graças ao componente <code>LocalizationPreviewProtector</code>).",
  "li_preview_4": "<strong>Proteção contra Crash:</strong> O sistema faz backup automático do estado da cena na pasta <code>Library</code> antes da pré-visualização. Se o Unity travar ou você forçar o fechamento durante a pré-visualização, a ferramenta detecta o arquivo de recuperação na próxima inicialização e oferece a restauração do estado original da cena.",
  "li_preview_overlay_1": "<strong>Acesso:</strong> A sobreposição aparece automaticamente na Visualização de Cena. Você pode alterná-la através do menu de Sobreposição do Unity (tecla <code>Espaço</code> na Visualização de Cena).",
  "li_preview_overlay_2": "<strong>Funcionalidade:</strong> Fornece um menu suspenso para alternar rapidamente o Idioma de Prévia atual sem abrir a janela principal.",
  "li_report_1": "<strong>Categorias:</strong> All Keys (Todas as Chaves), Added (Adicionadas), Updated (Atualizadas - texto alterado), Removed (Removidas), Duplicates (Duplicatas), Migrated (Migradas), Skipped (Ignoradas - inalteradas).",
  "li_report_2": "<strong>Busca Avançada (Advanced Find):</strong> Clique no botão <strong>Find</strong> ao lado de qualquer entrada para encontrar instantaneamente o objeto correspondente no projeto. A busca funciona de forma assíncrona, não bloqueando o editor, e pesquisa em todas as cenas e prefabs.",
  "li_report_all_keys": "<strong>Todas as Chaves:</strong> Uma lista de todas as chaves de localização detectadas no projeto com opções de busca e filtragem.",
  "li_report_btn_clear": "<strong>Limpar Relatório:</strong> Remove todos os resultados da varredura da memória da sessão atual.",
  "li_report_btn_copy_all": "<strong>Copiar Todas as Chaves:</strong> Copia todas as chaves de localização da categoria atual para a área de transferência do sistema.",
  "li_report_btn_load_last": "<strong>Carregar Última Varredura:</strong> Restaura instantaneamente os resultados da análise de projeto mais recente sem precisar revarrer.",
  "li_report_btn_save": "<strong>Salvar Relatório:</strong> Exporta os resultados da varredura atual para um arquivo de texto ou CSV para documentação ou auditoria externa.",
  "li_report_source_filter": "<strong>Filtro de Origem:</strong> Refina os resultados por sua origem (ex., mostrar apenas chaves encontradas em Scripts, Cenas ou Prefabs).",
  "li_safety_global_limit": "<strong>Limite Mensal Global:</strong> O <code>monthlyCharLimit</code> (padrão: 500.000 caracteres) atua como um disjuntor para todas as solicitações. Você pode ativar/desativar os avisos via <code>enableApiLimitWarning</code>.",
  "li_safety_profile_limit": "<strong>Limites de Perfil:</strong> Cada Perfil de Tradução permite definir seu próprio 'Máx. Caracteres Por Solicitação' e 'Tamanho do Lote'.",
  "li_settings_1": "<strong>Modo de Geração de Chave:</strong> Define a estratégia para criar identificadores únicos para seu texto:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(Padrão - Recomendado)</strong>: Gera chaves baseadas no nome da cena/prefab e na hierarquia do objeto (ex., <code>scene_Menu_BtnPlay_682412</code>). Ideal para projetos grandes pois garante unicidade e não é afetado por alterações de texto.</li><li><code>UseTextAsKey</code>: Usa o próprio texto de origem como chave (ex., \"Start Game\" → <code>Start Game</code>). Ideal para prototipagem rápida onde as chaves devem ser legíveis.</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(Híbrido)</strong>: O modo mais flexível. Primeiro verifica se um componente já possui uma chave atribuída manualmente ou um <code>[LocalizableField(key=\"...\")]</code>. Se nenhuma chave existir, gera uma hierárquica. <em>Use isso para preservar trabalho existente enquanto automatiza novo conteúdo.</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(Híbrido)</strong>: Similar ao anterior, mas recorre ao texto se nenhuma chave manual for encontrada. Respeita componentes e dados existentes.</li><li><code>Manual</code>: O scanner nunca cria novas chaves. Ele apenas atualiza objetos que já têm um componente de localização com uma chave. Perfeito para controle manual rigoroso.</li></ul>",
  "li_settings_10": "<strong>Ferramentas de Desenvolvedor:</strong> Na parte inferior da aba Configurações, você pode encontrar botões utilitários como <strong>Clear Saved Language Pref</strong> (reinicia o idioma salvo no PlayerPrefs para que o jogo inicie novamente com o idioma Padrão).",
  "li_settings_11": "<strong>Opções Dropdown Técnicas:</strong> Uma lista de valores de string (padrões: 'Option A', 'Option B', 'Option C') que o parser <strong>ignorará</strong> ao varrer Dropdowns. Isso mantém sua tabela de tradução limpa do texto placeholder padrão da UI do Unity.",
  "li_settings_2": "<strong>Gerenciamento de Idiomas:</strong><ul><li><strong>Source Language:</strong> O idioma usado em suas cenas/prefabs do Unity (idioma de desenvolvimento).</li><li><strong>Default Language:</strong> O idioma selecionado no primeiro lançamento do jogo se o idioma do sistema do usuário não for suportado.</li><li><strong>Lista:</strong> Gerencie os idiomas suportados, atribua <strong>Font Assets</strong> específicos e habilite o suporte a <strong>RTL</strong>.</li></ul>",
  "li_settings_3": "<strong>Configurações Gerais:</strong> Configuração para comportamento em todo o projeto:<ul><li><code>Translations Save Path</code>: O diretório raiz para armazenar arquivos de tradução <code>.json</code>. Para acesso em tempo de execução, deve estar dentro de <code>Assets/Resources</code> ou <code>Assets/StreamingAssets</code>.</li><li><code>Safe Mode</code>: Uma camada de proteção que bloqueia operações (como Auto-Translate) se inconsistências no projeto ou dependências ausentes forem detectadas.</li><li><code>Remove Missing Keys</code>: Se habilitado, o scanner excluirá automaticamente entradas do banco de dados que não estejam mais presentes em nenhuma cena ou prefab durante a atualização do projeto.</li><li><code>Parse Inactive Objects</code>: Determina se a ferramenta deve analisar e localizar GameObjects desativados ou ocultos.</li><li><code>Parse All Prefabs</code>: Varre todos os prefabs do projeto. Se desativado, apenas prefabs nas pastas especificadas na aba <strong>Content</strong> são processados.</li><li><code>Fill Comments By Paths</code>: Preenche automaticamente o campo 'Comment' na tabela de tradução com o caminho hierárquico do objeto na cena/prefab.</li><li><code>Split Files by Language</code>: Divide o banco de dados de tradução em múltiplos arquivos (ex., <code>en.json</code>, <code>ja.json</code>). Altamente recomendado para projetos grandes para reduzir o uso de memória em tempo de execução.</li><li><code>Allow Empty Source/Keys</code>: Permite que a ferramenta registre e rastreie objetos mesmo que seu texto de origem esteja vazio. Útil para texto dinâmico definido exclusivamente via código.</li><li><code>Attach to Regex-Ignored Text</code>: Obriga a ferramenta a adicionar componentes de localização a objetos cujo texto corresponde a uma regex de exclusão (como números), permitindo sobrescrita manual.</li><li><code>Find Settings Asset</code>: Um botão utilitário que localiza e seleciona instantaneamente o arquivo <code>LocalizationSettings.asset</code> na janela do Projeto.</li></ul>",
  "li_settings_4": "<strong>Depuração & Testes:</strong><ul><li><code>Placeholder Style</code>: Escolha o estilo para exibir placeholders no modo de pré-visualização.</li><li><code>Pseudo-Localization</code>: Selecione <strong>'Custom Pseudo'</strong> para revelar configurações avançadas de teste de layout (Fator de Expansão, Acentos e Delimitadores).</li></ul>",
  "li_settings_5": "<strong>Atualizações ao Vivo:</strong> Configurações para carregar traduções de um servidor remoto.",
  "li_settings_6": "<strong>Chave de API em Tempo de Execução:</strong> Armazena com segurança sua chave de API para <strong>Atualizações ao Vivo</strong> (buscando novas traduções no jogo). Isso é diferente das chaves do Serviço de Tradução usadas no Editor. A chave é <strong>ofuscada</strong> (criptografada) na build para evitar fácil extração por busca de string, mas lembre-se: nenhum segredo do lado do cliente é 100% seguro.",
  "li_settings_7": "<strong>Estratégia de Carregamento de Ativos:</strong> Escolha entre <code>Resources (Legado)</code>, <code>Addressables (Assíncrono)</code> e <code>Personalizado</code>. Aviso: Alterar este modo requer uma nova varredura do projeto. O modo Addressables é altamente recomendado para dispositivos móveis e WebGL para reduzir o uso de memória.",
  "li_settings_8": "<strong>Auto-Tradução:</strong> Usa o sistema <strong>Translation Profiles</strong> para localização impulsionada por IA. A configuração inclui:<ul><li><code>Text & Audio Profiles</code>: Selecione ou crie perfis ScriptableObject para configurar diferentes serviços (ex., OpenAI, DeepL, Google).</li><li><code>Presets Folder</code>: O diretório onde seus presets e perfis de tradução são armazenados.</li><li><code>Target Languages</code>: Uma lista de todos os idiomas do projeto com status em tempo real, barras de progresso e contagem de caracteres para o perfil selecionado.</li><li><code>Start Auto Translation</code>: Inicia o processo para todos os idiomas selecionados usando os perfis especificados.</li></ul>",
  "li_settings_9": "<strong>Melhorias de Depuração:</strong><ul><li><code>Show Hierarchy Icons</code>: Exibe ícones de status (Marca Verde / Aviso Amarelo) na hierarquia. <strong>Otimizado para Performance:</strong> Usa cache para garantir zero atraso mesmo em cenas grandes.</li><li><code>Show Scene View Labels</code>: Depuração visual diretamente na Visualização da Cena. Os rótulos são interativos: clique com o botão direito em qualquer rótulo da cena para copiar instantaneamente a chave de localização para a área de transferência.</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Regra de Estrutura de Pastas:</strong> Define como as subpastas são estruturadas ao gerar ativos localizados (ex., <code>{lang}/{category}</code>).",
  "li_settings_bridge_name": "<strong>Nome da Classe Bridge:</strong> Permite personalizar o nome da classe estática gerada (padrão é <code>AnkoLoc</code>).",
  "li_settings_general_safe_mode": "<strong>Modo Seguro:</strong> Garante que operações críticas não prossigam se puderem causar estados inconsistentes no projeto.",
  "li_settings_lang_culture_fallback": "<strong>Usar Fallback de Cultura:</strong> Se um dialeto regional específico (ex., <code>en-AU</code>) estiver ausente, a ferramenta tentará usar o idioma base (<code>en</code>) antes de recorrer ao <strong>Default Language</strong>.",
  "li_settings_lang_follow_system": "<strong>Seguir Idioma do Sistema:</strong> Troca automaticamente o idioma do jogo para corresponder ao idioma do SO do jogador no primeiro lançamento.",
  "li_settings_live_updates_security": "<strong>Segurança:</strong> chaves de API de tempo de execução são criptografadas (AES) na build para evitar extração casual. Sempre use HTTPS.",
  "li_settings_pseudo_accents": "<strong>Usar Acentos:</strong> Substitui caracteres padrão por versões acentuadas (ex., <code>å</code>, <code>é</code>). Use isso para garantir que suas fontes suportem todos os glifos necessários.",
  "li_settings_pseudo_brackets": "<strong>Adicionar Colchetes:</strong> Envolve o texto em <code>[ ]</code> para verificar o início e fim das strings localizadas, ajudando a identificar problemas de truncamento ou concatenação.",
  "li_settings_pseudo_expand_length": "<strong>Expandir Comprimento:</strong> Simula a expansão de texto comum em idiomas como Alemão ou Russo ao acrescentar caracteres ao final.",
  "li_settings_pseudo_expansion_factor": "<strong>Fator de Expansão:</strong> Multiplicador para simulação de comprimento de texto (ex., 2.0 deixará o texto duas vezes maior).",
  "li_settings_pseudo_prefix": "<strong>Prefixo Personalizado:</strong> Adiciona uma string específica (ex., <code>PSEUDO-</code>) ao início de cada texto localizado.",
  "li_settings_pseudo_suffix": "<strong>Sufixo Personalizado:</strong> Adiciona uma string específica ao final de cada texto localizado.",
  "li_settings_return_source": "<strong>Retornar Fonte se Ausente:</strong> Se habilitado, o sistema retornará o texto no idioma de origem (ou a própria chave) se nenhuma tradução for encontrada para o idioma atual.",
  "li_settings_tms_timeout": "<strong>Tempo Limite TMS:</strong> Especifica o tempo máximo de espera (em segundos) para requisições de rede a serviços TMS externos.",
  "li_settings_tool_check_deps": "<strong>Verificar Dependências:</strong> Reescaneia o projeto em busca de pacotes necessários (como Newtonsoft) e integrações opcionais.",
  "li_settings_tool_cleanup": "<strong>Limpeza Completa do Projeto:</strong> Uma ferramenta destrutiva que remove todos os componentes e dados do Anko Localization do projeto (use com cautela!).",
  "li_settings_tool_clear_prefs": "<strong>Limpar Preferências de Idioma:</strong> Redefine o idioma salvo em PlayerPrefs, forçando o jogo a usar o idioma padrão ou do sistema no próximo lançamento.",
  "li_settings_tool_font_manager": "<strong>Gerenciador de Fontes:</strong> Abre o Gerenciador de Fontes & Glifos para analisar caracteres ausentes e gerar ativos de fonte otimizados.",
  "li_settings_tool_migration": "<strong>Ferramenta de Migração:</strong> Facilita a transferência de dados e componentes do I2 Localization ou Unity Localization.",
  "li_settings_tool_test_center": "<strong>Centro de Teste de Localização:</strong> Uma ferramenta de diagnóstico para verificar a saúde do projeto, checar referências quebradas e garantir a integridade da localização.",
  "li_setup_1": "<strong>Criar Configurações:</strong> Na primeira abertura, a ferramenta criará um arquivo <code>LocalizationSettings.asset</code> na pasta <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Configurar Idiomas e Modo:</strong> Na aba <strong>Configurações</strong>, certifique-se de que sua <strong>Linguagem de Origem</strong> esteja correta. Além disso, verifique o <strong>Modo de Geração de Chaves</strong> (o padrão é <code>AutoGenerateKeysOnly</code>, que é recomendado para a maioria dos projetos).",
  "li_setup_3": "<strong>Especificar Conteúdo para Análise (Parsing):</strong> Na aba <strong>Content</strong>, adicione todas as cenas para análise à lista <strong>Scenes to Parse</strong>. Se você usa prefabs com texto, certifique-se de que suas pastas estejam adicionadas em <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Primeira Execução do Parser:</strong> Vá para a aba <strong>Actions</strong> e clique no botão <code>Update Keys</code>. A ferramenta fará a varredura do seu projeto, criará arquivos de tradução e adicionará automaticamente os componentes necessários (<code>LocalizedText</code>, <code>LocalizedAsset</code>, etc.) aos objetos de jogo.",
  "li_setup_5": "<strong>Configurações e Builds (CRÍTICO):</strong> A ferramenta adiciona automaticamente <code>LocalizationSettings.asset</code> a <code>Project Settings -> Player -> Preloaded Assets</code>. <br>⚠️ <strong>Verificação de Segurança:</strong> Se as configurações estiverem ausentes dos Preloaded Assets e não estiverem em uma pasta Resources, a ferramenta <strong>bloqueará a build</strong> com uma <code>BuildFailedException</code> para evitar que o jogo trave na inicialização.",
  "li_sidebar_presets": "<strong>Presets de Busca:</strong> Filtros predefinidos para tarefas comuns como encontrar strings não traduzidas ou chaves com placeholders ausentes.",
  "li_sidebar_search": "<strong>Busca Global:</strong> Procure por chaves ou textos específicos em todas as tabelas do seu projeto.",
  "li_tms_crowdin": "<strong>Crowdin:</strong> Requer ID do Projeto e Chave de API. Suporta o upload de XLIFF de origem e o download de traduções como um arquivo ZIP. <em>Avançado:</em> <code>File Name</code> (o caminho de destino no Crowdin).",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> Requer Chave de API. Integração simples e rápida para projetos menores. <em>Avançado:</em> <code>Import/Export Params</code> (permite adicionar flags extras da API Loco como <code>&tag=v1</code> ou <code>&status=translated</code>).",
  "li_tms_phrase": "<strong>Phrase:</strong> Gerenciamento de localização de nível empresarial. <em>Avançado:</em> <code>Update Translations/Descriptions</code> flags para controlar se a Phrase sobrescreve dados existentes ao fazer upload.",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> Suporta slugs de organização/projeto e autenticação por Token de API. <em>Avançado:</em> <code>Resource Slug</code> (cria automaticamente o recurso se ele não existir).",
  "li_tutorials_1": "<strong>Aprendizagem Interativa:</strong> Guias destacam elementos específicos da interface do usuário e esperam por suas ações.",
  "li_tutorials_2": "<strong>Lições Disponíveis:</strong>",
  "li_tutorials_editor": "<strong>Editor de Tradução:</strong> Recursos avançados do editor tipo planilha.",
  "li_tutorials_list": "<strong>Tutorial List:</strong> Acesse guias interativos para os principais recursos da ferramenta.",
  "li_tutorials_migration": "<strong>Migração:</strong> Como migrar de outros sistemas de localização (I2, Unity Localization).",
  "li_tutorials_quickstart": "<strong>Início Rápido:</strong> Configuração básica para texto e assets.",
  "li_tutorials_size": "<strong>Tutorial Size:</strong> Ajusta a escala da UI e a verbosidade dos guias interativos (Compacto a Extra Grande). Localizado no cabeçalho da aba Tutoriais.",
  "li_vis_debug_1": "<strong>Ícones da Hierarquia:</strong> Identifique instantaneamente problemas (Chave Ausente, Componente Ausente). Otimizado para ter zero impacto no desempenho.",
  "li_vis_debug_2": "<strong>Rótulos da Visualização de Cena:</strong> Exibe a chave sobre cada objeto localizado. <strong>Clique com o botão direito</strong> em um rótulo para 'Copiar Chave' ou 'Selecionar Objeto'.",
  "li_vis_debug_3": "<strong>Sobreposições:</strong> Use a sobreposição da visualização de cena (barra de espaço) para alternar os idiomas de pré-visualização instantaneamente.",
  "lightbox_aria_close": "Fechar visualizador de imagem",
  "lightbox_image_alt": "Visualização ampliada",
  "mindmap_edge_configure": "1. Configurar",
  "mindmap_edge_creates_components": "Cria Componentes",
  "mindmap_edge_defines_rules": "Define regras para",
  "mindmap_edge_edited_in": "Editado em",
  "mindmap_edge_enables_reaction": "Permite reação via",
  "mindmap_edge_extends": "Estende",
  "mindmap_edge_generates": "Gera",
  "mindmap_edge_manages_assets": "Gerencia ativos para",
  "mindmap_edge_opens": "Abre",
  "mindmap_edge_parse_project": "3. Analisar Projeto",
  "mindmap_edge_processed_by": "Processado por",
  "mindmap_edge_recommends_for": "Recomenda para",
  "mindmap_edge_relates_to": "Relaciona-se a",
  "mindmap_edge_reports_on": "Informa sobre",
  "mindmap_edge_see_faq": "Ver FAQ",
  "mindmap_edge_specify_content": "2. Especificar Conteúdo",
  "mindmap_edge_warns_about": "Avisa sobre",
  "mindmap_node_ai_ecosystem": "Ecossistema de IA",
  "mindmap_node_async_code": "Assíncrono / Addressables",
  "mindmap_node_dev_tools": "Ferramentas e Utilitários",
  "mindmap_node_tms_integration": "Integração TMS",
  "mindmap_preset_ai": "IA e Automação",
  "mindmap_preset_dev": "Fluxo de Trabalho do Desenvolvedor",
  "mindmap_preset_full": "Visualização Completa",
  "mindmap_preset_quick_start": "Início Rápido",
  "mindmap_preset_tools": "Ferramentas e Integrações",
  "mindmap_preset_translator": "Fluxo de Trabalho do Tradutor",
  "mindmap_toggle_title": "Mostrar Mapa Mental",
  "my_notes_title": "Minhas Notas",
  "no_notes_message_new": "Passe o mouse sobre o texto para adicionar uma nota.",
  "notes_add_title": "Adicionar uma nota a este bloco",
  "notes_close_title": "Fechar",
  "notes_delete_title": "Excluir nota",
  "notes_edit_text": "Editar",
  "notes_edit_title": "Editar nota",
  "notes_goto_title": "Ir para o texto",
  "notes_placeholder": "Sua nota...",
  "on_this_page_title": "Nesta Página",
  "p_actions_1": "A principal aba de trabalho.",
  "p_ai_assistant": "No Editor da Tabela de Tradução, você pode agora executar comandos de IA personalizados em células selecionadas através do menu de contexto (Botão Direito -> AI: ...).",
  "p_ai_audio_economy": "<strong>Economia de Custo:</strong> A ferramenta calcula um hash MD5 do seu texto e só regenera arquivos de áudio se o texto fonte tiver mudado, economizando seus créditos de API. Se você mudar uma tradução, o sistema sinaliza apenas aquele arquivo de áudio específico como 'Outdated' (Desatualizado). Use 'Generate Missing/Outdated' para regenerar apenas o que mudou, economizando créditos de API. A ferramenta faz o hash do seu texto e só regenera arquivos de áudio se o texto fonte tiver mudado, economizando seus créditos de API através de agrupamento inteligente (smart batching).",
  "p_ai_context": "Para melhorar a qualidade da tradução, a IA agora recebe contexto adicional:",
  "p_ai_intro": "A ferramenta utiliza um sistema de <strong>Perfil de Tradução</strong> (ScriptableObject). Isso mantém as configurações do serviço de tradução em ativos de perfil individuais, permitindo que você alterne as configurações facilmente.",
  "p_api_snippets_intro": "The <code>LocalizationManager.cs</code> fornece uma API robusta para gerenciamento de localização em tempo de execução. Abaixo estão os principais métodos que você usará em seus scripts.",
  "p_assets_1": "Esta aba é inteiramente dedicada à localização de recursos não textuais.",
  "p_async_api": "Ao usar Addressables, os assets não são carregados instantaneamente. Você deve usar a API assíncrona para evitar quedas de frames.",
  "p_bridge_description": "A ferramenta inclui um gerador de classe estática para acesso a chaves, permitindo que você use referências fortemente tipadas em vez de strings mágicas. Isso ajuda a prevenir erros de digitação e habilita o autocompletar da IDE.",
  "p_bridge_usage_title": "Exemplo de Uso:",
  "p_components_intro": "Estes componentes são a \"ponte\" entre seus objetos na cena e o banco de dados de tradução. Eles \"ouvem\" as mudanças de idioma e substituem automaticamente o texto ou ativo correto.",
  "p_content_1": "Aqui você informa à ferramenta onde exatamente procurar por texto. A interface foi completamente redesenhada para melhor usabilidade.",
  "p_custom_ai": "O tipo de serviço <strong>Custom AI</strong> permite que você conecte qualquer LLM via API REST.",
  "p_custom_asset_provider_1": "Desenvolver um provedor personalizado permite integrar seu próprio sistema de gerenciamento de ativos (por exemplo, um carregador de nuvem personalizado, um sistema de empacotamento interno específico ou um repositório de ativos baseado em banco de dados) diretamente no fluxo de trabalho de localização.",
  "p_custom_asset_provider_intro": "The Asset Provider system abstrai como os assets (Sprites, Áudio, Prefabs, etc.) são carregados em tempo de execução. Ele usa um <strong>Plugin Registry</strong> que descobre automaticamente qualquer implementação de classe de <code>IAssetProvider</code> marcada com o atributo <code>[AssetProviderPlugin]</code>. Isso permite a integração perfeita de sistemas de carregamento personalizados (como carregadores de nuvem ou empacotamento interno) sem modificar o núcleo da ferramenta.",
  "p_custom_attributes_description": "Além das chamadas de função, você pode marcar qualquer campo de string em seus scripts como localizável usando atributos personalizados. Por padrão, a ferramenta reconhece <code>[LocalizableField]</code>, mas você pode adicionar qualquer nome de atributo (como <code>[Header]</code> ou <code>[Tooltip]</code>) à lista <strong>Atributos para Escanear</strong>.",
  "p_custom_parser_1": "Você pode estender facilmente o sistema para suportar componentes personalizados criando sua própria classe de parser.",
  "p_editor_1": "Abre via <strong>Tools -> Localization -> Translation Table Editor</strong>. Esta é a principal ferramenta para edição manual de traduções.",
  "p_example_attribute_1": "A maneira mais poderosa de localizar variáveis de script. Funciona com <strong>private, protected, and public</strong> campos. O analisador lida recursivamente com <strong>Arrays, Lists</strong> e <strong>Nested Serializable Classes</strong>. Ele pode até gerar chaves para outros atributos (como <code>[Header]</code> ou <code>[Tooltip]</code>) se configurado nas Configurações.",
  "p_example_components_1": "O projeto inclui scripts prontos para uso que servem como excelentes exemplos.",
  "p_example_components_updated": "O código mudou. O carregamento do idioma (especialmente ao usar Addressables) agora é assíncrono.",
  "p_example_function_1": "Use a função <code>_()</code> para texto dinâmico que muda durante o jogo. O método que atualiza a UI deve ser marcado com o atributo <code>[OnLanguageChange]</code> para que seja chamado automaticamente quando o idioma for alterado. Um componente <code>LocalizedBehaviour</code> será adicionado automaticamente ao objeto para essa finalidade.",
  "p_example_plurals_1": "A ferramenta agora usa regras mais precisas para diferentes grupos de idiomas.",
  "p_font_glyph_manager_access": "Acesse via <strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>.",
  "p_intro_1": "Esta ferramenta é uma solução abrangente para a localização de jogos e aplicações na Unity. Ela automatiza o processo de coleta de texto e ativos, gerencia traduções através de uma interface poderosa, integra-se com serviços de tradução automática (incluindo IA Personalizada) e atualiza dinamicamente o conteúdo localizado no jogo.",
  "p_live_updates_guide": "O sistema de Atualizações ao Vivo permite que seu jogo obtenha novas traduções de um servidor remoto ou Google Sheet em tempo de execução, sem a necessidade de uma nova build.",
  "p_localizedasset_1": "Usado para trocar ativos com base no idioma. Detecta automaticamente o tipo de componente. Suporta: <ul><li><strong>2D:</strong> Sprites (<code>Image</code>, <code>SpriteRenderer</code>), Texturas (<code>RawImage</code>).</li><li><strong>Áudio/Vídeo:</strong> <code>AudioSource</code>, <code>VideoPlayer</code>.</li><li><strong>3D/Animação:</strong> <code>MeshFilter</code> (Meshes), <code>Renderer</code> (Materials), <code>Animator</code> (Controller), <code>PlayableDirector</code> (Timeline).</li></ul>",
  "p_localizedasset_2": "Para componentes com a opção <strong>Play on Awake</strong> (como <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> intercepta corretamente a reprodução automática, troca o ativo e, em seguida, inicia a reprodução para evitar a execução de conteúdo não localizado.",
  "p_localizedasset_updated": "O componente agora suporta carregamento assíncrono. Note que pode haver um pequeno atraso ao mudar de idioma se os ativos forem carregados da nuvem/disco (Addressables).",
  "p_localizedbehaviour_1": "Um componente utilitário que permite que seus scripts reajam a mudanças de idioma. Ele encontra e chama automaticamente métodos marcados com o atributo <code>[OnLanguageChange]</code>.",
  "p_localizeddropdown_1": "Adicionado a <code>Dropdown</code> e <code>TMP_Dropdown</code> para traduzir suas opções.",
  "p_localizedprefab_1": "Um componente para localizar prefabs inteiros. Funciona de forma não destrutiva: não modifica o prefab original, mas cria uma instância da versão localizada como um objeto filho, desabilitando todos os scripts (<code>MonoBehaviour</code>), renderizadores (<code>Renderer</code>) e colliders (<code>Collider</code>) no objeto original. Isso evita a execução de lógica dupla e artefatos visuais. Para o correto funcionamento em tempo de execução, sua ordem de execução é definida como -100 (<code>[DefaultExecutionOrder(-100)]</code>) para garantir que ele seja executado antes de outros scripts.",
  "p_localizedtext_1": "O componente principal para exibir texto traduzido. É colocado em objetos com <code>Text</code>, <code>TMP_Text</code> e <code>TextMesh</code>.",
  "p_migration_custom": "Você pode criar seus próprios perfis de migração para suportar sistemas personalizados ou configurações de projeto específicas. Cada perfil contém uma lista de <strong>Regras</strong> que definem como componentes e seus campos devem ser convertidos. As regras são verificadas na ordem de sua <strong>Prioridade</strong>.",
  "p_migration_custom_advanced": "Os Perfis de Migração oferecem configurações avançadas para ajustar o processo de importação e detecção:",
  "p_migration_google_sheet": "Você pode importar diretamente de um URL do Google Sheet sem baixar arquivos.",
  "p_migration_import_csv": "A ferramenta suporta arquivos CSV padrão (separados por vírgulas). A primeira linha deve ser o cabeçalho.",
  "p_migration_stubs": "Um problema comum ao migrar é que a exclusão do plugin antigo (por exemplo, I2) quebra a build, impedindo que a Unity compile a própria Ferramenta de Migração.",
  "p_migration_tool_access": "Acesse via <strong>Tools -> Anko Localization Tool -> Migration Tool</strong>.",
  "p_migration_tool_desc": "Ferramenta para transição de outros sistemas de localização (I2 Localization, Unity Localization).",
  "p_preview_1": "Diretamente abaixo do cabeçalho está a lista suspensa <strong>Preview Language</strong>. Este recurso poderoso permite que você veja como a localização ficará em qualquer idioma diretamente na janela <strong>Scene</strong> ou no <strong>Prefab Mode</strong>, sem rodar o jogo.",
  "p_preview_overlay": "Para uma iteração ainda mais rápida, você pode trocar de idioma diretamente da Scene View usando o <strong>Localization Preview Overlay</strong> dedicado.",
  "p_report_1": "Após cada análise, este relatório mostra o panorama completo do seu status de localização.",
  "p_safety_caps": "Para evitar altos custos acidentais ou grandes verificações de tráfego:",
  "p_script_parsing_rules_description": "A ferramenta pode ser configurada para reconhecer chaves de localização usadas em funções personalizadas ou até mesmo em sistemas concorrentes (como I2 Localization) sem modificar seu código existente. Isso é alcançado definindo padrões de regex que o scanner usa para extrair chaves de seus scripts.",
  "p_script_parsing_rules_usage": "Na aba <strong>Conteúdo</strong>, em <strong>Regras de Análise de Script</strong>, você pode adicionar regras que correspondam às suas chamadas de função específicas. Por exemplo, para suportar <code>I2.Loc.Get(\"key\")</code>, você pode adicionar uma regra com um padrão que capture a string dentro dos parênteses.",
  "p_settings_1": "Seu centro de controle. Aqui você define regras globais para todo o processo de localização.",
  "p_tms_intro": "A ferramenta agora suporta sincronização com sistemas populares de gerenciamento de tradução. Você pode enviar chaves de origem e baixar traduções diretamente no Unity.",
  "p_tms_setup": "1. Vá para <strong>Actions -> External Services</strong>.<br>2. Selecione seu provedor de serviço.<br>3. Insira as chaves de API e IDs de projeto.<br>4. Use os botões <strong>Push</strong> (Carregar chaves) e <strong>Pull</strong> (Baixar traduções) na janela de Configurações.",
  "p_tutorials_1": "A aba Tutoriais fornece guias interativos passo a passo para ajudá-lo a dominar os recursos da ferramenta diretamente no Editor Unity.",
  "p_uitklocalization_1": "Adicionado a objetos com um <code>UIDocument</code>. Suporta a localização de <strong>Labels, Buttons, HelpBox, Foldout, ProgressBar (title), TextField (label & placeholder), DropdownField (label & choices), RadioButton, RadioButtonGroup, ToggleButtonGroup (Unity 2023+), e Tooltips</strong> em qualquer elemento. Os identificadores são estáveis entre renomeações se IDs forem definidos no UI Builder.",
  "p_window_footer": "Exibe o status atual, o progresso das operações em segundo plano e a versão da ferramenta.",
  "p_window_header": "A barra superior fornece acesso global aos controles de visualização e ferramentas utilitárias que persistem independentemente da aba selecionada.",
  "p_window_sidebar": "A barra lateral gerencia a navegação entre diferentes abas funcionais e ferramentas de busca global.",
  "page_title": "Documentação da Ferramenta de Localização da Unity",
  "q_faq_addressables_1": "Eu habilitei o modo Addressables, mas os ativos não estão carregando. O que devo verificar?",
  "q_faq_addressables_2": "Como adiciono suporte para DeepL/Google?",
  "q_faq_addressables_3": "O migrador mostra erros de compilação após remover I2/UnityLoc. Como posso corrigir isso?",
  "q_faq_audio_smart_update": "Como a ferramenta economiza créditos de API ao regenerar arquivos de áudio?",
  "q_faq_components_1": "O componente LocalizedPrefab desabilita MonoBehaviours no objeto original. E se o objeto original tiver um script que cria outros objetos ou assina eventos em Awake()?",
  "q_faq_components_2": "Se o prefab original (LocalizedPrefab) tiver um Rigidbody ou outro componente de física, ele será desabilitado? Isso afetará a física se o prefab localizado não o tiver?",
  "q_faq_components_3": "O componente LocalizedAsset armazena o nome do componente de destino como uma string (_targetComponentTypeName). O que acontece se eu renomear um script de componente personalizado ou movê-lo para outro assembly (Assembly Definition)? O LocalizedAsset deixará de funcionar para ele?",
  "q_faq_components_4": "Se houver dois componentes Image no mesmo GameObject, como o LocalizedAsset sabe qual localizar? Ele funcionará com ambos ou apenas com o primeiro que encontrar?",
  "q_faq_components_5": "A documentação afirma que LocalizedPrefab tem uma ordem de execução de -100. E se eu tiver outro script com uma ordem de execução de -110 que tenta encontrar um objeto filho criado por LocalizedPrefab em seu Awake()? O LocalizedPrefab terá instanciado sua instância a tempo?",
  "q_faq_components_6": "O componente LocalizedText tem uma opção isStyleOnly. Se eu habilitá-lo e depois chamar myLocalizedText.SetFormattedText(\"new_key\") em código, o texto mudará, ou apenas o estilo (fonte/RTL)?",
  "q_faq_components_7": "LocalizedBehaviour encontra automaticamente métodos com o atributo [OnLanguageChange]. Ele encontrará métodos privados e protegidos, ou eles devem ser públicos?",
  "q_faq_components_8": "O componente LocalizedAsset intercepta Play on Awake. O que acontece se outro script no mesmo objeto tentar acessar o ativo (por exemplo, audioSource.clip.length) em Awake() ou Start() antes que LocalizedAsset o tenha trocado? É possível uma NullReferenceException ou o uso do ativo antigo?",
  "q_faq_custom_keys_attribute": "Posso usar meu próprio atributo para chaves em vez de [LocalizableField]?",
  "q_faq_custom_provider_1": "Por que meu provedor personalizado não aparece no menu suspenso de Configurações?",
  "q_faq_editor_1": "O que tem maior prioridade para validação de placeholder: a diretiva @placeholders: no comentário ou os placeholders encontrados no texto do idioma fonte? Por exemplo, se o texto fonte tem {name} e o comentário diz @placeholders: {username}.",
  "q_faq_editor_2": "Se eu cometer um erro de digitação na diretiva (por exemplo, @placeholder: em vez de @placeholders:), ela será ignorada ou a ferramenta emitirá um aviso?",
  "q_faq_editor_3": "O sistema de salvamento automático cria arquivos na pasta Backups/AutoSaves. Esses arquivos serão excluídos automaticamente após um salvamento manual bem-sucedido ou ao fechar a janela?",
  "q_faq_editor_4": "Se eu mudar as larguras das colunas no editor, essas configurações serão salvas entre as sessões do Unity?",
  "q_faq_editor_5": "A janela pop-up de edição de texto (MultiLineEditWindow) suporta sua própria pilha de Desfazer/Refazer (via Ctrl+Z) para alterações feitas dentro dela?",
  "q_faq_examples_1": "O que acontece se os nomes das propriedades no tipo anônimo passado para a função _() não corresponderem aos placeholders na string? Por exemplo, _(\"Hello, {username}\", new { user_name = \"Bob\" }). Haverá um erro, ou o placeholder simplesmente não será substituído?",
  "q_faq_examples_2": "O atributo [LocalizableField] funciona para campos privados. Ele funcionará para campos estáticos?",
  "q_faq_examples_3": "Se eu colocar o atributo [OnLanguageChange] em um método com parâmetros (por exemplo, void UpdateUI(string newLang)), o que acontecerá? Haverá um erro de compilação ou um aviso em tempo de execução?",
  "q_faq_examples_4": "Eu estou usando _(\"apple_count\", count). Se não houver uma chave apple_count_one para o idioma atual (para count = 1), qual forma o sistema escolherá? Ele usará apple_count_other como fallback?",
  "q_faq_examples_5": "A função _(\"key\", new { username = \"Alex\" }) usa um tipo anônimo. Isso não criará uma \"carga\" excessiva no coletor de lixo (GC) com chamadas frequentes em um método Update() em comparação com a passagem de um Dictionary<string, object> pré-criado?",
  "q_faq_examples_6": "Meu método marcado com [OnLanguageChange] não está sendo chamado. Por quê?",
  "q_faq_extending_1": "Meu parser personalizado será chamado automaticamente após cada Update Keys? Eu preciso registrá-lo em algum lugar, ou basta ter uma classe que implemente ITextComponentParser no projeto?",
  "q_faq_extending_2": "E se ocorrer uma exceção no meu parser personalizado? Isso interromperá todo o processo de análise, ou a ferramenta continuará com segurança com outros parsers?",
  "q_faq_installation_1": "O que acontece se meu projeto já tiver o pacote com.unity.nuget.newtonsoft-json de outro ativo? O instalador de dependência tentará atualizar ou ignorá-lo?",
  "q_faq_installation_2": "Eu acidentalmente cliquei em \"Skip for Now\" (Pular por Enquanto) e marquei \"Don't ask again\" (Não perguntar novamente) para dependências opcionais (por exemplo, para suporte a CSV). Como posso abrir a janela do instalador novamente para instalá-las?",
  "q_faq_installation_3": "A ferramenta não criou LocalizationSettings.asset em Assets/Resources. Por que isso pode ter acontecido, e posso criá-lo manualmente via Assets -> Create menu?",
  "q_faq_installation_4": "Posso mover o arquivo LocalizationSettings.asset para outra pasta Resources, por exemplo, Assets/MyGame/Resources? A ferramenta ainda o encontrará?",
  "q_faq_installation_5": "O instalador de dependência travou ou deu um erro. Posso instalar as dependências (Newtonsoft Json, Editor Coroutines) manualmente através do Unity Package Manager?",
  "q_faq_notes_1": "A documentação recomenda adicionar LanguageSelector à lista de ignorados. O que exatamente será quebrado se eu esquecer de fazer isso? Serão criadas chaves extras para \"Option A, Option B\"?",
  "q_faq_notes_2": "Se eu esquecer de adicionar um LocalizedText vazio com a caixa de seleção isStyleOnly habilitada no Label dentro do TMP_Dropdown usado pelo LanguageSelector, a fonte não mudará? Por que isso é necessário?",
  "q_faq_notes_3": "A chamada _() no método Update() não é recomendada. Mas e se eu precisar atualizar o texto a cada frame (por exemplo, um cronômetro)? Qual é a maneira mais performática de fazer isso, armazenando em cache apenas a string de formato?",
  "q_faq_tts_voices": "Como atribuo vozes específicas a personagens?",
  "q_faq_window_actions_1": "O que acontece se a conexão com a internet for perdida durante uma tradução automática em lote? A ferramenta tentará reenviar o lote falhado de acordo com a Retry Policy, ou o processo será completamente interrompido?",
  "q_faq_window_actions_2": "Se eu importar um arquivo CSV que contém chaves que já existem no projeto, mas com valores vazios para alguns idiomas, esses valores vazios substituirão minhas traduções existentes ou serão ignorados?",
  "q_faq_window_actions_3": "A seção \"Danger Zone\" permite excluir todos os componentes. Isso removerá componentes de prefabs que estão em pastas não especificadas nas Prefab Folders na aba Content?",
  "q_faq_window_actions_4": "Ao importar do Google Sheets, como devo formatar a coluna de comentários para que a validação de placeholder usando a diretiva @placeholders: funcione?",
  "q_faq_window_actions_5": "A ferramenta pode importar dados de várias planilhas de um único documento Google Sheets, ou só funciona com uma planilha por GID?",
  "q_faq_window_assets_1": "E se eu tiver dois ativos com a mesma chave, mas tipos diferentes, na mesma pasta de varredura (por exemplo, sound_effect_en.mp3 e sound_effect_en.wav)? Qual acabará na tabela de ativos?",
  "q_faq_window_assets_2": "Se eu clicar em Scan Assets & Analyze Project, e houver um objeto Image na cena para o qual um sprite localizado já existe, mas o objeto Image em si ainda não tem um componente LocalizedAsset, a ferramenta adicionará o componente e inserirá automaticamente a chave?",
  "q_faq_window_assets_3": "Posso usar a mesma Naming Rule para diferentes categorias de ativos se elas tiverem diferentes Scan Folders? Isso causará conflitos?",
  "q_faq_window_assets_4": "Se um ativo localizável (por exemplo, button_ok_en.png) não estiver na raiz da Scan Folder, mas em uma subpasta, o scanner o encontrará?",
  "q_faq_window_content_1": "E se eu adicionar uma cena a Scenes to Parse que não está incluída nas Build Settings? Isso afetará algo além do próprio processo de análise?",
  "q_faq_window_content_2": "Eu adicionei um objeto a Ignore Specific Objects (a lista temporária). Se eu fizer um prefab a partir deste objeto, a instância deste prefab também será ignorada?",
  "q_faq_window_content_3": "Se eu adicionar o componente TMPro.TMP_Text a Parsing Ignores -> Ignore Component Types, mas houver um objeto na cena com um LocalizedText que já referencia este TMP_Text, o que acontecerá na próxima Atualização de Chaves? A chave será excluída?",
  "q_faq_window_content_4": "A documentação diz que \"Pin\" salva o caminho completo para o objeto e será quebrado se for renomeado. E se eu fizer um prefab a partir do objeto e depois renomear o objeto original — o \"Pin\" continuará a funcionar para as instâncias do prefab?",
  "q_faq_window_content_5": "Se eu usar \"Pin\" para um objeto filho dentro de uma instância de prefab, qual caminho será salvo: relativo à raiz do prefab ou à raiz da cena? Funcionará em outras cenas?",
  "q_faq_window_preview_1": "Eu abri um prefab no Prefab Mode, apliquei o In-Editor Preview e pressionei Ctrl+S. Os dados temporários de pré-visualização serão salvos no ativo prefab? Como o LocalizationPreviewProtector lida com este caso?",
  "q_faq_window_preview_2": "Se eu habilitar o In-Editor Preview e o editor do Unity travar, e o arquivo Temp/localization_preview_recovery.json for corrompido (por exemplo, JSON vazio ou inválido), o que acontecerá na próxima inicialização?",
  "q_faq_window_preview_3": "No modo In-Editor Preview para LocalizedPrefab, uma instância temporária é criada. Os métodos Awake() e Start() serão executados nesta instância? Isso pode causar erros se eles não forem projetados para rodar no Edit Mode?",
  "q_faq_window_report_1": "O botão \"Find\" (Buscar) procura o objeto assincronamente. E se eu iniciar uma busca e depois clicar imediatamente em Update Keys? A busca será interrompida?",
  "q_faq_window_report_2": "Se uma chave for usada em vários lugares (por exemplo, em dois botões diferentes em cenas diferentes), como isso será exibido no relatório na categoria \"Duplicates\"?",
  "q_faq_window_report_3": "Se eu clicar em \"Find\" para uma chave que é usada apenas em código (via função _()), o que acontecerá? A ferramenta será capaz de encontrar e destacar o script C#?",
  "q_faq_window_settings_1": "Posso mudar o Key Generation Mode de UseTextAsKey para AutoGenerateKeysOnly no meio do projeto. O que exatamente acontecerá com minhas traduções existentes? Elas serão mapeadas para as novas chaves?",
  "q_faq_window_settings_2": "Se eu adicionar um idioma com um código que não tem regras de pluralização (por exemplo, \"kz\" para Cazaque) à lista Supported Languages, qual regra será usada por padrão?",
  "q_faq_window_settings_3": "E se eu especificar o Translations Path não em StreamingAssets, mas em uma pasta regular como Assets/MyTranslations? Os arquivos json serão incluídos na build do jogo?",
  "q_faq_window_settings_4": "A chave de API de tradução automática é armazenada em EditorPrefs. Se eu estiver trabalhando no projeto em dois computadores diferentes, preciso inserir a chave em cada máquina separadamente?",
  "tip_best_practice": "<strong>Dica Profissional:</strong> Se você precisar localizar uma Propriedade, crie um campo de suporte com <code>[LocalizableField]</code> e exponha a propriedade separadamente.",
  "toc_search_placeholder": "Pesquisar documentação...",
  "toc_title": "Sumário",
  "toggle_notes_title": "Alternar Notas",
  "warning_box_components": "<strong>Nota Importante:</strong> Todos os componentes descritos abaixo são adicionados aos objetos de jogo automaticamente durante a análise (quando você clica no botão <code>Update Keys</code>). Você não precisa adicioná-los manualmente.",
  "warning_tms_overwrite": "<strong>Warning:</strong> Baixar do TMS sobrescreverá as traduções locais das chaves correspondentes. Certifique-se de que seu TMS seja a única fonte de verdade."
}