{
  "page_title": "Documentação da Ferramenta de Localização Unity",
  "toc_title": "Índice",
  "toc_search_placeholder": "Pesquisar documentação...",
  "nav_introduction": "1. Introdução",
  "nav_quick_start": "2. Início Rápido",
  "nav_components": "3. Componentes Principais",
  "nav_loc_tool_window": "4. Janela \"Ferramenta de Localização\"",
  "nav_translation_editor": "5. Editor de Tradução",
  "nav_ai_profiles": "6. Perfis de IA & Tradução (Novo v1.1)",
  "nav_usage_examples": "7. Exemplos de Uso",
  "nav_important_notes": "8. Notas Importantes",
  "nav_extending": "9. Estendendo a Funcionalidade",
  "nav_faq": "10. FAQ & Solução de Problemas",
  "nav_key_features": "Principais Recursos",
  "nav_installation": "2.1. Instalação",
  "nav_initial_setup": "2.2. Configuração Inicial",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. Menu de Contexto",
  "nav_in_editor_preview": "4.1. Pré-visualização no Editor & Prefab",
  "nav_tab_settings": "4.2. Aba \"Configurações\"",
  "nav_tab_content": "4.3. Aba \"Conteúdo\" (Redesenhada na v1.1)",
  "nav_tab_actions": "4.4. Aba \"Ações\"",
  "nav_tab_assets": "4.5. Aba \"Assets\"",
  "nav_tab_report": "4.6. Aba \"Relatório\"",
  "nav_ai_profiles_overview": "6.1. Perfis de Tradução",
  "nav_custom_ai": "6.2. IA & Modelos Personalizados",
  "nav_ai_context": "6.3. Contexto & Glossário",
  "nav_ai_assistant": "6.4. Comandos do Assistente de IA",
  "nav_example_components": "7.1. Componentes Prontos",
  "nav_example_attribute": "7.2. Atributo [LocalizableField]",
  "nav_example_function": "7.3. Função _()",
  "nav_example_plurals": "7.4. Plurais & Gênero",
  "nav_custom_parser": "9.1. Criando um Parser",
  "nav_faq_installation": "10.1. Instalação & Início Rápido",
  "nav_faq_components": "10.2. Componentes Principais",
  "nav_faq_window": "10.3. Janela \"Ferramenta de Localização\"",
  "nav_faq_window_actions": "10.3. Janela \"Ferramenta de Localização\" - Aba \"Ações\"",
  "nav_faq_window_assets": "10.3. Janela \"Ferramenta de Localização\" - Aba \"Assets\"",
  "nav_faq_window_report": "10.3. Janela \"Ferramenta de Localização\" - Aba \"Relatório\"",
  "nav_faq_editor": "10.4. Editor de Tradução",
  "nav_faq_examples": "10.5. Exemplos de Uso & Código",
  "nav_faq_notes": "10.6. Nuances & Avisos Importantes",
  "nav_faq_extending": "10.7. Estendendo a Funcionalidade",
  "h1_introduction": "Introdução",
  "p_intro_1": "Esta ferramenta é uma solução abrangente para localizar jogos e aplicativos no Unity. Ela automatiza o processo de coleta de texto e assets, gerenciamento de traduções através de uma interface poderosa, integração com serviços de tradução automática e atualização dinâmica do conteúdo localizado no jogo.",
  "h2_key_features": "Principais Recursos",
  "li_feature_1": "<strong>Análise Avançada:</strong> Varredura automática de cenas, prefabs, UI Toolkit (UXML) e scripts C#, incluindo campos marcados com o atributo <code>[LocalizableField]</code>, bem como classes e listas aninhadas.",
  "li_feature_2": "<strong>Localização de Qualquer Asset:</strong> Gerencie sprites, áudio, prefabs, materiais, etc.",
  "li_feature_3": "<strong>Editor de Tradução Poderoso:</strong> Uma interface centralizada com salvamento automático, suporte completo a Desfazer/Refazer, agrupamento inteligente de chaves e **Novo na v1.1:** ações de multisseleção.",
  "li_feature_4": "<strong>IA & Tradução Automática (v1.1):</strong> Novo sistema de Perfis suportando DeepL, Google, Microsoft e **IA Personalizada (OpenAI, Gemini, Claude, Ollama)** com reconhecimento de contexto.",
  "li_feature_5": "<strong>Importação/Exportação Flexível:</strong> Suporte para CSV, XML, YAML, XLIFF e importação direta do Google Sheets.",
  "li_feature_6": "<strong>Pré-visualização ao Vivo no Editor:</strong> Visualize qualquer idioma sem executar o jogo.",
  "li_feature_7": "<strong>Suporte a Plurais & Gênero:</strong> Tratamento correto de formas plurais (com regras para idiomas eslavos, árabes e outros) e gênero.",
  "li_feature_8": "<strong>Suporte Completo a RTL:</strong> Exibição correta de idiomas da direita para a esquerda.",
  "li_feature_9": "<strong>Atualizações ao Vivo:</strong> Carregue traduções atualizadas de um servidor remoto no início do jogo.",
  "li_feature_10": "<strong>Gerenciador de Backup:</strong> Uma ferramenta integrada para criar e restaurar backups.",
  "h1_quick_start": "Início Rápido e Configuração",
  "h2_installation": "2.1. Instalação",
  "li_install_1": "Copie o asset para a pasta do seu projeto Unity.",
  "li_install_2": "A ferramenta verificará automaticamente as dependências necessárias. Confirme a instalação na caixa de diálogo que aparece.",
  "li_install_3": "As dependências necessárias (<code>Newtonsoft Json</code>, <code>Editor Coroutines</code>) são essenciais para a funcionalidade básica.",
  "li_install_4": "As dependências opcionais (<code>Arabic Support</code>, <code>CsvHelper</code>, <code>YamlDotNet</code>) habilitam recursos adicionais.",
  "li_install_5": "Clique em <strong>Install Selected</strong> para instalar os pacotes recomendados.",
  "li_install_6": "Após a instalação, abra a janela principal da ferramenta através do menu <strong>Tools -> Localization Tool</strong>.",
  "h2_initial_setup": "2.2. Configuração Inicial",
  "li_setup_1": "<strong>Criar Configurações:</strong> Na primeira vez que for aberta, a ferramenta criará um arquivo <code>LocalizationSettings.asset</code> na pasta <code>Assets/Resources</code>.",
  "li_setup_2": "<strong>Configurar Idiomas:</strong> Na aba <strong>Settings</strong>, em <strong>Language Management</strong>, certifique-se de que seu idioma principal (por exemplo, <code>en</code> para inglês) está selecionado como o <strong>Source Language</strong>. Habilite todos os idiomas que você planeja suportar.",
  "li_setup_3": "<strong>Especificar Conteúdo para Análise:</strong> Na aba <strong>Content</strong>, adicione todas as cenas para análise à lista <strong>Scenes to Parse</strong>. Se você usa prefabs com texto, certifique-se de que suas pastas sejam adicionadas a <strong>Prefab Folders</strong>.",
  "li_setup_4": "<strong>Primeira Execução do Parser:</strong> Vá para a aba <strong>Actions</strong> e clique no botão <code>Update Keys</code>. A ferramenta irá escanear seu projeto, criar arquivos de tradução e adicionar automaticamente os componentes necessários (<code>LocalizedText</code>, <code>LocalizedAsset</code>, etc.) aos objetos do jogo.",
  "h1_components": "Componentes Principais (atribuídos automaticamente)",
  "warning_box_components": "<strong>Nota Importante:</strong> Todos os componentes descritos abaixo são adicionados aos objetos do jogo automaticamente durante a análise (quando você clica no botão <code>Update Keys</code>). Você não precisa adicioná-los manualmente.",
  "p_components_intro": "Esses componentes são a \"ponte\" entre seus objetos na cena e o banco de dados de tradução. Eles \"ouvem\" as mudanças de idioma e substituem automaticamente o texto ou o asset correto.",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "O componente principal para exibir texto traduzido. Ele é colocado em objetos com <code>Text</code>, <code>TMP_Text</code> e <code>TextMesh</code>.",
  "li_localizedtext_1": "<code>localizationKey</code>: A chave usada para encontrar a tradução. Gerada automaticamente.",
  "li_localizedtext_2": "<code>isStyleOnly</code>: Se <code>true</code>, o componente aplicará apenas estilos (fonte, RTL), mas não alterará o texto em si. Útil para elementos cujo texto é gerenciado por outro script (por exemplo, <code>LanguageSelector</code>).",
  "li_localizedtext_3": "<code>originalSourceText</code>: O texto original no idioma base. Usado como fallback.",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "Usado para trocar assets (<code>Sprite</code>, <code>AudioClip</code>, <code>Material</code>, etc.). Ele detecta automaticamente o tipo de componente de destino no objeto (<code>Image</code>, <code>AudioSource</code>) e substitui seu recurso.",
  "p_localizedasset_2": "Para componentes com a opção <strong>Play on Awake</strong> (como <code>AudioSource</code>, <code>VideoPlayer</code>), <code>LocalizedAsset</code> intercepta corretamente a reprodução automática, troca o asset e, em seguida, inicia a reprodução para evitar a reprodução de conteúdo não localizado.",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "Um componente para localizar prefabs inteiros. Ele funciona de forma não destrutiva: não modifica o prefab original, mas cria uma instância da versão localizada como um objeto filho, desativando todos os scripts (<code>MonoBehaviour</code>), renderizadores (<code>Renderer</code>) e colisores (<code>Collider</code>) no objeto original. Isso evita a execução de lógica dupla e artefatos visuais. Para uma operação correta em tempo de execução, sua ordem de execução é definida como -100 (<code>[DefaultExecutionOrder(-100)]</code>) para garantir que seja executado antes de outros scripts.",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "Adicionado a objetos com um <code>UIDocument</code> e gerencia a localização de todos os elementos de texto dentro do documento do UI Toolkit (UXML).",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "Adicionado a <code>Dropdown</code> e <code>TMP_Dropdown</code> para traduzir suas opções.",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "Um componente utilitário que permite que seus scripts reajam a mudanças de idioma. Ele encontra e chama automaticamente os métodos marcados com o atributo <code>[OnLanguageChange]</code>.",
  "h2_context_menu": "3.7. Menu de Contexto \"Analisar para Localização\"",
  "p_context_menu_1": "Para adicionar rapidamente um <code>LocalizedAsset</code> a um objeto, você pode clicar com o botão direito no componente desejado (por exemplo, <code>Image</code>, <code>AudioSource</code>) no inspetor e selecionar <strong>Analyze for Localization</strong>. A ferramenta adicionará e configurará o componente por si mesma. (Isso é opcional, mas pode ser usado para adição manual).",
  "h1_loc_tool_window": "Janela \"Ferramenta de Localização\"",
  "h2_in_editor_preview": "4.1. Pré-visualização no Editor & Prefab",
  "p_preview_1": "Diretamente abaixo do cabeçalho está a lista suspensa **Preview Language**. Este recurso poderoso permite que você veja como a localização ficará em qualquer idioma diretamente na janela **Scene** ou **Modo Prefab**, sem executar o jogo.",
  "li_preview_1": "<strong>Como funciona:</strong> Selecione um idioma da lista e a ferramenta aplicará instantaneamente as traduções, fontes, configurações de RTL e assets correspondentes a todos os objetos localizáveis na cena ativa.",
  "li_preview_2": "<strong>Placeholders:</strong> Se um estilo de placeholder (por exemplo, <strong>Accents</strong> ou <strong>Brackets</strong>) for selecionado na aba <strong>Settings</strong>, esses placeholders serão exibidos no modo de pré-visualização em vez de traduções reais. Isso é ideal para testar o layout e encontrar elementos não localizados.",
  "li_preview_3": "<strong>Segurança:</strong> Todas as alterações feitas no modo de pré-visualização são temporárias. A ferramenta reverterá automaticamente tudo ao seu estado original quando você selecionar \"**Revert to Original**\", fechar a janela, mudar de cena ou antes de salvar uma cena/prefab (graças ao componente `LocalizationPreviewProtector`).",
  "li_preview_4": "<strong>Proteção contra Travamento:</strong> O sistema integrado `PreviewCrashProtector` restaurará automaticamente o estado original dos objetos se o editor do Unity travar enquanto uma pré-visualização estiver ativa. Agora suporta restauração no Modo Prefab também.",
  "h2_tab_settings": "4.2. Aba \"Configurações\"",
  "p_settings_1": "Seu centro de controle. Aqui você define regras globais para todo o processo de localização.",
  "li_settings_1": "<strong>Modo de Geração de Chave:</strong> Escolha como as chaves serão criadas.<ul><li><code>UseTextAsKey</code>: O próprio texto se torna a chave. Ideal para protótipos. Desvantagem: se você alterar o texto de origem, a chave muda e todas as suas traduções serão perdidas.</li><li><code>AutoGenerateKeysOnly</code>: A chave é gerada com base na hierarquia e no nome do objeto. Confiável para produção. Vantagem: as traduções não quebram quando o texto é alterado.</li><li><code>UseTextAsKeyWithCustomPriority</code> e <code>AutoGenerateWithCustomKeys</code>: Modos híbridos que permitem definir chaves personalizadas no código através do atributo <code>[LocalizableField(\"minha_chave_personalizada\")]</code>.</li><li>**Migração Segura:** Você pode alterar o modo a qualquer momento. A ferramenta migrará automaticamente todas as traduções existentes para o novo sistema de chaves.</li></ul>",
  "li_settings_2": "<strong>Gerenciamento de Idiomas:</strong> Configure a lista de idiomas. Para idiomas com caracteres especiais, atribua o <strong>Font Asset</strong> apropriado. Habilite a opção <strong>RTL</strong> para idiomas da direita para a esquerda.",
  "li_settings_3": "<strong>Configurações Gerais:</strong><ul><li><code>Parse Prefabs</code>: Habilita a análise de prefabs.</li><li><code>Split files by language</code>: Determina como armazenar as traduções (um arquivo grande ou um arquivo por idioma).</li><li><code>Translations Path</code>: O caminho para armazenar arquivos de tradução <code>.json</code>. Importante: a pasta deve estar dentro de <code>Assets/StreamingAssets/</code>.</li></ul>",
  "li_settings_4": "<strong>Depuração & Testes:</strong><ul><li><code>Placeholder Style</code>: Escolha o estilo para exibir placeholders no modo de pré-visualização.</li></ul>",
  "li_settings_5": "<strong>Atualizações ao Vivo:</strong> Configurações para carregar traduções de um servidor remoto.",
  "li_settings_6": "<strong>Chave de API de Tempo de Execução:</strong> Uma seção para armazenar com segurança uma chave de API que pode ser necessária no jogo compilado (armazenada em formato criptografado).",
  "h2_tab_content": "4.3. Aba \"Conteúdo\" (Redesenhada na v1.1)",
  "p_content_1": "Aqui você diz à ferramenta onde exatamente procurar por texto. A interface foi completamente redesenhada para melhor usabilidade.",
  "li_content_1": "<strong>Cenas para Analisar:</strong> Arraste e solte todas as cenas para análise aqui.",
  "li_content_2": "<strong>Pastas de Prefabs:</strong> Especifique pastas com prefabs. Agora suporta paginação e pesquisa para projetos grandes.",
  "li_content_3": "<strong>Textos Dinâmicos:</strong> Insira strings que são criadas exclusivamente em código aqui (por exemplo, \"Game Over\").",
  "li_content_4": "<strong>Ignorados na Análise:</strong> Especifique scripts, componentes ou objetos a serem ignorados.",
  "li_content_5": "<strong>Fixar:</strong> Este recurso permite que você \"fixe\" um objeto da cena na lista de ignorados. Em vez de uma referência temporária ao objeto, a ferramenta salvará seu caminho completo na hierarquia, tornando a ignorância persistente entre as sessões.",
  "h2_tab_actions": "4.4. Aba \"Ações\"",
  "p_actions_1": "A principal aba de trabalho.",
  "li_actions_1": "<strong>Atualizar Chaves:</strong> Executa o parser, que atualiza seus arquivos de tradução.",
  "li_actions_2": "<strong>Abrir Editor de Tradução:</strong> Abre uma janela separada e mais conveniente para editar todas as traduções.",
  "li_actions_3": "<strong>Gerenciamento de Dados:</strong> Use para trocar dados com tradutores (Exportar/Importar para CSV/XML/YAML/XLIFF, importar do Google Sheets).",
  "li_actions_4": "<strong>Tradução Automática:</strong> Preenche automaticamente todas as strings de tradução vazias usando o **Perfil de Tradução** ativo.",
  "li_actions_5": "<strong>Zona de Perigo:</strong> Contém botões para remover completamente todos os componentes de localização do projeto. Use com cuidado!",
  "h2_tab_assets": "4.5. Aba \"Assets\"",
  "p_assets_1": "Esta aba é inteiramente dedicada à localização de recursos não textuais.",
  "li_assets_1": "<strong>Crie uma estrutura de pastas (opcional):</strong> Na seção <strong>2. Geração de Pasta de Assets</strong>, clique em <strong>Criar Pastas de Assets Agora</strong>.",
  "li_assets_2": "<strong>Configure categorias e regras de nomenclatura:</strong> Na seção <strong>3. Categorias de Assets & Varredura</strong>, certifique-se de que a <strong>Regra de Nomenclatura</strong> (<code>{key}_{lang}</code>) corresponda aos seus arquivos (por exemplo, <code>button_ok_en.png</code>).",
  "li_assets_3": "<strong>Coloque seus assets:</strong> Coloque os assets localizados nas pastas.",
  "li_assets_4": "<strong>Escanear assets:</strong> Na seção <strong>4. Automação</strong>, clique em <strong>Escanear Assets & Atualizar Tabelas</strong>. O processo de limpeza tornou-se mais seguro: agora apenas os arquivos de tabela antigos (<code>.asset</code>) são excluídos, não a pasta inteira.",
  "li_assets_5": "<strong>Vincular assets a objetos:</strong> Clique em <strong>Analisar Projeto & Anexar Componentes</strong>.",
  "h2_tab_report": "4.6. Aba \"Relatório\"",
  "p_report_1": "Após cada análise, este relatório mostra o quadro completo do status da sua localização.",
  "li_report_1": "<strong>Categorias:</strong> Todas as Chaves, Adicionadas, Atualizadas (texto alterado), Removidas, Duplicatas, Migradas, Ignoradas (inalteradas).",
  "li_report_2": "<strong>Busca Avançada:</strong> Clique no botão **Encontrar** ao lado de qualquer entrada para encontrar instantaneamente o objeto correspondente no projeto. A busca funciona de forma assíncrona, não bloqueando o editor, e pesquisa em todas as cenas e prefabs. Se uma chave for usada em vários lugares, uma lista suspensa com todas as fontes aparecerá.",
  "h1_translation_editor": "Editor de Tabela de Tradução",
  "p_editor_1": "Abre via <strong>Tools -> Localization -> Translation Table Editor</strong>. Esta é a principal ferramenta para editar traduções manualmente.",
  "li_editor_1": "<strong>Agrupamento Inteligente:</strong> Chaves para plurais e gênero (por exemplo, <code>apple_count_one</code>, <code>apple_count_few</code>) são combinadas automaticamente em grupos recolhíveis.",
  "li_editor_2": "<strong>Edição Avançada:</strong> Clique em uma célula para abrir o pop-up **MultiLineEditWindow**. Ele mostra o texto de origem para comparação e valida placeholders.",
  "li_editor_3": "<strong>Seleção Avançada (Novo):</strong> Suporta a seleção de células individuais, linhas ou colunas inteiras (idiomas).",
  "li_editor_4": "<strong>Ações em Massa (Novo):</strong> Clique com o botão direito em uma seleção para realizar operações em massa: Traduzir Automaticamente células selecionadas, Limpar conteúdo ou Excluir chaves.",
  "li_editor_5": "<strong>Navegação Inteligente (Novo):</strong> Navegue pela tabela usando as setas do teclado e atalhos (Ctrl+S para salvar, Ctrl+Z/Y para Desfazer/Refazer).",
  "li_editor_6": "<strong>Verificação de Tamanho (Novo):</strong> Use o filtro \"Has Length Issues\" para destacar traduções que são significativamente mais longas que o texto de origem (limite configurável).",
  "h1_ai_profiles": "IA & Perfis de Tradução (Novo v1.1)",
  "h2_ai_profiles_overview": "6.1. Perfis de Tradução",
  "p_ai_intro": "A Versão 1.1 introduz um novo sistema de **Perfil de Tradução** (ScriptableObject). Isso move as configurações do serviço de tradução das configurações globais para assets de perfil individuais, permitindo que você alterne as configurações facilmente.",
  "li_ai_1": "Criar Perfil: Clique com o botão direito na visualização Project -> Create -> Localization -> Translation Profile.",
  "li_ai_2": "Serviços: Suporta DeepL, Google Translate, Microsoft Azure e **IA Personalizada**.",
  "li_ai_3": "Configurações: Cada perfil armazena sua própria Chave de API, limites (tamanho do lote, máx. caracteres) e configurações de modelo.",
  "li_ai_4": "AIPresetsGenerator: Use o gerador integrado para criar rapidamente perfis para serviços populares (OpenAI, Gemini, Claude, Ollama).",
  "h2_custom_ai": "6.2. IA & Modelos Personalizados",
  "p_custom_ai": "O tipo de serviço **IA Personalizada** permite que você conecte qualquer LLM via API REST.",
  "li_custom_ai_1": "GenericAIService: Uma implementação flexível que pode se comunicar com APIs compatíveis com OpenAI (incluindo LLMs locais via Ollama).",
  "li_custom_ai_2": "Modelos: Personalize o modelo JSON do corpo da requisição para corresponder aos requisitos da sua API.",
  "h2_ai_context": "6.3. Contexto & Glossário",
  "p_ai_context": "Para melhorar a qualidade da tradução, a IA agora recebe contexto adicional:",
  "li_context_1": "Notas do Desenvolvedor: Comentários da tabela de tradução são passados para a IA como contexto.",
  "li_context_2": "Caminho do Objeto: Se nenhum comentário existir, o caminho de hierarquia do objeto (por exemplo, <code>MainMenu/Canvas/StartButton</code>) é usado como contexto de fallback.",
  "li_context_3": "Glossário: Você pode carregar um glossário CSV no perfil para impor traduções específicas para termos e nomes.",
  "h2_ai_assistant": "6.4. Comandos do Assistente de IA",
  "p_ai_assistant": "No Editor de Tabela de Tradução, você pode agora executar comandos de IA personalizados em células selecionadas através do menu de contexto (Botão Direito -> AI: ...).",
  "li_assistant_1": "Configurável: Defina comandos no seu Perfil de Tradução (por exemplo, \"Corrigir Gramática\", \"Tornar Formal\", \"Encurtar para UI\").",
  "li_assistant_2": "Processamento em Lote: Selecione várias células para aplicar o comando a todas elas de uma vez.",
  "h1_usage_examples": "Exemplos de Uso",
  "h2_example_components": "7.1. Componentes e Exemplos Prontos",
  "p_example_components_1": "O projeto inclui scripts prontos para uso que servem como excelentes exemplos.",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> Um componente pronto para criar uma lista suspensa de interface do usuário para troca de idioma. Ele encontra automaticamente todos os idiomas disponíveis e gerencia sua troca.<br><strong>Como usar:</strong> Simplesmente adicione o componente <code>LanguageSelector</code> à sua cena (por exemplo, em um GameObject vazio) e especifique seu <code>TMP_Dropdown</code> no inspetor.",
  "li_example_components_2": "<strong>Exemplos de Código:</strong> Para aprender técnicas avançadas, como trabalhar com <code>[LocalizableField]</code>, a função <code>_()</code>, plurais e gênero, estude os arquivos <code>StatPurchaseTest.cs</code> e <code>TestLocalization.cs</code>. Eles demonstram claramente a implementação de todos os principais recursos da ferramenta em código.",
  "h2_example_attribute": "7.2. Atributo [LocalizableField]",
  "p_example_attribute_1": "O método preferido para textos que fazem parte da configuração de um componente no inspetor. O parser agora pode trabalhar com strings, listas/arrays de strings e até mesmo campos dentro de classes <code>[System.Serializable]</code> aninhadas.",
  "code_example_attribute": "using Ankonoanko.Localization; // Necessário para [LocalizableField]\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // O parser encontrará este campo e criará uma chave para ele\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"Você falhou na missão.\";\n    \n    // Você pode definir uma chave personalizada\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Você está pronto para uma aventura?\";\n    \n    // Funciona com listas\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Encontre o tesouro\" };\n    \n    // E até com classes aninhadas!\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. Função _() e Atributo [OnLanguageChange]",
  "p_example_function_1": "Use a função <code>_()</code> para texto dinâmico que muda durante o jogo. O método que atualiza a interface do usuário deve ser marcado com o atributo <code>[OnLanguageChange]</code> para que seja chamado automaticamente quando o idioma for alterado. Um componente <code>LocalizedBehaviour</code> será adicionado automaticamente ao objeto para este propósito.",
  "code_example_function": "// Para usar a chamada curta _(), adicione estas linhas\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // Necessário para [OnLanguageChange]\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // Atualização inicial\n    }\n    \n    // Este método será chamado automaticamente quando o idioma mudar\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. Placeholders indexados (como em string.Format)\n        // Chave: \"score_label\", Texto no arquivo: \"Pontuação: {0}\"\n        scoreText.text = _(\"score_label\", score); // Resultado: \"Pontuação: 100\"\n        \n        // 2. Placeholders nomeados (recomendado para legibilidade)\n        // Chave: \"welcome_message\", Texto: \"Bem-vindo, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // Para casos complexos ou alto desempenho\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. Plurais e Gênero",
  "p_example_plurals_1": "A ferramenta agora usa regras mais precisas para diferentes grupos de idiomas.",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Chaves: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Textos: \"{0} maçã\", \"{0} maçãs\", \"{0} maçãs\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Seleciona automaticamente a forma correta\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Chaves: \"user_greeted_male\", \"user_greeted_female\"\n        // Textos: \"Ele chegou.\", \"Ela chegou.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "Notas e Avisos Importantes",
  "li_notes_1": "<strong>Backups:</strong> Antes de operações globais (<code>Update Keys</code>, importação de dados), sempre crie um backup via <strong>Translation Table Editor -> Manage Backups</strong>.",
  "li_notes_2": "<strong>Segurança da Chave de API:</strong> A chave para trabalhar no editor é armazenada localmente em sua máquina (em <code>EditorPrefs</code>) e não entra no repositório. Para chaves necessárias na compilação do jogo, use a seção <strong>Runtime API Key</strong>.",
  "li_notes_3": "<strong>Pasta <code>StreamingAssets</code>:</strong> Os arquivos de tradução devem estar em uma subpasta de <code>Assets/StreamingAssets/</code> para serem incluídos na compilação do jogo.",
  "li_notes_4": "<strong>\"À prova de falhas\":</strong> A ferramenta protege você automaticamente de salvar acidentalmente dados temporários do modo de pré-visualização em uma cena ou prefab.",
  "li_notes_5": "<strong>Desempenho:</strong> A chamada <code>_()</code> é rápida, mas em loops que rodam a cada quadro (por exemplo, em <code>Update</code>), tente armazenar o resultado em cache em uma variável.",
  "li_notes_6": "<strong>Excluindo <code>LanguageSelector</code> da análise:</strong> O objeto com o componente <code>LanguageSelector</code> e seu <code>TMP_Dropdown</code> devem ser adicionados à lista <strong>Ignore Specific Objects</strong> na aba <strong>Content</strong>. Isso é necessário para evitar que o parser crie chaves extras para as opções do dropdown, já que o script <code>LanguageSelector</code> as preenche dinamicamente em tempo de execução. Ignorar evita conflitos e mantém os arquivos de tradução limpos.",
  "li_notes_7": "<strong>Fontes para <code>LanguageSelector</code>:</strong> Para que o idioma selecionado no <code>TMP_Dropdown</code> atualize corretamente sua fonte, adicione manualmente um componente <code>LocalizedText</code> vazio ao objeto filho <strong>Label</strong> do Dropdown e marque a caixa <code>isStyleOnly</code>.",
  "h1_extending": "Estendendo a Funcionalidade",
  "h2_custom_parser": "9.1. Criando um Parser Personalizado",
  "p_custom_parser_1": "Você pode estender facilmente o sistema para suportar componentes personalizados criando sua própria classe de parser.",
  "li_custom_parser_1": "Crie um novo script C# na pasta <strong>Editor</strong> do seu projeto.",
  "li_custom_parser_2": "Copie o modelo abaixo para ele.",
  "li_custom_parser_3": "Modifique a lógica para corresponder ao seu componente.",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// MODELO para criar um parser para um componente personalizado.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. Verifique se o objeto tem o componente personalizado que precisamos.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Saia se o componente não for encontrado\n        }\n        \n        // 2. Obtenha o texto dos campos do componente personalizado.\n        string titleText = component.Title;\n        \n        // 3. Verifique se o texto é válido para localização.\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. Gere a chave e a fonte usando ajudantes de TextParser.\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. Retorne o resultado.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repita para outros campos...\n        // (um sufixo pode ser adicionado para tornar as chaves únicas)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQ & Solução de Problemas",
  "h2_faq_installation": "10.1. Instalação & Início Rápido",
  "q_faq_installation_1": "O que acontece se meu projeto já tiver o pacote com.unity.nuget.newtonsoft-json de outro asset? O instalador de dependências tentará atualizá-lo ou ignorá-lo?",
  "a_faq_installation_1": "O instalador verifica a existência do tipo Newtonsoft.Json.JsonConvert. Se o tipo existir, ele considera a dependência satisfeita e não tentará instalar ou atualizar o pacote. Isso é feito para evitar conflitos de versão.",
  "q_faq_installation_2": "Eu acidentalmente cliquei em \"Pular por enquanto\" e marquei \"Não perguntar novamente\" para dependências opcionais (por exemplo, para suporte a CSV). Como posso abrir a janela do instalador novamente para instalá-las?",
  "a_faq_installation_2": "Você pode acionar manualmente uma verificação de dependências a qualquer momento através do menu Tools -> Localization -> Check Dependencies. Isso redefinirá a flag \"Não perguntar novamente\" e mostrará a janela com todos os pacotes opcionais ausentes novamente.",
  "q_faq_installation_3": "A ferramenta não criou o LocalizationSettings.asset em Assets/Resources. Por que isso pode ter acontecido, e posso criá-lo manualmente através do menu Assets -> Create?",
  "a_faq_installation_3": "Isso pode acontecer se você não tiver uma pasta Assets/Resources. A ferramenta tentará criá-la, mas as permissões do sistema de arquivos podem impedi-la. Sim, você pode criar o asset manualmente: clique com o botão direito na pasta Resources, selecione Create -> Localization -> Settings. A ferramenta o encontrará automaticamente.",
  "q_faq_installation_4": "Posso mover o arquivo LocalizationSettings.asset para outra pasta Resources, por exemplo, Assets/MyGame/Resources? A ferramenta ainda o encontrará?",
  "a_faq_installation_4": "Sim. A ferramenta usa Resources.Load(), que procura por um asset pelo nome em todas as pastas chamadas Resources em seu projeto. O importante é que o arquivo mantenha seu nome LocalizationSettings.asset.",
  "q_faq_installation_5": "O instalador de dependências congelou ou deu um erro. Posso instalar as dependências (Newtonsoft Json, Editor Coroutines) manualmente através do Unity Package Manager?",
  "a_faq_installation_5": "Sim. Você pode abrir Window -> Package Manager, clicar no ícone \"+\" e selecionar \"Add package by name...\". Insira os nomes dos pacotes: com.unity.nuget.newtonsoft-json e com.unity.editorcoroutines.",
  "h2_faq_components": "10.2. Componentes Principais",
  "q_faq_components_1": "O componente LocalizedPrefab desativa MonoBehaviours no objeto original. E se o objeto original tiver um script que cria outros objetos ou se inscreve em eventos em Awake()? Este código será executado?",
  "a_faq_components_1": "Não, não será. Desativar um MonoBehaviour impede que todos os métodos \"mágicos\" do Unity sejam chamados, incluindo Awake(), OnEnable() e Start(). Isso é intencional para evitar a execução de lógica duplicada. Toda a inicialização deve ocorrer em scripts nas versões localizadas do prefab.",
  "q_faq_components_2": "Se o prefab original (LocalizedPrefab) tiver um Rigidbody ou outro componente de física, ele será desativado? Isso afetará a física se o prefab localizado não o tiver?",
  "a_faq_components_2": "Sim, o comportamento físico do objeto original será neutralizado. O componente LocalizedPrefab encontra todos os componentes Rigidbody e Rigidbody2D em seu GameObject e define sua propriedade isKinematic como true. Isso os remove efetivamente dos cálculos de física dinâmica, evitando comportamentos indesejados, como um objeto invisível caindo ou reagindo a colisões. Ainda é recomendado que a versão localizada do prefab contenha todos os componentes de física necessários para o comportamento correto.",
  "q_faq_components_3": "O componente LocalizedAsset armazena o nome do componente de destino como uma string (_targetComponentTypeName). O que acontece se eu renomear um script de componente personalizado ou movê-lo para outro assembly (Assembly Definition)? O LocalizedAsset deixará de funcionar para ele?",
  "a_faq_components_3": "Sim, ele deixará de funcionar. O componente armazena o nome completo do tipo, incluindo o namespace e o assembly. Renomear o script ou movê-lo para outro .asmdef alterará esse nome, e o LocalizedAsset não será capaz de encontrar o componente de destino. Você precisará executar outra análise via Analyze Project & Attach Components para que ele atualize o nome.",
  "q_faq_components_4": "Se houver dois componentes Image no mesmo GameObject, como o LocalizedAsset sabe qual deles localizar? Ele funcionará com ambos ou apenas com o primeiro que encontrar?",
  "a_faq_components_4": "Um LocalizedAsset é criado para uma instância de componente específica. Ele mantém uma referência a esse componente no código. Se você adicionar manualmente um segundo LocalizedAsset e usar o menu de contexto \"Analyze for Localization\" para visar a segunda Image, você terá dois componentes LocalizedAsset, cada um gerenciando sua própria Image. O analisador automático só criará um componente para a primeira Image com um asset localizável que encontrar.",
  "q_faq_components_5": "A documentação afirma que o LocalizedPrefab tem uma ordem de execução de -100. E se eu tiver outro script com uma ordem de execução de -110 que tenta encontrar um objeto filho criado pelo LocalizedPrefab em seu Awake()? O LocalizedPrefab terá instanciado sua instância a tempo?",
  "a_faq_components_5": "Sim, terá. O LocalizedPrefab cria a instância do prefab localizado em seu método OnEnable(). A ordem de execução do Unity garante que todos os métodos Awake() sejam executados antes de todos os métodos OnEnable(). Assim, seu script com ordem -110 executará seu Awake(), depois o LocalizedPrefab com ordem -100 executará seu Awake(), e só depois disso seus métodos OnEnable() serão chamados em ordem. Seu script não encontrará o objeto porque ele ainda não terá sido criado.",
  "q_faq_components_6": "O componente LocalizedText tem uma opção isStyleOnly. Se eu habilitá-la e depois chamar myLocalizedText.SetFormattedText(\"nova_chave\") no código, o texto mudará, ou apenas o estilo (fonte/RTL)?",
  "a_faq_components_6": "Tanto a chave quanto o texto mudarão. Chamar SetFormattedText programaticamente substitui o comportamento de isStyleOnly para essa atualização específica. A opção isStyleOnly destina-se a impedir que o componente reaja a mudanças globais de idioma, mas ele sempre reagirá a uma mudança de chave direta através do código.",
  "q_faq_components_7": "O LocalizedBehaviour encontra automaticamente métodos com o atributo [OnLanguageChange]. Ele encontrará métodos privados e protegidos, ou eles devem ser públicos?",
  "a_faq_components_7": "Ele encontrará métodos com qualquer modificador de acesso (público, privado, protegido, interno). A reflexão no Unity permite a descoberta de todos os métodos de instância, independentemente do seu nível de acesso.",
  "q_faq_components_8": "O componente LocalizedAsset intercepta o Play on Awake. O que acontece se outro script no mesmo objeto tentar acessar o asset (por exemplo, audioSource.clip.length) em Awake() ou Start() antes que o LocalizedAsset o tenha trocado? É possível uma NullReferenceException ou o uso do asset antigo?",
  "a_faq_components_8": "O uso do asset antigo (não localizado) é possível. O LocalizedAsset realiza a troca em seu OnEnable(). Os métodos Awake() de todos os scripts são executados antes de OnEnable(). Se o seu script acessar audioSource.clip em Awake(), ele obterá o clipe original. Se o acessar em Start(), o resultado dependerá da ordem de execução do script. Para garantir o acesso ao asset localizado, defina uma ordem de execução posterior para o seu script ou acesse o asset em um método marcado com [OnLanguageChange].",
  "h2_faq_window": "10.3. Janela \"Ferramenta de Localização\"",
  "h3_faq_window_preview": "Pré-visualização no Editor & Prefab",
  "q_faq_window_preview_1": "Eu abri um prefab no Modo Prefab, apliquei a Pré-visualização no Editor e pressionei Ctrl+S. Os dados temporários da pré-visualização serão salvos no asset do prefab? Como o LocalizationPreviewProtector lida com este caso?",
  "a_faq_window_preview_1": "Não, não será salvo. O LocalizationPreviewProtector intercepta o evento de salvamento de asset (OnWillSaveAssets) e chama automaticamente RevertEditorPreview() antes que o Unity escreva as alterações no disco. Assim, o prefab será salvo em seu estado original e não localizado.",
  "q_faq_window_preview_2": "Se eu habilitar a Pré-visualização no Editor e o editor do Unity travar, e o arquivo Temp/localization_preview_recovery.json for corrompido (por exemplo, vazio ou JSON inválido), o que acontecerá na próxima inicialização?",
  "a_faq_window_preview_2": "O PreviewCrashProtector está envolto em um bloco try-catch. Se a desserialização do JSON falhar, um erro será registrado no console sobre a incapacidade de recuperar, e o processo terminará silenciosamente. Sua cena permanecerá no estado \"quebrado\" em que estava no momento do travamento. Nesse caso, você precisará selecionar manualmente \"Reverter ao Original\" na janela da ferramenta para forçar a reversão das alterações.",
  "q_faq_window_preview_3": "No modo de Pré-visualização no Editor para LocalizedPrefab, uma instância temporária é criada. Os métodos Awake() e Start() serão executados nesta instância? Isso poderia causar erros se eles não forem projetados para serem executados no Modo de Edição?",
  "a_faq_window_preview_3": "Sim, eles serão. PrefabUtility.InstantiatePrefab no Modo de Edição chama Awake() e OnEnable(). Se esses métodos contiverem lógica que não deve ser executada no editor (por exemplo, acessar singletons que só existem no Modo de Jogo), isso pode causar erros. Recomenda-se usar if (Application.isPlaying) ou #if UNITY_EDITOR para proteger esse código.",
  "h3_faq_window_settings": "Aba \"Configurações\"",
  "q_faq_window_settings_1": "Posso alterar o Modo de Geração de Chave de UseTextAsKey para AutoGenerateKeysOnly no meio do projeto. O que exatamente acontecerá com minhas traduções existentes? Elas serão mapeadas para as novas chaves?",
  "a_faq_window_settings_1": "Sim, serão. Ao alterar o modo, a ferramenta realiza uma \"migração segura\": ela analisa novamente todo o projeto, cria novas chaves de acordo com as novas regras, mas mapeia as chaves antigas e novas através do texto original. Em seguida, transfere todas as suas traduções e comentários existentes das chaves antigas para as novas. Suas traduções não serão perdidas.",
  "q_faq_window_settings_2": "Se eu adicionar um idioma com um código que não tem regras de pluralização (por exemplo, \"kz\" para cazaque) à lista de Idiomas Suportados, qual regra será usada por padrão?",
  "a_faq_window_settings_2": "A DefaultPluralRule será usada, que é adequada para o inglês e a maioria dos idiomas europeus (formas para \"one\" e \"other\").",
  "q_faq_window_settings_3": "E se eu especificar o Caminho das Traduções não em StreamingAssets, mas em uma pasta regular como Assets/MyTranslations? Os arquivos json serão incluídos na compilação do jogo?",
  "a_faq_window_settings_3": "Não, não serão. Apenas os assets localizados em uma pasta StreamingAssets ou Resources têm a garantia de serem incluídos na compilação. Se você especificar um caminho diferente, a localização funcionará no editor, mas não funcionará no jogo compilado, pois os arquivos de tradução não farão parte da compilação.",
  "q_faq_window_settings_4": "A chave da API de tradução automática é armazenada em EditorPrefs. Se eu estiver trabalhando no projeto em dois computadores diferentes, preciso inserir a chave em cada máquina separadamente?",
  "a_faq_window_settings_4": "Sim. O EditorPrefs é um armazenamento local para cada computador. Você precisará inserir a chave da API em cada máquina da qual planeja usar o recurso de tradução automática.",
  "h3_faq_window_content": "Aba \"Conteúdo\"",
  "q_faq_window_content_1": "E se eu adicionar uma cena a Cenas para Analisar que não está incluída nas Configurações de Compilação? Isso afetará algo além do próprio processo de análise?",
  "a_faq_window_content_1": "Não, não afetará. A lista Cenas para Analisar é usada exclusivamente para que a ferramenta saiba quais cenas abrir e analisar em busca de texto. Não está de forma alguma relacionada às cenas que irão para a compilação final do seu jogo.",
  "q_faq_window_content_2": "Eu adicionei um objeto a Ignorar Objetos Específicos (a lista temporária). Se eu fizer um prefab deste objeto, a instância deste prefab também será ignorada?",
  "a_faq_window_content_2": "Não, não será. A lista temporária armazena uma referência direta ao objeto na cena. Quando você cria um prefab, é um novo asset. Suas instâncias são objetos diferentes, e a regra de ignorar não se aplicará a eles. Para ignorar permanentemente os prefabs, eles devem ser adicionados à lista de ignorados como um asset de prefab.",
  "q_faq_window_content_3": "Se eu adicionar o componente TMPro.TMP_Text a Ignorados na Análise -> Ignorar Tipos de Componente, mas houver um objeto na cena com um LocalizedText que já referencia este TMP_Text, o que acontecerá na próxima Atualização de Chaves? A chave será excluída?",
  "a_faq_window_content_3": "Sim, será. Quando você clica em Atualizar Chaves, o parser reexamina todo o projeto. Ele verá que o tipo TMPro.TMP_Text deve ser ignorado e não gerará uma chave para ele. Durante o processo de comparação de chaves antigas e novas, ele determinará que a chave antiga não é mais usada e a marcará como \"Removida\".",
  "q_faq_window_content_4": "A documentação diz que \"Fixar\" salva o caminho completo para o objeto e será quebrado se for renomeado. E se eu fizer um prefab do objeto e depois renomear o objeto original — o \"Fixar\" continuará a funcionar para as instâncias do prefab?",
  "a_faq_window_content_4": "Não, não continuará. \"Fixar\" salva o caminho absoluto na hierarquia da cena no momento em que o botão é clicado (por exemplo, Canvas/Panel/Button). Este caminho não está relacionado à lógica do prefab. As instâncias do prefab terão o mesmo caminho, mas se você renomear o objeto pai na cena, \"Fixar\" deixará de funcionar tanto para o original quanto para as instâncias.",
  "q_faq_window_content_5": "Se eu usar \"Fixar\" para um objeto filho dentro de uma instância de prefab, qual caminho será salvo: relativo à raiz do prefab ou à raiz da cena? Funcionará em outras cenas?",
  "a_faq_window_content_5": "O caminho completo da raiz da cena será salvo. Por exemplo, MyPrefab(Clone)/Content/Icon. Este caminho \"fixado\" só funcionará na cena onde você o criou. Em outras cenas, é improvável que tal caminho seja encontrado.",
  "h3_faq_window_actions": "Aba \"Ações\"",
  "h3_faq_window_assets": "Aba \"Assets\"",
  "h3_faq_window_report": "Aba \"Relatório\"",
  "h2_faq_editor": "10.4. Editor de Tradução",
  "h2_faq_examples": "10.5. Exemplos de Uso & Código",
  "h2_faq_notes": "10.6. Nuances & Avisos Importantes",
  "h2_faq_extending": "10.7. Estendendo a Funcionalidade",
  "q_faq_window_actions_1": "O que acontece se a conexão com a internet for perdida durante uma tradução automática em lote? A ferramenta tentará novamente o lote com falha de acordo com a Política de Nova Tentativa, ou o processo será completamente interrompido?",
  "a_faq_window_actions_1": "A ferramenta tentará reenviar o lote exato que falhou, de acordo com as configurações da Política de Nova Tentativa (número de tentativas e atraso). Se todas as tentativas para este lote falharem, o processo de tradução para o idioma atual será interrompido e um erro será registrado no console. A tradução para os próximos idiomas na fila não será iniciada.",
  "q_faq_window_actions_2": "Se eu importar um arquivo CSV que contém chaves que já existem no projeto, mas com valores vazios para alguns idiomas, esses valores vazios substituirão minhas traduções existentes ou serão ignorados?",
  "a_faq_window_actions_2": "Valores vazios substituirão as traduções existentes. O processo de importação considera o arquivo CSV como a \"fonte da verdade\". Se o valor para a chave welcome_message na coluna ru estiver vazio, a tradução russa atual para esta chave será sobrescrita.",
  "q_faq_window_actions_3": "A seção \"Zona de Perigo\" permite excluir todos os componentes. Ela removerá componentes de prefabs que estão em pastas não especificadas nas Pastas de Prefabs na aba Conteúdo?",
  "a_faq_window_actions_3": "Sim, removerá. As funções na \"Zona de Perigo\" escaneiam todos os prefabs no projeto (AssetDatabase.FindAssets(\"t:Prefab\")), não apenas aqueles especificados na lista de análise, para garantir a limpeza mais completa possível.",
  "q_faq_window_actions_4": "Ao importar do Google Sheets, como devo formatar a coluna de comentários para que a validação de placeholder usando a diretiva @placeholders: funcione?",
  "a_faq_window_actions_4": "No seu documento do Google Sheets, a coluna deve ser intitulada \"Developer Notes\". Nas células desta coluna, você pode escrever comentários como de costume. Para especificar placeholders, basta adicionar uma linha como @placeholders: {username}, {score} no texto do comentário. A ferramenta reconhecerá automaticamente esta diretiva na importação.",
  "q_faq_window_actions_5": "A ferramenta pode importar dados de várias planilhas de um único documento do Google Sheets, ou só funciona com uma planilha por GID?",
  "a_faq_window_actions_5": "A ferramenta só funciona com uma planilha de cada vez. A URL de importação inclui um parâmetro gid=..., que identifica exclusivamente uma planilha específica no documento. Para importar dados de outra planilha, você precisa copiar sua URL (com um gid diferente) e realizar a importação novamente.",
  "q_faq_window_assets_1": "E se eu tiver dois assets com a mesma chave, mas tipos diferentes na mesma pasta de varredura (por exemplo, sound_effect_en.mp3 e sound_effect_en.wav)? Qual deles acabará na tabela de assets?",
  "a_faq_window_assets_1": "O scanner de assets os carrega especificando o tipo esperado (AssetDatabase.LoadAssetAtPath(path, expectedType)). Para a categoria AudioClip, ele só procurará e carregará arquivos que o Unity reconhece como AudioClips. Se ambos os arquivos forem clipes de áudio válidos, aquele que for processado por último será incluído na tabela, substituindo efetivamente o anterior. Recomenda-se evitar tais duplicatas.",
  "q_faq_window_assets_2": "Se eu clicar em Escanear Assets & Analisar Projeto, e houver um objeto Image na cena para o qual já existe um sprite localizado, mas o próprio objeto Image ainda não tem um componente LocalizedAsset, a ferramenta adicionará o componente e inserirá automaticamente a chave?",
  "a_faq_window_assets_2": "Sim, é exatamente assim que funciona. \"Analisar Projeto\" encontra o componente Image, olha o nome do sprite atribuído a ele (por exemplo, icon_play_en), extrai a chave (icon_play) e o idioma (en) dele, e então adiciona um componente LocalizedAsset a esse GameObject e escreve a chave icon_play nele.",
  "q_faq_window_assets_3": "Posso usar a mesma Regra de Nomenclatura para diferentes categorias de assets se eles tiverem Pastas de Varredura diferentes? Isso causará conflitos?",
  "a_faq_window_assets_3": "Sim, você pode. Não haverá conflitos, pois uma tabela de assets separada (LocalizedAssetTable) é criada para cada categoria. As chaves da categoria \"Sprites\" não se sobrepõem às chaves da categoria \"AudioClips\", mesmo que sejam nomeadas da mesma forma.",
  "q_faq_window_assets_4": "Se um asset localizável (por exemplo, button_ok_en.png) não estiver na raiz da Pasta de Varredura, mas em uma subpasta, o scanner o encontrará?",
  "a_faq_window_assets_4": "Sim, encontrará. O scanner usa a opção SearchOption.AllDirectories, o que significa que verificará recursivamente todas as subpastas dentro da Pasta de Varredura que você especificar.",
  "q_faq_window_report_1": "O botão \"Encontrar\" procura o objeto de forma assíncrona. E se eu iniciar uma busca e depois clicar imediatamente em Atualizar Chaves? A busca será interrompida?",
  "a_faq_window_report_1": "Sim, será interrompida. Qualquer nova ação que exija o bloqueio da interface do usuário (como Atualizar Chaves) interromperá a corrotina de busca atual. Uma caixa de diálogo aparecerá, solicitando que você interrompa a busca atual para iniciar uma nova.",
  "q_faq_window_report_2": "Se uma chave for usada em vários lugares (por exemplo, em dois botões diferentes em cenas diferentes), como isso será exibido no relatório na categoria \"Duplicatas\"?",
  "a_faq_window_report_2": "A categoria \"Duplicatas\" mostrará todas as fontes para essa chave. Você verá uma entrada para a chave, e o campo \"Fonte\" listará todos os caminhos (na cena 1 e na cena 2). O botão \"Encontrar\" neste caso abrirá uma lista suspensa, permitindo que você escolha para qual objeto navegar.",
  "q_faq_window_report_3": "Se eu clicar em \"Encontrar\" para uma chave que é usada apenas em código (através da função _()), o que acontecerá? A ferramenta será capaz de encontrar e destacar o script C#?",
  "a_faq_window_report_3": "Sim. O sistema de busca é treinado especificamente para reconhecer fontes como o script MyScript.cs. Quando você clicar em \"Encontrar\", ele procurará o asset MyScript.cs no projeto e o destacará (ping) na janela do Projeto.",
  "q_faq_editor_1": "O que tem maior prioridade para validação de placeholder: a diretiva @placeholders: no comentário ou os placeholders encontrados no texto do idioma de origem? Por exemplo, se o texto de origem tiver {name} e o comentário disser @placeholders: {username}.",
  "a_faq_editor_1": "A diretiva @placeholders: no comentário tem prioridade. É considerada uma instrução explícita do desenvolvedor e a \"fonte da verdade\". No seu exemplo, o editor exigirá {username} na tradução e ignorará {name} do texto de origem.",
  "q_faq_editor_2": "Se eu cometer um erro de digitação na diretiva (por exemplo, @placeholder: em vez de @placeholders:), ela será ignorada ou a ferramenta emitirá um aviso?",
  "a_faq_editor_2": "Será simplesmente ignorada. A ferramenta procura uma correspondência exata de @placeholders:. Se a diretiva estiver escrita incorretamente, ela será tratada como parte de um comentário regular, e a validação funcionará da maneira antiga - com base nos placeholders do texto de origem.",
  "q_faq_editor_3": "O sistema de salvamento automático cria arquivos na pasta Backups/AutoSaves. Esses arquivos serão excluídos automaticamente após um salvamento manual bem-sucedido ou o fechamento da janela?",
  "a_faq_editor_3": "Sim. Após um salvamento manual bem-sucedido ou o fechamento normal da janela (quando você salva as alterações), todos os arquivos de salvamento automático são excluídos para evitar a solicitação de recuperação na próxima inicialização. Eles só permanecem em caso de travamento do editor.",
  "q_faq_editor_4": "Se eu alterar a largura das colunas no editor, essas configurações serão salvas entre as sessões do Unity?",
  "a_faq_editor_4": "Sim. A largura das colunas é salva em EditorPrefs cada vez que você fecha a janela do editor de tradução e será restaurada na próxima vez que você a abrir.",
  "q_faq_editor_5": "A janela pop-up de edição de texto (MultiLineEditWindow) suporta sua própria pilha de Desfazer/Refazer (via Ctrl+Z) para alterações feitas dentro dela?",
  "a_faq_editor_5": "Sim. A MultiLineEditWindow tem sua própria pilha temporária de Desfazer/Refazer que funciona enquanto a janela está aberta. Isso permite que você desfaça e refaça alterações de texto dentro dessa janela. Uma vez que você salva o resultado (fechando a janela), essa alteração é registrada como uma única ação na pilha global de Desfazer/Refazer do editor principal.",
  "q_faq_examples_1": "O que acontece se os nomes das propriedades no tipo anônimo passado para a função _() não corresponderem aos placeholders na string? Por exemplo, _(\"Olá, {username}\", new { user_name = \"Bob\" }). Haverá um erro, ou o placeholder simplesmente não será substituído?",
  "a_faq_examples_1": "Não haverá erro. O placeholder {username} simplesmente não será substituído, e você obterá a string \"Olá, {username}\" como resultado. A substituição só ocorre com uma correspondência exata de nome.",
  "q_faq_examples_2": "O atributo [LocalizableField] funciona para campos privados. Funcionará para campos estáticos?",
  "a_faq_examples_2": "Sim, funcionará. O parser usa reflexão para encontrar campos com as flags BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, então ele encontrará e processará campos estáticos.",
  "q_faq_examples_3": "Se eu colocar o atributo [OnLanguageChange] em um método com parâmetros (por exemplo, void UpdateUI(string newLang)), o que acontecerá? Haverá um erro de compilação ou um aviso em tempo de execução?",
  "a_faq_examples_3": "Não haverá erro de compilação, mas um aviso do LocalizedBehaviour aparecerá no console do Unity em tempo de execução. Ele informará que encontrou um método com o atributo, mas o ignorou porque o método tem parâmetros. Tal método não será chamado.",
  "q_faq_examples_4": "Estou usando _(\"apple_count\", count). Se não houver a chave apple_count_one para o idioma atual (para count = 1), qual forma o sistema escolherá? Ele usará apple_count_other como fallback?",
  "a_faq_examples_4": "Sim. Se uma forma específica (_one, _few, etc.) não for encontrada, o sistema tentará usar a chave com o sufixo _other como fallback. Se essa também não for encontrada, a tradução para a chave base apple_count será usada.",
  "q_faq_examples_5": "A função _(\"key\", new { username = \"Alex\" }) usa um tipo anônimo. Isso não criará uma \"carga\" excessiva no coletor de lixo (GC) com chamadas frequentes em um método Update() em comparação com a passagem de um Dictionary<string, object> pré-criado?",
  "a_faq_examples_5": "Sim, criará. Cada chamada para new { ... } aloca memória no heap gerenciado, o que cria trabalho extra para o coletor de lixo. Para texto que é atualizado a cada quadro (em Update ou LateUpdate), é significativamente mais performático criar um Dictionary<string, object> uma vez em Start(), e apenas atualizar seus valores em Update() antes de passá-lo para a função _().",
  "q_faq_notes_1": "A documentação recomenda adicionar o LanguageSelector à lista de ignorados. O que exatamente quebrará se eu esquecer de fazer isso? Chaves extras serão criadas para \"Opção A, Opção B\"?",
  "a_faq_notes_1": "Sim. Se você não adicionar o LanguageSelector à lista de ignorados, o parser tratará seu TMP_Dropdown como um dropdown regular. Ele encontrará o padrão \"Opção A, Opção B, Opção C\" que o Unity cria e adicionará chaves para eles aos seus arquivos de tradução. Isso desorganizará seus arquivos com chaves desnecessárias, pois o LanguageSelector removerá essas opções em tempo de execução e criará as suas próprias de qualquer maneira.",
  "q_faq_notes_2": "Se eu esquecer de adicionar um LocalizedText vazio com a caixa de seleção isStyleOnly habilitada no Label dentro do TMP_Dropdown usado pelo LanguageSelector, a fonte não mudará? Por que isso é necessário?",
  "a_faq_notes_2": "Sim, a fonte não mudará. Isso é necessário porque o LanguageSelector altera diretamente a propriedade label.text. Sem um LocalizedText neste objeto, o sistema de localização não sabe que este elemento precisa de estilos (fonte, RTL) aplicados quando o idioma muda. Um LocalizedText vazio com isStyleOnly serve como um \"marcador\" para o sistema, dizendo: \"Observe este objeto e aplique estilos a ele, mas não toque em seu texto\".",
  "q_faq_notes_3": "Chamar _() no método Update() não é recomendado. Mas e se eu precisar atualizar o texto a cada quadro (por exemplo, um cronômetro)? Qual é a maneira mais performática de fazer isso, armazenando em cache apenas a string de formato?",
  "a_faq_notes_3": "A abordagem mais performática é armazenar em cache a string de formato em Start() ou em um método [OnLanguageChange], e usar string.Format regular em Update(). Exemplo: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } Isso evita procurar a chave no dicionário a cada quadro, o que é significativamente mais rápido.",
  "q_faq_extending_1": "Meu parser personalizado será chamado automaticamente após cada Update Keys? Preciso registrá-lo em algum lugar, ou basta ter uma classe que implementa ITextComponentParser no projeto?",
  "a_faq_extending_1": "Apenas ter a classe é suficiente. Quando o TextParser é executado, ele usa reflexão para encontrar todas as classes no projeto que implementam a interface ITextComponentParser e chama automaticamente seu método Parse() para cada GameObject. Nenhum registro manual é necessário.",
  "q_faq_extending_2": "E se ocorrer uma exceção no meu parser personalizado? Ela interromperá todo o processo de análise, ou a ferramenta continuará com segurança com outros parsers?",
  "a_faq_extending_2": "Uma exceção em seu parser personalizado interromperá o processo. O loop de análise principal não envolve chamadas a parsers personalizados em um bloco try-catch. Se o seu método Parse() lançar uma exceção não tratada,",
  "toggle_notes_title": "Alternar Notas",
  "mindmap_toggle_title": "Mostrar Mapa Mental",
  "on_this_page_title": "Nesta Página",
  "my_notes_title": "Minhas Notas",
  "no_notes_message_new": "Passe o mouse sobre o texto para adicionar uma nota.",
  "notes_add_title": "Adicionar uma nota a este bloco",
  "notes_placeholder": "Sua nota...",
  "notes_close_title": "Fechar",
  "notes_goto_title": "Ir para o texto",
  "notes_edit_title": "Editar nota",
  "notes_delete_title": "Excluir nota",
  "notes_edit_text": "Editar",
  "copy_code_copy": "Copiar",
  "copy_code_copied": "Copiado!",
  "copy_code_error": "Erro",
  "error_loading_title": "Erro ao Carregar",
  "error_loading_message": "Por favor, verifique sua conexão e atualize.",
  "lightbox_aria_close": "Fechar visualizador de imagem",
  "lightbox_image_alt": "Visualização ampliada",
  "mindmap_preset_full": "Visão Completa",
  "mindmap_preset_quick_start": "Início Rápido",
  "mindmap_preset_dev": "Fluxo de Trabalho do Desenvolvedor",
  "mindmap_preset_translator": "Fluxo de Trabalho do Tradutor",
  "mindmap_edge_configure": "1. Configurar",
  "mindmap_edge_specify_content": "2. Especificar Conteúdo",
  "mindmap_edge_parse_project": "3. Analisar Projeto",
  "mindmap_edge_creates_components": "Cria Componentes",
  "mindmap_edge_generates": "Gera",
  "mindmap_edge_opens": "Abre",
  "mindmap_edge_manages_assets": "Gerencia assets para",
  "mindmap_edge_defines_rules": "Define regras para",
  "mindmap_edge_reports_on": "Relata sobre",
  "mindmap_edge_enables_reaction": "Permite reação via",
  "mindmap_edge_processed_by": "Processado por",
  "mindmap_edge_edited_in": "Editado em",
  "mindmap_edge_extends": "Estende",
  "mindmap_edge_warns_about": "Avisa sobre",
  "mindmap_edge_relates_to": "Relaciona-se com",
  "mindmap_edge_recommends_for": "Recomenda para",
  "mindmap_edge_see_faq": "Ver FAQ"
}