{
  "a_faq_addressables_1": "Addressablesパッケージがインストールされていること、設定が作成されていること、および「Scan Assets & Generate Tables」をクリックしてグループにキーが登録されていることを確認してください。",
  "a_faq_addressables_2": "アセットフォルダに<code>Translation Profile</code>を作成し、サービスタイプを選択し、APIキーを入力して、このプロファイルを<code>Settings</code>ウィンドウに割り当てます。",
  "a_faq_addressables_3": "Migrationウィンドウ（Components / Importタブ）には、Emergency Stubs機能を有効にする「Enable Stubs」ボタンがあります。この機能は、I2 LocalizationまたはUnity Localization用の偽のプレースホルダクラスを作成し、プラグインを削除した直後にプロジェクトをすぐにコンパイルできるようにします。この機能はANKO_ENABLE_MIGRATION_STUBS定義シンボルの切り替えで動作します。これにより「The type name 'Localize' could not be found」エラーを防ぎ、新しいシステムを使用するためにコードを適切にリファクタリングする時間が得られます。Enable Stubsは、古いローカリゼーションプラグインを削除した後のコンパイルエラーを修正できるようにします。v2.0では、マイグレーションシステムが<strong>Migration Profiles</strong>で拡張され、他のプラグインからのより堅牢な移行ルールが可能になりました。",
  "a_faq_audio_smart_update": "ツールは、ソーステキストが変更された場合にのみ音声ファイルを再生成するために、MD5ハッシュを使用したスマートバッチ処理を使用します。テキストコンテンツのMD5ハッシュを計算し、以前に生成された音声ファイルと比較します。テキストが変更されていない場合、再生成をスキップし、APIクレジットを節約します。これにより、不要なAPI呼び出しを防ぎ、音声を再生成する際のコストを削減します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、APIクレジットを節約します。",
  "a_faq_components_1": "いいえ、実行されません。MonoBehaviourを無効にすると、Awake()、OnEnable()、Start()を含むUnityのすべての「マジック」メソッドの呼び出しが防がれます。これは、重複したロジックの実行を避けるために意図的なものです。すべての初期化は、プレハブのローカライズされたバージョンのスクリプトで発生する必要があります。",
  "a_faq_components_2": "はい、元のオブジェクトの物理的な動作は無効になります。LocalizedPrefabコンポーネントは、そのGameObject上のすべてのRigidbodyおよびRigidbody2Dコンポーネントを見つけ、isKinematicプロパティをtrueに設定します。これにより、それらは動的な物理計算から効果的に削除され、見えないオブジェクトが落下したり、衝突に反応したりするなどの不要な動作を防ぎます。ただし、正しい動作のために、ローカライズされたバージョブのプレハブには必要なすべての物理コンポーネントが含まれていることが引き続き推奨されます。",
  "a_faq_components_3": "はい、そうなります。コンポーネントは名前空間とアセンブリを含む完全な型名を保存します。スクリプトの名前を変更したり、別の .asmdef に移動したりするとこの名前が変わり、LocalizedAsset は対象コンポーネントを見つけられなくなります。名前を更新するには、Analyze Project & Attach Components を実行して再度解析する必要があります。",
  "a_faq_components_4": "LocalizedAssetは、特定のコンポーネントインスタンスに対して作成されます。コード内でそのコンポーネントへの参照を保持します。2番目のLocalizedAssetを手動で追加し、「Analyze for Localization」コンテキストメニューを使用して2番目のImageをターゲットにした場合、それぞれが独自のImageを管理する2つのLocalizedAssetコンポーネントが存在することになります。自動アナライザーは、ローカライズ可能なアセットを持つ最初のImageに対してのみコンポーネントを作成します。",
  "a_faq_components_5": "はい、完了しています。LocalizedPrefabは、OnEnable()メソッドでローカライズされたプレハブのインスタンスを作成します。Unityの実行順序は、すべてのAwake()メソッドがすべてのOnEnable()メソッドの前に実行されることを保証します。したがって、実行順序-110のスクリプトはAwake()を実行し、次に実行順序-100のLocalizedPrefabがAwake()を実行し、その後でのみOnEnable()メソッドが順番に呼び出されます。スクリプトはまだ作成されていないため、オブジェクトを見つけることはできません。",
  "a_faq_components_6": "キーとテキストの両方が変更されます。SetFormattedTextをプログラムで呼び出すと、その特定の更新に対してisStyleOnlyの動作が上書きされます。isStyleOnlyオプションは、コンポーネントがグローバルな言語変更に反応するのを防ぐことを目的としていますが、コードによる直接的なキーの変更には常に反応します。",
  "a_faq_components_7": "任意のアクセス修飾子（public、private、protected、internal）を持つメソッドを見つけます。UnityのReflectionは、アクセスレベルに関係なく、すべてのインスタンスメソッドの検出を可能にします。",
  "a_faq_components_8": "古い（ローカライズされていない）アセットの使用は可能です。LocalizedAssetはOnEnable()で交換を実行します。すべてのスクリプトのAwake()メソッドはOnEnable()の前に実行されます。スクリプトがAwake()でaudioSource.clipにアクセスする場合、元のクリップが取得されます。Start()でアクセスする場合、結果はスクリプトの実行順序によって異なります。ローカライズされたアセットへのアクセスを保証するには、スクリプトの実行順序を遅く設定するか、[OnLanguageChange]でマークされたメソッドでアセットにアクセスします。",
  "a_faq_custom_keys_attribute": "はい。**Content Tab**の「Attributes to Scan」の下で、任意の属性名（例：<code>[Header]</code>、<code>[TermsPopup]</code>）を追加できます。パーサーは、その属性を持つすべての文字列フィールドをローカライズ可能として扱います。",
  "a_faq_custom_provider_1": "クラスが<code>IAssetProvider</code>を実装し、抽象クラスでなく、<code>[AssetProviderPlugin]</code>属性が付与されていることを確認してください。また、ツールはプロバイダーを検出するためにすべてのアセンブリをスキャンするので、起動時にコンソールにリフレクション関連のエラーがないか確認してください。",
  "a_faq_editor_1": "コメント内の@placeholders:ディレクティブが優先されます。これは開発者からの明示的な指示であり、「信頼できる情報源」と見なされます。この例では、エディタは翻訳に{username}を要求し、ソーステキストからの{name}は無視します。",
  "a_faq_editor_2": "単に無視されます。ツールは@placeholders:の正確な一致を探します。ディレクティブのスペルが間違っている場合、それは通常のコメントの一部として扱われ、検証は古い方法、つまりソーステキストからのプレースホルダーに基づいて機能します。",
  "a_faq_editor_3": "はい。手動での保存が成功した後、または通常のウィンドウの閉鎖時（変更を保存するとき）に、次回の起動時に回復を求めるプロンプトが表示されるのを避けるために、すべてのオートセーブファイルは削除されます。エディタがクラッシュした場合にのみ残ります。",
  "a_faq_editor_4": "はい。列幅は、翻訳エディタウィンドウを閉じるたびにEditorPrefsに保存され、次回開いたときに復元されます。",
  "a_faq_editor_5": "はい。MultiLineEditWindowには、ウィンドウが開いている間機能する独自のits一時的なUndo/Redoスタックがあります。これにより、そのウィンドウ内でのテキストの変更をアンドゥおよびリドゥできます。結果を保存すると（ウィンドウを閉じることによって）、この変更はメインエディタのグローバルなUndo/Redoスタックに単一のアクションとして記録されます。",
  "a_faq_examples_1": "エラーは発生しません。{username}プレースホルダーは単に置き換えられず、「Hello, {username}」という文字列が結果として得られます。置き換えは、正確な名前の一致があった場合にのみ発生します。",
  "a_faq_examples_2": "はい、機能します。パーサーは、BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Staticフラグを持つフィールドを見つけるためにReflectionを使用するため、スタティックフィールドを見つけて処理します。",
  "a_faq_examples_3": "コンパイルエラーは発生しませんが、UnityコンソールにLocalizedBehaviourからの警告が表示されます。属性を持つメソッドが見つかったが、メソッドにパラメーターがあるため無視されたことが報告されます。このようなメソッドは呼び出されません。",
  "a_faq_examples_4": "はい。特定の形式（_one、_fewなど）が見つからない場合、システムはフォールバックとして_otherサフィックスを持つキーを使用しようとします。それも見つからない場合は、ベースキーapple_countの翻訳が使用されます。",
  "a_faq_examples_5": "はい、かけます。new { ... }の各呼び出しは、マネージドヒープにメモリを割り当て、ガベージコレクターに余分な作業を作成します。毎フレーム更新されるテキスト（UpdateまたはLateUpdate内）の場合、Start()でDictionary<string, object>を一度作成し、Update()でその値を更新してから_()関数に渡す方が、パフォーマンスが大幅に向上します。",
  "a_faq_examples_6": "メソッドにパラメーターがあるかどうかを確認してください。<code>[OnLanguageChange]</code>属性は、**パラメーターのない**メソッド（例：<code>void UpdateUI()</code>）でのみ機能します。メソッドに引数が必要な場合は、パラメーターのないメソッドでラップしてください。",
  "a_faq_extending_1": "クラスがあるだけで十分です。TextParserが実行されると、Reflectionを使用してITextComponentParserインターフェースを実装するプロジェクト内のすべてのクラスを見つけ、GameObjectごとにParse()メソッドを自動的に呼び出します。手動での登録は必要ありません。",
  "a_faq_extending_2": "カスタムパーサーでの例外は、プロセスを中断します。メインのパース処理ループは、カスタムパーサーへの呼び出しをtry-catchブロックでラップしません。Parse()メソッドが未処理の例外をスローすると、",
  "a_faq_installation_1": "インストーラーは、Newtonsoft.Json.JsonConvertタイプが存在するかどうかをチェックします。このタイプが存在する場合、依存関係が満たされていると見なし、パッケージのインストールまたは更新を試みません。これはバージョン競合を防ぐために行われます。",
  "a_faq_installation_2": "Tools -> Localization -> Check Dependenciesメニューから、いつでも手動で依存関係チェックをトリガーできます。これにより、「Don't ask again」フラグがリセットされ、不足しているすべてのオプションパッケージを含むウィンドウが再び表示されます。",
  "a_faq_installation_3": "これは、Assets/Resourcesフォルダがない場合に発生する可能性があります。ツールはそれを作成しようとしますが、ファイルシステムのアクセス許可によって妨げられる可能性があります。はい、手動でアセットを作成できます。Resourcesフォルダ内で右クリックし、Create -> Localization -> Settingsを選択します。ツールはそれを自動的に見つけます。",
  "a_faq_installation_4": "はい。ツールはResources.Load()を使用します。これは、プロジェクト内のResourcesという名前のすべてのフォルダで名前によってアセットを検索します。重要なのは、ファイルがその名前LocalizationSettings.assetを保持していることです。",
  "a_faq_installation_5": "はい。Window -> Package Managerを開き、「+」アイコンをクリックして、「Add package by name...」を選択できます。パッケージ名com.unity.nuget.newtonsoft-jsonとcom.unity.editorcoroutinesを入力します。",
  "a_faq_notes_1": "はい。LanguageSelectorを無視リストに追加しない場合、パーサーはそのTMP_Dropdownを通常のドロップダウンとして扱います。Unityが作成するデフォルトの「Option A、Option B、Option C」を見つけ、それらのキーを翻訳ファイルに追加します。これにより、LanguageSelectorが実行時にこれらのオプションを削除し、独自のオプションを作成するため、ファイルに不要なキーがごちゃ混ぜになります。",
  "a_faq_notes_2": "はい、フォントは変更されません。これは、LanguageSelectorがlabel.textプロパティを直接変更するためです。このオブジェクトにLocalizedTextがないと、ローカライゼーションシステムは、この要素に言語が変更されたときにスタイル（フォント、RTL）を適用する必要があることを知りません。isStyleOnlyを持つ空のLocalizedTextは、「このオブジェクトを監視し、スタイルを適用しますが、テキストには触れないでください」という、システムへの「マーカー」として機能します。",
  "a_faq_notes_3": "最もパフォーマンスの高いアプローチは、Start()または[OnLanguageChange]メソッドでフォーマット文字列をキャッシュし、Update()で通常のstring.Formatを使用することです。例：private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } これにより、毎フレーム辞書でキーを検索する必要がなくなり、大幅に高速になります。",
  "a_faq_runtime_api_key_distinction": "<strong>Q: 'Translation Service Keys' と 'Runtime API Key' の違いは何ですか？</strong><br>A: <strong>Translation Service Keys</strong>（OpenAI、DeepL）は<strong>Unity Editor</strong>で翻訳を生成する際に使用されます。これらはコンピュータのレジストリ（EditorPrefs）に保存され、ビルドには含まれません。<br><strong>Runtime API Key</strong>は<strong>Game Build</strong>でライブアップデートを取得するために使用されます。ビルドに含まれ（暗号化されて）います。",
  "a_faq_tts_voices": "<strong>Translation Profile</strong>（インスペクター）で、「Voice Mappings」リストを使用します。Regexパターン（例：<code>^hero_.*</code>）を特定のボイスIDにマッピングできます。ジェネレーターは、キー名に基づいて正しいボイスを自動的に選択します。",
  "a_faq_window_actions_1": "ツールは、リトライポリシー設定（試行回数と遅延）に従って、失敗した正確なバッチを再送信しようとします。このバッチのすべての試行が失敗した場合、現在の言語の翻訳プロセスは中断され、エラーがコンソールにログに記録されます。キュー内の次の言語の翻訳は開始されません。",
  "a_faq_window_actions_2": "空の値は既存の翻訳を置き換えます。インポートプロセスは、CSVファイルを「信頼できる情報源」と見なします。キーwelcome_messageのru列の値が空の場合、このキーの現在のロシア語翻訳は上書きされます。",
  "a_faq_window_actions_3": "はい、削除します。「危険ゾーン」の機能は、プロジェクト内のすべてのプレハブ（AssetDatabase.FindAssets(\"t:Prefab\")）をスキャンし、パース処理リストで指定されたものだけでなく、可能な限り最も完全なクリーンアップを保証します。",
  "a_faq_window_actions_4": "Google Sheetsドキュメントでは、列のタイトルは「Developer Notes」である必要があります。この列のセルには、通常どおりコメントを記述できます。プレースホルダーを指定するには、コメントテキストに@placeholders: {username}, {score}のような行を追加するだけです。ツールは、インポート時にこのディレクティブを自動的に認識します。",
  "a_faq_window_actions_5": "ツールは一度に1つのシートでのみ機能します。インポートURLにはgid=...パラメーターが含まれており、これはドキュメント内の特定のシートを一意に識別します。別のシートからデータをインポートするには、そのURL（別のgidを持つ）をコピーし、インポートを再度実行する必要があります。",
  "a_faq_window_assets_1": "アセットスキャナーは、予想されるタイプを指定してロードします（AssetDatabase.LoadAssetAtPath(path, expectedType)）。AudioClipカテゴリの場合、UnityがAudioClipとして認識するファイルのみを検索してロードします。両方のファイルが有効なオーディオクリップである場合、最後に処理されたファイルがテーブルに含まれ、事実上前のファイルを上書きします。このような重複は避けることをお勧めします。",
  "a_faq_window_assets_2": "はい、それが正確に機能する方法です。「Analyze Project」はImageコンポーネントを見つけ、それに割り当てられたスプライトの名前（例：icon_play_en）を見て、そこからキー（icon_play）と言語（en）を抽出し、そのGameObjectにLocalizedAssetコンポーネントを追加し、キーicon_playをそれに書き込みます。",
  "a_faq_window_assets_3": "はい、使用できます。カテゴリごとに別のアセットテーブル（LocalizedAssetTable）が作成されるため、競合はありません。「Sprites」カテゴリのキーは、「AudioClips」カテゴリのキーと、名前が同じであっても重複しません。",
  "a_faq_window_assets_4": "はい、見つけます。スキャナーはSearchOption.AllDirectoriesオプションを使用します。これは、指定したScan Folder内のすべてのサブフォルダを再帰的にチェックすることを意味します。",
  "a_faq_window_content_1": "いいえ、影響しません。Scenes to Parseリストは、ツールにどのシーンを開いてテキストを分析するかを知らせるためだけに使用されます。最終的なゲームビルドに含まれるシーンとは一切関係ありません。",
  "a_faq_window_content_2": "いいえ、無視されません。一時リストは、シーン内のオブジェクトへの直接参照を保存します。プレハブを作成すると、それは新しいアセットです。そのインスタンスは異なるオブジェクトであり、無視ルールはそれらに適用されません。プレハブを永続的に無視するには、それらをプレハブアセットとして無視リストに追加する必要があります。",
  "a_faq_window_content_3": "はい、削除されます。Update Keysをクリックすると、パーサーはプロジェクト全体を再スキャンします。TMPro.TMP_Textタイプを無視する必要があると判断し、それに対するキーを生成しません。古いキーと新しいキーを比較するプロセス中に、古いキーが使用されなくなったと判断し、「Removed」としてマークします。",
  "a_faq_window_content_4": "いいえ、機能しません。「Pin」は、ボタンがクリックされた時点でのシーンヒエラルキー内の絶対パス（例：Canvas/Panel/Button）を保存します。このパスはプレハブロジックとは関係ありません。プレハブインスタンスは同じパスを持ちますが、シーン内の親オブジェクトの名前を変更すると、「Pin」はオリジナルとインスタンスの両方で機能しなくなります。",
  "a_faq_window_content_5": "シーンルートからの完全なパスが保存されます。例：MyPrefab(Clone)/Content/Icon。この「ピン留めされた」パスは、それを作成したシーンでのみ機能します。他のシーンでは、そのようなパスが見つかる可能性は低いです。",
  "a_faq_window_preview_1": "いいえ、保存されません。PreviewSafetyBridgeはアセット保存イベント（OnWillSaveAssets）をインターセプトし、Unityがディスクに変更を書き込む前に自動的にRevertEditorPreview()を呼び出します。そのため、プレハブは元のローカライズされていない状態で保存されます。",
  "a_faq_window_preview_2": "PreviewRecoveryServiceはクラッシュ復旧を処理します。Unityがクラッシュした場合、次回起動時にバックアップファイルを検出し、シーン状態の復元を試みます。自動復旧に失敗した場合は、ツールウィンドウで手動で「Revert to Original」を選択する必要があります。",
  "a_faq_window_preview_3": "はい、実行されます。編集モードでのPrefabUtility.InstantiatePrefabは、Awake()とOnEnable()を呼び出します。これらのメソッドに、再生モードでのみ存在するシングルトンへのアクセスなど、エディタで実行すべきではないロジックが含まれている場合、エラーを引き起こす可能性があります。そのようなコードを保護するために、if (Application.isPlaying)または#if UNITY_EDITORを使用することをお勧めします。",
  "a_faq_window_report_1": "はい、中断されます。UIブロッキングを必要とする新しいアクション（Update Keysなど）は、現在の検索コルーチンを停止します。ダイアログボックスが表示され、新しい検索を開始するために現在の検索を停止するように求められます。",
  "a_faq_window_report_2": "「Duplicates」カテゴリには、そのキーのすべてのソースが表示されます。キーのエントリが1つ表示され、「Source」フィールドにすべてのパス（シーン1とシーン2）がリストされます。この場合、「Find」ボタンはドロップダウンリストを開き、どのオブジェクトにナビゲートするかを選択できます。",
  "a_faq_window_report_3": "はい。検索システムは、スクリプトMyScript.csなどのソースを認識するように特別に訓練されています。「Find」をクリックすると、プロジェクト内でMyScript.csアセットを検索し、Projectウィンドウでハイライト表示（ping）します。",
  "a_faq_window_settings_1": "はい、マッピングされます。モードを変更すると、ツールは「安全な移行」を実行します。プロジェクト全体を再パースし、新しいルールに従って新しいキーを作成しますが、元のテキストを介して古いキーと新しいキーをマッピングします。次に、既存のすべての翻訳とコメントを古いキーから新しいキーに転送します。翻訳が失われることはありません。",
  "a_faq_window_settings_2": "DefaultPluralRuleが使用されます。これは英語およびほとんどのヨーロッパ言語に適しています（「one」と「other」の形式）。",
  "a_faq_window_settings_3": "いいえ、含まれません。StreamingAssetsまたはResourcesフォルダにあるアセットのみがビルドに含まれることが保証されています。別のパスを指定した場合、翻訳ファイルはビルドの一部にならないため、ローカライゼーションはエディタでは機能しますが、コンパイルされたゲームでは機能しません。",
  "a_faq_window_settings_4": "はい。EditorPrefsは各コンピュータのローカルストレージです。各マシンで<strong>Translation Service API Key</strong>（OpenAI/DeepLなどエディタ使用向け）を入力する必要があります。ただし、ビルドで使用される<strong>Runtime API Key</strong>はプロジェクト設定に保存され、ソースコントロールで共有されます（暗号化）。",
  "code_async_example": "using Ankonoanko.Localization.Next;\n\nprivate async void Start() {\n    // Correct way to load localized assets with Addressables\n    var sprite = await LocalizationManager.Instance.GetLocalizedAssetAsync<Sprite>(\"flag_icon\");\n    myImage.sprite = sprite;\n}",
  "code_bridge_example": "// Using the generated class (Strongly Typed)\nstring text = AnkoLoc.MyKey;\n\n// Instead of using strings\nstring text = _(\"MyKey\");",
  "code_custom_attribute_example": "// Using custom attributes for automatic scanning\npublic class MyScript : MonoBehaviour {\n    [LocalizableField]\n    public string npcName; // Automatically found\n\n    [Header(\"Title\")] \n    // If you add \"Header\" to Attributes to Scan, this will also be found!\n    public string sectionTitle;\n}",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\nusing Ankonoanko.Localization.Next;\n\n// TEMPLATE for creating a parser for a custom component.\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings,\n        string prefabContextPath,\n        Dictionary<string, string> textToKeyMap = null,\n        List<Regex> ignoreRegexes = null,\n        bool migrationActive = false)\n    {\n        // 1. Check if the object has the custom component we need.\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // Exit if the component is not found\n        }\n        \n        // 2. Get the text from the custom component's fields.\n        string titleText = component.Title;\n        \n        // 3. Check if the text is valid for localization.\n        // We use ParsingLogic helper to check against ignore patterns\n        if (ParsingLogic.IsValidLocalizableText(titleText, ignoreRegexes))\n        {\n            // 4. Generate the key and source using helpers from ParsingLogic.\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap);\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            \n            // 5. Return the result.\n            yield return (titleText, key, source);\n        }\n        \n        // 6. Repeat for other fields...\n        string descriptionText = component.Description;\n        if (ParsingLogic.IsValidLocalizableText(descriptionText, ignoreRegexes))\n        {\n            string key = ParsingLogic.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode, prefabContextPath, null, textToKeyMap) + \"_desc\";\n            string source = ParsingLogic.GetSourceStringForObject(gameObject, prefabContextPath);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "code_custom_provider_example": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Ankonoanko.Localization.Next\n{\n    [AssetProviderPlugin(\n        \"My Custom System\",  // ← Name visible to user\n        \"Description of your asset loading system\",  // ← Short description\n        Author = \"Your Name\",\n        Version = \"1.0\"\n    )]\n    public class MyCustomProvider : IAssetProvider\n    {\n        private Dictionary<string, UnityEngine.Object> _loadedAssets = new();\n        private string _currentLanguage;\n\n        public string ProviderName => \"My Asset System\";\n        public bool SupportsSyncLoading => true;\n        public bool SupportsAsyncLoading => true;\n\n        public void Initialize(LocalizationSettings settings) { /* Init system */ }\n\n        public T Load<T>(string key) where T : UnityEngine.Object {\n            if (_loadedAssets.TryGetValue(key, out var cached)) return (T)cached;\n            T asset = Resources.Load<T>(key); // Replace with your logic\n            if (asset != null) _loadedAssets[key] = asset;\n            return asset;\n        }\n\n        public async Task<T> LoadAsync<T>(string key) where T : UnityEngine.Object {\n            return await Task.Run(() => Load<T>(key));\n        }\n\n        public void Unload(string key) => _loadedAssets.Remove(key);\n        public void UnloadAll() => _loadedAssets.Clear();\n        public bool Exists(string key) => true;\n        public void Dispose() => UnloadAll();\n\n        public void SetCurrentLanguage(string lang) {\n            _currentLanguage = lang;\n            UnloadAll(); // Clear cache for new language\n        }\n    }\n}",
  "code_example_attribute": "using Ankonoanko.Localization.Next;\nusing UnityEngine;\nusing System.Collections.Generic;\n\n// 1. Unattached & Base Classes (No MonoBehaviour needed)\npublic class BaseData { \n    [LocalizableField] protected string rarity = \"Common\"; \n}\n\npublic class MegaTest : BaseData // Inherited fields are scanned!\n{\n    // 2. Basic Fields (Public, Private, Protected)\n    [LocalizableField] private string _private = \"Private Field\";\n    [LocalizableField] public string PublicField = \"Public Field\";\n\n    // 3. Properties (Auto & Full)\n    [LocalizableField] public string AutoProp { get; set; } = \"Auto Property\";\n    [LocalizableField] public string GetOnly { get; } = \"Get Only Property\";\n\n    // 4. Static & Constants (Global text)\n    public const string GLOBAL_CONST = \"Global Const Value\";\n    [LocalizableField] public static string StaticField = \"Static Global Text\";\n    \n    // Roslyn resolves these references during scan:\n    private const string LOCAL_CONST = \"LocalConst\";\n    [LocalizableField] public string ReferenceConst = LOCAL_CONST;\n    [LocalizableField] public string GlobalConstRef = GLOBAL_CONST;\n\n    // 5. String Concatenation & Interpolation (Calculated at parse time)\n    [LocalizableField] public string Concat1 = \"Hello \" + \"World\";\n    [LocalizableField] public string Concat2 = \"Prefix: \" + LOCAL_CONST;\n    \n    // 6. Custom Keys & Attributes\n    [LocalizableField(\"main_menu_title\")] public string Title = \"Game Title\";\n    [LocalizableField(key: \"custom_key_syntax\")] public string KeySyntax = \"Explicit Key\";\n    \n    [Header(\"Header Text\")] // Scanned if 'Header' added to Attributes to Scan\n    [Tooltip(\"Tooltip Text\")]\n    public string annotatedField;\n    \n    // 7. Collections (Arrays, Lists, Target-typed new)\n    [LocalizableField] public string[] Array1 = { \"A\", \"B\" };\n    [LocalizableField] public List<string> List1 = new List<string> { \"C\", \"D\" };\n    [LocalizableField] public List<string> ListNew = new() { \"E\", \"F\" }; // C# 9.0+\n    \n    // 8. Nested Objects (Deep Recursion)\n    [System.Serializable]\n    public class DialogStep {\n        [LocalizableField] public string actorName;\n        [LocalizableField] public string message;\n    }\n    [LocalizableField] public DialogStep introStep; \n    [LocalizableField] public List<DialogStep> dialogSelect; // List of objects!\n}",
  "code_example_attribute_limitations": "[LocalizableField]\npublic Dictionary<string, string> Dict; // FAIL: Dictionary (Use Lists)\n\n[LocalizableField]\npublic int Number = 5; // FAIL: Non-string types",
  "code_example_function": "// 1. Add Static Import for short syntax\nusing static Ankonoanko.Localization.Next.LocalizationManager; \n\npublic class RuntimeExample : MonoBehaviour {\n    void Demo() {\n        // 2. Simple Key/Text lookup\n        _(\"Hello World\");\n        \n        // 3. Indexed Formatting ({0}, {1})\n        _(\"Score: {0} / {1}\", 10, 20); \n\n        // 4. Named Arguments (Smart Formatting)\n        // Uses anonymous object. Key = \"welcome_user\"\n        _(\"welcome_user\", new { name = \"Hero\", level = 5 }); \n\n        // 5. Pluralization (Integer argument)\n        // Automatically finds key_one, key_few, key_many\n        _(\"coins_count\", 5); \n\n        // 6. Genderization (Gender enum)\n        // Automatically finds key_male, key_female\n        _(\"npc_greeting\", Gender.Female);\n\n        // 7. Manual Dictionary (High performance / Dynamic)\n        var args = new Dictionary<string, object> { { \"rank\", \"S\" } };\n        _(\"rank_msg\", args);\n\n        // 8. Nesting (Translating arguments recursively)\n        _(\"Element: {0}\", _(\"Fire\")); \n    }\n}",
  "code_example_plurals": "using static Ankonoanko.Localization.Next.LocalizationManager;\nusing Ankonoanko.Localization.Next;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // Keys: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // Texts: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // Automatically selects the correct form\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // Keys: \"user_greeted_male\", \"user_greeted_female\"\n        // Texts: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "code_script_rule_example": "// Supporting custom or third-party functions\n// Before: The scanner only sees _(\\\"key\\\") calls\nstring text = MyLegacySystem.Translate(\\\"old_key\\\");\nstring i2Text = LocalizationManager.GetTranslation(\\\"I2_KEY\\\");\n\n// After: Add a Script Parsing Rule with regex pattern\n// These keys will now be automatically indexed and managed by the tool!",
  "copy_code_copied": "コピーしました！",
  "copy_code_copy": "コピー",
  "copy_code_error": "エラー",
  "error_loading_message": "接続を確認し、更新してください。",
  "error_loading_title": "読み込みエラー",
  "h1_ai_audio": "AI音声 / テキスト読み上げ (Text-to-Speech)",
  "h1_ai_profiles": "AI と翻訳プロファイル",
  "h1_api_snippets": "API とコードスニペット",
  "h1_components": "コアコンポーネント（自動的に割り当てられます）",
  "h1_extending": "機能の拡張",
  "h1_faq": "FAQとトラブルシューティング",
  "h1_font_glyph_manager": "フォント＆グリフマネージャ",
  "h1_important_notes": "重要な注意事項と警告",
  "h1_introduction": "はじめに",
  "h1_loc_tool_window": "「ローカライゼーションツール」ウィンドウ",
  "h1_migration_tool": "移行ツール",
  "h1_quick_start": "クイックスタートとセットアップ",
  "h1_tms": "外部 TMS 統合 (Crowdin, Loco, Phrase, Transifex)",
  "h1_translation_editor": "翻訳テーブルエディタ",
  "h1_usage_examples": "使用例",
  "h2_ai_assistant": "AI アシスタントコマンド",
  "h2_ai_audio_setup": "セットアップ",
  "h2_ai_audio_usage": "使用方法",
  "h2_ai_context": "コンテキストと用語集",
  "h2_ai_profiles_overview": "翻訳プロファイル",
  "h2_async_api": "非同期 API (Addressables)",
  "h2_backup_manager": "バックアップマネージャー",
  "h2_bridge_generation": "C# ブリッジを生成（強く型付けされたアクセス）",
  "h2_custom_ai": "カスタム AI とモデル",
  "h2_custom_asset_provider": "カスタムアセットプロバイダーの作成",
  "h2_custom_attributes": "カスタム属性スキャン",
  "h2_custom_parser": "カスタムパーサーの作成",
  "h2_example_attribute": "[LocalizableField] 属性",
  "h2_example_components": "既製コンポーネントと例",
  "h2_example_components_updated": "更新された LanguageSelector.cs",
  "h2_example_function": "_() 関数 と [OnLanguageChange] 属性",
  "h2_example_plurals": "複数形と性別",
  "h2_faq_addressables": "Addressablesと移行",
  "h2_faq_audio": "AI音声 / テキスト読み上げ (Text-to-Speech)",
  "h2_faq_components": "コアコンポーネント",
  "h2_faq_editor": "翻訳エディタ",
  "h2_faq_examples": "使用例とコード",
  "h2_faq_extending": "機能拡張",
  "h2_faq_installation": "インストールとクイックスタート",
  "h2_faq_notes": "重要なニュアンスと警告",
  "h2_faq_window": "\"Localization Tool\" ウィンドウ",
  "h2_font_glyph_manager_features": "機能",
  "h2_in_editor_preview": "エディター内 & Prefab プレビュー",
  "h2_initial_setup": "初期設定",
  "h2_installation": "インストール",
  "h2_key_features": "主な機能",
  "h2_live_updates_guide": "ライブアップデートガイド",
  "h2_localizedasset": "ローカライズされたアセット",
  "h2_localizedasset_updated": "LocalizedAssetの非同期ローディング",
  "h2_localizedbehaviour": "ローカライズされたBehaviour",
  "h2_localizeddropdown": "ローカライズされたドロップダウン",
  "h2_localizedprefab": "ローカライズされたPrefab",
  "h2_localizedtext": "ローカライズされたテキスト",
  "h2_migration_custom": "カスタムプロファイルの作成",
  "h2_migration_google_sheets": "Google Sheets キー",
  "h2_migration_import_formats": "インポート形式（CSV と Google Sheets）",
  "h2_migration_stubs": "安全なマイグレーションと緊急スタブ",
  "h2_migration_tool_features": "機能",
  "h2_migration_workflow": "マイグレーションワークフローガイド",
  "h2_preview_overlay": "シーンビューオーバーレイ",
  "h2_safety_caps": "制限と安全クオータ",
  "h2_script_parsing_rules": "スクリプト解析ルール（互換性）",
  "h2_tab_actions": "\"Actions\" タブ",
  "h2_tab_assets": "\"Assets\" タブ",
  "h2_tab_content": "\"Content\" タブ",
  "h2_tab_report": "\"Report\" タブ",
  "h2_tab_settings": "\"Settings\" タブ",
  "h2_tab_tutorials": "\"Tutorials\" タブ",
  "h2_tms_setup": "セットアップと使用方法",
  "h2_tms_supported": "サポートされているサービス",
  "h2_uitklocalization": "UITKローカリゼーション",
  "h2_visual_debugging_guide": "ビジュアルデバッグ",
  "h2_window_footer": "ウィンドウフッター (ステータスバー)",
  "h2_window_header": "ウィンドウヘッダーとツールバー",
  "h2_window_sidebar": "メインメニュー（サイドバー）",
  "h3_actions_autotranslate": "自動翻訳",
  "h3_actions_danger": "危険ゾーン",
  "h3_actions_data": "データ管理",
  "h3_actions_editor": "翻訳エディタ",
  "h3_actions_parsing": "解析",
  "h3_actions_tms_integration": "外部サービス（TMS）",
  "h3_assets_automation": "自動化",
  "h3_assets_categories": "アセットカテゴリ",
  "h3_assets_folder_gen": "フォルダー生成",
  "h3_assets_loading": "ロード戦略",
  "h3_assets_storage": "ストレージ構成",
  "h3_attribute_cheat_sheet": "クイックリファレンス: 推奨事項と非推奨事項",
  "h3_attribute_features": "サポートされている型と機能",
  "h3_attribute_limitations": "制限事項",
  "h3_content_components_ignore": "無視するコンポーネントタイプ",
  "h3_content_dynamic_keys": "動的キー接頭辞",
  "h3_content_dynamic_texts": "動的テキスト",
  "h3_content_objects_ignore": "無視するオブジェクト",
  "h3_content_prefabs": "Prefab フォルダー",
  "h3_content_regex": "無視する正規表現パターン",
  "h3_content_scenes": "解析対象シーン",
  "h3_content_script_rules": "スクリプト解析ルール",
  "h3_content_scripts_ignore": "無視するスクリプト",
  "h3_custom_provider_steps": "実装手順",
  "h3_faq_window_actions": "「アクション」タブ",
  "h3_faq_window_assets": "「アセット」タブ",
  "h3_faq_window_content": "「コンテンツ」タブ",
  "h3_faq_window_preview": "エディタ内プレビュー",
  "h3_faq_window_report": "「レポート」タブ",
  "h3_faq_window_settings": "「設定」タブ",
  "h3_mode_auto": "AutoGenerateKeysOnly（標準）",
  "h3_mode_hybrid": "ハイブリッドモード（カスタム優先度）",
  "h3_mode_text": "UseTextAsKey（簡易）",
  "h3_report_all_keys": "すべてのキー",
  "h3_settings_debugging": "デバッグ",
  "h3_settings_general": "一般設定",
  "h3_settings_keygen": "キー生成",
  "h3_settings_languages": "言語管理",
  "h3_settings_liveupdates": "ライブアップデート",
  "h3_settings_pseudo": "擬似ローカリゼーション設定",
  "h3_settings_runtimeapi": "ランタイム API",
  "h3_settings_tools": "一般および開発ツール",
  "h3_tutorials_list": "チュートリアル一覧",
  "lbl_not_supported": "サポートされていません",
  "lbl_supported": "完全にサポート",
  "li_actions_1": "<strong>パース処理:</strong><ul><li><strong>Update Keys:</strong> 「コンテンツ」タブの設定で定義された完全なプロジェクトスキャン。</li><li><strong>Scan Selected Assets:</strong> Project Viewで現在選択されているファイル/フォルダ**のみ**をスキャンします。「Remove Missing Keys」を自動的に無効にするため、部分的な更新に安全です。</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> すべての翻訳を編集するための、より便利な独立したウィンドウを開きます。",
  "li_actions_3": "<strong>Data Management:</strong> 翻訳者とのデータ交換に使用します（CSV/XML/YAML/XLIFFへのエクスポート/インポート、Google Sheetsからのインポート）。<strong>Google Sheets:</strong> 'Edit'リンクと'Publish to Web' URLの両方をサポートします（GIDパラメータを確認）。",
  "li_actions_4": "<strong>自動翻訳:</strong> アクティブな<strong>Translation Profile</strong>を使用して、すべての空の翻訳文字列を自動的に埋めます。",
  "li_actions_5": "<strong>危険ゾーン:</strong> プロジェクトからすべてのローカライゼーションコンポーネントを完全に削除するためのボタンが含まれています。注意して使用してください！",
  "li_ai_1": "<strong>プロファイルの作成:</strong> Projectビューで右クリック -> Create -> Localization -> Translation Profile。",
  "li_ai_2": "<strong>サービス:</strong> DeepL、Google Translate、Microsoft Azure、および**Custom AI**をサポートします。",
  "li_ai_3": "<strong>設定:</strong> 各プロファイルは、独自のAPIキー、制限（バッチサイズ、最大文字数）、およびモデル設定を保存します。",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> 組み込みのジェネレーターを使用して、人気のあるサービス（OpenAI、Gemini、Claude、Ollama）のプロファイルをすばやく作成します。",
  "li_ai_audio_generate": "<strong>Translation Table Editor</strong>で、行/セルを選択 -> 右クリック -> **Generate Audio**。",
  "li_ai_audio_hash": "<strong>スマートアップデートとハッシュ化:</strong> ツールはテキストコンテンツのMD5ハッシュを計算し、ソーステキストが変更された場合にのみ音声ファイルを再生成するため、APIクレジットを節約します。前回の音声生成以降に翻訳が変更されたかどうかを検出します。エディタは、これらの行を「Outdated」アイコン（黄色）でハイライト表示し、変更された行**のみ**を更新できるようにします。このスマートバッチ処理機能は、不要なAPI呼び出しを防ぎ、音声を再生成する際のコストを削減します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、APIクレジットを節約します。",
  "li_ai_audio_profile": "<strong>Settings</strong>で、**Active Audio Profile**（例：OpenAI TTSまたはElevenLabs）を選択します。",
  "li_ai_audio_save": "ファイルはプロファイルで指定されたフォルダに保存されます。",
  "li_ai_audio_voice_mapping": "<strong>ボイスマッピング（マルチスピーカー）:</strong> 異なる AI ボイスを自動的に異なるキャラクターに割り当てます。<strong>Voice Mappings</strong> リストを使用して、正規表現パターン（例: <code>^hero_.*</code>）を特定の Voice ID にリンクします。ツールは音声生成時にキー名に基づいて適切なボイスを自動的に選択します。",
  "li_ai_provider_settings": "<strong>Provider Settings:</strong> 各サービスはAPIキー、モデル（例：GPT-4o、Sonnet）、音声固有のパラメータ（Stability、Similarity）の設定が可能です。",
  "li_api_async_method": "<strong>GetLocalizedAssetAsync&lt;T&gt;:</strong> Addressables アセットを非同期でロードするために使用します。<code>Task&lt;T&gt;</code> を返します。",
  "li_api_gender_method": "GetGendered: GetGendered(string baseKey, Gender gender) は性別固有の翻訳を返します。",
  "li_api_plural_method": "<strong>GetPlural:</strong> <code>GetPlural(string baseKey, double count)</code> は言語固有のルールに基づいて正しい複数形を返します。",
  "li_api_set_lang_method": "<strong>SetLanguage:</strong> 言語を変更するためのコルーチン（<code>IEnumerator</code>）。必ず <code>StartCoroutine()</code> を使用してください。",
  "li_assets_1": "<strong>フォルダ構造の作成（オプション）:</strong> **2. Asset Folder Generation**セクションで、**Create Asset Folders Now**をクリックします。",
  "li_assets_2": "<strong>カテゴリと命名ルールの設定:</strong> **3. Asset Categories & Scanning**セクションで、**Naming Rule**（<code>{key}_{lang}</code>）がファイルと一致すること（例：<code>button_ok_en.png</code>）を確認します。",
  "li_assets_3": "<strong>アセットの配置:</strong> ローカライズされたアセットをフォルダに配置します。",
  "li_assets_4": "<strong>アセットのスキャン:</strong> **4. Automation**セクションで、**Scan Assets & Update Tables**をクリックします。クリーンアッププロセスがより安全になりました。古いテーブルファイル（<code>.asset</code>）のみが削除され、フォルダ全体は削除されません。",
  "li_assets_5": "<strong>アセットとオブジェクトのリンク:</strong> **Analyze Project & Attach Components**をクリックします。",
  "li_assets_6": "<strong>Addressables統合:</strong> **Addressables**モードが有効な場合、スキャン中にアセットは自動的に<code>{Category}/{Language}/{Key}</code>形式のアドレスでAddressablesグループに登録されます。",
  "li_assets_addressables_naming": "<strong>命名規則:</strong> スキャン時、ツールはAddressableアドレスを自動的に<code>{Category}/{Language}/{Key}</code>形式に設定します。ランタイムでアセットをロードするためにLocalizationManagerがこの特定の形式に依存しているため、これらのアドレスを**手動で変更しないでください**。",
  "li_assets_auto_folders": "<strong>Auto-Generate Folders:</strong> 有効にすると、ツールは最初のアセットローカリゼーション時に、サポートされているすべての言語用の必要なディレクトリ構造を自動的に作成します。",
  "li_assets_folder_gen": "<strong>Folder Generation:</strong> ルールに従ってローカライズされたアセット用のフォルダー構造を自動的に作成します。",
  "li_assets_storage_path": "<strong>Asset Storage Path:</strong> すべてのローカライズされたアセット（スプライト、オーディオ等）のルートディレクトリを定義します。<code>{lang}</code> 変数を使用して、言語ごとのフォルダー構造を指定してください。",
  "li_assistant_1": "<strong>設定可能:</strong> Translation Profileでコマンドを定義します（例：「Fix Grammar」、「Make Formal」、「Shorten for UI」）。",
  "li_assistant_2": "<strong>バッチ処理:</strong> 複数のセルを選択して、それらすべてにコマンドを一括で適用します。",
  "li_assistant_3": "<strong>Custom Commands:</strong> <strong>Translation Profile</strong> インスペクターで独自のプロンプトを定義します（<code>AIAssistantCommand</code> のリスト）。各コマンドは <strong>Label</strong>（コンテキストメニューに表示）と <strong>Prompt</strong>（AI に送信される指示、例: 'Rewrite in pirate style'）を持ちます。",
  "li_attr_feat_1": "<strong>コレクション:</strong> <code>List&lt;string&gt;</code> および <code>string[]</code> をサポートします。キーはサフィックス <code>_0</code>、<code>_1</code> などで生成されます。リストフィールド自体にカスタムキーを使用して、すべてのアイテムにプレフィックスを付けることもできます。",
  "li_attr_feat_2": "<strong>アクセス修飾子:</strong> <code>private</code>、<code>protected</code>、<code>internal</code>、および <code>public</code> フィールドで動作します。",
  "li_attr_feat_3": "<strong>カスタム属性:</strong> <em>コンテンツタブ</em>の設定で、<code>HeaderAttribute</code>、<code>TooltipAttribute</code>、または任意のカスタム属性名を追加できます。パーサーは、これらの属性を持つフィールド (例: <code>[Header(\"Text\")]</code>) をローカライズ可能な文字列として扱います！",
  "li_attr_feat_4": "<strong>ネストされたオブジェクト:</strong> <code>[System.Serializable]</code>でマークされたクラスまたは構造体内のフィールドを再帰的にスキャンします。これには、単一のインスタンスとネストされたオブジェクトのリストが含まれます。",
  "li_attr_feat_5": "<strong>Formatted Strings:</strong> 補間文字列（<code>$\"Text {0}\"</code>）、逐語的文字列（<code>@\"Text\"</code>）、連結（<code>\"A\" + \"B\"</code>）をサポートします。",
  "li_attr_limit_1": "<strong>Properties are Supported:</strong> パーサーは<code>Fields</code>と<code>Properties</code>の両方をスキャンします。Getterが必要です。",
  "li_attr_limit_2": "<strong>辞書:</strong> <code>Dictionary&lt;T, string&gt;</code> は解析のために直接サポートされていません。",
  "li_attr_limit_3": "<strong>静的フィールド:</strong> コードファイル内の静的分析 (正規表現) を介してサポートされますが、ゲームオブジェクトで堅牢な検出を行うには、インスタンスフィールドを使用することをお勧めします。",
  "li_backup_desc": "翻訳の変更を追跡し、以前のバージョンに復元します。",
  "li_backup_rollback": "<strong>Rollback:</strong> 選択したキーまたはテーブル全体を即座に以前の状態に戻します。",
  "li_backup_snapshots": "<strong>Snapshots:</strong> バルク操作の前に名前付きリストアポイントを作成します。",
  "li_cheat_base_private": "<strong>Base Private Fields:</strong> サポート（スキャナが基底クラスのファイルを直接読み取ります）",
  "li_cheat_collections": "<code>List&lt;string&gt;</code>, <code>string[]</code> 配列",
  "li_cheat_concatenation": "<strong>String Concatenation:</strong> <code>\"A\" + \"B\"</code>（サポート）",
  "li_cheat_constructor_args": "<strong>複雑なコンストラクター引数:</strong> <code>new Item(\"Name\" + index)</code>",
  "li_cheat_dictionaries": "<strong>辞書</strong> (Unityインスペクターでは自然にシリアライズされません)",
  "li_cheat_headers": "<code>[Header(\"...\")]</code> のような属性（完全にサポート）",
  "li_cheat_nested_lists": "<strong>ネストされたオブジェクトのリスト</strong> (例: <code>List&lt;ItemData&gt;</code>)",
  "li_cheat_non_literals": "<strong>変数と定数:</strong> <code>const string s = \"Value\";</code> または <code>static string</code>（サポート済み、Roslyn が同じファイルから値を解決）",
  "li_cheat_private": "<code>private</code> / <code>protected</code> フィールド（サポート）",
  "li_cheat_properties": "<strong>Properties:</strong> <code>{ get; set; }</code>（自動プロパティとフルプロパティをサポート）",
  "li_cheat_scriptable_objects": "<strong>ScriptableObjects</strong>（参照されていればサポート）",
  "li_cheat_serializable": "ネストされた <code>[Serializable] class</code> (インベントリアイテム、ダイアログノード)",
  "li_cheat_static": "<strong>Static Fields:</strong> <code>public static string</code>（完全にサポート）",
  "li_cheat_structs": "<strong>Structs & Records:</strong> サポート（再帰的スキャン）",
  "li_cheat_ternary": "<strong>ロジック/三項演算子:</strong> <code>cond ? \"A\" : \"B\"</code> (パーサーは値を判別できません)",
  "li_cheat_unattached": "<strong>Unattached Scripts:</strong> サポート（スキャナがプロジェクト内のすべての.csファイルを読み取ります）",
  "li_content_1": "<strong>Scenes to Parse:</strong> 解析対象のすべてのシーンをここにドラッグアンドドロップします。",
  "li_content_2": "<strong>Prefab Folders:</strong> プレハブを含むフォルダを指定します。大規模プロジェクト向けのページネーションと検索をサポートするようになりました。",
  "li_content_3": "<strong>Dynamic Texts:</strong> ここにコード内でのみ作成される文字列（例：「Game Over」）を入力します。",
  "li_content_4": "<strong>Component Types to Ignore:</strong> スキャン中にスキップすべき Unity コンポーネントタイプを指定します。",
  "li_content_5": "<strong>Pin to Ignore:</strong> この機能により、シーン内のオブジェクトを永続的に無視リストに「ピン留め」できます。",
  "li_content_6": "<strong>Scripts to Ignore:</strong> 特定の C# スクリプトまたはフォルダー全体を追加して、解析から除外します。",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> キーのプレフィックスのリスト（例: <code>Item_</code>）で、クリーンアップ時に削除されません。",
  "li_content_dynamic_keys": "<strong>Dynamic Key Prefixes:</strong> 動的である可能性があると認識すべきプレフィックス（例: <code>quest_item_</code>）を定義します。これにより、ツールは静的 UI ラベルとデータ駆動キーを区別できます。",
  "li_content_dynamic_texts": "<strong>Dynamic Text Rules:</strong> コードで動的に更新されるテキストのパターンを設定します。これにより、スキャナーが実行時に変化するテキストの冗長なキー作成を防ぎます。",
  "li_content_regex_example": "<strong>Custom Wrapper Example:</strong> カスタム関数 <code>MyGame.Loc(\"KEY\")</code> を使用する場合は、正規表現でスクリプト解析ルールを追加してください: <code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>.",
  "li_content_regex_presets": "<strong>Ignored Regex Patterns:</strong> クリック <strong>'Add Common Pattern'</strong> で、URL、メールアドレスなどの動的コンテンツをすばやく除外できます。",
  "li_content_scanner": "<strong>Roslyn Code Scanner:</strong> C# の構文ツリーを理解する高度な静的解析エンジンで、堅牢なキー検出を実現します。",
  "li_content_scanner_details_1": "<strong>Smart Call Detection:</strong> <code>LocalizationManager._(\"Text\")</code>、<code>_(\"Text\")</code>、<code>GetTranslation(\"Text\")</code> の呼び出しを自動的に検出します。これらの呼び出しに対して<strong>Text-As-Key</strong>モードを強制し、複数形や性別といったランタイム機能が正しく動作するようにします。",
  "li_content_scanner_details_2": "<strong>Constant Resolution:</strong> スキャナは`const`や`static readonly`の文字列変数を解決できるほど賢くあります。<code>_ (MyConst)</code>を使用すると、同じクラスで定義されている`MyConst`の値を取得し、ソーステキストとして使用します。",
  "li_content_scanner_details_3": "<strong>属性とメタデータ:</strong> `[LocalizableField]`、`[Header]`、または`[Tooltip]`（設定されている場合）のフィールドまたはプロパティをスキャンします。<strong>配列</strong>、<strong>リスト</strong>、さらには<strong>入れ子のシリアライズ可能クラス</strong>も再帰的に処理します。",
  "li_content_scanner_details_4": "<strong>最新のC#サポート:</strong> C# 9.0以降の構文をフルサポートし、ターゲット型<code>new()</code>式、暗黙的配列作成、文字列補間（`$\"String {0}\"`）を含みます。",
  "li_content_script_rules_attributes": "<strong>Attributes to Scan:</strong> パーサーがローカライズ可能な文字列ソースとして認識すべきカスタム属性（例: <code>[Header]</code> や <code>[Tooltip]</code>）を定義します。",
  "li_content_script_rules_bridge_name": "<strong>Bridge Class Name:</strong> 生成される静的クラスの名前を定義できます。",
  "li_content_script_rules_bridges": "<strong>Generate C# Bridges:</strong> すべてのキーに型安全にアクセスできる静的クラス（例: <code>AnkoLoc</code>）を自動的に作成し、マジック文字列を排除し、IDE のオートコンプリートを有効にします。",
  "li_context_1": "<strong>開発者ノート:</strong> 翻訳テーブルからのコメントがコンテキストとしてAIに渡されます。",
  "li_context_2": "<strong>オブジェクトパス:</strong> コメントが存在しない場合、オブジェクトのヒエラルキーパス（例：<code>MainMenu/Canvas/StartButton</code>）がフォールバックコンテキストとして使用されます。",
  "li_context_3": "<strong>用語集:</strong> CSV用語集をプロファイルにロードして、用語や名前の特定の翻訳を強制できます。",
  "li_context_4": "<strong>プロジェクトの説明:</strong> ゲームの設定と対象ユーザーを記述し、AIが全体のコンテキストを理解できるようにします。",
  "li_context_5": "<strong>トーンとスタイル:</strong> 望むペルソナ（例: 'Friendly'、'Professional'、'Pirate'）とフォーマットルールを定義します。",
  "li_context_glossary": "<strong>辞書マネージャー:</strong> 用語集と直接やり取りし、'Add'、'Edit'、'Remove'（追加、編集、削除）できます。大文字小文字の区別や'翻訳しない'タイプをサポートします。",
  "li_context_optimization": "<strong>トークン最適化:</strong> システムはコンテキストを賢く圧縮し、キャッシュを再利用してトークン使用量とコストを最小化します。",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> OpenAI互換API（Ollamaを介したローカルLLMを含む）と通信できる柔軟な実装。",
  "li_custom_ai_2": "<strong>Templates & Auth:</strong> 完全にリクエストをカスタマイズできます。 <ul><li><strong>Auth:</strong> <code>Auth Header Key</code>（例: <code>Authorization</code>）と <code>Format</code>（例: <code>Bearer {0}</code>）を設定します。クエリパラメータでの API キーもサポートします。</li><li><strong>Body Template:</strong> テキスト用に <code>{model}</code> や <code>{prompt}</code>、音声用に <code>{input}</code> や <code>{voice}</code> などのプレースホルダーを含む JSON テンプレートを使用します。</li><li><strong>Response Path:</strong> 結果への JSON パスを定義します（例: <code>choices[0].message.content</code>）。</li></ul>",
  "li_custom_ai_3": "<strong>組み込みの安全機能:</strong> AIモデルから返されることが多い壊れた書式設定タグ（例：<ph0>）を自動的に修復し、信頼性が高く一貫した翻訳を保証します。",
  "li_custom_parser_1": "プロジェクトの**Editor**フォルダに新しいC#スクリプトを作成します。",
  "li_custom_parser_2": "以下のテンプレートをコピーして貼り付けます。",
  "li_custom_parser_3": "ロジックをカスタムコンポーネントに合わせて変更します。",
  "li_custom_provider_manual_reg": "<strong>手動登録:</strong> DI注入や遅延初期化など高度なシナリオでは、初期化時に<code>AssetProviderFactory.RegisterCustomProvider(\"MyID\", myInstance)</code>を使用してプロバイダーを手動で登録できます。",
  "li_custom_provider_step_1": "<strong>インターフェースの実装:</strong> <code>IAssetProvider</code>を実装する新しいクラスを作成します。システムのAPIを使用して、<code>Load&lt;T&gt;</code>（同期）と<code>LoadAsync&lt;T&gt;</code>（非同期）でアセットをロードする方法を定義する必要があります。",
  "li_custom_provider_step_2": "<strong>ライフサイクルの定義:</strong> <code>Initialize</code>、<code>Dispose</code>、<code>UnloadAll</code>を実装します。これらのメソッドは、言語切替やリソースのクリーンアップ時に<code>LocalizationManager</code>から呼び出されます。",
  "li_custom_provider_step_3": "<strong>言語安全性:</strong> アクティブな言語が変更されるたびに<code>SetCurrentLanguage</code>メソッドが呼び出されます。これを使用して内部パスを更新したり、アセットメタデータを再取得したりします。",
  "li_custom_provider_step_4": "<strong>自動検出（推奨）:</strong> クラスに<code>[AssetProviderPlugin]</code>属性を付与します。これにより、プロバイダーが<strong>Settings Tab -&gt; Asset Loading Strategy</strong>のドロップダウンに即座に表示されます。",
  "li_editor_1": "<strong>スマートグルーピング:</strong> 複数形とジェンダーのキー（例：<code>apple_count_one</code>、<code>apple_count_few</code>）は、折りたたみ可能なグループに自動的に結合されます。",
  "li_editor_2": "<strong>高度な編集:</strong> セルをクリックすると、<strong>MultiLineEditWindow</strong>ポップアップが開きます。これは、比較のためにソーステキストを表示し、プレースホルダーを検証します。",
  "li_editor_3": "<strong>高度な選択:</strong> 個別セル、行全体、特定列（言語）など柔軟な選択モードをサポートします。複雑な選択には<code>Ctrl+Click</code>と<code>Shift+Click</code>を使用します。",
  "li_editor_4": "<strong>大量操作:</strong> 数千のセルに対して一括で操作を実行します。選択範囲を右クリックして: <ul><li><strong>自動翻訳:</strong> アクティブなAIプロファイルを使用して不足している翻訳を埋めます。</li><li><strong>ソースから埋める:</strong> 翻訳を素早くリセットします。</li><li><strong>ロック切替:</strong> '完璧'な翻訳が誤って上書きされるのを防ぎます。</li><li><strong>音声生成:</strong> 選択したフレーズのTTSをバッチ処理します。</li></ul>",
  "li_editor_5": "<strong>高性能ナビゲーション:</strong> エディタは仮想化された'MultiColumnListView'を使用し、1万件以上のキーでもスムーズにスクロールできます。キーボードナビゲーション（矢印キー/Tab）と強力なショートカットをサポートします: <code>Ctrl+S</code>（保存）、<code>Ctrl+Z/Y</code>（元に戻す/やり直し）、<code>Ctrl+F</code>（検索フォーカス）。",
  "li_editor_6": "<strong>高度な検索プリセット:</strong> 専用フィルタでプロジェクトを監査します: <ul><li><strong>ステータス:</strong> 未翻訳（現在/任意の言語）、ソースと同一、ロック済み。</li><li><strong>コンテンツ:</strong> コメントあり、プレースホルダーあり/欠如、長さの問題あり（自動検出）。</li><li><strong>構造:</strong> 複数形、性別別、またはその両方。</li><li><strong>音声:</strong> 音声欠如、古い（ハッシュ不一致）。</li></ul>",
  "li_editor_7": "<strong>スマート音声管理:</strong> TTSファイルの「新鮮さ」を追跡します。翻訳テキストを編集すると、<strong>黄色インジケータ（古い）</strong>が表示され、音声ファイルのハッシュがテキストと一致しなくなったことを示します。ワンクリックで古いファイルだけを再生成します。",
  "li_editor_8": "<strong>ロック機構:</strong> 説明: <ul><li><strong>ロックされたセル/行:</strong> <strong>自動翻訳</strong>、<strong>CSV/Googleインポート</strong>、または<strong>ソースから埋める</strong>による変更を防止します。</li><li><strong>使用例:</strong> ネイティブスピーカーが手動で検証した「ゴールド」翻訳をロックします。</li><li><strong>一括制御:</strong> プロジェクト全体で言語全体や特定の機能（例: キャラクター名）をロックします。</li></ul>",
  "li_editor_layout": "<strong>動的マルチペインレイアウト:</strong> 3ペインシステムを使用して、左側に「固定」列（キーなど）を固定し、中央で20以上の言語をスクロールできます。ヘッダーのコンテキストメニューで列の表示/非表示を切り替えます。",
  "li_editor_regex": "<strong>正規表現検索:</strong> メインウィンドウとテーブルエディタの両方で<strong>正規表現</strong>をサポートします。クエリに<code>* + ? ^ $ [ ] ( ) { } | .</code>などの記号が含まれる場合、自動的に正規表現として扱われます（例: <code>^item_.*</code>は'item_'で始まるすべてのキーを検索）。",
  "li_editor_structure": "<strong>テーブルとグループ:</strong> データはテーブル（ファイル）として整理され、エディタではグループ（フォルダ）として表示され、ナビゲーションが向上します。",
  "li_editor_ui_test": "<strong>組み込みUIテスト:</strong> <ul><li><strong>長さ拡張スライダー:</strong> テキストの拡張（0% - 100%）をシミュレートし、エディタを離れずにドイツ語やロシア語など長い言語でUIがどう動作するか確認します。</li><li><strong>リッチテキストレンダラー:</strong> タグ（<code>&lt;b&gt;</code>、<code>&lt;color&gt;</code>）の描画を切り替えて、ゲームを実行せずにスタイリングを検証します。</li></ul>",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 言語切り替え用のUIドロップダウンリストを作成するための既製のコンポーネントです。利用可能なすべての言語を自動的に見つけ、その切り替えを管理します。<br><strong>使用方法:</strong> シーン（例：空のGameObject）に<code>LanguageSelector</code>コンポーネントを追加し、インスペクターで<code>TMP_Dropdown</code>を指定するだけです。",
  "li_example_components_2": "<strong>コード例:</strong> <code>[LocalizableField]</code>、<code>_()</code>関数、複数形、およびジェンダーの操作などの高度な手法を学ぶには、<code>StatPurchaseTest.cs</code>ファイルと<code>TestLocalization.cs</code>ファイルを調べてください。これらは、ツールのすべての主要機能のコードでの実装を明確に示しています。",
  "li_example_components_new": "<strong>新規 (v2.0):</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>。<code>IEnumerator</code>を返します。Yieldする必要があります。",
  "li_example_components_old": "<strong>旧:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code>（同期的なvoid） - <strong>非推奨</strong>。コルーチンバージョンを使用してください。",
  "li_feature_1": "<strong>高度なパース処理:</strong> シーン、プレハブ、UI Toolkit (UXML)、および <code>[LocalizableField]</code> 属性でマークされたフィールド、ネストされたクラスやリストを含むC#スクリプトの自動スキャン。",
  "li_feature_10": "<strong>バックアップマネージャ:</strong> バックアップの作成と復元のための組み込みツール。",
  "li_feature_11": "<strong>AIパワード:</strong> カスタマイズ可能なプロファイルを介したOpenAI、Anthropic (Claude)、Google Gemini、およびローカルLLM (Ollama) のサポート。",
  "li_feature_12": "<strong>テキスト読み上げ (TTS):</strong> AI（OpenAI、ElevenLabs）を使用したローカライズされた文字列の音声ファイルの生成。",
  "li_feature_13": "<strong>移行ツール:</strong> I2 LocalizationおよびUnity Localizationプラグインからの自動移行のためのツール。",
  "li_feature_14": "<strong>フォント＆グリフマネージャ:</strong> 使用されている文字を分析し、フォント内の不足しているグリフを見つけるためのツール。",
  "li_feature_15": "<strong>ビジュアルデバッグ:</strong> 迅速なデバッグのためのヒエラルキー内のアイコンとシーンビュー内のラベル。",
  "li_feature_2": "<strong>あらゆるアセットのローカライズ:</strong> スプライト、オーディオ、プレハブ、マテリアルなどを管理します。",
  "li_feature_3": "<strong>強力な翻訳エディタ:</strong> 自動保存、完全なUndo/Redoサポート、スマートキーグルーピング、マルチ選択アクションを備えた集中インターフェース。",
  "li_feature_4": "<strong>AI と機械翻訳:</strong> DeepL、Google、Microsoft、そして<strong>カスタムAI（OpenAI、Gemini、Claude、Ollama）</strong>をサポートするプロファイルシステムで、コンテキスト認識があります。",
  "li_feature_5": "<strong>柔軟なインポート/エクスポート:</strong> CSV、XML、YAML、XLIFFをサポートし、Google Sheetsからの直接インポートも可能です。",
  "li_feature_6": "<strong>ライブプレビュー:</strong> ゲームを実行せずに、シーンビューまたは<strong>プレハブモード</strong>で任意の言語をプレビュー。",
  "li_feature_7": "<strong>複数形と性別サポート:</strong> 完全なCLDRサポート（v43）。<strong>アジア</strong>（なし）、<strong>英語/ゲルマン語</strong>（One, Other）、<strong>フランス語</strong>（One 0-1）、<strong>スラブ語</strong>（One, Few, Many - RU, UK, PL）、<strong>アラビア語</strong>、<strong>ケルト語</strong>、<strong>バルト語</strong>（LT, LV）などの規則を含みます。",
  "li_feature_8": "<strong>完全なRTLサポート:</strong> 右から左への言語の正しい表示。",
  "li_feature_9": "<strong>ライブアップデート:</strong> ゲーム開始時にリモートサーバーから最新の翻訳をロード。",
  "li_feature_tool_translation": "<strong>完全に翻訳されたUI:</strong> ツールのインターフェースはローカライズ可能です。<strong>メインウィンドウヘッダー</strong>のドロップダウンでエディタ言語を切り替えられます。",
  "li_font_global": "<strong>グローバルレポート:</strong> すべての言語で欠落しているすべてのグリフのレポートを生成します。",
  "li_font_glyph_analyze": "すべての翻訳を分析し、割り当てられたフォント（TMP_FontAsset）が使用されているすべての文字をサポートしているかどうかを確認します。",
  "li_font_glyph_copy": "フォントアトラス生成のために、すべてのユニークな言語文字をコピーできます。テクスチャ領域を最適化するために、<strong>ASCII、数字、句読点を除外するフィルタ</strong>を含みます。",
  "li_font_glyph_missing": "不足しているグリフのリストを表示します。",
  "li_font_glyph_workflow": "<strong>TMPのワークフロー:</strong> 1. スキャンを実行します。 2. グリフが不足している言語を選択します。 3. <strong>'Copy Character Set'</strong>をクリックします。 4. Window -> TextMeshPro -> Font Asset Creatorを開きます。 5. クリップボードを「Character Sequence (Custom Range)」フィールドに貼り付け、ゲームが必要とする文字のみを含むアトラスを生成します。",
  "li_font_unicode": "<strong>Unicode 範囲:</strong> 翻訳で使用されている特定のUnicode範囲（例: 基本ラテン、キリル文字）を表示し、フォントアセットを最適化します。",
  "li_footer_status": "<strong>Status & Progress:</strong> パース、インポート、AI 生成タスクのリアルタイムフィードバックを提供します。",
  "li_header_lang_selector": "<strong>Editor Language:</strong> ツールのインターフェイス言語を切り替えます。ツール UI は完全にローカライズ可能です。",
  "li_header_preview_btn": "<strong>Preview Toggle:</strong> エディタ内プレビューをすばやく有効化または無効化します。'Revert' ボタンでシーンの元の値に戻せます。",
  "li_header_toolbar_buttons": "<strong>Global Toolbar:</strong> ドキュメント、Discord、設定アセット、依存関係チェッカー、レビュー ページへ直接アクセスできます。",
  "li_install_1": "<strong>重要 (v2.0 アップデート):</strong> v1.xからアップグレードする場合、インポート前に古い `Ankonoanko` フォルダを<strong>必ず削除</strong>してください。バージョン2.0は名前空間の変更によりクリーンインストールが必要です。",
  "li_install_2": "ツールが必要な依存関係を自動的にチェックします。表示されるダイアログボックスでインストールを確認してください。",
  "li_install_3": "必須の依存関係（<code>Newtonsoft Json</code>、<code>Editor Coroutines</code>）は、基本的な機能に必要です。",
  "li_install_4": "オプションの依存関係（<code>Arabic Support</code>、<code>CsvHelper</code>、<code>YamlDotNet</code>）は、追加機能を有効にします。",
  "li_install_5": "推奨パッケージをインストールするには、<strong>Install Selected</strong>をクリックします。",
  "li_install_6": "インストール後、<strong>Tools -> Localization Tool</strong>メニューからメインツールウィンドウを開きます。",
  "li_install_7": "非同期アセットローディングを使用する予定がある場合は、パッケージマネージャーを介して<strong>Addressables</strong>パッケージをインストールしてください。",
  "li_live_updates_1": "<strong>有効化:</strong> 設定で「Enable Live Updates」をチェックします。",
  "li_live_updates_2": "<strong>ソース:</strong> JSON辞書を返す<code>Live Update URL</code>または<code>Google Sheet URL</code>を提供します。",
  "li_live_updates_3": "<strong>キャッシュ:</strong> 翻訳は<code>liveUpdateCachePath</code>にローカルでキャッシュされ、オフラインでもゲームが動作するようにします。",
  "li_live_updates_4": "<strong>セキュリティ:</strong> サーバーが認証を必要とする場合、<strong>Runtime API Key</strong>（暗号化）を使用してください。",
  "li_localizedtext_1": "<code>localizationKey</code>: 翻訳を検索するために使用されるキーです。自動生成または手動で割り当て可能です。",
  "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code>の場合、コンポーネントはスタイル（フォント、RTL）だけを適用し、テキスト自体は変更しません。スクリプト内の`_()`呼び出しで更新される動的テキスト要素に重要です。",
  "li_localizedtext_3": "<code>originalSourceText</code>: ベース言語の元のテキスト。フォールバックとして使用されます。",
  "li_localizedtext_key_override": "<strong>Manual Key Override:</strong> キーの横にある 'Edit' アイコンをクリックして手動でキーを入力できます。'X' で自動生成に戻します。これは <code>LocalizedText</code>、<code>LocalizedDropdown</code>（各オプション個別）および <code>UITKLocalization</code> で機能します。",
  "li_localizedtext_search_key": "<strong>テーブル内検索:</strong> 虫眼鏡アイコンをクリックすると、翻訳テーブルが即座に開き、その特定のキーにフォーカスします。",
  "li_migration_csv_details_1": "<strong>スマートフィルタリング:</strong> インポーターは、アセットパス（例: <code>.png</code>、<code>.mp3</code>、<code>Assets/...</code>）のように見える行を自動的にスキップし、テキストデータベースをクリーンに保ちます。",
  "li_migration_csv_details_2": "<strong>'Type' 列:</strong> 'Type'列が存在する場合（I2形式）、'Text'とマークされた行またはタイプが空の行だけがインポートされます。アセットをインポートするには、マイグレーションプロファイルを使用して<code>LocalizedAsset</code>にマッピングします。",
  "li_migration_csv_req_1": "<strong>キー列:</strong> <code>Key</code>という名前（大文字小文字は区別しない）であるか、マイグレーションプロファイルで定義されている必要があります。",
  "li_migration_csv_req_2": "<strong>言語列:</strong> 無視されていないすべての列は言語コード（例: 'en'、'ja'、'English'）として扱われます。ツールはこれらをプロジェクトの言語に曖昧一致させようとします。",
  "li_migration_csv_req_3": "<strong>Comments:</strong> <code>Desc</code>、<code>Description</code>、<code>Comment</code> という名前の列は開発者ノートとしてインポートされます。このリストは <strong>マイグレーションプロファイル</strong> で設定可能です。",
  "li_migration_custom_1": "Projectビューで右クリック → Create → Anko Localization → Migration Profile。",
  "li_migration_custom_2": "<strong>Rules:</strong> 変換ルールを定義します（[Source Component] に [Context Filter] がある場合、[Target Component] に変換）。ルールは <strong>Priority</strong>（数値が大きいほど先に処理）、<strong>Harvest Assets</strong>（Sprites や Audio など参照アセットを自動抽出・登録）、<strong>Context Filtering</strong>（同一オブジェクト上の複数コンポーネントを区別）をサポートします。",
  "li_migration_fallback_keys": "<strong>フォールバックキー フィールド:</strong> レガシーコンポーネントからキーを抽出する際にチェックする追加のフィールド名を指定します。古いシステムがキー用に非標準のプロパティ名を使用している場合に便利です。",
  "li_migration_gs_1": "<strong>アクセス:</strong> シートは共有（「リンクを知っている全員が閲覧可能」）またはウェブに公開されている必要があります。",
  "li_migration_gs_2": "<strong>シートタブ (GID):</strong> URLに<code>gid=...</code>パラメータが含まれている必要があります。これによりツールはどのタブを読むか正確に判断します（例: <code>gid=0</code>は通常最初のタブ/シート）。",
  "li_migration_ignored_headers": "<strong>無視する CSV ヘッダー:</strong> インポート時にスキップすべき列を定義します（例: 'Type', 'Description'）。これにより、ツールがメタデータ列を言語データとして扱うのを防ぎます。",
  "li_migration_legacy_components": "<strong>追加のレガシーコンポーネント:</strong> 直接的な変換ルールが定義されていなくても、マイグレーションスキャン時にツールが「レガシー」と検出すべきコンポーネント名を手動でリストします。",
  "li_migration_profile_details": "<strong>Advanced Profile Settings:</strong><ul><li><code>CsvKeyHeader</code>: Key 列のヘッダー名。</li><li><code>CsvCommentHeaders</code>: 開発者ノート/コメントとして扱うヘッダーのリスト。</li><li><code>IgnoredCsvHeaders</code>: スキップする列（'Type' や 'Status' などのメタデータ）。言語として扱われるのを防ぎます。</li><li><code>AssetExtensions</code>: スキャン時にアセットとして認識されるファイル拡張子。</li><li><code>FallbackKeyFields</code>: 主キー列が空の場合にチェックする追加フィールド名。</li></ul>",
  "li_migration_rule_fields": "<strong>Rule Configuration:</strong><ul><li><code>Priority</code>: 値が大きいほど先に処理されます。特定のケースを汎用ケースより先に処理するために使用します。</li><li><code>Context Filter</code>: 同一オブジェクトに特定のコンポーネント（例: <code>Text</code>）がある場合にのみ適用します。</li><li><code>Harvest Assets</code>: 有効にすると、レガシーコンポーネントから現在のアセット（例: Sprite）を抽出し、アセットテーブルに登録します。</li><li><code>Asset Field Path</code>: アセット参照が格納されたフィールドへのパス。</li><li><code>Additional Data Path</code>: Dropdown のような複雑なコンポーネントで複数の値/オプションを取得するために使用します。</li></ul>",
  "li_migration_stubs_1": "<strong>問題:</strong> 古いプラグインアセットを削除すると、Unityは欠落したスクリプト（例: <code>Localize</code> コンポーネントが欠如）を検出します。エディタはコンパイルエラーモードに入ります。",
  "li_migration_stubs_2": "<strong>Solution:</strong> 'Emergency Stubs' 機能は、古いプラグインと同一の名前と名前空間を持つ軽量な空クラスを生成します。これによりコンパイラが満たされます。",
  "li_migration_stubs_3": "<strong>Workflow:</strong> 1. <strong>Enable Emergency Stubs</strong> をクリックします（これにより <code>ANKO_ENABLE_MIGRATION_STUBS</code> が Project Settings に追加されます）。2. 古いプラグインフォルダーを削除します。3. Unity はフェイククラスを使用して正常に再コンパイルされます。4. <strong>Component Converter</strong> を実行し、スタブを公式コンポーネントに置き換えます。5. リファクタリングが完了したら <strong>Disable Stubs</strong> をクリックします。",
  "li_migration_tool_converter": "<strong>ステップ 2: コンポーネントコンバーター:</strong> シーンとプレハブをスキャンします。古いコンポーネント（例：<code>Localize</code>）を<code>LocalizedText</code> / <code>LocalizedAsset</code>に自動的に置き換え、キーを転送します。",
  "li_migration_tool_fields": "<strong>Profile Settings:</strong> 設定可能な 'Source Plugin' タイプと 'Asset Mapping' ルールにより、テクスチャやオーディオの正しい転送が保証されます。",
  "li_migration_tool_import": "<strong>ステップ 1: データインポート:</strong> CSV（I2）またはXLIFF（Unity Loc）ファイルをインポートして、キーデータベースを作成します。",
  "li_migration_tool_profiles": "<strong>Migration Profiles:</strong> カスタムプロファイルを作成して、サードパーティプラグイン (I2、Unity Loc) からのアセットと設定をマッピングします。",
  "li_migration_tool_safemode": "<strong>Safe Mode & Emergency Stubs:</strong> コンポーネントは削除されずに無効化されます。重要な <strong>Emergency Stubs</strong> 機能（<code>ANKO_ENABLE_MIGRATION_STUBS</code> 定義シンボルで有効化）を含み、I2 Localization または Unity Localization 用のフェイクプレースホルダクラスを生成し、プラグイン削除後すぐにプロジェクトがコンパイルできるようにします。これにより \"The type name 'Localize' could not be found\" エラーを防ぎ、新システムへのコードリファクタリング時間を確保できます。Enable Stubs は古いローカリゼーションプラグイン削除後のコンパイルエラー修正を可能にします。",
  "li_migration_tool_setup": "<strong>ステップ 0: セットアップ:</strong> コンポーネント名（例：I2の<code>Localize</code>）とキーが保存されているフィールドを設定します。プリセットが利用可能です。",
  "li_migration_workflow_1": "<strong>1. Backup:</strong> 作業を開始する前に、プロジェクトをソース管理 (Git) にコミットするか、ファイルのバックアップを作成してください。",
  "li_migration_workflow_2": "<strong>2. Enable Stubs:</strong> Migration Tool を開き、'Safe Mode' タブへ。対象システム (I2/UnityLoc) 用に <strong>Enable Emergency Stubs</strong> をクリックします。これによりプロジェクトに軽量な偽クラスが作成されます。",
  "li_migration_workflow_3": "<strong>3. Remove Old Plugin:</strong> 古いプラグインフォルダーを削除します (例: 'Assets/Plugins/I2')。Unity が再コンパイルします。Stubs があるおかげで <strong>NOT</strong> 'Type not found' エラーが発生せず、Prefab 上のすべてのコンポーネント参照が保持されます。",
  "li_migration_workflow_4": "<strong>4. Import Data:</strong> 'Import Data' タブで、ソース CSV/XLIFF をロードします。プレビューを確認し、<strong>Import</strong> をクリックしてください。これにより AnKo の翻訳テーブルが生成されます。",
  "li_migration_workflow_5": "<strong>5. Convert Components:</strong> 'Component Converter' タブで 'Entire Project' を選択し、<strong>Scan & Convert</strong> をクリックします。ツールは古いスタブを 'LocalizedText'/'LocalizedAsset' コンポーネントに置き換え、キーを転送します。",
  "li_migration_workflow_6": "<strong>6. Cleanup:</strong> すべてが正常に動作したら、<strong>Disable Stubs</strong> をクリックし、Unity に再コンパイルさせます。",
  "li_notes_1": "<strong>バックアップ:</strong> 主要な変更を行う前に、必ず<strong>Translation Table Editor -> Manage Backups</strong>からバックアップを作成してください。バックアップは、Unityプロジェクトをクリーンに保ち、インポート時間を短縮するために、**プロジェクトルート（Assetsフォルダの外）**の<code>LocalizationBackups</code>フォルダに保存されます。",
  "li_notes_2": "<strong>APIキーのセキュリティ:</strong> エディタで作業するためのキーは、お使いのマシンにローカルに保存され（<code>EditorPrefs</code>）、リポジトリには含まれません。ゲームビルドで必要なキーには、**Runtime API Key**セクションを使用してください。",
  "li_notes_3": "<strong><code>StreamingAssets</code>フォルダ:</strong> 翻訳ファイルは、ゲームビルドに含まれるために、<code>Assets/StreamingAssets/</code>のサブフォルダにある必要があります。",
  "li_notes_4": "<strong>「愚かさからの保護」:</strong> ツールは、プレビューモードからの一時的なデータがシーンやプレハブに誤って保存されるのを自動的に防ぎます。",
  "li_notes_5": "<strong>パフォーマンス:</strong> <code>_()</code>の呼び出しは高速ですが、毎フレーム実行されるループ（例：<code>Update</code>内）では、結果を変数にキャッシュするようにしてください。",
  "li_notes_6": "<strong><code>LanguageSelector</code>をパース処理から除外する:</strong> <code>LanguageSelector</code>コンポーネントとその<code>TMP_Dropdown</code>を持つオブジェクトは、**Content**タブの**Ignore Specific Objects**リストに追加する必要があります。これは、<code>LanguageSelector</code>スクリプトが実行時に動的にオプションを設定するため、パーサーがドロップダウンオプションの追加のキーを作成するのを防ぐために必要です。無視することで、競合を防ぎ、翻訳ファイルをきれいに保ちます。",
  "li_notes_7": "<strong><code>LanguageSelector</code>のフォント:</strong> 選択した言語の<code>TMP_Dropdown</code>内のフォントが正しく更新されるようにするには、ドロップダウンの子**Label**オブジェクトに空の<code>LocalizedText</code>コンポーネントを手動で追加し、<code>isStyleOnly</code>チェックボックスをオンにします。",
  "li_notes_addressables_code": "<strong>コードとAddressables:</strong> **Addressables (Async)**モードに切り替える場合は、スクリプト内で<code>GetLocalizedAssetAsync<T>()</code>を**使用する必要があります**。同期<code>GetLocalizedAsset<T>()</code>を呼び出すと、nullが返され、メインスレッドのフリーズを防ぐために警告がログに記録されます。",
  "li_notes_addressables_sync_warning": "<strong>同期 vs 非同期:</strong> **Addressables (Async)**モードに切り替える場合は、コードを更新して<code>GetLocalizedAssetAsync<T>()</code>を使用**する必要があります**。同期メソッドを呼び出すと、nullが返され、メインスレッドのフリーズを防ぐために警告がログに記録されます。",
  "li_preview_1": "<strong>仕組み:</strong> リストから言語を選択すると、ツールはアクティブなシーンまたは開いているプレハブ内のすべてのローカライズ可能なオブジェクトに、対応する翻訳、フォント、RTL設定、およびアセットを瞬時に適用します。",
  "li_preview_2": "<strong>プレースホルダー:</strong> **Settings**タブでプレースホルダーのスタイル（例：<strong>Accents</strong>または<strong>Brackets</strong>）が選択されている場合、実際の翻訳の代わりにこれらのプレースホルダーがプレビューモードで表示されます。これは、レイアウトのテストやローカライズされていない要素の検出に最適です。",
  "li_preview_3": "<strong>安全性:</strong> プレビューモードで行われたすべての変更は一時的なものです。**Revert to Original**を選択するか、ウィンドウを閉じるか、シーンを変更するか、シーン/プレハブを保存する前（<code>LocalizationPreviewProtector</code>コンポーネントのおかげ）に、ツールはすべてを元の状態に自動的に復元します。",
  "li_preview_4": "<strong>クラッシュ保護:</strong> システムは、プレビューする前にシーンの状態を<code>Library</code>フォルダに自動的にバックアップします。プレビュー中にUnityがクラッシュしたり、強制終了したりした場合、ツールは次回の起動時に回復ファイルを検出し、元のシーンの状態を復元することを提案します。",
  "li_preview_overlay_1": "<strong>Access:</strong> オーバーレイは Scene View に自動的に表示されます。Unity Overlay メニュー (<code>Space</code> キー) で切り替えることができます。",
  "li_preview_overlay_2": "<strong>Functionality:</strong> メインウィンドウを開かずに現在のプレビュー言語をすばやく切り替えるドロップダウンを提供します。",
  "li_report_1": "<strong>カテゴリ:</strong> All Keys、Added、Updated（テキスト変更）、Removed、Duplicates、Migrated、Skipped（変更なし）。",
  "li_report_2": "<strong>高度な検索:</strong> エントリの横にある**Find**ボタンをクリックすると、プロジェクト内の対応するオブジェクトを即座に見つけることができます。検索は非同期で動作し、エディタをブロックせず、すべてのシーンとプレハブを検索します。",
  "li_report_all_keys": "<strong>All Keys:</strong> プロジェクトで検出されたすべてのローカリゼーションキーの一覧で、検索とフィルタリングオプションがあります。",
  "li_report_btn_clear": "<strong>Clear Report:</strong> 現在のセッションのメモリからすべてのスキャン結果を削除します。",
  "li_report_btn_copy_all": "<strong>Copy All Keys:</strong> 現在のカテゴリのすべてのローカリゼーションキーをシステムクリップボードにコピーします。",
  "li_report_btn_load_last": "<strong>Load Last Scan:</strong> 再スキャンせずに、最新のプロジェクト分析結果を即座に復元します。",
  "li_report_btn_save": "<strong>Save Report:</strong> 現在のスキャン結果をテキストまたは CSV ファイルにエクスポートし、外部ドキュメントや監査に利用できます。",
  "li_report_source_filter": "<strong>Source Filter:</strong> 結果を起点（例: Scripts、Scenes、Prefabs のみ）で絞り込みます。",
  "li_safety_global_limit": "<strong>Global Monthly Limit:</strong> <code>monthlyCharLimit</code> (デフォルト: 500,000 文字) はすべてのリクエストの回路ブレーカーとして機能します。<code>enableApiLimitWarning</code> で警告のオン/オフが可能です。",
  "li_safety_profile_limit": "<strong>Profile Limits:</strong> 各 Translation Profile は独自の 'Max Chars Per Request' と 'Batch Size' を設定できます。",
  "li_settings_1": "<strong>Key Generation Mode:</strong> テキストのユニーク識別子を作成する戦略を定義します:<ul><li><code>AutoGenerateKeysOnly</code> <strong>(デフォルト - 推奨)</strong>: シーン/プレハブ名とオブジェクト階層に基づいてキーを生成します（例: <code>scene_Menu_BtnPlay_682412</code>）。大規模プロジェクトに最適で、ユニーク性が保証され、テキスト変更の影響を受けません。</li><li><code>UseTextAsKey</code>: ソーステキストそのものをキーとして使用します（例: \"Start Game\" → <code>Start Game</code>）。キーを人間が読める形にしたい迅速なプロトタイピングに最適です。</li><li><code>AutoGenerateWithCustomKeys</code> <strong>(ハイブリッド)</strong>: 最も柔軟なモードです。まずコンポーネントに手動で割り当てられたキーまたは <code>[LocalizableField(key=\"...\")]</code> があるか確認します。キーが無い場合は階層的なキーを生成します。<em>既存の作業を保持しつつ新コンテンツを自動化したい場合に使用してください。</em></li><li><code>UseTextAsKeyWithCustomPriority</code> <strong>(ハイブリッド)</strong>: 上記と同様ですが、手動キーが見つからない場合はテキスト自体を使用します。既存のコンポーネントやデータを尊重します。</li><li><code>Manual</code>: スキャナは決して新しいキーを作成しません。キーを持つローカリゼーションコンポーネントが既にあるオブジェクトのみを更新します。厳密な手動管理に最適です。</li></ul>",
  "li_settings_10": "<strong>開発ツール:</strong> 設定タブの下部には、<strong>Clear Saved Language Pref</strong>（保存された言語をPlayerPrefsでリセットし、ゲームがデフォルト言語で再起動するようにします）のようなユーティリティボタンがあります。",
  "li_settings_11": "<strong>テクニカルドロップダウンオプション:</strong> パーサーがDropdownをスキャンするときに**無視する**文字列値のリスト（デフォルト：「Option A」、「Option B」、「Option C」）。これにより、UnityのデフォルトUIプレースホルダーテキストから翻訳テーブルをきれいに保ちます。",
  "li_settings_2": "<strong>言語管理:</strong><ul><li><strong>Source Language:</strong> Unityのシーン/プレハブで使用されている言語（開発言語）。</li><li><strong>Default Language:</strong> ユーザーのシステム言語がサポートされていない場合、ゲームの初回起動時に選択される言語。</li><li><strong>リスト:</strong> サポートされている言語を管理し、特定の<strong>Font Assets</strong>を割り当て、<strong>RTL</strong>サポートを有効にします。</li></ul>",
  "li_settings_3": "<strong>General Settings:</strong> プロジェクト全体の動作を設定します:<ul><li><code>Translations Save Path</code>: <code>.json</code> 翻訳ファイルを保存するルートディレクトリです。ゲーム内でアクセスする場合、<code>Assets/Resources</code> または <code>Assets/StreamingAssets</code> 内に配置する必要があります。</li><li><code>Safe Mode</code>: プロジェクトの不整合や依存関係の欠如が検出された場合、操作（Auto-Translate など）をブロックする保護層です。</li><li><code>Remove Missing Keys</code>: 有効にすると、スキャナはプロジェクト更新時にシーンやプレハブに存在しなくなったデータベースのエントリを自動的に削除します。</li><li><code>Parse Inactive Objects</code>: 無効化または非表示の GameObject をスキャンしてローカライズするかどうかを決定します。</li><li><code>Parse All Prefabs</code>: プロジェクト内のすべてのプレハブをスキャンします。無効にすると、<strong>Content</strong> タブで指定されたフォルダ内のプレハブのみが処理されます。</li><li><code>Fill Comments By Paths</code>: オブジェクトのシーン/プレハブ階層パスを 'Comment' フィールドに自動的に入力します。</li><li><code>Split Files by Language</code>: 翻訳データベースを複数のファイル（例: <code>en.json</code>, <code>ja.json</code>）に分割します。大規模プロジェクトでランタイムメモリ負荷を減らすために強く推奨されます。</li><li><code>Allow Empty Source/Keys</code>: ソーステキストが空でもオブジェクトを登録・追跡できるようにします。コードだけで設定される動的テキストに便利です。</li><li><code>Attach to Regex-Ignored Text</code>: 除外正規表現（例: 数字）にマッチするテキストを持つオブジェクトにもローカリゼーションコンポーネントを付与し、手動で上書きできるようにします。</li><li><code>Find Settings Asset</code>: プロジェクトウィンドウで <code>LocalizationSettings.asset</code> ファイルを即座に検索して選択するユーティリティボタンです。</li></ul>",
  "li_settings_4": "<strong>Debugging and Testing:</strong><ul><li><code>Placeholder Style</code>: プレビュー時にプレースホルダーを表示するスタイルを選択します。</li><li><code>Pseudo-Localization</code>: <strong>'Custom Pseudo'</strong> を選択すると、拡張率、アクセント、区切り文字などの高度なレイアウトテスト設定が表示されます。</li></ul>",
  "li_settings_5": "<strong>ライブアップデート:</strong> リモートサーバーから翻訳をロードするための設定。",
  "li_settings_6": "<strong>Runtime API Key:</strong> ゲーム内で新しい翻訳を取得する <strong>Live Updates</strong> 用の API キーを安全に保存します。これはエディタで使用する Translation Service のキーとは異なります。ビルド内ではキーは <strong>obfuscated</strong> (暗号化) され、文字列検索による簡単な抽出を防ぎますが、クライアント側のシークレットが 100% 安全ということはありません。",
  "li_settings_7": "<strong>Asset Loading Strategy:</strong> <code>Resources (Legacy)</code>、<code>Addressables (Async)</code>、<code>Custom</code> のいずれかを選択します。警告: このモードを変更するとプロジェクトの再スキャンが必要です。モバイルや WebGL でのメモリ使用量削減のため、Addressables モードが強く推奨されます。",
  "li_settings_8": "<strong>Auto-Translation:</strong> <strong>翻訳プロファイル</strong> システムを使用して AI 主導のローカリゼーションを行います。設定項目は以下の通りです:<ul><li><code>Text & Audio Profiles</code>: 各種サービス（例: OpenAI、DeepL、Google）を設定する ScriptableObject プロファイルを選択または作成します。</li><li><code>Presets Folder</code>: 翻訳プリセットとプロファイルが保存されているディレクトリです。</li><li><code>Target Languages</code>: 選択されたプロファイルに対するリアルタイムステータス、プログレスバー、文字数を含む、プロジェクト内のすべての言語のリストです。</li><li><code>Start Auto Translation</code>: 指定されたプロファイルを使用して、選択されたすべての言語の自動翻訳プロセスを開始します。</li></ul>",
  "li_settings_9": "<strong>Debugging Enhancements:</strong><ul><li><code>Show Hierarchy Icons</code>: 階層ビューにステータスアイコン（緑のチェック / 黄色の警告）を表示します。<strong>パフォーマンス最適化:</strong> キャッシュを使用し、大規模シーンでも遅延ゼロを実現します。</li><li><code>Show Scene View Labels</code>: シーンビュー上で直接視覚的デバッグを行います。ラベルはインタラクティブで、任意のシーンラベルを右クリックするとローカリゼーションキーが即座にクリップボードにコピーされます。</li></ul>",
  "li_settings_asset_folder_rule": "<strong>Folder Structure Rule:</strong> ローカライズされたアセットを生成する際のサブフォルダ構成方法を定義します（例: <code>{lang}/{category}</code>）。",
  "li_settings_bridge_name": "<strong>Bridge Class Name:</strong> 生成される静的クラスの名前をカスタマイズできます（デフォルトは <code>AnkoLoc</code>）。",
  "li_settings_general_safe_mode": "<strong>Safe Mode:</strong> プロジェクトの状態が不整合になる可能性がある場合、重要な操作が実行されないようにします。",
  "li_settings_lang_culture_fallback": "<strong>Use Culture Fallback:</strong> 特定の地域方言（例: <code>en-AU</code>）が存在しない場合、ツールはまずベース言語（<code>en</code>）を使用し、次に <strong>Default Language</strong> にフォールバックします。",
  "li_settings_lang_follow_system": "<strong>Follow System Language:</strong> 初回起動時に、プレイヤーの OS 言語に合わせてゲーム言語を自動的に切り替えます。",
  "li_settings_live_updates_security": "<strong>Security:</strong> ランタイム API キーはビルド内で暗号化 (AES) され、簡易的な抽出を防止します。常に HTTPS を使用してください。",
  "li_settings_pseudo_accents": "<strong>Use Accents:</strong> 標準文字をアクセント付き文字（例: <code>å</code>, <code>é</code>）に置き換えます。フォントが必要なすべてのグリフをサポートしているか確認するために使用します。",
  "li_settings_pseudo_brackets": "<strong>Add Brackets:</strong> テキストを <code>[ ]</code> で囲み、ローカライズ文字列の開始と終了を確認し、文字列の切り捨てや結合問題の特定に役立ちます。",
  "li_settings_pseudo_expand_length": "<strong>Expand Length:</strong> ドイツ語やロシア語などで一般的なテキストの長さ増加を、末尾文字を付加してシミュレートします。",
  "li_settings_pseudo_expansion_factor": "<strong>Expansion Factor:</strong> テキスト長シミュレーションの倍率です（例: 2.0 はテキストを2倍の長さにします）。",
  "li_settings_pseudo_prefix": "<strong>Custom Prefix:</strong> すべてのローカライズテキストの先頭に特定の文字列（例: <code>PSEUDO-</code>）を追加します。",
  "li_settings_pseudo_suffix": "<strong>Custom Suffix:</strong> すべてのローカライズテキストの末尾に特定の文字列を追加します。",
  "li_settings_return_source": "<strong>Return Source if Missing:</strong> 有効にすると、現在の言語で翻訳が見つからない場合にソース言語のテキスト（またはキー自体）を返します。",
  "li_settings_tms_timeout": "<strong>TMS Timeout:</strong> 外部 TMS サービスへのネットワーク要求の最大待機時間（秒）を指定します。",
  "li_settings_tool_check_deps": "<strong>Check Dependencies:</strong> 必須パッケージ（例: Newtonsoft）やオプション統合を再スキャンします。",
  "li_settings_tool_cleanup": "<strong>Full Project Cleanup:</strong> プロジェクトからすべての Anko Localization コンポーネントとデータを削除する破壊的ツールです（注意して使用してください）。",
  "li_settings_tool_clear_prefs": "<strong>Clear Language Prefs:</strong> PlayerPrefs に保存された言語設定をリセットし、次回起動時にデフォルトまたはシステム言語を使用させます。",
  "li_settings_tool_font_manager": "<strong>Font Manager:</strong> 欠損文字を分析し、最適化されたフォントアセットを生成する Font & Glyph Manager を開きます。",
  "li_settings_tool_migration": "<strong>Migration Tool:</strong> I2 Localization または Unity Localization からデータとコンポーネントの移行を支援します。",
  "li_settings_tool_test_center": "<strong>Localization Test Center:</strong> プロジェクトの健全性を検証し、壊れた参照をチェックし、ローカリゼーションの整合性を確保する診断ツールです。",
  "li_setup_1": "<strong>設定の作成:</strong> 初回起動時に、ツールは<code>Assets/Resources</code>フォルダに<code>LocalizationSettings.asset</code>ファイルを作成します。",
  "li_setup_2": "<strong>言語とモードの設定:</strong> <strong>Settings</strong> タブで、<strong>Source Language</strong> が正しいことを確認してください。また、<strong>Key Generation Mode</strong> を確認します（デフォルトは <code>AutoGenerateKeysOnly</code> で、ほとんどのプロジェクトに推奨されます）。",
  "li_setup_3": "<strong>パース処理のコンテンツ指定:</strong> **Content**タブで、解析対象のすべてのシーンを**Scenes to Parse**リストに追加します。テキストを含むプレハブを使用する場合は、そのフォルダが**Prefab Folders**に追加されていることを確認してください。",
  "li_setup_4": "<strong>最初のパーサー実行:</strong> **Actions**タブに移動し、<code>Update Keys</code>ボタンをクリックします。ツールはプロジェクトをスキャンし、翻訳ファイルを作成し、必要なコンポーネント（<code>LocalizedText</code>、<code>LocalizedAsset</code>など）をゲームオブジェクトに自動的に追加します。",
  "li_setup_5": "<strong>設定とビルド（重要）:</strong> ツールは自動的に<code>LocalizationSettings.asset</code>を<code>Project Settings -> Player -> Preloaded Assets</code>に追加します。 <br>⚠️ <strong>安全確認:</strong> 設定がPreloaded Assetsにない、またはResourcesフォルダにない場合、ツールはゲームが起動時にクラッシュするのを防ぐために<code>BuildFailedException</code>で<strong>ビルドをブロック</strong>します。",
  "li_sidebar_presets": "<strong>Search Presets:</strong> 未翻訳文字列やプレースホルダーが欠如したキーを探すなど、一般的なタスク用の事前定義フィルタです。",
  "li_sidebar_search": "<strong>Global Search:</strong> プロジェクト内のすべてのテーブルを横断して、特定のキーやテキストを検索します。",
  "li_tms_crowdin": "<strong>Crowdin:</strong> プロジェクトIDとAPIキーが必要です。ソースXLIFFのアップロードと、翻訳をZIPアーカイブとしてダウンロードをサポートします。<em>高度な設定:</em> <code>File Name</code>（Crowdin内のターゲットパス）。",
  "li_tms_loco": "<strong>Loco (localise.biz):</strong> APIキーが必要です。小規模プロジェクト向けのシンプルで高速な統合です。<em>高度な設定:</em> <code>Import/Export Params</code>（<code>&tag=v1</code> や <code>&status=translated</code> のような追加のLoco APIフラグを追加できます）。",
  "li_tms_phrase": "<strong>Phrase:</strong> エンタープライズレベルのローカリゼーション管理です。<em>高度な設定:</em> <code>Update Translations/Descriptions</code> フラグで、アップロード時にPhraseが既存データを上書きするかどうかを制御します。",
  "li_tms_transifex": "<strong>Transifex (v3):</strong> 組織/プロジェクトスラッグとAPIトークン認証をサポートします。<em>高度な設定:</em> <code>Resource Slug</code>（存在しない場合は自動的にリソースを作成します）。",
  "li_tutorials_1": "<strong>インタラクティブ学習:</strong> ガイドが特定の UI 要素をハイライトし、あなたの操作を待ちます。",
  "li_tutorials_2": "<strong>利用可能なレッスン:</strong>",
  "li_tutorials_editor": "<strong>翻訳エディタ:</strong> スプレッドシート風エディタの高度な機能。",
  "li_tutorials_list": "<strong>Tutorial List:</strong> ツールの主要機能に関するインタラクティブガイドにアクセスできます。",
  "li_tutorials_migration": "<strong>マイグレーション:</strong> 他のローカリゼーションシステム（I2、Unity Localization）からの移行方法。",
  "li_tutorials_quickstart": "<strong>クイックスタート:</strong> テキストとアセットの基本設定。",
  "li_tutorials_size": "<strong>Tutorial Size:</strong> インタラクティブガイドのUIスケールと詳細度を調整します（CompactからExtra Largeまで）。Tutorialsタブのヘッダーにあります。",
  "li_vis_debug_1": "<strong>Hierarchy Icons:</strong> 問題 (Missing Key、Missing Component) を即座に検出します。パフォーマンスへの影響はゼロになるよう最適化されています。",
  "li_vis_debug_2": "<strong>Scene View Labels:</strong> 各ローカライズされたオブジェクト上にキーを表示します。ラベルを <strong>右クリック</strong> して 'Copy Key' または 'Select Object' を選択できます。",
  "li_vis_debug_3": "<strong>Overlays:</strong> シーンビューのオーバーレイ (Space キー) を使用してプレビュー言語を即座に切り替えます。",
  "lightbox_aria_close": "画像ビューアを閉じる",
  "lightbox_image_alt": "拡大表示",
  "mindmap_edge_configure": "1. 設定",
  "mindmap_edge_creates_components": "コンポーネントを作成",
  "mindmap_edge_defines_rules": "ルールを定義する",
  "mindmap_edge_edited_in": "編集される",
  "mindmap_edge_enables_reaction": "反応を有効にする",
  "mindmap_edge_extends": "拡張する",
  "mindmap_edge_generates": "生成する",
  "mindmap_edge_manages_assets": "アセットを管理する",
  "mindmap_edge_opens": "開く",
  "mindmap_edge_parse_project": "3. プロジェクトをパース",
  "mindmap_edge_processed_by": "処理される",
  "mindmap_edge_recommends_for": "推奨する",
  "mindmap_edge_relates_to": "関連する",
  "mindmap_edge_reports_on": "レポートを出す",
  "mindmap_edge_see_faq": "FAQを参照",
  "mindmap_edge_specify_content": "2. コンテンツを指定",
  "mindmap_edge_warns_about": "警告する",
  "mindmap_node_ai_ecosystem": "AI エコシステム",
  "mindmap_node_async_code": "非同期 / Addressables",
  "mindmap_node_dev_tools": "ツールとユーティリティ",
  "mindmap_node_tms_integration": "TMS 統合",
  "mindmap_preset_ai": "AI と自動化",
  "mindmap_preset_dev": "開発者ワークフロー",
  "mindmap_preset_full": "全体表示",
  "mindmap_preset_quick_start": "クイックスタート",
  "mindmap_preset_tools": "ツールと統合",
  "mindmap_preset_translator": "翻訳者ワークフロー",
  "mindmap_toggle_title": "マインドマップを表示",
  "my_notes_title": "マイノート",
  "no_notes_message_new": "テキストにカーソルを合わせると、メモを追加できます。",
  "notes_add_title": "このブロックにメモを追加",
  "notes_close_title": "閉じる",
  "notes_delete_title": "メモを削除",
  "notes_edit_text": "編集",
  "notes_edit_title": "メモを編集",
  "notes_goto_title": "テキストに移動",
  "notes_placeholder": "あなたのメモ...",
  "on_this_page_title": "このページの内容",
  "p_actions_1": "メインの作業タブ。",
  "p_ai_assistant": "翻訳テーブルエディタでは、コンテキストメニュー（右クリック -> AI: ...）を介して、選択したセルでカスタムAIコマンドを実行できるようになりました。",
  "p_ai_audio_economy": "<strong>コスト削減:</strong> ツールはテキストのMD5ハッシュを計算し、ソーステキストが変更された場合にのみ音声ファイルを再生成するため、APIクレジットを節約できます。翻訳を変更した場合、システムはその特定の音声ファイルにのみ「Outdated」のフラグを立てます。変更されたものだけを再生成するために「Generate Missing/Outdated」を使用し、APIクレジットを節約します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、スマートバッチ処理を通じてAPIクレジットを節約します。",
  "p_ai_context": "翻訳の品質を向上させるために、AIは追加のコンテキストを受け取るようになりました。",
  "p_ai_intro": "このツールは <strong>Translation Profile</strong> システム (ScriptableObject) を使用します。これにより、翻訳サービスの設定が個別のプロファイルアセットに保持され、構成を簡単に切り替えることができます。",
  "p_api_snippets_intro": "<code>LocalizationManager.cs</code> は、実行時ローカリゼーション管理のための堅牢なAPIを提供します。以下はスクリプトで使用する主要なメソッドです。",
  "p_assets_1": "このタブは、非テキストリソースのローカライズ専用です。",
  "p_async_api": "Addressables を使用する場合、アセットは即座にロードされません。フレームドロップを防ぐために非同期 API を使用する必要があります。",
  "p_bridge_description": "このツールにはキーアクセス用の静的クラスジェネレータが含まれており、マジック文字列の代わりに強く型付けされた参照を使用できます。これによりタイプミスを防止し、IDE のオートコンプリートが有効になります。",
  "p_bridge_usage_title": "使用例:",
  "p_components_intro": "これらのコンポーネントは、シーン内のオブジェクトと翻訳データベースとの間の「橋渡し」です。言語の変更を「リッスン」し、正しいテキストまたはアセットを自動的に置き換えます。",
  "p_content_1": "ここでは、ツールにテキストをどこで探すべきかを正確に伝えます。インターフェースは使いやすさを向上させるために完全に再設計されました。",
  "p_custom_ai": "<strong>Custom AI</strong>サービスタイプを使用すると、REST APIを介して任意のLLMを接続できます。",
  "p_custom_asset_provider_1": "カスタムプロバイダーを開発することで、独自のアセット管理システム（例: カスタムクラウドローダー、特定の内部バンドリングシステム、またはデータベース駆動のアセットリポジトリ）をローカリゼーションワークフローに直接統合できます。",
  "p_custom_asset_provider_intro": "Asset Providerシステムは、実行時にアセット（Sprites、Audio、Prefabなど）がロードされる方法を抽象化します。<strong>Plugin Registry</strong> を使用し、<code>IAssetProvider</code> の実装クラスで <code>[AssetProviderPlugin]</code> 属性が付与されたものを自動的に検出します。これにより、コアツールキットを変更せずに、カスタムロードシステム（クラウドローダーや内部バンドリングなど）をシームレスに統合できます。",
  "p_custom_attributes_description": "関数呼び出しに加えて、スクリプト内の任意の文字列フィールドをカスタム属性でローカライズ可能としてマークできます。デフォルトではツールは <code>[LocalizableField]</code> を認識しますが、<code>[Header]</code> や <code>[Tooltip]</code> のような任意の属性名を <strong>Attributes to Scan</strong> リストに追加できます。",
  "p_custom_parser_1": "独自のパーサークラスを作成することで、カスタムコンポーネントをサポートするようにシステムを簡単に拡張できます。",
  "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong>から開きます。これは、手動で翻訳を編集するための主要なツールです。",
  "p_example_attribute_1": "スクリプト変数をローカライズする最も強力な方法です。<strong>private, protected, and public</strong> フィールドでも機能します。パーサーは <strong>Arrays, Lists</strong>、および <strong>Nested Serializable Classes</strong> を再帰的に処理します。設定で構成すれば、他の属性（<code>[Header]</code> や <code>[Tooltip]</code> など）用のキーも生成できます。",
  "p_example_components_1": "プロジェクトには、優れた例となる既製のスクリプトが含まれています。",
  "p_example_components_updated": "コードが変更されました。言語のロード（特にAddressablesを使用する場合）が非同期になりました。",
  "p_example_function_1": "ゲームプレイ中に変化する動的テキストには、<code>_()</code>関数を使用します。UIを更新するメソッドは、言語が変更されたときに自動的に呼び出されるように、<code>[OnLanguageChange]</code>属性でマークする必要があります。この目的のために、<code>LocalizedBehaviour</code>コンポーネントがオブジェクトに自動的に追加されます。",
  "p_example_plurals_1": "ツールは、異なる言語グループに対してより正確なルールを使用するようになりました。",
  "p_font_glyph_manager_access": "<strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>からアクセスします。",
  "p_intro_1": "このツールは、Unityでのゲームおよびアプリケーションのローカライズのための包括的なソリューションです。テキストとアセットの収集の自動化、強力なインターフェースを介した翻訳管理、機械翻訳サービス（カスタムAIを含む）との統合、ゲーム内でのローカライズコンテンツの動的な更新を実現します。",
  "p_live_updates_guide": "Live Updates システムを使用すると、ゲームは新しい翻訳をリモートサーバーまたは Google Sheet からランタイムで取得でき、再ビルドは不要です。",
  "p_localizedasset_1": "言語に基づいてアセットを交換するために使用されます。コンポーネントのタイプを自動的に検出します。サポート対象: <ul><li><strong>2D:</strong> スプライト（<code>Image</code>、<code>SpriteRenderer</code>）、テクスチャ（<code>RawImage</code>）。</li><li><strong>オーディオ/ビデオ:</strong> <code>AudioSource</code>、<code>VideoPlayer</code>。</li><li><strong>3D/アニメーション:</strong> <code>MeshFilter</code>（メッシュ）、<code>Renderer</code>（マテリアル）、<code>Animator</code>（コントローラー）、<code>PlayableDirector</code>（タイムライン）。</li></ul>",
  "p_localizedasset_2": "<strong>Play on Awake</strong>オプションを持つコンポーネント（<code>AudioSource</code>、<code>VideoPlayer</code>など）の場合、<code>LocalizedAsset</code>は自動再生を正しくインターセプトし、アセットを交換した後、ローカライズされていないコンテンツが再生されるのを防ぐために再生を開始します。",
  "p_localizedasset_updated": "コンポーネントは非同期ローディングをサポートするようになりました。アセットがクラウド/ディスク（Addressables）からロードされる場合、言語の変更時にわずかな遅延が発生する可能性があることに注意してください。",
  "p_localizedbehaviour_1": "スクリプトが言語の変更に反応できるようにするユーティリティコンポーネントです。<code>[OnLanguageChange]</code>属性でマークされたメソッドを自動的に見つけて呼び出します。",
  "p_localizeddropdown_1": "<code>Dropdown</code>と<code>TMP_Dropdown</code>に追加され、そのオプションを翻訳します。",
  "p_localizedprefab_1": "プレハブ全体をローカライズするためのコンポーネントです。非破壊的に動作します。元のプレハブを変更するのではなく、ローカライズされたバージョンのインスタンスを子オブジェクトとして作成し、元のオブジェクトのすべてのスクリプト（<code>MonoBehaviour</code>）、レンダラー（<code>Renderer</code>）、およびコライダー（<code>Collider</code>）を無効にします。これにより、二重のロジック実行と視覚的なアーティファクトを防ぎます。正しいランタイム操作のために、他のスクリプトよりも早く実行されるように、その実行順序は-100（<code>[DefaultExecutionOrder(-100)]</code>）に設定されています。",
  "p_localizedtext_1": "翻訳されたテキストを表示するための主要なコンポーネントです。<code>Text</code>、<code>TMP_Text</code>、および<code>TextMesh</code>を持つオブジェクトに配置されます。",
  "p_migration_custom": "カスタムシステムや特定のプロジェクト設定をサポートするために、独自のマイグレーションプロファイルを作成できます。各プロファイルは、コンポーネントとそのフィールドの変換方法を定義する <strong>Rules</strong> のリストを含みます。Rules は <strong>Priority</strong> の順にチェックされます。",
  "p_migration_custom_advanced": "マイグレーションプロファイルは、インポートと検出プロセスを微調整するための高度な設定を提供します:",
  "p_migration_google_sheet": "ファイルをダウンロードせずに、Google Sheet の URL から直接インポートできます。",
  "p_migration_import_csv": "ツールは標準的な CSV ファイル（カンマ区切り）をサポートします。最初の行はヘッダーである必要があります。",
  "p_migration_stubs": "マイグレーション時の一般的な問題は、古いプラグイン（例: I2）を削除するとビルドが壊れ、Unity が Migration Tool 自体をコンパイルできなくなることです。",
  "p_migration_tool_access": "<strong>Tools -> Anko Localization Tool -> Migration Tool</strong>からアクセスします。",
  "p_migration_tool_desc": "他のローカライゼーションシステム（I2 Localization、Unity Localization）からの移行のためのツール。",
  "p_preview_1": "ヘッダーのすぐ下には、<strong>Preview Language</strong>ドロップダウンリストがあります。この強力な機能により、ゲームを実行せずに、<strong>Scene</strong>ウィンドウまたは<strong>Prefab Mode</strong>でローカライズが任意の言語でどのように見えるかを直接確認できます。",
  "p_preview_overlay": "さらに高速な反復のために、専用の <strong>Localization Preview Overlay</strong> を使用して Scene View から直接言語を切り替えることができます。",
  "p_report_1": "パース処理の後、このレポートはローカライゼーションのステータスの全体像を示します。",
  "p_safety_caps": "意図しない高コストや大量トラフィックのチェックを防ぐために:",
  "p_script_parsing_rules_description": "ツールは、既存のコードを変更せずにカスタム関数や競合システム（例: I2 Localization）で使用されているローカリゼーションキーを認識するように設定できます。これは、スキャナがスクリプトからキーを抽出するために使用する正規表現パターンを定義することで実現します。",
  "p_script_parsing_rules_usage": "<strong>Content</strong> タブの <strong>Script Parsing Rules</strong> セクションで、特定の関数呼び出しにマッチするルールを追加できます。例えば、<code>I2.Loc.Get(\\\"key\\\")</code> をサポートするために、括弧内の文字列をキャプチャするパターンのルールを追加できます。",
  "p_settings_1": "あなたのコントロールセンター。ここでは、ローカライズプロセス全体のグローバルルールを定義します。",
  "p_tms_intro": "このツールは、人気のある翻訳管理システムとの同期をサポートするようになりました。Unity 内でソースキーをプッシュし、翻訳をプルできます。",
  "p_tms_setup": "1. <strong>Actions -> External Services</strong> に移動します。<br>2. サービスプロバイダーを選択します。<br>3. APIキーとプロジェクトIDを入力します。<br>4. 設定ウィンドウの <strong>Push</strong>（キーのアップロード） と <strong>Pull</strong>（翻訳のダウンロード） ボタンを使用します。",
  "p_tutorials_1": "チュートリアルタブは、インタラクティブなステップバイステップガイドを提供し、Unity エディタ内で直接ツールの機能を習得できるよう支援します。",
  "p_uitklocalization_1": "<code>UIDocument</code> を持つオブジェクトに追加されます。任意の要素上で <strong>Labels、Buttons、HelpBox、Foldout、ProgressBar（title）、TextField（label と placeholder）、DropdownField（label と choices）、RadioButton、RadioButtonGroup、ToggleButtonGroup（Unity 2023+）、および Tooltips</strong> のローカリゼーションをサポートします。UI BuilderでIDが設定されている場合、識別子は名前変更後も安定しています。",
  "p_window_footer": "現在のステータス、バックグラウンド操作の進行状況、ツールのバージョンを表示します。",
  "p_window_header": "トップバーは、プレビューコントロールやユーティリティツールへのグローバルアクセスを提供し、選択されたタブに関係なく保持されます。",
  "p_window_sidebar": "サイドバーは、さまざまな機能タブ間のナビゲーションとグローバル検索ツールを処理します。",
  "page_title": "Unityローカライゼーションツール ドキュメント",
  "q_faq_addressables_1": "Addressablesモードを有効にしましたが、アセットがロードされません。何を確認すべきですか？",
  "q_faq_addressables_2": "DeepL/Googleのサポートを追加するにはどうすればよいですか？",
  "q_faq_addressables_3": "I2/UnityLocを削除した後、マイグレータがコンパイルエラーを表示します。これを修正するにはどうすればよいですか？",
  "q_faq_audio_smart_update": "音声ファイルを再生成する際に、ツールはどのようにAPIクレジットを節約しますか？",
  "q_faq_components_1": "LocalizedPrefab コンポーネントは元のオブジェクトの MonoBehaviour を無効にします。元のオブジェクトに Awake() で他のオブジェクトを生成したりイベントにサブスクライブするスクリプトがある場合はどうなりますか？",
  "q_faq_components_2": "元のプレハブ（LocalizedPrefab）にRigidbodyや他の物理コンポーネントがある場合、それは無効になりますか？ローカライズされたプレハブにそれがない場合、これは物理に影響しますか？",
  "q_faq_components_3": "LocalizedAssetコンポーネントは、ターゲットコンポーネント名を文字列（_targetComponentTypeName）として保存します。カスタムコンポーネントスクリプトの名前を変更したり、別のAssemblyInfo（Assembly Definition）に移動したりすると、LocalizedAssetはそれに対して機能しなくなりますか？",
  "q_faq_components_4": "同じGameObjectに2つのImageコンポーネントがある場合、LocalizedAssetはどちらをローカライズするかをどのように知りますか？両方で機能しますか、それとも最初に見つけたものだけですか？",
  "q_faq_components_5": "LocalizedPrefabコンポーネントの実行順序が-100であるとドキュメントに記載されています。Awake()でLocalizedPrefabによって作成された子オブジェクトを見つけようとする実行順序が-110の別のスクリプトがある場合、LocalizedPrefabは間に合ってインスタンス化を完了していますか？",
  "q_faq_components_6": "LocalizedTextコンポーネントにはisStyleOnlyオプションがあります。これを有効にしてから、コードでmyLocalizedText.SetFormattedText(\"new_key\")を呼び出すと、テキストは変更されますか、それともスタイル（フォント/RTL）のみが変更されますか？",
  "q_faq_components_7": "LocalizedBehaviourは[OnLanguageChange]属性を持つメソッドを自動的に見つけます。privateおよびprotectedメソッドも見つけますか、それともpublicである必要がありますか？",
  "q_faq_components_8": "LocalizedAssetコンポーネントはPlay on Awakeをインターセプトします。同じオブジェクト上の別のスクリプトが、LocalizedAssetが交換する前にAwake()またはStart()でアセット（例：audioSource.clip.length）にアクセスしようとするとどうなりますか？NullReferenceExceptionまたは古いアセットの使用は可能ですか？",
  "q_faq_custom_keys_attribute": "<code>[LocalizableField]</code>の代わりに、独自の属性をキーに使用できますか？",
  "q_faq_custom_provider_1": "カスタムプロバイダーが Settings のドロップダウンに表示されないのはなぜですか？",
  "q_faq_editor_1": "プレースホルダー検証において、コメント内の@placeholders:ディレクティブとソース言語テキストで見つかったプレースホルダーのどちらが優先されますか？たとえば、ソーステキストに{name}があり、コメントに@placeholders: {username}とある場合。",
  "q_faq_editor_2": "ディレクティブでタイプミスをした場合（例：@placeholders:ではなく@placeholder:）、それは無視されますか、それともツールは警告を出しますか？",
  "q_faq_editor_3": "オートセーブシステムはBackups/AutoSavesフォルダにファイルを作成します。これらのファイルは、手動での保存が成功した後、またはウィンドウを閉じた後に自動的に削除されますか？",
  "q_faq_editor_4": "エディタで列幅を変更した場合、これらの設定はUnityセッション間で保存されますか？",
  "q_faq_editor_5": "テキスト編集ポップアップウィンドウ（MultiLineEditWindow）は、その中で行われた変更に対して独自のUndo/Redoスタック（Ctrl + Zを介して）をサポートしていますか？",
  "q_faq_examples_1": "_()関数に渡された匿名型のプロパティ名が文字列内のプレースホルダーと一致しない場合、どうなりますか？たとえば、_(\"Hello, {username}\", new { user_name = \"Bob\" })。エラーが発生しますか、それともプレースホルダーは単に置き換えられませんか？",
  "q_faq_examples_2": "[LocalizableField]属性はプライベートフィールドで機能します。スタティックフィールドで機能しますか？",
  "q_faq_examples_3": "パラメーターを持つメソッド（例：void UpdateUI(string newLang)）に[OnLanguageChange]属性を設定した場合、どうなりますか？コンパイルエラーが発生しますか、それともランタイム警告が発生しますか？",
  "q_faq_examples_4": "_(\"apple_count\", count)を使用しています。現在の言語にキーapple_count_oneがない場合（count = 1の場合）、システムはどの形式を選択しますか？フォールバックとしてapple_count_otherを使用しますか？",
  "q_faq_examples_5": "関数_(\"key\", new { username = \"Alex\" })は匿名型を使用します。これは、事前に作成されたDictionary<string, object>を渡すのと比較して、Update()メソッドでの頻繁な呼び出しでガベージコレクター（GC）に過度の「負荷」をかけませんか？",
  "q_faq_examples_6": "[OnLanguageChange]属性でマークされたメソッドが呼び出されません。なぜですか？",
  "q_faq_extending_1": "カスタムパーサーは、Update Keysの後に自動的に呼び出されますか？どこかに登録する必要がありますか、それともプロジェクトにITextComponentParserを実装するクラスがあるだけで十分ですか？",
  "q_faq_extending_2": "カスタムパーサーで例外が発生した場合、どうなりますか？パース処理全体が中断されますか、それともツールは他のパーサーで安全に続行しますか？",
  "q_faq_installation_1": "私のプロジェクトに他のアセットからcom.unity.nuget.newtonsoft-jsonパッケージが既に存在する場合、依存関係インストーラーはそれを更新しようとしますか、それとも無視しますか？",
  "q_faq_installation_2": "オプションの依存関係（例：CSVサポート用）について、誤って「Skip for Now」をクリックし、「Don't ask again」にチェックを入れてしまいました。インストーラーウィンドウを再度表示して、それらをインストールするにはどうすればよいですか？",
  "q_faq_installation_3": "ツールがAssets/ResourcesにLocalizationSettings.assetを作成しませんでした。なぜこのようなことが起こった可能性があり、Assets -> Createメニューから手動で作成できますか？",
  "q_faq_installation_4": "LocalizationSettings.assetファイルを別のResourcesフォルダ、たとえばAssets/MyGame/Resourcesに移動できますか？ツールはまだそれを見つけますか？",
  "q_faq_installation_5": "依存関係インストーラーがフリーズしたり、エラーを出したりしました。パッケージマネージャーを介して依存関係（Newtonsoft Json、Editor Coroutines）を手動でインストールできますか？",
  "q_faq_notes_1": "ドキュメントでは、LanguageSelectorを無視リストに追加することを推奨しています。これを忘れた場合、正確には何が壊れますか？「Option A、Option B」の追加のキーが作成されますか？",
  "q_faq_notes_2": "LanguageSelectorで使用されるTMP_Dropdown内のLabelに、isStyleOnlyチェックボックスが有効になっている空のLocalizedTextを**手動で**追加するのを忘れた場合、フォントは変更されませんか？なぜこれが必要なのですか？",
  "q_faq_notes_3": "Update()メソッドでの_()の呼び出しは推奨されません。しかし、毎フレームテキストを更新する必要がある場合（例：タイマー）はどうですか？フォーマット文字列のみをキャッシュする最もパフォーマンスの高い方法はありますか？",
  "q_faq_tts_voices": "特定のボイスをキャラクターに割り当てるにはどうすればよいですか？",
  "q_faq_window_actions_1": "バッチ自動翻訳中にインターネット接続が失われた場合、どうなりますか？ツールはリトライポリシーに従って失敗したバッチを再試行しますか、それともプロセスは完全に中断されますか？",
  "q_faq_window_actions_2": "プロジェクトに既に存在するキーを含むCSVファイルをインポートしましたが、一部の言語の値が空の場合、これらの空の値は既存の翻訳を置き換えますか、それとも無視されますか？",
  "q_faq_window_actions_3": "「危険ゾーン」セクションでは、すべてのコンポーネントを削除できます。これは、ContentタブのPrefab Foldersで指定されていないフォルダにあるプレハブからコンポーネントを削除しますか？",
  "q_faq_window_actions_4": "Google Sheetsからインポートする場合、@placeholders:ディレクティブを使用したプレースホルダー検証を機能させるために、コメント列をどのようにフォーマットする必要がありますか？",
  "q_faq_window_actions_5": "ツールは、単一のGoogle Sheetsドキュメントの複数のシートからデータをインポートできますか、それとも1つのGIDあたり1つのシートでのみ機能しますか？",
  "q_faq_window_assets_1": "同じキーであるが異なるタイプのアセットが同じスキャンフォルダにある場合（例：sound_effect_en.mp3とsound_effect_en.wav）、どちらがアセットテーブルに残りますか？",
  "q_faq_window_assets_2": "Scan Assets & Analyze Projectをクリックし、シーン内にローカライズされたスプライトが既に存在するImageオブジェクトがあるが、Imageオブジェクト自体にはまだLocalizedAssetコンポーネントがない場合、ツールはコンポーネントを追加し、キーを自動的に挿入しますか？",
  "q_faq_window_assets_3": "異なるScan Foldersがある場合、同じNaming Ruleを異なるアセットカテゴリに使用できますか？これにより競合が発生しますか？",
  "q_faq_window_assets_4": "ローカライズ可能なアセット（例：button_ok_en.png）がScan Folderのルートではなく、サブフォルダにある場合、スキャナーは見つけますか？",
  "q_faq_window_content_1": "Build Settingsに含まれていないシーンをScenes to Parseに追加した場合、パース処理自体以外に何かに影響しますか？",
  "q_faq_window_content_2": "Ignore Specific Objects（一時リスト）にオブジェクトを追加しました。このオブジェクトからプレハブを作成した場合、このプレハブのインスタンスも無視されますか？",
  "q_faq_window_content_3": "TMPro.TMP_TextコンポーネントをParsing Ignores -> Ignore Component Typesに追加しましたが、シーン内に既にこのTMP_Textを参照しているLocalizedTextを持つオブジェクトがある場合、次回のUpdate Keysでどうなりますか？キーは削除されますか？",
  "q_faq_window_content_4": "ドキュメントには、「Pin」はオブジェクトへの完全なパスを保存し、名前が変更されると壊れると記載されています。オブジェクトからプレハブを作成し、その後元のオブジェクトの名前を変更した場合、「Pin」はプレハブインスタンスに対して引き続き機能しますか？",
  "q_faq_window_content_5": "プレハブインスタンス内の子オブジェクトに「Pin」を使用した場合、どのパスが保存されますか。プレハブルートに対する相対パスですか、それともシーンルートですか？他のシーンで機能しますか？",
  "q_faq_window_preview_1": "プレハブモードでプレハブを開き、エディタ内プレビューを適用し、Ctrl + Sを押しました。一時的なプレビューデータはプレハブアセットに保存されますか？LocalizationPreviewProtectorはこのケースをどのように処理しますか？",
  "q_faq_window_preview_2": "エディタ内プレビューを有効にしていて、Unityエディタがクラッシュし、Temp/localization_preview_recovery.jsonファイルが破損した場合（例：空または無効なJSON）、次回の起動時にどうなりますか？",
  "q_faq_window_preview_3": "LocalizedPrefabのエディタ内プレビューモードでは、一時的なインスタンスが作成されます。このインスタンスでAwake()とStart()メソッドは実行されますか？これらが編集モードで実行されるように設計されていない場合、エラーを引き起こす可能性がありますか？",
  "q_faq_window_report_1": "「Find」ボタンはオブジェクトを非同期で検索します。検索を開始してからすぐにUpdate Keysをクリックした場合、検索は中断されますか？",
  "q_faq_window_report_2": "キーが複数の場所で使用されている場合（例：異なるシーンの2つの異なるボタン）、これはレポートの「Duplicates」カテゴリにどのように表示されますか？",
  "q_faq_window_report_3": "コード内でのみ使用されているキー（_()関数を介して）に対して「Find」をクリックした場合、どうなりますか？ツールはC#スクリプトを見つけてハイライト表示（ping）できますか？",
  "q_faq_window_settings_1": "プロジェクトの途中でキー生成モードをUseTextAsKeyからAutoGenerateKeysOnlyに変更できます。既存の翻訳には正確に何が起こりますか？それらは新しいキーにマッピングされますか？",
  "q_faq_window_settings_2": "サポートされている言語リストに複数形ルールがない言語コード（例：カザフ語の「kz」）を追加した場合、デフォルトでどのルールが使用されますか？",
  "q_faq_window_settings_3": "Translations PathをStreamingAssetsではなく、Assets/MyTranslationsのような通常のフォルダに指定した場合、jsonファイルはゲームビルドに含まれますか？",
  "q_faq_window_settings_4": "自動翻訳APIキーはEditorPrefsに保存されます。プロジェクトで2台の異なるコンピューターで作業している場合、各マシンで個別にキーを入力する必要がありますか？",
  "tip_best_practice": "<strong>プロのヒント:</strong> プロパティをローカライズする必要がある場合は、<code>[LocalizableField]</code>でバッキングフィールドを作成し、プロパティを個別に公開します。",
  "toc_search_placeholder": "ドキュメントを検索...",
  "toc_title": "目次",
  "toggle_notes_title": "ノートの切り替え",
  "warning_box_components": "<strong>重要な注意:</strong> 以下に説明するすべてのコンポーネントは、パース処理中（<code>Update Keys</code>ボタンをクリックしたとき）にゲームオブジェクトに自動的に追加されます。手動で追加する必要はありません。",
  "warning_tms_overwrite": "<strong>Warning:</strong> TMS からプルすると、該当キーのローカル翻訳が上書きされます。TMS が唯一の真実の情報源であることを確認してください。"
}