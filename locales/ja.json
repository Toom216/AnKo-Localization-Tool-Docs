{
  "page_title": "Unityローカライゼーションツール ドキュメント",
  "toc_title": "目次",
  "toc_search_placeholder": "ドキュメントを検索...",
  "nav_introduction": "1. はじめに",
  "nav_quick_start": "2. クイックスタート",
  "nav_components": "3. コアコンポーネント",
  "nav_loc_tool_window": "4. 「ローカライゼーションツール」ウィンドウ",
  "nav_translation_editor": "5. 翻訳エディタ",
  "nav_ai_profiles": "6. AI＆翻訳プロファイル (New v1.1)",
  "nav_usage_examples": "7. 使用例",
  "nav_important_notes": "8. 重要な注意事項",
  "nav_extending": "9. 機能の拡張",
  "nav_faq": "10. FAQとトラブルシューティング",
  "nav_migration_tool": "11. 移行ツール",
  "nav_font_glyph_manager": "12. フォント＆グリフマネージャ",
  "nav_pseudo_tool": "13. 疑似ローカライゼーションツール",
  "nav_ai_audio": "14. AI音声 / テキスト読み上げ (Text-to-Speech)",
  "nav_key_features": "主な機能",
  "nav_installation": "2.1. インストール",
  "nav_initial_setup": "2.2. 初期設定",
  "nav_localizedtext": "3.1. LocalizedText",
  "nav_localizedasset": "3.2. LocalizedAsset",
  "nav_localizedprefab": "3.3. LocalizedPrefab",
  "nav_uitklocalization": "3.4. UITKLocalization",
  "nav_localizeddropdown": "3.5. LocalizedDropdown",
  "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
  "nav_context_menu": "3.7. コンテキストメニュー",
  "nav_in_editor_preview": "4.1. エディタ内＆プレハブプレビュー",
  "nav_tab_settings": "4.2. 「設定」タブ",
  "nav_tab_content": "4.3. 「コンテンツ」タブ (再設計)",
  "nav_tab_actions": "4.4. 「アクション」タブ",
  "nav_tab_assets": "4.5. 「アセット」タブ",
  "nav_tab_report": "4.6. 「レポート」タブ",
  "nav_ai_profiles_overview": "6.1. 翻訳プロファイル",
  "nav_custom_ai": "6.2. カスタムAIとモデル",
  "nav_ai_context": "6.3. コンテキストと用語集",
  "nav_ai_assistant": "6.4. AIアシスタントコマンド",
  "nav_example_components": "7.1. 既製のコンポーネント",
  "nav_example_attribute": "7.2. [LocalizableField] 属性",
  "nav_example_function": "7.3. _() 関数",
  "nav_example_plurals": "7.4. 複数形とジェンダー",
  "nav_custom_parser": "9.1. パーサーの作成",
  "nav_faq_installation": "10.1. インストールとクイックスタート",
  "nav_faq_components": "10.2. コアコンポーネント",
  "nav_faq_window": "10.3. 「ローカライゼーションツール」ウィンドウ",
  "nav_faq_window_actions": "10.3. 「ローカライゼーションツール」ウィンドウ - 「アクション」タブ",
  "nav_faq_window_assets": "10.3. 「ローカライゼーションツール」ウィンドウ - 「アセット」タブ",
  "nav_faq_window_report": "10.3. 「ローカライゼーションツール」ウィンドウ - 「レポート」タブ",
  "nav_faq_editor": "10.4. 翻訳エディタ",
  "nav_faq_examples": "10.5. 使用例とコード",
  "nav_faq_notes": "10.6. 重要な注意点と警告",
  "nav_faq_extending": "10.7. 機能の拡張",
  "h1_introduction": "はじめに",
  "p_intro_1": "このツールは、Unityでのゲームおよびアプリケーションのローカライズのための包括的なソリューションです。テキストとアセットの収集の自動化、強力なインターフェースを介した翻訳管理、機械翻訳サービス（カスタムAIを含む）との統合、ゲーム内でのローカライズコンテンツの動的な更新を実現します。",
  "h2_key_features": "主な機能",
  "li_feature_1": "<strong>高度なパース処理:</strong> シーン、プレハブ、UI Toolkit (UXML)、および <code>[LocalizableField]</code> 属性でマークされたフィールド、ネストされたクラスやリストを含むC#スクリプトの自動スキャン。",
  "li_feature_2": "<strong>あらゆるアセットのローカライズ:</strong> スプライト、オーディオ、プレハブ、マテリアルなどを管理します。",
  "li_feature_3": "<strong>強力な翻訳エディタ:</strong> オートセーブ、完全なアンドゥ/リドゥサポート、スマートなキーグルーピング、および<strong>New in v1.1:</strong> 複数選択アクションを備えた一元化されたインターフェース。",
  "li_feature_4": "<strong>AIと機械翻訳 (v1.1):</strong> DeepL、Google、Microsoft、そしてコンテキスト認識機能を備えた<strong>カスタムAI (OpenAI, Gemini, Claude, Ollama)</strong> をサポートする新しいプロファイルシステム。",
  "li_feature_5": "<strong>柔軟なインポート/エクスポート:</strong> CSV、XML、YAML、XLIFFをサポートし、Google Sheetsからの直接インポートも可能です。",
  "li_feature_6": "<strong>ライブプレビュー:</strong> ゲームを実行せずに、シーンビューまたは<strong>プレハブモード</strong>で任意の言語をプレビュー。",
  "li_feature_7": "<strong>複数形とジェンダーのサポート:</strong> 複数形（スラブ語、アラビア語、その他の言語のルールを含む）とジェンダーの正しい処理。",
  "li_feature_8": "<strong>完全なRTLサポート:</strong> 右から左への言語の正しい表示。",
  "li_feature_9": "<strong>ライブアップデート:</strong> ゲーム開始時にリモートサーバーから最新の翻訳をロード。",
  "li_feature_10": "<strong>バックアップマネージャ:</strong> バックアップの作成と復元のための組み込みツール。",
  "li_feature_11": "<strong>AIパワード:</strong> カスタマイズ可能なプロファイルを介したOpenAI、Anthropic (Claude)、Google Gemini、およびローカルLLM (Ollama) のサポート。",
  "li_feature_12": "<strong>テキスト読み上げ (TTS):</strong> AI（OpenAI、ElevenLabs）を使用したローカライズされた文字列の音声ファイルの生成。",
  "li_feature_13": "<strong>移行ツール:</strong> I2 LocalizationおよびUnity Localizationプラグインからの自動移行のためのツール。",
  "li_feature_14": "<strong>フォント＆グリフマネージャ:</strong> 使用されている文字を分析し、フォント内の不足しているグリフを見つけるためのツール。",
  "li_feature_15": "<strong>ビジュアルデバッグ:</strong> 迅速なデバッグのためのヒエラルキー内のアイコンとシーンビュー内のラベル。",
  "h1_quick_start": "クイックスタートとセットアップ",
  "h2_installation": "2.1. インストール",
  "li_install_1": "アセットをUnityプロジェクトフォルダにコピーします。",
  "li_install_2": "ツールが必要な依存関係を自動的にチェックします。表示されるダイアログボックスでインストールを確認してください。",
  "li_install_3": "必須の依存関係（<code>Newtonsoft Json</code>、<code>Editor Coroutines</code>）は、基本的な機能に必要です。",
  "li_install_4": "オプションの依存関係（<code>Arabic Support</code>、<code>CsvHelper</code>、<code>YamlDotNet</code>）は、追加機能を有効にします。",
  "li_install_5": "推奨パッケージをインストールするには、<strong>Install Selected</strong>をクリックします。",
  "li_install_6": "インストール後、<strong>Tools -> Localization Tool</strong>メニューからメインツールウィンドウを開きます。",
  "li_install_7": "非同期アセットローディングを使用する予定がある場合は、パッケージマネージャーを介して<strong>Addressables</strong>パッケージをインストールしてください。",
  "h2_initial_setup": "2.2. 初期設定",
  "li_setup_1": "<strong>設定の作成:</strong> 初回起動時に、ツールは<code>Assets/Resources</code>フォルダに<code>LocalizationSettings.asset</code>ファイルを作成します。",
  "li_setup_2": "<strong>言語の設定:</strong> **Settings**タブの**Language Management**で、メイン言語（例：英語の場合は<code>en</code>）が**Source Language**として選択されていることを確認してください。サポートする予定のすべての言語を有効にしてください。",
  "li_setup_3": "<strong>パース処理のコンテンツ指定:</strong> **Content**タブで、解析対象のすべてのシーンを**Scenes to Parse**リストに追加します。テキストを含むプレハブを使用する場合は、そのフォルダが**Prefab Folders**に追加されていることを確認してください。",
  "li_setup_4": "<strong>最初のパーサー実行:</strong> **Actions**タブに移動し、<code>Update Keys</code>ボタンをクリックします。ツールはプロジェクトをスキャンし、翻訳ファイルを作成し、必要なコンポーネント（<code>LocalizedText</code>、<code>LocalizedAsset</code>など）をゲームオブジェクトに自動的に追加します。",
  "li_setup_5": "<strong>設定とビルド（重要）:</strong> ツールは自動的に<code>LocalizationSettings.asset</code>を<code>Project Settings -> Player -> Preloaded Assets</code>に追加します。 <br>⚠️ <strong>安全確認:</strong> 設定がPreloaded Assetsにない、またはResourcesフォルダにない場合、ツールはゲームが起動時にクラッシュするのを防ぐために<code>BuildFailedException</code>で<strong>ビルドをブロック</strong>します。",
  "h1_components": "コアコンポーネント（自動的に割り当てられます）",
  "warning_box_components": "<strong>重要な注意:</strong> 以下に説明するすべてのコンポーネントは、パース処理中（<code>Update Keys</code>ボタンをクリックしたとき）にゲームオブジェクトに自動的に追加されます。手動で追加する必要はありません。",
  "p_components_intro": "これらのコンポーネントは、シーン内のオブジェクトと翻訳データベースとの間の「橋渡し」です。言語の変更を「リッスン」し、正しいテキストまたはアセットを自動的に置き換えます。",
  "h2_localizedtext": "3.1. LocalizedText",
  "p_localizedtext_1": "翻訳されたテキストを表示するための主要なコンポーネントです。<code>Text</code>、<code>TMP_Text</code>、および<code>TextMesh</code>を持つオブジェクトに配置されます。",
  "li_localizedtext_1": "<code>localizationKey</code>: 翻訳を見つけるために使用されるキー。自動的に生成されます。",
  "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code>の場合、コンポーネントはスタイル（フォント、RTL）のみを適用し、テキスト自体は変更しません。（例：<code>LanguageSelector</code>によってテキストが管理されている要素に役立ちます）。",
  "li_localizedtext_3": "<code>originalSourceText</code>: ベース言語の元のテキスト。フォールバックとして使用されます。",
  "h2_localizedasset": "3.2. LocalizedAsset",
  "p_localizedasset_1": "言語に基づいてアセットを交換するために使用されます。コンポーネントのタイプを自動的に検出します。サポート対象: <ul><li><strong>2D:</strong> スプライト（<code>Image</code>、<code>SpriteRenderer</code>）、テクスチャ（<code>RawImage</code>）。</li><li><strong>オーディオ/ビデオ:</strong> <code>AudioSource</code>、<code>VideoPlayer</code>。</li><li><strong>3D/アニメーション:</strong> <code>MeshFilter</code>（メッシュ）、<code>Renderer</code>（マテリアル）、<code>Animator</code>（コントローラー）、<code>PlayableDirector</code>（タイムライン）。</li></ul>",
  "p_localizedasset_2": "<strong>Play on Awake</strong>オプションを持つコンポーネント（<code>AudioSource</code>、<code>VideoPlayer</code>など）の場合、<code>LocalizedAsset</code>は自動再生を正しくインターセプトし、アセットを交換した後、ローカライズされていないコンテンツが再生されるのを防ぐために再生を開始します。",
  "h2_localizedprefab": "3.3. LocalizedPrefab",
  "p_localizedprefab_1": "プレハブ全体をローカライズするためのコンポーネントです。非破壊的に動作します。元のプレハブを変更するのではなく、ローカライズされたバージョンのインスタンスを子オブジェクトとして作成し、元のオブジェクトのすべてのスクリプト（<code>MonoBehaviour</code>）、レンダラー（<code>Renderer</code>）、およびコライダー（<code>Collider</code>）を無効にします。これにより、二重のロジック実行と視覚的なアーティファクトを防ぎます。正しいランタイム操作のために、他のスクリプトよりも早く実行されるように、その実行順序は-100（<code>[DefaultExecutionOrder(-100)]</code>）に設定されています。",
  "h2_uitklocalization": "3.4. UITKLocalization",
  "p_uitklocalization_1": "<code>UIDocument</code>を持つオブジェクトに追加されます。ラベル、ボタン、<strong>TextFieldのプレースホルダー、DropdownFieldの選択肢、RadioButtonGroupとToggleButtonGroupのオプション</strong>のローカライズをサポートします。UI BuilderでIDが設定されている場合、識別子は名前の変更後も安定しています。",
  "h2_localizeddropdown": "3.5. LocalizedDropdown",
  "p_localizeddropdown_1": "<code>Dropdown</code>と<code>TMP_Dropdown</code>に追加され、そのオプションを翻訳します。",
  "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
  "p_localizedbehaviour_1": "スクリプトが言語の変更に反応できるようにするユーティリティコンポーネントです。<code>[OnLanguageChange]</code>属性でマークされたメソッドを自動的に見つけて呼び出します。",
  "h2_context_menu": "3.7. 「ローカライズのために分析」コンテキストメニュー",
  "p_context_menu_1": "オブジェクトに<code>LocalizedAsset</code>をすばやく追加するには、インスペクター内の目的のコンポーネント（例：<code>Image</code>、<code>AudioSource</code>）を右クリックし、<strong>Analyze for Localization</strong>を選択します。ツールがコンポーネント自体を追加および設定します。（これはオプションですが、手動で追加するために使用できます）。",
  "h1_loc_tool_window": "「ローカライゼーションツール」ウィンドウ",
  "h2_in_editor_preview": "4.1. エディタ内＆プレハブプレビュー",
  "p_preview_1": "ヘッダーのすぐ下には、<strong>Preview Language</strong>ドロップダウンリストがあります。この強力な機能により、ゲームを実行せずに、<strong>Scene</strong>ウィンドウまたは<strong>Prefab Mode</strong>でローカライズが任意の言語でどのように見えるかを直接確認できます。",
  "li_preview_1": "<strong>仕組み:</strong> リストから言語を選択すると、ツールはアクティブなシーンまたは開いているプレハブ内のすべてのローカライズ可能なオブジェクトに、対応する翻訳、フォント、RTL設定、およびアセットを瞬時に適用します。",
  "li_preview_2": "<strong>プレースホルダー:</strong> **Settings**タブでプレースホルダーのスタイル（例：<strong>Accents</strong>または<strong>Brackets</strong>）が選択されている場合、実際の翻訳の代わりにこれらのプレースホルダーがプレビューモードで表示されます。これは、レイアウトのテストやローカライズされていない要素の検出に最適です。",
  "li_preview_3": "<strong>安全性:</strong> プレビューモードで行われたすべての変更は一時的なものです。**Revert to Original**を選択するか、ウィンドウを閉じるか、シーンを変更するか、シーン/プレハブを保存する前（<code>LocalizationPreviewProtector</code>コンポーネントのおかげ）に、ツールはすべてを元の状態に自動的に復元します。",
  "li_preview_4": "<strong>クラッシュ保護:</strong> システムは、プレビューする前にシーンの状態を<code>Library</code>フォルダに自動的にバックアップします。プレビュー中にUnityがクラッシュしたり、強制終了したりした場合、ツールは次回の起動時に回復ファイルを検出し、元のシーンの状態を復元することを提案します。",
  "h2_tab_settings": "4.2. 「設定」タブ",
  "p_settings_1": "あなたのコントロールセンター。ここでは、ローカライズプロセス全体のグローバルルールを定義します。",
  "li_settings_1": "<strong>キー生成モード:</strong> キーの作成方法を選択します。<ul><li><code>UseTextAsKey</code>: テキスト自体がキーになります。プロトタイプに最適です。</li><li><code>AutoGenerateKeysOnly</code>: オブジェクトのヒエラルキーと名前に基づいてキーが生成されます。本番環境で信頼性があります。</li><li><code>Manual</code>: パーサーはキーを自動的に生成しません。既にキーが割り当てられているオブジェクトのみを更新します。</li><li><code>UseTextAsKeyWithCustomPriority</code> / <code>AutoGenerateWithCustomKeys</code>: コード属性を介したカスタムキーを許可するハイブリッドモード。</li><li><strong>安全な移行:</strong> モードはいつでも変更できます。ツールは既存の翻訳を移行しようと試みます。</li></ul>",
  "li_settings_2": "<strong>言語管理:</strong><ul><li><strong>Source Language:</strong> Unityのシーン/プレハブで使用されている言語（開発言語）。</li><li><strong>Default Language:</strong> ユーザーのシステム言語がサポートされていない場合、ゲームの初回起動時に選択される言語。</li><li><strong>リスト:</strong> サポートされている言語を管理し、特定の<strong>Font Assets</strong>を割り当て、<strong>RTL</strong>サポートを有効にします。</li></ul>",
  "li_settings_3": "<strong>一般設定:</strong><ul><li><code>Parse Prefabs</code>: プレハブのパース処理を有効にします。</li><li><code>Split files by language</code>: 翻訳をどのように保存するかを決定します（1つの大きなファイルまたは言語ごとに1つのファイル）。</li><li><code>Translations Path</code>: <code>.json</code>翻訳ファイルを保存するパス。重要: フォルダは<code>Assets/StreamingAssets/</code>内にある必要があります。</li></ul>",
  "li_settings_4": "<strong>デバッグとテスト:</strong><ul><li><code>Placeholder Style</code>: プレビューモードでプレースホルダーを表示するためのスタイルを選択します。</li></ul>",
  "li_settings_5": "<strong>ライブアップデート:</strong> リモートサーバーから翻訳をロードするための設定。",
  "li_settings_6": "<strong>ランタイムAPIキー:</strong> ゲーム内での自動翻訳のためのAPIキーを安全に保存します。このキーは、文字列検索による簡単な抽出を防ぐためにビルド内で<strong>難読化</strong>（暗号化）されますが、クライアント側のシークレットは100%安全ではないことに注意してください。",
  "li_settings_7": "<strong>アセットローディング戦略:</strong> <code>Resources (Legacy)</code>（同期ローディング、古い方法）と<code>Addressables (Async)</code>（非同期ローディング、大規模プロジェクトに推奨）の間の選択。",
  "li_settings_8": "<strong>自動翻訳:</strong> 現在は<strong>Translation Profiles</strong>システムを使用しています。プロファイルアセットを作成するか（右クリック -> 作成 -> Localization -> Translation Profile）、または<code>Localization/Presets</code>フォルダ内のプリセットを選択する必要があります。プロファイルは、Google Translate、DeepL、Microsoft、OpenAI、Claude、Gemini、Ollamaをサポートしています。設定で、**Active Text Profile**（テキスト用）と**Active Audio Profile**（TTS用）を選択します。",
  "li_settings_9": "<strong>デバッグ機能の強化:</strong><ul><li><code>Show Hierarchy Icons</code>: ヒエラルキーにステータスアイコン（緑色のチェックマーク/黄色の警告）を表示します。<strong>パフォーマンス最適化:</strong> 大規模なシーンでもラグがないようにキャッシュを使用します。</li><li><code>Show Scene View Labels</code>: シーンビューに直接表示される視覚的なデバッグ。ラベルはインタラクティブです。シーンラベルを右クリックすると、ローカライゼーションキーをクリップボードに即座にコピーできます。</li><li><code>Pseudo-Localization</code>: 翻訳なしでUIレイアウトの拡張をテストします。</li></ul>",
  "li_settings_10": "<strong>開発ツール:</strong> 設定タブの下部には、<strong>Clear Saved Language Pref</strong>（保存された言語をPlayerPrefsでリセットし、ゲームがデフォルト言語で再起動するようにします）のようなユーティリティボタンがあります。",
  "li_settings_11": "<strong>テクニカルドロップダウンオプション:</strong> パーサーがDropdownをスキャンするときに**無視する**文字列値のリスト（デフォルト：「Option A」、「Option B」、「Option C」）。これにより、UnityのデフォルトUIプレースホルダーテキストから翻訳テーブルをきれいに保ちます。",
  "li_assistant_3": "<strong>カスタムコマンド:</strong> プリセットに限定されません! <strong>Translation Profile</strong>アセットインスペクターを開いて、独自のプロンプト（例：「海賊スタイルで書き直す」、「スペルチェック」）を追加します。これらはエディタのコンテキストメニューに自動的に表示されます。",
  "li_font_glyph_workflow": "<strong>TMPのワークフロー:</strong> 1. スキャンを実行します。 2. グリフが不足している言語を選択します。 3. <strong>'Copy Character Set'</strong>をクリックします。 4. Window -> TextMeshPro -> Font Asset Creatorを開きます。 5. クリップボードを「Character Sequence (Custom Range)」フィールドに貼り付け、ゲームが必要とする文字のみを含むアトラスを生成します。",
  "li_assets_addressables_naming": "<strong>命名規則:</strong> スキャン時、ツールはAddressableアドレスを自動的に<code>{Category}/{Language}/{Key}</code>形式に設定します。ランタイムでアセットをロードするためにLocalizationManagerがこの特定の形式に依存しているため、これらのアドレスを**手動で変更しないでください**。",
  "p_ai_audio_economy": "<strong>コスト削減:</strong> ツールはテキストのMD5ハッシュを計算し、ソーステキストが変更された場合にのみ音声ファイルを再生成するため、APIクレジットを節約できます。翻訳を変更した場合、システムはその特定の音声ファイルにのみ「Outdated」のフラグを立てます。変更されたものだけを再生成するために「Generate Missing/Outdated」を使用し、APIクレジットを節約します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、スマートバッチ処理を通じてAPIクレジットを節約します。",
  "li_content_regex_example": "<strong>カスタムラッパーの例:</strong> カスタム関数<code>MyGame.Loc(\"KEY\")</code>を使用する場合、正規表現<code>\\bMyGame\\.Loc\\s*\\(\\s*\"([^\"]*)\"</code>を含むスクリプトパースルールを追加します。これで、パーサーはカスタムコードからキーをキャプチャします。",
  "li_settings_icons_legend": "<strong>ヒエラルキーアイコンの凡例:</strong><br>🟢 (緑色のチェックマーク): ローカライズ済み＆キーが設定されています。<br>🔴 (赤色のエラー): ローカライズされたコンポーネントは存在するが、**キーが不足しています**。<br>🟡 (黄色の警告): Text/Imageコンポーネントは見つかったが、**ローカライゼーションコンポーネントがアタッチされていません**。<br>🐛 (バグ): オブジェクトは設定によって**無視されています**。",
  "h2_tab_content": "4.3. 「コンテンツ」タブ (v1.1で再設計)",
  "p_content_1": "ここでは、ツールにテキストをどこで探すべきかを正確に伝えます。インターフェースは使いやすさを向上させるために完全に再設計されました。",
  "li_content_1": "<strong>Scenes to Parse:</strong> 解析対象のすべてのシーンをここにドラッグアンドドロップします。",
  "li_content_2": "<strong>Prefab Folders:</strong> プレハブを含むフォルダを指定します。大規模プロジェクト向けのページネーションと検索をサポートするようになりました。",
  "li_content_3": "<strong>Dynamic Texts:</strong> ここにコード内でのみ作成される文字列（例：「Game Over」）を入力します。",
  "li_content_4": "<strong>パース処理の設定:</strong> 無視するスクリプト/オブジェクトを指定します。**Attributes to Scan**の下で、カスタム属性名（例：<code>[Header]</code>、<code>[TermsPopup]</code>）を追加して、パーサーがそれらのフィールドをローカライズ可能なテキストとして扱うようにできます。",
  "li_content_5": "<strong>Pin:</strong> この機能を使用すると、シーン内のオブジェクトを無視リストに「ピン留め」できます。オブジェクトへの一時的な参照の代わりに、ツールはヒエラルキー内のその完全なパスを保存し、セッション間で無視が持続するようにします。",
  "li_content_6": "<strong>Script Parsing Rules:</strong> コード内のキーを見つけるためのカスタムRegexルールを定義します。 <br>🔥 <strong>New:</strong> **'Add Preset'**ボタンを使用して、サードパーティ製アセット（I2 Localization、Unity Localization）または標準ラッパーのルールを即座に追加できます。",
  "li_content_7": "<strong>Dynamic Key Prefixes:</strong> クリーンアップ（Remove Missing Keys）中に削除されないキーのプレフィックスのリスト（例：<code>Item_</code>）。パーサーがシーンで見つけられなかった場合でも削除されません。",
  "h2_tab_actions": "4.4. 「アクション」タブ",
  "p_actions_1": "メインの作業タブ。",
  "li_actions_1": "<strong>パース処理:</strong><ul><li><strong>Update Keys:</strong> 「コンテンツ」タブの設定で定義された完全なプロジェクトスキャン。</li><li><strong>Scan Selected Assets:</strong> Project Viewで現在選択されているファイル/フォルダ**のみ**をスキャンします。「Remove Missing Keys」を自動的に無効にするため、部分的な更新に安全です。</li></ul>",
  "li_actions_2": "<strong>Open Translation Editor:</strong> すべての翻訳を編集するための、より便利な独立したウィンドウを開きます。",
  "li_actions_3": "<strong>データ管理:</strong> 翻訳者とのデータ交換に使用します（CSV/XML/YAML/XLIFFへのエクスポート/インポート、Google Sheetsからのインポート）。",
  "li_actions_4": "<strong>自動翻訳:</strong> アクティブな<strong>Translation Profile</strong>を使用して、すべての空の翻訳文字列を自動的に埋めます。",
  "li_actions_5": "<strong>危険ゾーン:</strong> プロジェクトからすべてのローカライゼーションコンポーネントを完全に削除するためのボタンが含まれています。注意して使用してください！",
  "h2_tab_assets": "4.5. 「アセット」タブ",
  "p_assets_1": "このタブは、非テキストリソースのローカライズ専用です。",
  "li_assets_1": "<strong>フォルダ構造の作成（オプション）:</strong> **2. Asset Folder Generation**セクションで、**Create Asset Folders Now**をクリックします。",
  "li_assets_2": "<strong>カテゴリと命名ルールの設定:</strong> **3. Asset Categories & Scanning**セクションで、**Naming Rule**（<code>{key}_{lang}</code>）がファイルと一致すること（例：<code>button_ok_en.png</code>）を確認します。",
  "li_assets_3": "<strong>アセットの配置:</strong> ローカライズされたアセットをフォルダに配置します。",
  "li_assets_4": "<strong>アセットのスキャン:</strong> **4. Automation**セクションで、**Scan Assets & Update Tables**をクリックします。クリーンアッププロセスがより安全になりました。古いテーブルファイル（<code>.asset</code>）のみが削除され、フォルダ全体は削除されません。",
  "li_assets_5": "<strong>アセットとオブジェクトのリンク:</strong> **Analyze Project & Attach Components**をクリックします。",
  "li_assets_6": "<strong>Addressables統合:</strong> **Addressables**モードが有効な場合、スキャン中にアセットは自動的に<code>{Category}/{Language}/{Key}</code>形式のアドレスでAddressablesグループに登録されます。",
  "h2_tab_report": "4.6. 「レポート」タブ",
  "p_report_1": "パース処理の後、このレポートはローカライゼーションのステータスの全体像を示します。",
  "li_report_1": "<strong>カテゴリ:</strong> All Keys、Added、Updated（テキスト変更）、Removed、Duplicates、Migrated、Skipped（変更なし）。",
  "li_report_2": "<strong>高度な検索:</strong> エントリの横にある**Find**ボタンをクリックすると、プロジェクト内の対応するオブジェクトを即座に見つけることができます。検索は非同期で動作し、エディタをブロックせず、すべてのシーンとプレハブを検索します。",
  "h1_translation_editor": "翻訳テーブルエディタ",
  "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong>から開きます。これは、手動で翻訳を編集するための主要なツールです。",
  "li_editor_1": "<strong>スマートグルーピング:</strong> 複数形とジェンダーのキー（例：<code>apple_count_one</code>、<code>apple_count_few</code>）は、折りたたみ可能なグループに自動的に結合されます。",
  "li_editor_2": "<strong>高度な編集:</strong> セルをクリックすると、<strong>MultiLineEditWindow</strong>ポップアップが開きます。これは、比較のためにソーステキストを表示し、プレースホルダーを検証します。",
  "li_editor_3": "<strong>高度な選択 (New):</strong> 個々のセル、行、または列全体（言語）の選択をサポートします。",
  "li_editor_4": "<strong>一括アクション (New):</strong> 選択範囲を右クリックして、一括操作を実行します。選択したセルの自動翻訳、コンテンツのクリア、またはキーの削除。",
  "li_editor_5": "<strong>スマートナビゲーション (New):</strong> キーボードの矢印とショートカット（保存はCtrl+S、アンドゥ/リドゥはCtrl+Z/Y）を使用してテーブルをナビゲートします。",
  "li_editor_6": "<strong>検証フィルタ:</strong> 高度なフィルタを使用してプロジェクトを監査します。<ul><li><strong>Has Length Issues:</strong> 翻訳がソースよりも大幅に長い場合（+X%）の警告。</li><li><strong>Outdated Audio:</strong> テキストが変更されたが音声が再生成されていないキーを表示。</li><li><strong>Missing Placeholders:</strong> {0}がソースにはあるが翻訳にないことを検出。</li></ul>",
  "li_editor_7": "<strong>オーディオステータス:</strong> テーブルに音声ファイルのステータスが表示されるようになりました。テキストが変更されたが音声ファイルが古いままの場合（ハッシュの不一致）、警告（黄色のアイコン）が表示されます。",
  "li_editor_8": "<strong>強化されたコンテキストメニュー:</strong> コマンドが追加されました: <strong>Generate Audio</strong>（選択したセルのボイスオーバーを作成）および<strong>AI Assistant</strong>（選択したAIプロファイルを使用して「Fix Grammar」や「Shorten」などのコマンドを実行）。",
  "h1_ai_profiles": "AI＆翻訳プロファイル (New v1.1)",
  "h2_ai_profiles_overview": "6.1. 翻訳プロファイル",
  "p_ai_intro": "バージョン1.1では、新しい**Translation Profile**システム（ScriptableObject）が導入されました。これにより、翻訳サービスの設定がグローバル設定から個々のプロファイルアセットに移動され、構成を簡単に切り替えることができます。",
  "li_ai_1": "<strong>プロファイルの作成:</strong> Projectビューで右クリック -> Create -> Localization -> Translation Profile。",
  "li_ai_2": "<strong>サービス:</strong> DeepL、Google Translate、Microsoft Azure、および**Custom AI**をサポートします。",
  "li_ai_3": "<strong>設定:</strong> 各プロファイルは、独自のAPIキー、制限（バッチサイズ、最大文字数）、およびモデル設定を保存します。",
  "li_ai_4": "<strong>AIPresetsGenerator:</strong> 組み込みのジェネレーターを使用して、人気のあるサービス（OpenAI、Gemini、Claude、Ollama）のプロファイルをすばやく作成します。",
  "h2_custom_ai": "6.2. カスタムAIとモデル",
  "p_custom_ai": "<strong>Custom AI</strong>サービスタイプを使用すると、REST APIを介して任意のLLMを接続できます。",
  "li_custom_ai_1": "<strong>GenericAIService:</strong> OpenAI互換API（Ollamaを介したローカルLLMを含む）と通信できる柔軟な実装。",
  "li_custom_ai_2": "<strong>テンプレート:</strong> APIの要件に合わせてリクエストボディのJSONテンプレートをカスタマイズします。",
  "li_custom_ai_3": "<strong>組み込みの安全機能:</strong> AIモデルから返されることが多い壊れた書式設定タグ（例：<ph0>）を自動的に修復し、信頼性が高く一貫した翻訳を保証します。",
  "h2_ai_context": "6.3. コンテキストと用語集",
  "p_ai_context": "翻訳の品質を向上させるために、AIは追加のコンテキストを受け取るようになりました。",
  "li_context_1": "<strong>開発者ノート:</strong> 翻訳テーブルからのコメントがコンテキストとしてAIに渡されます。",
  "li_context_2": "<strong>オブジェクトパス:</strong> コメントが存在しない場合、オブジェクトのヒエラルキーパス（例：<code>MainMenu/Canvas/StartButton</code>）がフォールバックコンテキストとして使用されます。",
  "li_context_3": "<strong>用語集:</strong> CSV用語集をプロファイルにロードして、用語や名前の特定の翻訳を強制できます。",
  "h2_ai_assistant": "6.4. AIアシスタントコマンド",
  "p_ai_assistant": "翻訳テーブルエディタでは、コンテキストメニュー（右クリック -> AI: ...）を介して、選択したセルでカスタムAIコマンドを実行できるようになりました。",
  "li_assistant_1": "<strong>設定可能:</strong> Translation Profileでコマンドを定義します（例：「Fix Grammar」、「Make Formal」、「Shorten for UI」）。",
  "li_assistant_2": "<strong>バッチ処理:</strong> 複数のセルを選択して、それらすべてにコマンドを一括で適用します。",
  "h1_usage_examples": "使用例",
  "h2_example_components": "7.1. 既製のコンポーネントと例",
  "p_example_components_1": "プロジェクトには、優れた例となる既製のスクリプトが含まれています。",
  "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 言語切り替え用のUIドロップダウンリストを作成するための既製のコンポーネントです。利用可能なすべての言語を自動的に見つけ、その切り替えを管理します。<br><strong>使用方法:</strong> シーン（例：空のGameObject）に<code>LanguageSelector</code>コンポーネントを追加し、インスペクターで<code>TMP_Dropdown</code>を指定するだけです。",
  "li_example_components_2": "<strong>コード例:</strong> <code>[LocalizableField]</code>、<code>_()</code>関数、複数形、およびジェンダーの操作などの高度な手法を学ぶには、<code>StatPurchaseTest.cs</code>ファイルと<code>TestLocalization.cs</code>ファイルを調べてください。これらは、ツールのすべての主要機能のコードでの実装を明確に示しています。",
  "h2_example_attribute": "7.2. [LocalizableField] 属性",
  "p_example_attribute_1": "インスペクターのコンポーネント構成の一部であるテキストに推奨される方法です。パーサーは、文字列、文字列のリスト/配列、さらにはネストされた<code>[System.Serializable]</code>クラス内のフィールドでも動作するようになりました。",
  "code_example_attribute": "using Ankonoanko.Localization; // [LocalizableField]に必要\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // パーサーはこのフィールドを見つけ、キーを作成します\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"You have failed the quest.\";\n    \n    // カスタムキーを設定できます\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"Are you ready for an adventure?\";\n    \n    // リストで動作します\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"Find the treasure\" };\n    \n    // ネストされたクラスでも動作します！\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
  "h2_example_function": "7.3. _() 関数と [OnLanguageChange] 属性",
  "p_example_function_1": "ゲームプレイ中に変化する動的テキストには、<code>_()</code>関数を使用します。UIを更新するメソッドは、言語が変更されたときに自動的に呼び出されるように、<code>[OnLanguageChange]</code>属性でマークする必要があります。この目的のために、<code>LocalizedBehaviour</code>コンポーネントがオブジェクトに自動的に追加されます。",
  "code_example_function": "// 短い _() 呼び出しを使用するには、これらの行を追加します\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange]に必要\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // 初期更新\n    }\n    \n    // このメソッドは、言語が変更されたときに自動的に呼び出されます\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. インデックス付きプレースホルダー (string.Formatと同様)\n        // キー: \"score_label\", ファイル内のテキスト: \"Score: {0}\"\n        scoreText.text = _(\"score_label\", score); // 結果: \"Score: 100\"\n        \n        // 2. 名前付きプレースホルダー (可読性のために推奨)\n        // キー: \"welcome_message\", テキスト: \"Welcome, {username}!\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // 複雑なケースまたは高いパフォーマンスのために\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
  "h2_example_plurals": "7.4. 複数形とジェンダー",
  "p_example_plurals_1": "ツールは、異なる言語グループに対してより正確なルールを使用するようになりました。",
  "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // キー: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // テキスト: \"{0} apple\", \"{0} apples\", \"{0} apples\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // 正しい形式を自動的に選択します\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // キー: \"user_greeted_male\", \"user_greeted_female\"\n        // テキスト: \"He has arrived.\", \"She has arrived.\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
  "h1_important_notes": "重要な注意事項と警告",
  "li_notes_1": "<strong>バックアップ:</strong> 主要な変更を行う前に、必ず<strong>Translation Table Editor -> Manage Backups</strong>からバックアップを作成してください。バックアップは、Unityプロジェクトをクリーンに保ち、インポート時間を短縮するために、**プロジェクトルート（Assetsフォルダの外）**の<code>LocalizationBackups</code>フォルダに保存されます。",
  "li_notes_2": "<strong>APIキーのセキュリティ:</strong> エディタで作業するためのキーは、お使いのマシンにローカルに保存され（<code>EditorPrefs</code>）、リポジトリには含まれません。ゲームビルドで必要なキーには、**Runtime API Key**セクションを使用してください。",
  "li_notes_3": "<strong><code>StreamingAssets</code>フォルダ:</strong> 翻訳ファイルは、ゲームビルドに含まれるために、<code>Assets/StreamingAssets/</code>のサブフォルダにある必要があります。",
  "li_notes_4": "<strong>「愚かさからの保護」:</strong> ツールは、プレビューモードからの一時的なデータがシーンやプレハブに誤って保存されるのを自動的に防ぎます。",
  "li_notes_5": "<strong>パフォーマンス:</strong> <code>_()</code>の呼び出しは高速ですが、毎フレーム実行されるループ（例：<code>Update</code>内）では、結果を変数にキャッシュするようにしてください。",
  "li_notes_6": "<strong><code>LanguageSelector</code>をパース処理から除外する:</strong> <code>LanguageSelector</code>コンポーネントとその<code>TMP_Dropdown</code>を持つオブジェクトは、**Content**タブの**Ignore Specific Objects**リストに追加する必要があります。これは、<code>LanguageSelector</code>スクリプトが実行時に動的にオプションを設定するため、パーサーがドロップダウンオプションの追加のキーを作成するのを防ぐために必要です。無視することで、競合を防ぎ、翻訳ファイルをきれいに保ちます。",
  "li_notes_7": "<strong><code>LanguageSelector</code>のフォント:</strong> 選択した言語の<code>TMP_Dropdown</code>内のフォントが正しく更新されるようにするには、ドロップダウンの子**Label**オブジェクトに空の<code>LocalizedText</code>コンポーネントを手動で追加し、<code>isStyleOnly</code>チェックボックスをオンにします。",
  "li_notes_addressables_code": "<strong>コードとAddressables:</strong> **Addressables (Async)**モードに切り替える場合は、スクリプト内で<code>GetLocalizedAssetAsync<T>()</code>を**使用する必要があります**。同期<code>GetLocalizedAsset<T>()</code>を呼び出すと、nullが返され、メインスレッドのフリーズを防ぐために警告がログに記録されます。",
  "li_content_regex_presets": "<strong>無視されるRegexパターン:</strong> **'Add Common Pattern'**をクリックすると、<em>URL、メールアドレス、日付、価格、UUID</em>などの動的コンテンツを、Regexを手動で記述せずに翻訳からすばやく除外できます。",
  "li_notes_addressables_sync_warning": "<strong>同期 vs 非同期:</strong> **Addressables (Async)**モードに切り替える場合は、コードを更新して<code>GetLocalizedAssetAsync<T>()</code>を使用**する必要があります**。同期メソッドを呼び出すと、nullが返され、メインスレッドのフリーズを防ぐために警告がログに記録されます。",
  "q_faq_custom_keys_attribute": "<code>[LocalizableField]</code>の代わりに、独自の属性をキーに使用できますか？",
  "a_faq_custom_keys_attribute": "はい。**Content Tab**の「Attributes to Scan」の下で、任意の属性名（例：<code>[Header]</code>、<code>[TermsPopup]</code>）を追加できます。パーサーは、その属性を持つすべての文字列フィールドをローカライズ可能として扱います。",
  "q_faq_tts_voices": "特定のボイスをキャラクターに割り当てるにはどうすればよいですか？",
  "a_faq_tts_voices": "<strong>Translation Profile</strong>（インスペクター）で、「Voice Mappings」リストを使用します。Regexパターン（例：<code>^hero_.*</code>）を特定のボイスIDにマッピングできます。ジェネレーターは、キー名に基づいて正しいボイスを自動的に選択します。",
  "h1_extending": "機能の拡張",
  "h2_custom_parser": "9.1. カスタムパーサーの作成",
  "p_custom_parser_1": "独自のパーサークラスを作成することで、カスタムコンポーネントをサポートするようにシステムを簡単に拡張できます。",
  "li_custom_parser_1": "プロジェクトの**Editor**フォルダに新しいC#スクリプトを作成します。",
  "li_custom_parser_2": "以下のテンプレートをコピーして貼り付けます。",
  "li_custom_parser_3": "ロジックをカスタムコンポーネントに合わせて変更します。",
  "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// カスタムコンポーネントのパーサーを作成するためのテンプレート。\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. オブジェクトに目的のカスタムコンポーネントがあるかどうかを確認します。\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // コンポーネントが見つからない場合は終了\n        }\n        \n        // 2. カスタムコンポーネントのフィールドからテキストを取得します。\n        string titleText = component.Title;\n        \n        // 3. テキストがローカライズに有効かどうかを確認します。\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. TextParserのヘルパーを使用してキーとソースを生成します。\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. 結果を返します。\n            yield return (titleText, key, source);\n        }\n        \n        // 6. 他のフィールドについても繰り返します...\n        // (キーをユニークにするためにサフィックスを追加できます)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
  "h1_faq": "FAQとトラブルシューティング",
  "h1_migration_tool": "移行ツール",
  "p_migration_tool_desc": "他のローカライゼーションシステム（I2 Localization、Unity Localization）からの移行のためのツール。",
  "p_migration_tool_access": "<strong>Tools -> Anko Localization Tool -> Migration Tool</strong>からアクセスします。",
  "h2_migration_tool_features": "機能",
  "li_migration_tool_setup": "<strong>ステップ 0: セットアップ:</strong> コンポーネント名（例：I2の<code>Localize</code>）とキーが保存されているフィールドを設定します。プリセットが利用可能です。",
  "li_migration_tool_import": "<strong>ステップ 1: データインポート:</strong> CSV（I2）またはXLIFF（Unity Loc）ファイルをインポートして、キーデータベースを作成します。",
  "li_migration_tool_converter": "<strong>ステップ 2: コンポーネントコンバーター:</strong> シーンとプレハブをスキャンします。古いコンポーネント（例：<code>Localize</code>）を<code>LocalizedText</code> / <code>LocalizedAsset</code>に自動的に置き換え、キーを転送します。",
  "li_migration_tool_safemode": "<strong>セーフモードと緊急スタブ:</strong> コンポーネントは削除されるのではなく、無効になります。重要な**緊急スタブ**機能（ANKO_ENABLE_MIGRATION_STUBS定義シンボルを介してアクティブ化）が含まれています。これは、I2 LocalizationまたはUnity Localizationのフェイクプレースホルダークラスを生成し、それらのプラグインを削除した後すぐにプロジェクトがコンパイルできるようにします。「The type name 'Localize' could not be found」エラーを防ぎ、新しいシステムを使用するためにコードを適切にリファクタリングする時間を与えます。スタブを有効にすることで、古いローカライゼーションプラグインを削除した後のコンパイルエラーを修正できます。",
  "h1_font_glyph_manager": "フォント＆グリフマネージャ",
  "p_font_glyph_manager_access": "<strong>Tools -> Anko Localization Tool -> Font & Glyph Manager</strong>からアクセスします。",
  "h2_font_glyph_manager_features": "機能",
  "li_font_glyph_analyze": "すべての翻訳を分析し、割り当てられたフォント（TMP_FontAsset）が使用されているすべての文字をサポートしているかどうかを確認します。",
  "li_font_glyph_missing": "不足しているグリフのリストを表示します。",
  "li_font_glyph_copy": "フォントアトラス生成のために、すべてのユニークな言語文字をコピーできるようにします。",
  "h1_pseudo_tool": "疑似ローカライゼーションツール",
  "p_pseudo_tool_desc": "より長いテキストを持つ言語をシミュレートするために、拡張されたテキストでUIレイアウトをテストするためのツール。",
  "p_pseudo_tool_access": "<strong>Tools -> Anko Localization Tool -> Pseudo-Localization Generator</strong>からアクセスします。",
  "h2_pseudo_tool_features": "機能",
  "li_pseudo_tool_setup": "<strong>疑似ローカライゼーションジェネレーター:</strong> フェイク言語（例：[E-x-p-a-n-d-e-d]）を生成し、UIレイアウトのストレステストを行います。テキストの長さを係数（例：+40%）で拡張して、ドイツ語/ロシア語のテキスト拡張をシミュレートするのをサポートします。",
  "h1_ai_audio": "AI音声 / テキスト読み上げ (Text-to-Speech)",
  "h2_ai_audio_setup": "セットアップ",
  "li_ai_audio_profile": "<strong>Settings</strong>で、**Active Audio Profile**（例：OpenAI TTSまたはElevenLabs）を選択します。",
  "h2_ai_audio_usage": "使用方法",
  "li_ai_audio_generate": "<strong>Translation Table Editor</strong>で、行/セルを選択 -> 右クリック -> **Generate Audio**。",
  "li_ai_audio_save": "ファイルはプロファイルで指定されたフォルダに保存されます。",
  "li_ai_audio_hash": "<strong>スマートアップデートとハッシュ化:</strong> ツールはテキストコンテンツのMD5ハッシュを計算し、ソーステキストが変更された場合にのみ音声ファイルを再生成するため、APIクレジットを節約します。前回の音声生成以降に翻訳が変更されたかどうかを検出します。エディタは、これらの行を「Outdated」アイコン（黄色）でハイライト表示し、変更された行**のみ**を更新できるようにします。このスマートバッチ処理機能は、不要なAPI呼び出しを防ぎ、音声を再生成する際のコストを削減します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、APIクレジットを節約します。",
  "li_ai_audio_voice_mapping": "<strong>ボイスマッピング（マルチスピーカー）:</strong> 異なるAIボイスを異なるキャラクターに自動的に割り当てます。**Translation Profile**で、「Voice Mappings」リストを使用して、Regexパターン（例：<code>^hero_.*</code>）を特定のボイスIDにリンクします。ツールはキー名に基づいて正しいボイスを自動的に使用します。",
  "h2_example_components_updated": "更新された LanguageSelector.cs",
  "p_example_components_updated": "コードが変更されました。言語のロード（特にAddressablesを使用する場合）が非同期になりました。",
  "li_example_components_old": "<strong>古い:</strong> <code>LocalizationManager.Instance.SetLanguage(lang)</code>（同期/void）。",
  "li_example_components_new": "<strong>新しい:</strong> <code>StartCoroutine(LocalizationManager.Instance.SetLanguage(lang))</code>（非同期/コルーチン）。",
  "h2_localizedasset_updated": "LocalizedAssetの非同期ローディング",
  "p_localizedasset_updated": "コンポーネントは非同期ローディングをサポートするようになりました。アセットがクラウド/ディスク（Addressables）からロードされる場合、言語の変更時にわずかな遅延が発生する可能性があることに注意してください。",
  "h2_faq_installation": "10.1. インストールとクイックスタート",
  "q_faq_installation_1": "私のプロジェクトに他のアセットからcom.unity.nuget.newtonsoft-jsonパッケージが既に存在する場合、依存関係インストーラーはそれを更新しようとしますか、それとも無視しますか？",
  "a_faq_installation_1": "インストーラーは、Newtonsoft.Json.JsonConvertタイプが存在するかどうかをチェックします。このタイプが存在する場合、依存関係が満たされていると見なし、パッケージのインストールまたは更新を試みません。これはバージョン競合を防ぐために行われます。",
  "q_faq_installation_2": "オプションの依存関係（例：CSVサポート用）について、誤って「Skip for Now」をクリックし、「Don't ask again」にチェックを入れてしまいました。インストーラーウィンドウを再度表示して、それらをインストールするにはどうすればよいですか？",
  "a_faq_installation_2": "Tools -> Localization -> Check Dependenciesメニューから、いつでも手動で依存関係チェックをトリガーできます。これにより、「Don't ask again」フラグがリセットされ、不足しているすべてのオプションパッケージを含むウィンドウが再び表示されます。",
  "q_faq_installation_3": "ツールがAssets/ResourcesにLocalizationSettings.assetを作成しませんでした。なぜこのようなことが起こった可能性があり、Assets -> Createメニューから手動で作成できますか？",
  "a_faq_installation_3": "これは、Assets/Resourcesフォルダがない場合に発生する可能性があります。ツールはそれを作成しようとしますが、ファイルシステムのアクセス許可によって妨げられる可能性があります。はい、手動でアセットを作成できます。Resourcesフォルダ内で右クリックし、Create -> Localization -> Settingsを選択します。ツールはそれを自動的に見つけます。",
  "q_faq_installation_4": "LocalizationSettings.assetファイルを別のResourcesフォルダ、たとえばAssets/MyGame/Resourcesに移動できますか？ツールはまだそれを見つけますか？",
  "a_faq_installation_4": "はい。ツールはResources.Load()を使用します。これは、プロジェクト内のResourcesという名前のすべてのフォルダで名前によってアセットを検索します。重要なのは、ファイルがその名前LocalizationSettings.assetを保持していることです。",
  "q_faq_installation_5": "依存関係インストーラーがフリーズしたり、エラーを出したりしました。パッケージマネージャーを介して依存関係（Newtonsoft Json、Editor Coroutines）を手動でインストールできますか？",
  "a_faq_installation_5": "はい。Window -> Package Managerを開き、「+」アイコンをクリックして、「Add package by name...」を選択できます。パッケージ名com.unity.nuget.newtonsoft-jsonとcom.unity.editorcoroutinesを入力します。",
  "h2_faq_components": "10.2. コアコンポーネント",
  "q_faq_components_1": "LocalizedPrefabコンポーネントは、元のオブジェクトのMonoBehaviourを無効にします。元のオブジェクトに、Awake()で他のオブジェクトを作成したり、イベントを購読したりするスクリプトがある場合はどうなりますか？このコードは実行されますか？",
  "a_faq_components_1": "いいえ、実行されません。MonoBehaviourを無効にすると、Awake()、OnEnable()、Start()を含むUnityのすべての「マジック」メソッドの呼び出しが防がれます。これは、重複したロジックの実行を避けるために意図的なものです。すべての初期化は、プレハブのローカライズされたバージョンのスクリプトで発生する必要があります。",
  "q_faq_components_2": "元のプレハブ（LocalizedPrefab）にRigidbodyや他の物理コンポーネントがある場合、それは無効になりますか？ローカライズされたプレハブにそれがない場合、これは物理に影響しますか？",
  "a_faq_components_2": "はい、元のオブジェクトの物理的な動作は無効になります。LocalizedPrefabコンポーネントは、そのGameObject上のすべてのRigidbodyおよびRigidbody2Dコンポーネントを見つけ、isKinematicプロパティをtrueに設定します。これにより、それらは動的な物理計算から効果的に削除され、見えないオブジェクトが落下したり、衝突に反応したりするなどの不要な動作を防ぎます。ただし、正しい動作のために、ローカライズされたバージョブのプレハブには必要なすべての物理コンポーネントが含まれていることが引き続き推奨されます。",
  "q_faq_components_3": "LocalizedAssetコンポーネントは、ターゲットコンポーネント名を文字列（_targetComponentTypeName）として保存します。カスタムコンポーネントスクリプトの名前を変更したり、別のAssemblyInfo（Assembly Definition）に移動したりすると、LocalizedAssetはそれに対して機能しなくなりますか？",
  "a_faq_components_3": "はい、機能しなくなります。コンポーネントは、名前空間とAssemblyInfoを含む完全なタイプ名を保存します。スクリプトの名前を変更したり、別の.asmdefに移動したりすると、この名前が変更され、LocalizedAssetはターゲットコンポーネントを見つけることができなくなります。名前を更新するには、Analyze Project & Attach Componentsを介して別の分析を実行する必要があります。",
  "q_faq_components_4": "同じGameObjectに2つのImageコンポーネントがある場合、LocalizedAssetはどちらをローカライズするかをどのように知りますか？両方で機能しますか、それとも最初に見つけたものだけですか？",
  "a_faq_components_4": "LocalizedAssetは、特定のコンポーネントインスタンスに対して作成されます。コード内でそのコンポーネントへの参照を保持します。2番目のLocalizedAssetを手動で追加し、「Analyze for Localization」コンテキストメニューを使用して2番目のImageをターゲットにした場合、それぞれが独自のImageを管理する2つのLocalizedAssetコンポーネントが存在することになります。自動アナライザーは、ローカライズ可能なアセットを持つ最初のImageに対してのみコンポーネントを作成します。",
  "q_faq_components_5": "LocalizedPrefabコンポーネントの実行順序が-100であるとドキュメントに記載されています。Awake()でLocalizedPrefabによって作成された子オブジェクトを見つけようとする実行順序が-110の別のスクリプトがある場合、LocalizedPrefabは間に合ってインスタンス化を完了していますか？",
  "a_faq_components_5": "はい、完了しています。LocalizedPrefabは、OnEnable()メソッドでローカライズされたプレハブのインスタンスを作成します。Unityの実行順序は、すべてのAwake()メソッドがすべてのOnEnable()メソッドの前に実行されることを保証します。したがって、実行順序-110のスクリプトはAwake()を実行し、次に実行順序-100のLocalizedPrefabがAwake()を実行し、その後でのみOnEnable()メソッドが順番に呼び出されます。スクリプトはまだ作成されていないため、オブジェクトを見つけることはできません。",
  "q_faq_components_6": "LocalizedTextコンポーネントにはisStyleOnlyオプションがあります。これを有効にしてから、コードでmyLocalizedText.SetFormattedText(\"new_key\")を呼び出すと、テキストは変更されますか、それともスタイル（フォント/RTL）のみが変更されますか？",
  "a_faq_components_6": "キーとテキストの両方が変更されます。SetFormattedTextをプログラムで呼び出すと、その特定の更新に対してisStyleOnlyの動作が上書きされます。isStyleOnlyオプションは、コンポーネントがグローバルな言語変更に反応するのを防ぐことを目的としていますが、コードによる直接的なキーの変更には常に反応します。",
  "q_faq_components_7": "LocalizedBehaviourは[OnLanguageChange]属性を持つメソッドを自動的に見つけます。privateおよびprotectedメソッドも見つけますか、それともpublicである必要がありますか？",
  "a_faq_components_7": "任意のアクセス修飾子（public、private、protected、internal）を持つメソッドを見つけます。UnityのReflectionは、アクセスレベルに関係なく、すべてのインスタンスメソッドの検出を可能にします。",
  "q_faq_components_8": "LocalizedAssetコンポーネントはPlay on Awakeをインターセプトします。同じオブジェクト上の別のスクリプトが、LocalizedAssetが交換する前にAwake()またはStart()でアセット（例：audioSource.clip.length）にアクセスしようとするとどうなりますか？NullReferenceExceptionまたは古いアセットの使用は可能ですか？",
  "a_faq_components_8": "古い（ローカライズされていない）アセットの使用は可能です。LocalizedAssetはOnEnable()で交換を実行します。すべてのスクリプトのAwake()メソッドはOnEnable()の前に実行されます。スクリプトがAwake()でaudioSource.clipにアクセスする場合、元のクリップが取得されます。Start()でアクセスする場合、結果はスクリプトの実行順序によって異なります。ローカライズされたアセットへのアクセスを保証するには、スクリプトの実行順序を遅く設定するか、[OnLanguageChange]でマークされたメソッドでアセットにアクセスします。",
  "h2_faq_window": "10.3. 「ローカライゼーションツール」ウィンドウ",
  "h3_faq_window_preview": "エディタ内プレビュー",
  "q_faq_window_preview_1": "プレハブモードでプレハブを開き、エディタ内プレビューを適用し、Ctrl + Sを押しました。一時的なプレビューデータはプレハブアセットに保存されますか？LocalizationPreviewProtectorはこのケースをどのように処理しますか？",
  "a_faq_window_preview_1": "いいえ、保存されません。LocalizationPreviewProtectorは、アセット保存イベント（OnWillSaveAssets）をインターセプトし、Unityが変更をディスクに書き込む前に自動的にRevertEditorPreview()を呼び出します。したがって、プレハブは元のローカライズされていない状態で保存されます。",
  "q_faq_window_preview_2": "エディタ内プレビューを有効にしていて、Unityエディタがクラッシュし、Temp/localization_preview_recovery.jsonファイルが破損した場合（例：空または無効なJSON）、次回の起動時にどうなりますか？",
  "a_faq_window_preview_2": "PreviewCrashProtectorはtry-catchブロックでラップされています。JSONデシリアライズに失敗した場合、回復不能なことに関するエラーがコンソールにログに記録され、プロセスは静かに終了します。シーンはクラッシュ時の「壊れた」状態のままになります。この場合、変更のロールバックを強制するために、ツールウィンドウで手動で「Revert to Original」を選択する必要があります。",
  "q_faq_window_preview_3": "LocalizedPrefabのエディタ内プレビューモードでは、一時的なインスタンスが作成されます。このインスタンスでAwake()とStart()メソッドは実行されますか？これらが編集モードで実行されるように設計されていない場合、エラーを引き起こす可能性がありますか？",
  "a_faq_window_preview_3": "はい、実行されます。編集モードでのPrefabUtility.InstantiatePrefabは、Awake()とOnEnable()を呼び出します。これらのメソッドに、再生モードでのみ存在するシングルトンへのアクセスなど、エディタで実行すべきではないロジックが含まれている場合、エラーを引き起こす可能性があります。そのようなコードを保護するために、if (Application.isPlaying)または#if UNITY_EDITORを使用することをお勧めします。",
  "h3_faq_window_settings": "「設定」タブ",
  "q_faq_window_settings_1": "プロジェクトの途中でキー生成モードをUseTextAsKeyからAutoGenerateKeysOnlyに変更できます。既存の翻訳には正確に何が起こりますか？それらは新しいキーにマッピングされますか？",
  "a_faq_window_settings_1": "はい、マッピングされます。モードを変更すると、ツールは「安全な移行」を実行します。プロジェクト全体を再パースし、新しいルールに従って新しいキーを作成しますが、元のテキストを介して古いキーと新しいキーをマッピングします。次に、既存のすべての翻訳とコメントを古いキーから新しいキーに転送します。翻訳が失われることはありません。",
  "q_faq_window_settings_2": "サポートされている言語リストに複数形ルールがない言語コード（例：カザフ語の「kz」）を追加した場合、デフォルトでどのルールが使用されますか？",
  "a_faq_window_settings_2": "DefaultPluralRuleが使用されます。これは英語およびほとんどのヨーロッパ言語に適しています（「one」と「other」の形式）。",
  "q_faq_window_settings_3": "Translations PathをStreamingAssetsではなく、Assets/MyTranslationsのような通常のフォルダに指定した場合、jsonファイルはゲームビルドに含まれますか？",
  "a_faq_window_settings_3": "いいえ、含まれません。StreamingAssetsまたはResourcesフォルダにあるアセットのみがビルドに含まれることが保証されています。別のパスを指定した場合、翻訳ファイルはビルドの一部にならないため、ローカライゼーションはエディタでは機能しますが、コンパイルされたゲームでは機能しません。",
  "q_faq_window_settings_4": "自動翻訳APIキーはEditorPrefsに保存されます。プロジェクトで2台の異なるコンピューターで作業している場合、各マシンで個別にキーを入力する必要がありますか？",
  "a_faq_window_settings_4": "はい。EditorPrefsは各コンピューターのローカルストレージです。自動翻訳機能を使用する予定の各マシンでAPIキーを入力する必要があります。",
  "h3_faq_window_content": "「コンテンツ」タブ",
  "q_faq_window_content_1": "Build Settingsに含まれていないシーンをScenes to Parseに追加した場合、パース処理自体以外に何かに影響しますか？",
  "a_faq_window_content_1": "いいえ、影響しません。Scenes to Parseリストは、ツールにどのシーンを開いてテキストを分析するかを知らせるためだけに使用されます。最終的なゲームビルドに含まれるシーンとは一切関係ありません。",
  "q_faq_window_content_2": "Ignore Specific Objects（一時リスト）にオブジェクトを追加しました。このオブジェクトからプレハブを作成した場合、このプレハブのインスタンスも無視されますか？",
  "a_faq_window_content_2": "いいえ、無視されません。一時リストは、シーン内のオブジェクトへの直接参照を保存します。プレハブを作成すると、それは新しいアセットです。そのインスタンスは異なるオブジェクトであり、無視ルールはそれらに適用されません。プレハブを永続的に無視するには、それらをプレハブアセットとして無視リストに追加する必要があります。",
  "q_faq_window_content_3": "TMPro.TMP_TextコンポーネントをParsing Ignores -> Ignore Component Typesに追加しましたが、シーン内に既にこのTMP_Textを参照しているLocalizedTextを持つオブジェクトがある場合、次回のUpdate Keysでどうなりますか？キーは削除されますか？",
  "a_faq_window_content_3": "はい、削除されます。Update Keysをクリックすると、パーサーはプロジェクト全体を再スキャンします。TMPro.TMP_Textタイプを無視する必要があると判断し、それに対するキーを生成しません。古いキーと新しいキーを比較するプロセス中に、古いキーが使用されなくなったと判断し、「Removed」としてマークします。",
  "q_faq_window_content_4": "ドキュメントには、「Pin」はオブジェクトへの完全なパスを保存し、名前が変更されると壊れると記載されています。オブジェクトからプレハブを作成し、その後元のオブジェクトの名前を変更した場合、「Pin」はプレハブインスタンスに対して引き続き機能しますか？",
  "a_faq_window_content_4": "いいえ、機能しません。「Pin」は、ボタンがクリックされた時点でのシーンヒエラルキー内の絶対パス（例：Canvas/Panel/Button）を保存します。このパスはプレハブロジックとは関係ありません。プレハブインスタンスは同じパスを持ちますが、シーン内の親オブジェクトの名前を変更すると、「Pin」はオリジナルとインスタンスの両方で機能しなくなります。",
  "q_faq_window_content_5": "プレハブインスタンス内の子オブジェクトに「Pin」を使用した場合、どのパスが保存されますか。プレハブルートに対する相対パスですか、それともシーンルートですか？他のシーンで機能しますか？",
  "a_faq_window_content_5": "シーンルートからの完全なパスが保存されます。例：MyPrefab(Clone)/Content/Icon。この「ピン留めされた」パスは、それを作成したシーンでのみ機能します。他のシーンでは、そのようなパスが見つかる可能性は低いです。",
  "h3_faq_window_actions": "「アクション」タブ",
  "h3_faq_window_assets": "「アセット」タブ",
  "h3_faq_window_report": "「レポート」タブ",
  "h2_faq_editor": "10.4. 翻訳エディタ",
  "h2_faq_examples": "10.5. 使用例とコード",
  "h2_faq_notes": "10.6. 重要な注意点と警告",
  "h2_faq_extending": "10.7. 機能の拡張",
  "q_faq_window_actions_1": "バッチ自動翻訳中にインターネット接続が失われた場合、どうなりますか？ツールはリトライポリシーに従って失敗したバッチを再試行しますか、それともプロセスは完全に中断されますか？",
  "a_faq_window_actions_1": "ツールは、リトライポリシー設定（試行回数と遅延）に従って、失敗した正確なバッチを再送信しようとします。このバッチのすべての試行が失敗した場合、現在の言語の翻訳プロセスは中断され、エラーがコンソールにログに記録されます。キュー内の次の言語の翻訳は開始されません。",
  "q_faq_window_actions_2": "プロジェクトに既に存在するキーを含むCSVファイルをインポートしましたが、一部の言語の値が空の場合、これらの空の値は既存の翻訳を置き換えますか、それとも無視されますか？",
  "a_faq_window_actions_2": "空の値は既存の翻訳を置き換えます。インポートプロセスは、CSVファイルを「信頼できる情報源」と見なします。キーwelcome_messageのru列の値が空の場合、このキーの現在のロシア語翻訳は上書きされます。",
  "q_faq_window_actions_3": "「危険ゾーン」セクションでは、すべてのコンポーネントを削除できます。これは、ContentタブのPrefab Foldersで指定されていないフォルダにあるプレハブからコンポーネントを削除しますか？",
  "a_faq_window_actions_3": "はい、削除します。「危険ゾーン」の機能は、プロジェクト内のすべてのプレハブ（AssetDatabase.FindAssets(\"t:Prefab\")）をスキャンし、パース処理リストで指定されたものだけでなく、可能な限り最も完全なクリーンアップを保証します。",
  "q_faq_window_actions_4": "Google Sheetsからインポートする場合、@placeholders:ディレクティブを使用したプレースホルダー検証を機能させるために、コメント列をどのようにフォーマットする必要がありますか？",
  "a_faq_window_actions_4": "Google Sheetsドキュメントでは、列のタイトルは「Developer Notes」である必要があります。この列のセルには、通常どおりコメントを記述できます。プレースホルダーを指定するには、コメントテキストに@placeholders: {username}, {score}のような行を追加するだけです。ツールは、インポート時にこのディレクティブを自動的に認識します。",
  "q_faq_window_actions_5": "ツールは、単一のGoogle Sheetsドキュメントの複数のシートからデータをインポートできますか、それとも1つのGIDあたり1つのシートでのみ機能しますか？",
  "a_faq_window_actions_5": "ツールは一度に1つのシートでのみ機能します。インポートURLにはgid=...パラメーターが含まれており、これはドキュメント内の特定のシートを一意に識別します。別のシートからデータをインポートするには、そのURL（別のgidを持つ）をコピーし、インポートを再度実行する必要があります。",
  "q_faq_window_assets_1": "同じキーであるが異なるタイプのアセットが同じスキャンフォルダにある場合（例：sound_effect_en.mp3とsound_effect_en.wav）、どちらがアセットテーブルに残りますか？",
  "a_faq_window_assets_1": "アセットスキャナーは、予想されるタイプを指定してロードします（AssetDatabase.LoadAssetAtPath(path, expectedType)）。AudioClipカテゴリの場合、UnityがAudioClipとして認識するファイルのみを検索してロードします。両方のファイルが有効なオーディオクリップである場合、最後に処理されたファイルがテーブルに含まれ、事実上前のファイルを上書きします。このような重複は避けることをお勧めします。",
  "q_faq_window_assets_2": "Scan Assets & Analyze Projectをクリックし、シーン内にローカライズされたスプライトが既に存在するImageオブジェクトがあるが、Imageオブジェクト自体にはまだLocalizedAssetコンポーネントがない場合、ツールはコンポーネントを追加し、キーを自動的に挿入しますか？",
  "a_faq_window_assets_2": "はい、それが正確に機能する方法です。「Analyze Project」はImageコンポーネントを見つけ、それに割り当てられたスプライトの名前（例：icon_play_en）を見て、そこからキー（icon_play）と言語（en）を抽出し、そのGameObjectにLocalizedAssetコンポーネントを追加し、キーicon_playをそれに書き込みます。",
  "q_faq_window_assets_3": "異なるScan Foldersがある場合、同じNaming Ruleを異なるアセットカテゴリに使用できますか？これにより競合が発生しますか？",
  "a_faq_window_assets_3": "はい、使用できます。カテゴリごとに別のアセットテーブル（LocalizedAssetTable）が作成されるため、競合はありません。「Sprites」カテゴリのキーは、「AudioClips」カテゴリのキーと、名前が同じであっても重複しません。",
  "q_faq_window_assets_4": "ローカライズ可能なアセット（例：button_ok_en.png）がScan Folderのルートではなく、サブフォルダにある場合、スキャナーは見つけますか？",
  "a_faq_window_assets_4": "はい、見つけます。スキャナーはSearchOption.AllDirectoriesオプションを使用します。これは、指定したScan Folder内のすべてのサブフォルダを再帰的にチェックすることを意味します。",
  "q_faq_window_report_1": "「Find」ボタンはオブジェクトを非同期で検索します。検索を開始してからすぐにUpdate Keysをクリックした場合、検索は中断されますか？",
  "a_faq_window_report_1": "はい、中断されます。UIブロッキングを必要とする新しいアクション（Update Keysなど）は、現在の検索コルーチンを停止します。ダイアログボックスが表示され、新しい検索を開始するために現在の検索を停止するように求められます。",
  "q_faq_window_report_2": "キーが複数の場所で使用されている場合（例：異なるシーンの2つの異なるボタン）、これはレポートの「Duplicates」カテゴリにどのように表示されますか？",
  "a_faq_window_report_2": "「Duplicates」カテゴリには、そのキーのすべてのソースが表示されます。キーのエントリが1つ表示され、「Source」フィールドにすべてのパス（シーン1とシーン2）がリストされます。この場合、「Find」ボタンはドロップダウンリストを開き、どのオブジェクトにナビゲートするかを選択できます。",
  "q_faq_window_report_3": "コード内でのみ使用されているキー（_()関数を介して）に対して「Find」をクリックした場合、どうなりますか？ツールはC#スクリプトを見つけてハイライト表示（ping）できますか？",
  "a_faq_window_report_3": "はい。検索システムは、スクリプトMyScript.csなどのソースを認識するように特別に訓練されています。「Find」をクリックすると、プロジェクト内でMyScript.csアセットを検索し、Projectウィンドウでハイライト表示（ping）します。",
  "q_faq_editor_1": "プレースホルダー検証において、コメント内の@placeholders:ディレクティブとソース言語テキストで見つかったプレースホルダーのどちらが優先されますか？たとえば、ソーステキストに{name}があり、コメントに@placeholders: {username}とある場合。",
  "a_faq_editor_1": "コメント内の@placeholders:ディレクティブが優先されます。これは開発者からの明示的な指示であり、「信頼できる情報源」と見なされます。この例では、エディタは翻訳に{username}を要求し、ソーステキストからの{name}は無視します。",
  "q_faq_editor_2": "ディレクティブでタイプミスをした場合（例：@placeholders:ではなく@placeholder:）、それは無視されますか、それともツールは警告を出しますか？",
  "a_faq_editor_2": "単に無視されます。ツールは@placeholders:の正確な一致を探します。ディレクティブのスペルが間違っている場合、それは通常のコメントの一部として扱われ、検証は古い方法、つまりソーステキストからのプレースホルダーに基づいて機能します。",
  "q_faq_editor_3": "オートセーブシステムはBackups/AutoSavesフォルダにファイルを作成します。これらのファイルは、手動での保存が成功した後、またはウィンドウを閉じた後に自動的に削除されますか？",
  "a_faq_editor_3": "はい。手動での保存が成功した後、または通常のウィンドウの閉鎖時（変更を保存するとき）に、次回の起動時に回復を求めるプロンプトが表示されるのを避けるために、すべてのオートセーブファイルは削除されます。エディタがクラッシュした場合にのみ残ります。",
  "q_faq_editor_4": "エディタで列幅を変更した場合、これらの設定はUnityセッション間で保存されますか？",
  "a_faq_editor_4": "はい。列幅は、翻訳エディタウィンドウを閉じるたびにEditorPrefsに保存され、次回開いたときに復元されます。",
  "q_faq_editor_5": "テキスト編集ポップアップウィンドウ（MultiLineEditWindow）は、その中で行われた変更に対して独自のUndo/Redoスタック（Ctrl + Zを介して）をサポートしていますか？",
  "a_faq_editor_5": "はい。MultiLineEditWindowには、ウィンドウが開いている間機能する独自のits一時的なUndo/Redoスタックがあります。これにより、そのウィンドウ内でのテキストの変更をアンドゥおよびリドゥできます。結果を保存すると（ウィンドウを閉じることによって）、この変更はメインエディタのグローバルなUndo/Redoスタックに単一のアクションとして記録されます。",
  "q_faq_examples_1": "_()関数に渡された匿名型のプロパティ名が文字列内のプレースホルダーと一致しない場合、どうなりますか？たとえば、_(\"Hello, {username}\", new { user_name = \"Bob\" })。エラーが発生しますか、それともプレースホルダーは単に置き換えられませんか？",
  "a_faq_examples_1": "エラーは発生しません。{username}プレースホルダーは単に置き換えられず、「Hello, {username}」という文字列が結果として得られます。置き換えは、正確な名前の一致があった場合にのみ発生します。",
  "q_faq_examples_2": "[LocalizableField]属性はプライベートフィールドで機能します。スタティックフィールドで機能しますか？",
  "a_faq_examples_2": "はい、機能します。パーサーは、BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Staticフラグを持つフィールドを見つけるためにReflectionを使用するため、スタティックフィールドを見つけて処理します。",
  "q_faq_examples_3": "パラメーターを持つメソッド（例：void UpdateUI(string newLang)）に[OnLanguageChange]属性を設定した場合、どうなりますか？コンパイルエラーが発生しますか、それともランタイム警告が発生しますか？",
  "a_faq_examples_3": "コンパイルエラーは発生しませんが、UnityコンソールにLocalizedBehaviourからの警告が表示されます。属性を持つメソッドが見つかったが、メソッドにパラメーターがあるため無視されたことが報告されます。このようなメソッドは呼び出されません。",
  "q_faq_examples_4": "_(\"apple_count\", count)を使用しています。現在の言語にキーapple_count_oneがない場合（count = 1の場合）、システムはどの形式を選択しますか？フォールバックとしてapple_count_otherを使用しますか？",
  "a_faq_examples_4": "はい。特定の形式（_one、_fewなど）が見つからない場合、システムはフォールバックとして_otherサフィックスを持つキーを使用しようとします。それも見つからない場合は、ベースキーapple_countの翻訳が使用されます。",
  "q_faq_examples_5": "関数_(\"key\", new { username = \"Alex\" })は匿名型を使用します。これは、事前に作成されたDictionary<string, object>を渡すのと比較して、Update()メソッドでの頻繁な呼び出しでガベージコレクター（GC）に過度の「負荷」をかけませんか？",
  "a_faq_examples_5": "はい、かけます。new { ... }の各呼び出しは、マネージドヒープにメモリを割り当て、ガベージコレクターに余分な作業を作成します。毎フレーム更新されるテキスト（UpdateまたはLateUpdate内）の場合、Start()でDictionary<string, object>を一度作成し、Update()でその値を更新してから_()関数に渡す方が、パフォーマンスが大幅に向上します。",
  "q_faq_examples_6": "[OnLanguageChange]属性でマークされたメソッドが呼び出されません。なぜですか？",
  "a_faq_examples_6": "メソッドにパラメーターがあるかどうかを確認してください。<code>[OnLanguageChange]</code>属性は、**パラメーターのない**メソッド（例：<code>void UpdateUI()</code>）でのみ機能します。メソッドに引数が必要な場合は、パラメーターのないメソッドでラップしてください。",
  "q_faq_notes_1": "ドキュメントでは、LanguageSelectorを無視リストに追加することを推奨しています。これを忘れた場合、正確には何が壊れますか？「Option A、Option B」の追加のキーが作成されますか？",
  "a_faq_notes_1": "はい。LanguageSelectorを無視リストに追加しない場合、パーサーはそのTMP_Dropdownを通常のドロップダウンとして扱います。Unityが作成するデフォルトの「Option A、Option B、Option C」を見つけ、それらのキーを翻訳ファイルに追加します。これにより、LanguageSelectorが実行時にこれらのオプションを削除し、独自のオプションを作成するため、ファイルに不要なキーがごちゃ混ぜになります。",
  "q_faq_notes_2": "LanguageSelectorで使用されるTMP_Dropdown内のLabelに、isStyleOnlyチェックボックスが有効になっている空のLocalizedTextを**手動で**追加するのを忘れた場合、フォントは変更されませんか？なぜこれが必要なのですか？",
  "a_faq_notes_2": "はい、フォントは変更されません。これは、LanguageSelectorがlabel.textプロパティを直接変更するためです。このオブジェクトにLocalizedTextがないと、ローカライゼーションシステムは、この要素に言語が変更されたときにスタイル（フォント、RTL）を適用する必要があることを知りません。isStyleOnlyを持つ空のLocalizedTextは、「このオブジェクトを監視し、スタイルを適用しますが、テキストには触れないでください」という、システムへの「マーカー」として機能します。",
  "q_faq_notes_3": "Update()メソッドでの_()の呼び出しは推奨されません。しかし、毎フレームテキストを更新する必要がある場合（例：タイマー）はどうですか？フォーマット文字列のみをキャッシュする最もパフォーマンスの高い方法はありますか？",
  "a_faq_notes_3": "最もパフォーマンスの高いアプローチは、Start()または[OnLanguageChange]メソッドでフォーマット文字列をキャッシュし、Update()で通常のstring.Formatを使用することです。例：private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } これにより、毎フレーム辞書でキーを検索する必要がなくなり、大幅に高速になります。",
  "q_faq_extending_1": "カスタムパーサーは、Update Keysの後に自動的に呼び出されますか？どこかに登録する必要がありますか、それともプロジェクトにITextComponentParserを実装するクラスがあるだけで十分ですか？",
  "a_faq_extending_1": "クラスがあるだけで十分です。TextParserが実行されると、Reflectionを使用してITextComponentParserインターフェースを実装するプロジェクト内のすべてのクラスを見つけ、GameObjectごとにParse()メソッドを自動的に呼び出します。手動での登録は必要ありません。",
  "q_faq_extending_2": "カスタムパーサーで例外が発生した場合、どうなりますか？パース処理全体が中断されますか、それともツールは他のパーサーで安全に続行しますか？",
  "h2_faq_addressables": "Addressablesと移行",
  "q_faq_addressables_1": "Addressablesモードを有効にしましたが、アセットがロードされません。何を確認すべきですか？",
  "a_faq_addressables_1": "Addressablesパッケージがインストールされていること、設定が作成されていること、および「Scan Assets & Generate Tables」をクリックしてグループにキーが登録されていることを確認してください。",
  "q_faq_addressables_2": "DeepL/Googleのサポートを追加するにはどうすればよいですか？",
  "a_faq_addressables_2": "アセットフォルダに<code>Translation Profile</code>を作成し、サービスタイプを選択し、APIキーを入力して、このプロファイルを<code>Settings</code>ウィンドウに割り当てます。",
  "q_faq_addressables_3": "I2/UnityLocを削除した後、マイグレータがコンパイルエラーを表示します。これを修正するにはどうすればよいですか？",
  "a_faq_addressables_3": "Migrationウィンドウ（タブ0）には、Emergency Stubs機能をアクティブ化する「Enable Stubs」ボタンがあります。これにより、I2 LocalizationまたはUnity Localizationのフェイクプレースホルダークラスが作成され、それらのプラグインを削除した後すぐにプロジェクトがコンパイルできるようになります。この機能は、ANKO_ENABLE_MIGRATION_STUBS定義シンボルを切り替えることによって機能します。「The type name 'Localize' could not be found」エラーを防ぎ、新しいシステムを使用するためにコードを適切にリファクタリングする時間を与えます。スタブを有効にすることで、古いローカライゼーションプラグインを削除した後のコンパイルエラーを修正できます。",
  "a_faq_extending_2": "カスタムパーサーでの例外は、プロセスを中断します。メインのパース処理ループは、カスタムパーサーへの呼び出しをtry-catchブロックでラップしません。Parse()メソッドが未処理の例外をスローすると、",
  "h2_faq_audio": "AI音声 / テキスト読み上げ (Text-to-Speech)",
  "q_faq_audio_smart_update": "音声ファイルを再生成する際に、ツールはどのようにAPIクレジットを節約しますか？",
  "a_faq_audio_smart_update": "ツールは、ソーステキストが変更された場合にのみ音声ファイルを再生成するために、MD5ハッシュを使用したスマートバッチ処理を使用します。テキストコンテンツのMD5ハッシュを計算し、以前に生成された音声ファイルと比較します。テキストが変更されていない場合、再生成をスキップし、APIクレジットを節約します。これにより、不要なAPI呼び出しを防ぎ、音声を再生成する際のコストを削減します。ツールはテキストをハッシュ化し、ソーステキストが変更された場合にのみ音声ファイルを再生成し、APIクレジットを節約します。",
  "toggle_notes_title": "ノートの切り替え",
  "mindmap_toggle_title": "マインドマップを表示",
  "on_this_page_title": "このページの内容",
  "my_notes_title": "マイノート",
  "no_notes_message_new": "テキストにカーソルを合わせると、メモを追加できます。",
  "notes_add_title": "このブロックにメモを追加",
  "notes_placeholder": "あなたのメモ...",
  "notes_close_title": "閉じる",
  "notes_goto_title": "テキストに移動",
  "notes_edit_title": "メモを編集",
  "notes_delete_title": "メモを削除",
  "notes_edit_text": "編集",
  "copy_code_copy": "コピー",
  "copy_code_copied": "コピーしました！",
  "copy_code_error": "エラー",
  "error_loading_title": "読み込みエラー",
  "error_loading_message": "接続を確認し、更新してください。",
  "lightbox_aria_close": "画像ビューアを閉じる",
  "lightbox_image_alt": "拡大表示",
  "mindmap_preset_full": "全体表示",
  "mindmap_preset_quick_start": "クイックスタート",
  "mindmap_preset_dev": "開発者ワークフロー",
  "mindmap_preset_translator": "翻訳者ワークフロー",
  "mindmap_edge_configure": "1. 設定",
  "mindmap_edge_specify_content": "2. コンテンツを指定",
  "mindmap_edge_parse_project": "3. プロジェクトをパース",
  "mindmap_edge_creates_components": "コンポーネントを作成",
  "mindmap_edge_generates": "生成する",
  "mindmap_edge_opens": "開く",
  "mindmap_edge_manages_assets": "アセットを管理する",
  "mindmap_edge_defines_rules": "ルールを定義する",
  "mindmap_edge_reports_on": "レポートを出す",
  "mindmap_edge_enables_reaction": "反応を有効にする",
  "mindmap_edge_processed_by": "処理される",
  "mindmap_edge_edited_in": "編集される",
  "mindmap_edge_extends": "拡張する",
  "mindmap_edge_warns_about": "警告する",
  "mindmap_edge_relates_to": "関連する",
  "mindmap_edge_recommends_for": "推奨する",
  "mindmap_edge_see_faq": "FAQを参照"
}