{
    "page_title": "Unityローカリゼーションツール ドキュメント",
    "toc_title": "目次",
    "toc_search_placeholder": "ドキュメントを検索...",
    "nav_introduction": "1. はじめに",
    "nav_quick_start": "2. クイックスタート",
    "nav_components": "3. コアコンポーネント",
    "nav_loc_tool_window": "4. 「ローカリゼーションツール」ウィンドウ",
    "nav_translation_editor": "5. 翻訳エディタ",
    "nav_usage_examples": "6. 使用例",
    "nav_important_notes": "7. 重要事項",
    "nav_extending": "8. 機能の拡張",
    "nav_faq": "9. FAQとトラブルシューティング",
    "nav_key_features": "主な機能",
    "nav_installation": "2.1. インストール",
    "nav_initial_setup": "2.2. 初期設定",
    "nav_localizedtext": "3.1. LocalizedText",
    "nav_localizedasset": "3.2. LocalizedAsset",
    "nav_localizedprefab": "3.3. LocalizedPrefab",
    "nav_uitklocalization": "3.4. UITKLocalization",
    "nav_localizeddropdown": "3.5. LocalizedDropdown",
    "nav_localizedbehaviour": "3.6. LocalizedBehaviour",
    "nav_context_menu": "3.7. コンテキストメニュー",
    "nav_in_editor_preview": "4.1. エディタ内プレビュー",
    "nav_tab_settings": "4.2. 「設定」タブ",
    "nav_tab_content": "4.3. 「コンテンツ」タブ",
    "nav_tab_actions": "4.4. 「アクション」タブ",
    "nav_tab_assets": "4.5. 「アセット」タブ",
    "nav_tab_report": "4.6. 「レポート」タブ",
    "nav_example_components": "6.1. すぐに使えるコンポーネント",
    "nav_example_attribute": "6.2. [LocalizableField] 属性",
    "nav_example_function": "6.3. _() 関数",
    "nav_example_plurals": "6.4. 複数形と性別",
    "nav_custom_parser": "8.1. パーサーの作成",
    "nav_faq_installation": "9.1. インストールとクイックスタート",
    "nav_faq_components": "9.2. コアコンポーネント",
    "nav_faq_window": "9.3. 「ローカリゼーションツール」ウィンドウ",
    "nav_faq_window_actions": "9.3. 「ローカリゼーションツール」ウィンドウ - 「アクション」タブ",
    "nav_faq_window_assets": "9.3. 「ローカリゼーションツール」ウィンドウ - 「アセット」タブ",
    "nav_faq_window_report": "9.3. 「ローカリゼーションツール」ウィンドウ - 「レポート」タブ",
    "nav_faq_editor": "9.4. 翻訳エディタ",
    "nav_faq_examples": "9.5. 使用例とコード",
    "nav_faq_notes": "9.6. 重要なニュアンスと警告",
    "nav_faq_extending": "9.7. 機能の拡張",
    "h1_introduction": "はじめに",
    "p_intro_1": "このツールは、Unityでのゲームやアプリケーションのローカライズのための包括的なソリューションです。テキストやアセットの収集、強力なインターフェースによる翻訳管理、機械翻訳サービスとの連携、ゲーム内のローカライズされたコンテンツの動的な更新プロセスを自動化します。",
    "h2_key_features": "主な機能",
    "li_feature_1": "<strong>高度な解析:</strong> シーン、プレハブ、UI Toolkit (UXML)、C# スクリプトを自動的にスキャンします。<code>[LocalizableField]</code> 属性でマークされたフィールドや、ネストされたクラスやリストも含まれます。",
    "li_feature_2": "<strong>任意のアセットのローカライズ:</strong> スプライト、オーディオ、プレハブ、マテリアルなどを管理します。",
    "li_feature_3": "<strong>強力な翻訳エディタ:</strong> 自動保存、完全な元に戻す/やり直しサポート、スマートなキーグルーピングを備えた中央集権的なインターフェース。",
    "li_feature_4": "<strong>機械翻訳:</strong> DeepL、Google 翻訳、Microsoft Translator との統合。各サービスごとに柔軟な設定（バッチサイズ、リトライ回数）が可能です。",
    "li_feature_5": "<strong>柔軟なインポート/エクスポート:</strong> CSV、XML、YAML、XLIFF のサポート、および Google スプレッドシートからの直接インポート。",
    "li_feature_6": "<strong>エディタ内ライブプレビュー:</strong> ゲームを実行せずに、任意の言語でプレビューできます。",
    "li_feature_7": "<strong>複数形と性別のサポート:</strong> 複数形（スラブ語、アラビア語、その他の言語のルールを含む）と性別の正しい処理。",
    "li_feature_8": "<strong>完全な RTL サポート:</strong> 右から左へ記述する言語の正しい表示。",
    "li_feature_9": "<strong>ライブアップデート:</strong> ゲーム開始時にリモートサーバーから最新の翻訳を読み込みます。",
    "li_feature_10": "<strong>バックアップマネージャー:</strong> バックアップの作成と復元のための組み込みツール。",
    "h1_quick_start": "クイックスタートと設定",
    "h2_installation": "2.1. インストール",
    "li_install_1": "Unity プロジェクトフォルダにアセットをコピーします。",
    "li_install_2": "ツールは必要な依存関係を自動的にチェックします。表示されるダイアログボックスでインストールを確認してください。",
    "li_install_3": "基本的な機能には、必須の依存関係（<code>Newtonsoft Json</code>、<code>Editor Coroutines</code>）が必要です。",
    "li_install_4": "オプションの依存関係（<code>Arabic Support</code>、<code>CsvHelper</code>、<code>YamlDotNet</code>）により、追加機能が有効になります。",
    "li_install_5": "<strong>選択したものをインストール</strong>をクリックして、推奨パッケージをインストールします。",
    "li_install_6": "インストール後、<strong>Tools -> Localization Tool</strong> メニューからメインツールウィンドウを開きます。",
    "h2_initial_setup": "2.2. 初期設定",
    "li_setup_1": "<strong>設定の作成:</strong> 初めて開くと、ツールは <code>Assets/Resources</code> フォルダに <code>LocalizationSettings.asset</code> ファイルを作成します。",
    "li_setup_2": "<strong>言語の設定:</strong> <strong>設定</strong>タブの<strong>言語管理</strong>で、メイン言語（例: 英語の場合は <code>en</code>）が<strong>ソース言語</strong>として選択されていることを確認します。サポートするすべての言語を有効にします。",
    "li_setup_3": "<strong>解析するコンテンツの指定:</strong> <strong>コンテンツ</strong>タブで、分析するすべてのシーンを<strong>解析するシーン</strong>リストに追加します。テキスト付きのプレハブを使用する場合は、そのフォルダが<strong>プレハブフォルダ</strong>に追加されていることを確認してください。",
    "li_setup_4": "<strong>最初のパーサーの実行:</strong> <strong>アクション</strong>タブに移動し、<code>キーを更新</code>ボタンをクリックします。ツールはプロジェクトをスキャンし、翻訳ファイルを作成し、必要なコンポーネント（<code>LocalizedText</code>、<code>LocalizedAsset</code>など）をゲームオブジェクトに自動的に追加します。",
    "h1_components": "コアコンポーネント（自動的に割り当てられます）",
    "warning_box_components": "<strong>重要:</strong> 以下に説明するすべてのコンポーネントは、解析中（<code>キーを更新</code>ボタンをクリックしたとき）にゲームオブジェクトに自動的に追加されます。手動で追加する必要はありません。",
    "p_components_intro": "これらのコンポーネントは、シーン内のオブジェクトと翻訳データベースとの間の「橋渡し」をします。言語の変更を「リッスン」し、正しいテキストやアセットを自動的に置き換えます。",
    "h2_localizedtext": "3.1. LocalizedText",
    "p_localizedtext_1": "翻訳されたテキストを表示するための主要なコンポーネントです。<code>Text</code>、<code>TMP_Text</code>、<code>TextMesh</code> を持つオブジェクトに配置されます。",
    "li_localizedtext_1": "<code>localizationKey</code>: 翻訳を見つけるために使用されるキー。自動的に生成されます。",
    "li_localizedtext_2": "<code>isStyleOnly</code>: <code>true</code> の場合、コンポーネントはスタイル（フォント、RTL）のみを適用し、テキスト自体は変更しません。テキストが別のスクリプト（例: <code>LanguageSelector</code>）によって管理されている要素に便利です。",
    "li_localizedtext_3": "<code>originalSourceText</code>: 基本言語の元のテキスト。フォールバックとして使用されます。",
    "h2_localizedasset": "3.2. LocalizedAsset",
    "p_localizedasset_1": "アセット（<code>Sprite</code>、<code>AudioClip</code>、<code>Material</code>など）を交換するために使用されます。オブジェクト上のターゲットコンポーネントタイプ（<code>Image</code>、<code>AudioSource</code>）を自動的に検出し、そのリソースを置き換えます。",
    "p_localizedasset_2": "<strong>Play on Awake</strong> オプションを持つコンポーネント（<code>AudioSource</code>、<code>VideoPlayer</code>など）の場合、<code>LocalizedAsset</code> は自動再生を正しくインターセプトし、アセットを交換してから再生を開始して、ローカライズされていないコンテンツが再生されるのを防ぎます。",
    "h2_localizedprefab": "3.3. LocalizedPrefab",
    "p_localizedprefab_1": "プレハブ全体をローカライズするためのコンポーネントです。非破壊的に動作します。元のプレハबを変更するのではなく、ローカライズされたバージョンのインスタンスを子オブジェクトとして作成し、元のオブジェクト上のすべてのスクリプト（<code>MonoBehaviour</code>）、レンダラー（<code>Renderer</code>）、コライダー（<code>Collider</code>）を無効にします。これにより、二重のロジック実行や視覚的なアーティファクトが防止されます。正しいランタイム操作のために、実行順序は -100 に設定されています（<code>[DefaultExecutionOrder(-100)]</code>）。これにより、他のスクリプトの前に実行されることが保証されます。",
    "h2_uitklocalization": "3.4. UITKLocalization",
    "p_uitklocalization_1": "<code>UIDocument</code> を持つオブジェクトに追加され、UI Toolkit ドキュメント（UXML）内のすべてのテキスト要素のローカライズを管理します。",
    "h2_localizeddropdown": "3.5. LocalizedDropdown",
    "p_localizeddropdown_1": "<code>Dropdown</code> および <code>TMP_Dropdown</code> に追加され、そのオプションを翻訳します。",
    "h2_localizedbehaviour": "3.6. LocalizedBehaviour",
    "p_localizedbehaviour_1": "スクリプトが言語の変更に反応できるようにするユーティリティコンポーネントです。<code>[OnLanguageChange]</code> 属性でマークされたメソッドを自動的に見つけて呼び出します。",
    "h2_context_menu": "3.7. 「ローカライズのために分析」コンテキストメニュー",
    "p_context_menu_1": "オブジェクトに <code>LocalizedAsset</code> をすばやく追加するには、インスペクターで目的のコンポーネント（例: <code>Image</code>、<code>AudioSource</code>）を右クリックし、<strong>ローカライズのために分析</strong>を選択します。ツールはコンポーネント自体を追加して設定します。（これはオプションですが、手動で追加する場合に使用できます）。",
    "h1_loc_tool_window": "「ローカリゼーションツール」ウィンドウ",
    "h2_in_editor_preview": "4.1. エディタ内プレビュー",
    "p_preview_1": "ヘッダーのすぐ下に<strong>プレビュー言語</strong>ドロップダウンリストがあります。この強力な機能により、ゲームを実行せずに、<strong>シーン</strong>ウィンドウで直接、任意の言語でローカライズがどのように表示されるかを確認できます。",
    "li_preview_1": "<strong>仕組み:</strong> リストから言語を選択すると、ツールは対応する翻訳、フォント、RTL 設定、アセットをアクティブなシーン内のすべてのローカライズ可能なオブジェクトに即座に適用します。",
    "li_preview_2": "<strong>プレースホルダー:</strong> <strong>設定</strong>タブでプレースホルダースタイル（例: <strong>アクセント</strong>または<strong>括弧</strong>）が選択されている場合、実際の翻訳の代わりにこれらのプレースホルダーがプレビューモードで表示されます。これは、レイアウトのテストやローカライズされていない要素を見つけるのに最適です。",
    "li_preview_3": "<strong>安全性:</strong> プレビューモードで行われたすべての変更は一時的なものです。「<strong>元に戻す</strong>」を選択するか、ウィンドウを閉じるか、シーンを変更するか、シーン/プレハブを保存する前に、ツールはすべてを元の状態に自動的に戻します（<code>LocalizationPreviewProtector</code> コンポーネントのおかげです）。",
    "li_preview_4": "<strong>クラッシュ保護:</strong> 組み込みの <code>PreviewCrashProtector</code> システムは、プレビューがアクティブなときに Unity エディタがクラッシュした場合に、オブジェクトの元の状態を自動的に復元します。",
    "h2_tab_settings": "4.2. 「設定」タブ",
    "p_settings_1": "コントロールセンターです。ここで、ローカライズプロセス全体のグローバルルールを定義します。",
    "li_settings_1": "<strong>キー生成モード:</strong> キーの作成方法を選択します。<ul><li><code>UseTextAsKey</code>: テキスト自体がキーになります。プロトタイプに最適です。デメリット: ソーステキストを変更するとキーが変更され、そのすべての翻訳が失われます。</li><li><code>AutoGenerateKeysOnly</code>: キーはオブジェクトの階層と名前に基づいて生成されます。本番環境で信頼性があります。メリット: テキストが変更されても翻訳は壊れません。</li><li><code>UseTextAsKeyWithCustomPriority</code> および <code>AutoGenerateWithCustomKeys</code>: <code>[LocalizableField(\"my_custom_key\")]</code> 属性を使用してコードでカスタムキーを設定できるハイブリッドモード。</li><li><strong>安全な移行:</strong> モードはいつでも変更できます。ツールは既存のすべての翻訳を新しいキーシステムに自動的に移行します。</li></ul>",
    "li_settings_2": "<strong>言語管理:</strong> 言語のリストを設定します。特殊文字を持つ言語には、適切な<strong>フォントアセット</strong>を割り当てます。右から左へ記述する言語には、<strong>RTL</strong> オプションを有効にします。",
    "li_settings_3": "<strong>一般設定:</strong><ul><li><code>Parse Prefabs</code>: プレハブの解析を有効にします。</li><li><code>Split files by language</code>: 翻訳をどのように保存するかを決定します（1 つの大きなファイルまたは言語ごとに 1 つのファイル）。</li><li><code>Translations Path</code>: <code>.json</code> 翻訳ファイルを保存するパス。重要: フォルダは <code>Assets/StreamingAssets/</code> 内にある必要があります。</li></ul>",
    "li_settings_4": "<strong>デバッグとテスト:</strong><ul><li><code>Placeholder Style</code>: プレビューモードでプレースホルダーを表示するスタイルを選択します。</li></ul>",
    "li_settings_5": "<strong>ライブアップデート:</strong> リモートサーバーから翻訳を読み込むための設定。",
    "li_settings_6": "<strong>ランタイム API キー:</strong> コンパイルされたゲームで必要になる可能性のある API キーを安全に保存するためのセクション（暗号化された形式で保存されます）。",
    "h2_tab_content": "4.3. 「コンテンツ」タブ",
    "p_content_1": "ここで、ツールにテキストをどこで探すべきかを正確に指示します。",
    "li_content_1": "<strong>解析するシーン:</strong> ここに分析するすべてのシーンをドラッグアンドドロップします。",
    "li_content_2": "<strong>プレハブフォルダ:</strong> プレハブのあるフォルダを指定します。",
    "li_content_3": "<strong>動的テキスト:</strong> ここにコード内でのみ作成される文字列（例: 「ゲームオーバー」）を入力します。",
    "li_content_4": "<strong>解析の無視:</strong> 無視するスクリプト、コンポーネント、またはオブジェクトを指定します。",
    "li_content_5": "<strong>ピン:</strong> この機能を使用すると、シーンからオブジェクトを無視リストに「ピン留め」できます。オブジェクトへ一時的な参照の代わりに、ツールは階層内の完全なパスを保存し、セッション間で無視を持続させます（ただし、オブジェクトまたはその親の名前を変更すると、このリンクは壊れます）。",
    "h2_tab_actions": "4.4. 「アクション」タブ",
    "p_actions_1": "メインの作業タブです。",
    "li_actions_1": "<strong>キーを更新:</strong> パーサーを実行し、翻訳ファイルを更新します。",
    "li_actions_2": "<strong>翻訳エディタを開く:</strong> すべての翻訳を編集するための、より便利な別のウィンドウを開きます。",
    "li_actions_3": "<strong>データ管理:</strong> 翻訳者とのデータ交換に使用します（CSV/XML/YAML/XLIFF へのエクスポート/インポート、Google スプレッドシートからのインポート）。",
    "li_actions_4": "<strong>自動翻訳:</strong> 空の翻訳文字列をすべて自動的に入力します。新しい設定では、各サービス（DeepL、Google、Microsoft）ごとにバッチサイズ（<strong>バッチサイズ</strong>）とリトライポリシー（<strong>リトライポリシー</strong>）を個別に管理できます。ツールは翻訳された文字数を追跡し、潜在的な制限超過について警告します。",
    "li_actions_5": "<strong>危険ゾーン:</strong> プロジェクトからすべてのローカリゼーションコンポーネントを完全に削除するためのボタンが含まれています。注意して使用してください！",
    "h2_tab_assets": "4.5. 「アセット」タブ",
    "p_assets_1": "このタブは、テキスト以外のリソースのローカライズに完全に特化しています。",
    "li_assets_1": "<strong>フォルダ構造の作成（オプション）:</strong> セクション <strong>2. アセットフォルダの生成</strong>で、<strong>今すぐアセットフォルダを作成</strong>をクリックします。",
    "li_assets_2": "<strong>カテゴリと命名規則の設定:</strong> セクション <strong>3. アセットカテゴリとスキャン</strong>で、<strong>命名規則</strong>（<code>{key}_{lang}</code>）がファイル（例: <code>button_ok_en.png</code>）と一致していることを確認します。",
    "li_assets_3": "<strong>アセットの配置:</strong> ローカライズされたアセットをフォルダに配置します。",
    "li_assets_4": "<strong>アセットのスキャン:</strong> セクション <strong>4. 自動化</strong>で、<strong>アセットをスキャンしてテーブルを更新</strong>をクリックします。クリーンアッププロセスはより安全になりました。古いテーブルファイル（<code>.asset</code>）のみが削除され、フォルダ全体は削除されません。",
    "li_assets_5": "<strong>アセットをオブジェクトにリンク:</strong> <strong>プロジェクトを分析してコンポーネントを添付</strong>をクリックします。",
    "h2_tab_report": "4.6. 「レポート」タブ",
    "p_report_1": "各解析後、このレポートはローカリゼーションステータスの全体像を示します。",
    "li_report_1": "<strong>カテゴリ:</strong> すべてのキー、追加済み、更新済み（テキスト変更）、削除済み、重複、移行済み、スキップ済み（変更なし）。",
    "li_report_2": "<strong>高度な検索:</strong> 任意のエントリの横にある<strong>検索</strong>ボタンをクリックすると、プロジェクト内の対応するオブジェクトを即座に見つけることができます。検索はエディタをブロックせずに非同期で動作し、すべてのシーンとプレハブを検索します。キーが複数の場所で使用されている場合は、すべてのソースを含むドロップダウンリストが表示されます。",
    "h1_translation_editor": "翻訳テーブルエディタ",
    "p_editor_1": "<strong>Tools -> Localization -> Translation Table Editor</strong> から開きます。これは、翻訳を手動で編集するための主要なツールです。",
    "li_editor_1": "<strong>スマートグルーピング:</strong> 複数形と性別のキー（例: <code>apple_count_one</code>、<code>apple_count_few</code>）は、折りたたみ可能なグループに自動的に結合されます。",
    "li_editor_2": "<strong>高度な編集:</strong> セルをクリックすると、<strong>MultiLineEditWindow</strong> ポップアップが開きます。比較のためにソーステキストを表示し、すばやくコピーでき、リアルタイムでプレースホルダーの不一致（例: <code>{username}</code>）をチェックし、不足しているものや余分なものをハイライトします。",
    "li_editor_3": "<strong>コメントによるプレースホルダーの検証:</strong> キーのコメントに特別なディレクティブを追加することで、翻訳にどのプレースホルダーを含めるべきかを明示的に指定できます。例: <code>@placeholders: {username}, {score}</code>。<strong>MultiLineEditWindow</strong> は、このリストを真実の主要なソースとして使用します。",
    "li_editor_4": "<strong>ナビゲーションと管理:</strong> スクロールバーを使用するか、マウスの中ボタンを押したままにしてテーブルをナビゲートします。セパレータをドラッグして列の幅を変更します。<code>Ctrl+S</code> で変更を保存します。",
    "li_editor_5": "<strong>完全な元に戻す/やり直し:</strong> アクションのスタック全体（テキストの変更、キーの追加/削除）は、<code>Ctrl+Z</code> / <code>Ctrl+Y</code> によって完全にサポートされています。",
    "li_editor_6": "<strong>バックアップと自動保存:</strong> <strong>バックアップを管理</strong>ボタンを使用します。ツールは数分ごとにセッションを自動的に保存します。クラッシュした場合、変更を復元するように求められます。",
    "h1_usage_examples": "使用例",
    "h2_example_components": "6.1. すぐに使えるコンポーネントと例",
    "p_example_components_1": "プロジェクトには、優れた例として役立つすぐに使えるスクリプトが含まれています。",
    "li_example_components_1": "<strong><code>LanguageSelector.cs</code>:</strong> 言語切り替え用の UI ドロップダウンリストを作成するための、すぐに使えるコンポーネントです。利用可能なすべての言語を自動的に見つけ、それらの切り替えを管理します。<br><strong>使用方法:</strong> シーンに <code>LanguageSelector</code> コンポーネントを追加し（例: 空の GameObject に）、インスペクターで <code>TMP_Dropdown</code> を指定するだけです。",
    "li_example_components_2": "<strong>コード例:</strong> <code>[LocalizableField]</code>、<code>_()</code> 関数、複数形、性別の操作など、高度なテクニックを学ぶには、<code>StatPurchaseTest.cs</code> と <code>TestLocalization.cs</code> ファイルを調べてください。これらは、ツールのすべての主要機能のコードでの実装を明確に示しています。",
    "h2_example_attribute": "6.2. [LocalizableField] 属性",
    "p_example_attribute_1": "インスペクターでコンポーネントの設定の一部であるテキストに推奨される方法です。パーサーは、文字列、文字列のリスト/配列、さらにはネストされた <code>[System.Serializable]</code> クラス内のフィールドを操作できるようになりました。",
    "code_example_attribute": "using Ankonoanko.Localization; // [LocalizableField] に必要\nusing UnityEngine;\nusing System.Collections.Generic;\npublic class QuestManager : MonoBehaviour\n{\n    // パーサーはこのフィールドを見つけてキーを作成します\n    [LocalizableField]\n    private string defaultQuestFailedMessage = \"クエストに失敗しました。\";\n    \n    // カスタムキーを設定できます\n    [LocalizableField(\"custom_quest_start_dialog\")]\n    public string startDialog = \"冒険の準備はできていますか？\";\n    \n    // リストで動作します\n    [LocalizableField]\n    private List<string> missionObjectives = new List<string> { \"宝物を見つける\" };\n    \n    // ネストされたクラスでも動作します！\n    [System.Serializable]\n    public class ItemInfo\n    {\n        [LocalizableField] public string Name;\n        [LocalizableField] public string Description;\n    }\n    \n    [LocalizableField]\n    private ItemInfo magicSword;\n}",
    "h2_example_function": "6.3. _() 関数と [OnLanguageChange] 属性",
    "p_example_function_1": "ゲームプレイ中に変化する動的テキストには <code>_()</code> 関数を使用します。UI を更新するメソッドには <code>[OnLanguageChange]</code> 属性を付けて、言語が変更されたときに自動的に呼び出されるようにする必要があります。この目的のために、<code>LocalizedBehaviour</code> コンポーネントがオブジェクトに自動的に追加されます。",
    "code_example_function": "// 短い _() 呼び出しを使用するには、これらの行を追加します\nusing static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization; // [OnLanguageChange] に必要\nusing UnityEngine;\nusing TMPro;\nusing System.Collections.Generic;\npublic class PlayerHUD : MonoBehaviour\n{\n    [SerializeField] private TMP_Text scoreText;\n    private int score = 100;\n    private string playerName = \"Alex\";\n    \n    void Start()\n    {\n        UpdateUI(); // 初期更新\n    }\n    \n    // このメソッドは、言語が変更されると自動的に呼び出されます\n    [OnLanguageChange]\n    void UpdateUI()\n    {\n        // 1. インデックス付きプレースホルダー（string.Format のように）\n        // キー: \"score_label\", ファイル内のテキスト: \"スコア: {0}\"\n        scoreText.text = _(\"score_label\", score); // 結果: \"スコア: 100\"\n        \n        // 2. 名前付きプレースホルダー（読みやすさのため推奨）\n        // キー: \"welcome_message\", テキスト: \"ようこそ、{username} さん！\"\n        string welcomeText = _(\"welcome_message\", new { username = playerName });\n        \n        // 複雑なケースや高パフォーマンスの場合\n        var args = new Dictionary<string, object> { { \"username\", playerName } };\n        string welcomeText2 = _(\"welcome_message\", args);\n    }\n}",
    "h2_example_plurals": "6.4. 複数形と性別",
    "p_example_plurals_1": "このツールは、さまざまな言語グループに対してより正確なルールを使用するようになりました。",
    "code_example_plurals": "using static Ankonoanko.Localization.LocalizationManager;\nusing Ankonoanko.Localization;\nusing UnityEngine;\npublic class ItemCounter : MonoBehaviour\n{\n    void DisplayItemCount(int count)\n    {\n        // キー: \"apple_count_one\", \"apple_count_few\", \"apple_count_many\"\n        // テキスト: \"{0} 個のリンゴ\", \"{0} 個のリンゴ\", \"{0} 個のリンゴ\"\n        string appleText = _(\"apple_count\", count); \n        Debug.Log(appleText); // 正しい形式を自動的に選択します\n    }\n    \n    void GreetUser(Gender userGender)\n    {\n        // キー: \"user_greeted_male\", \"user_greeted_female\"\n        // テキスト: \"彼が到着しました。\", \"彼女が到着しました。\"\n        string greeting = _(\"user_greeted\", userGender);\n        Debug.Log(greeting);\n    }\n}",
    "h1_important_notes": "重要事項と警告",
    "li_notes_1": "<strong>バックアップ:</strong> グローバルな操作（<code>キーを更新</code>、データインポート）の前に、常に <strong>翻訳テーブルエディタ -> バックアップを管理</strong> からバックアップを作成してください。",
    "li_notes_2": "<strong>API キーのセキュリティ:</strong> エディタで作業するためのキーは、お使いのコンピューターにローカルに保存され（<code>EditorPrefs</code> 内）、リポジトリには含まれません。ゲームビルドで必要なキーには、<strong>ランタイム API キー</strong>セクションを使用してください。",
    "li_notes_3": "<strong><code>StreamingAssets</code> フォルダ:</strong> 翻訳ファイルは、ゲームビルドに含まれるように、<code>Assets/StreamingAssets/</code> のサブフォルダにある必要があります。",
    "li_notes_4": "<strong>「フールプルーフ」:</strong> ツールは、プレビューモードからの一時的なデータをシーンやプレハブに誤って保存しないように自動的に保護します。",
    "li_notes_5": "<strong>パフォーマンス:</strong> <code>_()</code> 呼び出しは高速ですが、毎フレーム実行されるループ（例: <code>Update</code> 内）では、結果を変数にキャッシュするようにしてください。",
    "li_notes_6": "<strong><code>LanguageSelector</code> を解析から除外する:</strong> <code>LanguageSelector</code> コンポーネントとその <code>TMP_Dropdown</code> を持つオブジェクトは、<strong>コンテンツ</strong>タブの<strong>特定のオブジェクトを無視</strong>リストに追加する必要があります。これは、<code>LanguageSelector</code> スクリプトが実行時に動的にドロップダウンオプションを入力するため、パーサーが余分なキーを作成するのを防ぐために必要です。無視することで、競合を防ぎ、翻訳ファイルをきれいに保ちます。",
    "li_notes_7": "<strong><code>LanguageSelector</code> のフォント:</strong> <code>TMP_Dropdown</code> で選択した言語のフォントが正しく更新されるようにするには、ドロップダウンの子 <strong>Label</strong> オブジェクトに空の <code>LocalizedText</code> コンポーネントを手動で追加し、<code>isStyleOnly</code> ボックスをオンにします。",
    "h1_extending": "機能の拡張",
    "h2_custom_parser": "8.1. カスタムパーサーの作成",
    "p_custom_parser_1": "独自のパーサークラスを作成することで、カスタムコンポーネントをサポートするようにシステムを簡単に拡張できます。",
    "li_custom_parser_1": "プロジェクトの <strong>Editor</strong> フォルダに新しい C# スクリプトを作成します。",
    "li_custom_parser_2": "以下のテンプレートをコピーします。",
    "li_custom_parser_3": "ロジックをコンポーネントに合わせて変更します。",
    "code_custom_parser": "#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Ankonoanko.Localization;\n\n// カスタムコンポーネント用のパーサーを作成するためのテンプレート。\npublic class CustomComponentParser_Template : ITextComponentParser\n{\n    public IEnumerable<(string text, string key, string source)> Parse(\n        GameObject gameObject,\n        LocalizationSettings settings)\n    {\n        // 1. オブジェクトに必要なカスタムコンポーネントがあるかどうかを確認します。\n        var component = gameObject.GetComponent<AwesomeComponentFromAssetStore>();\n        if (component == null)\n        {\n            yield break; // コンポーネントが見つからない場合は終了します\n        }\n        \n        // 2. カスタムコンポーネントのフィールドからテキストを取得します。\n        string titleText = component.Title;\n        \n        // 3. テキストがローカライズに有効かどうかを確認します。\n        if (TextParser.IsValidLocalizableText(titleText))\n        {\n            // 4. TextParser のヘルパーを使用してキーとソースを生成します。\n            string key = TextParser.GenerateKeyForObject(gameObject, titleText, settings.keyGenerationMode);\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            \n            // 5. 結果を返します。\n            yield return (titleText, key, source);\n        }\n        \n        // 6. 他のフィールドについても繰り返します...\n        // (キーを一意にするためにサフィックスを追加できます)\n        string descriptionText = component.Description;\n        if (TextParser.IsValidLocalizableText(descriptionText))\n        {\n            string key = TextParser.GenerateKeyForObject(gameObject, descriptionText, settings.keyGenerationMode) + \"_description\";\n            string source = TextParser.GetSourceStringForObject(gameObject);\n            yield return (descriptionText, key, source);\n        }\n    }\n}\n#endif",
    "h1_faq": "FAQとトラブルシューティング",
    "h2_faq_installation": "9.1. インストールとクイックスタート",
    "q_faq_installation_1": "プロジェクトに別のアセットから com.unity.nuget.newtonsoft-json パッケージが既にある場合、どうなりますか？依存関係インストーラーは更新しようとしますか、それとも無視しますか？",
    "a_faq_installation_1": "インストーラーは Newtonsoft.Json.JsonConvert 型の存在をチェックします。型が存在する場合、依存関係は満たされていると見なし、パッケージのインストールや更新は試みません。これはバージョン競合を防ぐためです。",
    "q_faq_installation_2": "誤って「今はスキップ」をクリックし、オプションの依存関係（例: CSV サポート用）について「二度と尋ねない」をチェックしてしまいました。インストーラーウィンドウを再度表示してインストールするにはどうすればよいですか？",
    "a_faq_installation_2": "Tools -> Localization -> Check Dependencies メニューからいつでも依存関係のチェックを手動でトリガーできます。これにより、「二度と尋ねない」フラグがリセットされ、不足しているすべてのオプションパッケージを含むウィンドウが再度表示されます。",
    "q_faq_installation_3": "ツールが Assets/Resources に LocalizationSettings.asset を作成しませんでした。なぜこれが起こった可能性があり、Assets -> Create メニューから手動で作成できますか？",
    "a_faq_installation_3": "Assets/Resources フォルダがない場合に発生する可能性があります。ツールはそれを作成しようとしますが、ファイルシステムの権限によって妨げられる可能性があります。はい、手動でアセットを作成できます。Resources フォルダを右クリックし、Create -> Localization -> Settings を選択します。ツールは自動的にそれを見つけます。",
    "q_faq_installation_4": "LocalizationSettings.asset ファイルを別の Resources フォルダ（例: Assets/MyGame/Resources）に移動できますか？ツールはそれでも見つけられますか？",
    "a_faq_installation_4": "はい。ツールは Resources.Load() を使用します。これは、プロジェクト内の Resources という名前のすべてのフォルダから名前でアセットを検索します。重要なのは、ファイルが LocalizationSettings.asset という名前を保持していることです。",
    "q_faq_installation_5": "依存関係インストーラーがフリーズしたり、エラーが発生したりしました。Unity Package Manager を通じて依存関係（Newtonsoft Json、Editor Coroutines）を手動でインストールできますか？",
    "a_faq_installation_5": "はい。Window -> Package Manager を開き、「+」アイコンをクリックして、「Add package by name...」を選択します。パッケージ名 com.unity.nuget.newtonsoft-json と com.unity.editorcoroutines を入力します。",
    "h2_faq_components": "9.2. コアコンポーネント",
    "q_faq_components_1": "LocalizedPrefab コンポーネントは、元のオブジェクトの MonoBehaviours を無効にします。元のオブジェクトに、他のオブジェクトを作成したり、Awake() でイベントをサブスクライブしたりするスクリプトがある場合はどうなりますか？このコードは実行されますか？",
    "a_faq_components_1": "いいえ、実行されません。MonoBehaviour を無効にすると、Awake()、OnEnable()、Start() を含む Unity の「マジック」メソッドがすべて呼び出されなくなります。これは、重複したロジックの実行を避けるために意図的なものです。すべての初期化は、プレハブのローカライズされたバージョンのスクリプトで行う必要があります。",
    "q_faq_components_2": "元のプレハブ（LocalizedPrefab）に Rigidbody または別の物理コンポーネントがある場合、それは無効になりますか？ローカライズされたプレハブにそれがない場合、これは物理に影響しますか？",
    "a_faq_components_2": "はい、元のオブジェクトの物理的な振る舞いは無効化されます。LocalizedPrefab コンポーネントは、その GameObject 上のすべての Rigidbody および Rigidbody2D コンポーネントを見つけ、isKinematic プロパティを true に設定します。これにより、動的な物理計算から効果的に除外され、見えないオブジェクトが落下したり衝突に反応したりするような望ましくない動作を防ぎます。ローカライズされたバージョンのプレハブにも、正しい動作のために必要なすべての物理コンポーネントを含めることが引き続き推奨されます。",
    "q_faq_components_3": "LocalizedAsset コンポーネントは、ターゲットコンポーネント名を文字列（_targetComponentTypeName）として保存します。カスタムコンポーネントスクリプトの名前を変更したり、別のアセンブリ（アセンブリ定義）に移動したりするとどうなりますか？LocalizedAsset は動作しなくなりますか？",
    "a_faq_components_3": "はい、動作しなくなります。コンポーネントは、名前空間とアセンブリを含む完全な型名を保存します。スクリプトの名前を変更したり、別の .asmdef に移動したりすると、この名前が変更され、LocalizedAsset はターゲットコンポーネントを見つけることができなくなります。名前を更新するには、Analyze Project & Attach Components を介して別の分析を実行する必要があります。",
    "q_faq_components_4": "同じ GameObject に 2 つの Image コンポーネントがある場合、LocalizedAsset はどちらをローカライズするかをどのように知りますか？両方で動作しますか、それとも最初に見つかったものだけで動作しますか？",
    "a_faq_components_4": "LocalizedAsset は、特定のコンポーネントインスタンスに対して作成されます。コード内でそのコンポーネントへの参照を保持します。2 番目の LocalizedAsset を手動で追加し、「ローカライズのために分析」コンテキストメニューを使用して 2 番目の Image をターゲットにする場合、それぞれが独自の Image を管理する 2 つの LocalizedAsset コンポーネントが作成されます。自動アナライザーは、最初に見つかったローカライズ可能なアセットを持つ Image に対してのみコンポーネントを作成します。",
    "q_faq_components_5": "ドキュメントには、LocalizedPrefab の実行順序は -100 であると記載されています。実行順序が -110 の別のスクリプトが、Awake() で LocalizedPrefab によって作成された子オブジェクトを見つけようとした場合はどうなりますか？LocalizedPrefab はインスタンスを間に合わせてインスタンス化しますか？",
    "a_faq_components_5": "はい、間に合います。LocalizedPrefab は OnEnable() メソッドでローカライズされたプレハブのインスタンスを作成します。Unity の実行順序は、すべての Awake() メソッドがすべての OnEnable() メソッドの前に実行されることを保証します。したがって、順序 -110 のスクリプトが Awake() を実行し、次に順序 -100 の LocalizedPrefab が Awake() を実行し、その後でのみそれらの OnEnable() メソッドが順番に呼び出されます。まだ作成されていないため、スクリプトはオブジェクトを見つけられません。",
    "q_faq_components_6": "LocalizedText コンポーネントには isStyleOnly オプションがあります。これを有効にしてから、コードで myLocalizedText.SetFormattedText(\"new_key\") を呼び出すと、テキストは変更されますか、それともスタイル（フォント/RTL）だけが変更されますか？",
    "a_faq_components_6": "キーとテキストの両方が変更されます。SetFormattedText をプログラムで呼び出すと、その特定の更新に対して isStyleOnly の動作がオーバーライドされます。isStyleOnly オプションは、コンポーネントがグローバルな言語の変更に反応するのを防ぐためのものですが、コードによる直接のキー変更には常に反応します。",
    "q_faq_components_7": "LocalizedBehaviour は [OnLanguageChange] 属性を持つメソッドを自動的に見つけます。private および protected メソッドを見つけますか、それとも public でなければなりませんか？",
    "a_faq_components_7": "任意のアクセス修飾子（public、private、protected、internal）を持つメソッドを見つけます。Unity のリフレクションにより、アクセスレベルに関係なくすべてのインスタンスメソッドを検出できます。",
    "q_faq_components_8": "LocalizedAsset コンポーネントは Play on Awake をインターセプトします。同じオブジェクト上の別のスクリプトが、LocalizedAsset がスワップする前に Awake() または Start() でアセット（例: audioSource.clip.length）にアクセスしようとした場合はどうなりますか？NullReferenceException または古いアセットの使用の可能性はありますか？",
    "a_faq_components_8": "古い（ローカライズされていない）アセットの使用の可能性があります。LocalizedAsset は OnEnable() でスワップを実行します。すべてのスクリプトの Awake() メソッドは OnEnable() の前に実行されます。スクリプトが Awake() で audioSource.clip にアクセスすると、元のクリップを取得します。Start() でアクセスする場合、結果はスクリプトの実行順序に依存します。ローカライズされたアセットへのアクセスを保証するには、スクリプトの実行順序を遅く設定するか、[OnLanguageChange] でマークされたメソッドでアセットにアクセスします。",
    "h2_faq_window": "9.3. 「ローカリゼーションツール」ウィンドウ",
    "h3_faq_window_preview": "エディタ内プレビュー",
    "q_faq_window_preview_1": "プレハブモードでプレハブを開き、エディタ内プレビューを適用し、Ctrl+S を押しました。一時的なプレビューデータはプレハブアセットに保存されますか？LocalizationPreviewProtector はこのケースをどのように処理しますか？",
    "a_faq_window_preview_1": "いいえ、保存されません。LocalizationPreviewProtector はアセット保存イベント（OnWillSaveAssets）をインターセプトし、Unity が変更をディスクに書き込む前に自動的に RevertEditorPreview() を呼び出します。したがって、プレハブは元のローカライズされていない状態で保存されます。",
    "q_faq_window_preview_2": "エディタ内プレビューを有効にして Unity エディタがクラッシュし、Temp/localization_preview_recovery.json ファイルが破損した場合（例: 空または無効な JSON）、次回の起動時に何が起こりますか？",
    "a_faq_window_preview_2": "PreviewCrashProtector は try-catch ブロックでラップされています。JSON のデシリアライズに失敗した場合、回復できない旨のエラーがコンソールに記録され、プロセスは静かに終了します。シーンはクラッシュ時の「壊れた」状態のままになります。この場合、ツールウィンドウで「元に戻す」を手動で選択して、変更のロールバックを強制する必要があります。",
    "q_faq_window_preview_3": "LocalizedPrefab のエディタ内プレビューモードでは、一時的なインスタンスが作成されます。このインスタンスで Awake() および Start() メソッドは実行されますか？編集モードで実行されるように設計されていない場合、エラーが発生する可能性はありますか？",
    "a_faq_window_preview_3": "はい、実行されます。編集モードの PrefabUtility.InstantiatePrefab は Awake() と OnEnable() を呼び出します。これらのメソッドにエディタで実行すべきでないロジック（例: 再生モードでのみ存在するシングルトンへのアクセス）が含まれている場合、エラーが発生する可能性があります。if (Application.isPlaying) または #if UNITY_EDITOR を使用して、そのようなコードを保護することをお勧めします。",
    "h3_faq_window_settings": "「設定」タブ",
    "q_faq_window_settings_1": "プロジェクトの途中でキー生成モードを UseTextAsKey から AutoGenerateKeysOnly に変更できます。既存の翻訳に具体的に何が起こりますか？新しいキーにマッピングされますか？",
    "a_faq_window_settings_1": "はい、マッピングされます。モードを変更すると、ツールは「安全な移行」を実行します。プロジェクト全体を再解析し、新しいルールに従って新しいキーを作成しますが、元のテキストを介して古いキーと新しいキーをマッピングします。その後、既存のすべての翻訳とコメントを古いキーから新しいキーに転送します。翻訳は失われません。",
    "q_faq_window_settings_2": "サポートされている言語リストに複数形化ルールがないコードの言語（例: カザフ語の「kz」）を追加した場合、デフォルトでどのルールが使用されますか？",
    "a_faq_window_settings_2": "DefaultPluralRule が使用されます。これは、英語およびほとんどのヨーロッパ言語（「one」と「other」の形式）に適しています。",
    "q_faq_window_settings_3": "Translations Path を StreamingAssets ではなく、Assets/MyTranslations のような通常のフォルダに指定した場合はどうなりますか？json ファイルはゲームビルドに含まれますか？",
    "a_faq_window_settings_3": "いいえ、含まれません。StreamingAssets または Resources フォルダにあるアセットのみがビルドに含まれることが保証されています。別のパスを指定した場合、ローカリゼーションはエディタでは機能しますが、翻訳ファイルがビルドの一部にならないため、コンパイルされたゲームでは機能しません。",
    "q_faq_window_settings_4": "自動翻訳 API キーは EditorPrefs に保存されます。2 台の異なるコンピューターでプロジェクトに取り組んでいる場合、各マシンでキーを個別に入力する必要がありますか？",
    "a_faq_window_settings_4": "はい。EditorPrefs は各コンピューターのローカルストレージです。自動翻訳機能を使用する予定の各マシンで API キーを入力する必要があります。",
    "h3_faq_window_content": "「コンテンツ」タブ",
    "q_faq_window_content_1": "ビルド設定に含まれていないシーンを「解析するシーン」に追加した場合はどうなりますか？これは解析プロセス自体以外に何か影響しますか？",
    "a_faq_window_content_1": "いいえ、影響しません。「解析するシーン」リストは、ツールにどのシーンを開いてテキストを分析するかを知らせるためにのみ使用されます。ゲームの最終ビルドに含まれるシーンとは一切関係ありません。",
    "q_faq_window_content_2": "オブジェクトを「特定のオブジェクトを無視」（一時リスト）に追加しました。このオブジェクトからプレハブを作成した場合、このプレハブのインスタンスも無視されますか？",
    "a_faq_window_content_2": "いいえ、無視されません。一時リストは、シーン内のオブジェクトへの直接参照を保存します。プレハブを作成すると、それは新しいアセットになります。そのインスタンスは異なるオブジェクトであり、無視ルールは適用されません。プレハブを永続的に無視するには、プレハブアセットとして無視リストに追加する必要があります。",
    "q_faq_window_content_3": "TMPro.TMP_Text コンポーネントを「解析の無視」->「コンポーネントタイプを無視」に追加しましたが、シーン内にこの TMP_Text を既に参照している LocalizedText を持つオブジェクトがある場合、次の「キーを更新」で何が起こりますか？キーは削除されますか？",
    "a_faq_window_content_3": "はい、削除されます。「キーを更新」をクリックすると、パーサーはプロジェクト全体を再スキャンします。TMPro.TMP_Text 型は無視されるべきであると判断し、キーを生成しません。古いキーと新しいキーを比較するプロセス中に、古いキーが使用されなくなったと判断し、「削除済み」としてマークします。",
    "q_faq_window_content_4": "ドキュメントには、「ピン」はオブジェクトへのフルパスを保存し、名前が変更されると壊れると記載されています。オブジェクトからプレハブを作成し、元のオブジェクトの名前を変更した場合、「ピン」はプレハブインスタンスに対して機能し続けますか？",
    "a_faq_window_content_4": "いいえ、機能しません。「ピン」は、ボタンがクリックされた瞬間のシーン階層内の絶対パス（例: Canvas/Panel/Button）を保存します。このパスはプレハブロジックとは関係ありません。プレハブインスタンスも同じパスを持ちますが、シーン内の親オブジェクトの名前を変更すると、「ピン」は元とインスタンスの両方で機能しなくなります。",
    "q_faq_window_content_5": "プレハブインスタンス内の子オブジェクトに「ピン」を使用した場合、どのパスが保存されますか？プレハブのルートからの相対パスですか、それともシーンのルートからのパスですか？他のシーンでも機能しますか？",
    "a_faq_window_content_5": "シーンのルートからのフルパスが保存されます。たとえば、MyPrefab(Clone)/Content/Icon です。この「ピン留め」されたパスは、作成したシーンでのみ機能します。他のシーンでは、そのようなパスが見つかる可能性は低いです。",
    "h3_faq_window_actions": "「アクション」タブ",
    "h3_faq_window_assets": "「アセット」タブ",
    "h3_faq_window_report": "「レポート」タブ",
    "h2_faq_editor": "9.4. 翻訳エディタ",
    "h2_faq_examples": "9.5. 使用例とコード",
    "h2_faq_notes": "9.6. 重要なニュアンスと警告",
    "h2_faq_extending": "9.7. 機能の拡張",
    "q_faq_window_actions_1": "バッチ自動翻訳中にインターネット接続が失われた場合はどうなりますか？ツールはリトライポリシーに従って失敗したバッチを再試行しますか、それともプロセスは完全に中断されますか？",
    "a_faq_window_actions_1": "ツールは、リトライポリシー設定（試行回数と遅延）に従って、失敗した正確なバッチを再送信しようとします。このバッチのすべての試行が失敗した場合、現在の言語の翻訳プロセスは中断され、エラーがコンソールに記録されます。キュー内の次の言語の翻訳は開始されません。",
    "q_faq_window_actions_2": "プロジェクトに既に存在するキーを含むが、一部の言語の値が空の CSV ファイルをインポートした場合、これらの空の値は既存の翻訳を置き換えますか、それとも無視されますか？",
    "a_faq_window_actions_2": "空の値は既存の翻訳を置き換えます。インポートプロセスは、CSV ファイルを「真実のソース」と見なします。キー welcome_message の ja 列の値が空の場合、このキーの現在の日本語の翻訳は上書きされます。",
    "q_faq_window_actions_3": "「危険ゾーン」セクションでは、すべてのコンポーネントを削除できます。「コンテンツ」タブの「プレハブフォルダ」で指定されていないフォルダにあるプレハブからコンポーネントを削除しますか？",
    "a_faq_window_actions_3": "はい、削除します。「危険ゾーン」の機能は、解析リストで指定されたものだけでなく、プロジェクト内のすべてのプレハブ（AssetDatabase.FindAssets(\"t:Prefab\")）をスキャンして、可能な限り完全なクリーンアップを保証します。",
    "q_faq_window_actions_4": "Google スプレッドシートからインポートする場合、@placeholders: ディレクティブを使用してプレースホルダーの検証が機能するようにコメント列をどのようにフォーマットすればよいですか？",
    "a_faq_window_actions_4": "Google スプレッドシートのドキュメントでは、列のタイトルを「開発者メモ」にする必要があります。この列のセルには、通常どおりコメントを記述できます。プレースホルダーを指定するには、コメントテキストに @placeholders: {username}, {score} のような行を追加するだけです。ツールはインポート時にこのディレクティブを自動的に認識します。",
    "q_faq_window_actions_5": "ツールは 1 つの Google スプレッドシートのドキュメントの複数のシートからデータをインポートできますか、それとも GID ごとに 1 つのシートでのみ機能しますか？",
    "a_faq_window_actions_5": "ツールは一度に 1 つのシートでのみ機能します。インポート URL には gid=... パラメータが含まれており、ドキュメント内の特定のシートを一意に識別します。別のシートからデータをインポートするには、その URL（別の gid を持つ）をコピーして、再度インポートを実行する必要があります。",
    "q_faq_window_assets_1": "同じスキャンフォルダに同じキーで異なるタイプのアセットがある場合（例: sound_effect_ja.mp3 と sound_effect_ja.wav）、どちらがアセットテーブルに含まれますか？",
    "a_faq_window_assets_1": "アセットスキャナーは、期待される型を指定してそれらをロードします（AssetDatabase.LoadAssetAtPath(path, expectedType)）。AudioClip カテゴリの場合、Unity が AudioClips として認識するファイルのみを検索してロードします。両方のファイルが有効なオーディオクリップである場合、最後に処理されたものがテーブルに含まれ、前のものを効果的に上書きします。このような重複は避けることをお勧めします。",
    "q_faq_window_assets_2": "「アセットをスキャンしてプロジェクトを分析」をクリックし、シーンにローカライズされたスプライトが既に存在する Image オブジェクトがあるが、Image オブジェクト自体にはまだ LocalizedAsset コンポーネントがない場合、ツールはコンポーネントを追加してキーを自動的に挿入しますか？",
    "a_faq_window_assets_2": "はい、まさにそのように動作します。「プロジェクトを分析」は Image コンポーネントを見つけ、それに割り当てられているスプライトの名前（例: icon_play_ja）を見て、そこからキー（icon_play）と言語（ja）を抽出し、その GameObject に LocalizedAsset コンポーネントを追加してキー icon_play を書き込みます。",
    "q_faq_window_assets_3": "異なるスキャンフォルダがある場合、異なるアセットカテゴリに同じ命名規則を使用できますか？これは競合を引き起こしますか？",
    "a_faq_window_assets_3": "はい、使用できます。カテゴリごとに別々のアセットテーブル（LocalizedAssetTable）が作成されるため、競合は発生しません。「Sprites」カテゴリのキーは、同じ名前であっても「AudioClips」カテゴリのキーと重複しません。",
    "q_faq_window_assets_4": "ローカライズ可能なアセット（例: button_ok_ja.png）がスキャンフォルダのルートではなく、サブフォルダにある場合、スキャナーはそれを見つけますか？",
    "a_faq_window_assets_4": "はい、見つけます。スキャナーは SearchOption.AllDirectories オプションを使用します。つまり、指定したスキャンフォルダ内のすべてのサブフォルダを再帰的にチェックします。",
    "q_faq_window_report_1": "「検索」ボタンはオブジェクトを非同期で検索します。検索を開始してすぐに「キーを更新」をクリックした場合はどうなりますか？検索は中断されますか？",
    "a_faq_window_report_1": "はい、中断されます。UI のブロックを必要とする新しいアクション（「キーを更新」など）は、現在の検索コルーチンを停止します。新しい検索を開始するために現在の検索を停止するように求めるダイアログボックスが表示されます。",
    "q_faq_window_report_2": "キーが複数の場所（例: 異なるシーンの 2 つの異なるボタン）で使用されている場合、これは「重複」カテゴリのレポートでどのように表示されますか？",
    "a_faq_window_report_2": "「重複」カテゴリには、そのキーのすべてのソースが表示されます。キーのエントリが 1 つ表示され、「ソース」フィールドにすべてのパス（シーン 1 とシーン 2）がリストされます。この場合、「検索」ボタンをクリックするとドロップダウンリストが開き、どのオブジェクトに移動するかを選択できます。",
    "q_faq_window_report_3": "コード内でのみ使用されているキー（_() 関数経由）に対して「検索」をクリックした場合はどうなりますか？ツールは C# スクリプトを見つけてハイライトできますか？",
    "a_faq_window_report_3": "はい。検索システムは、MyScript.cs のようなソースを認識するように特別にトレーニングされています。「検索」をクリックすると、プロジェクト内の MyScript.cs アセットを検索し、プロジェクトウィンドウでハイライト（ping）します。",
    "q_faq_editor_1": "プレースホルダーの検証では、コメント内の @placeholders: ディレクティブとソース言語のテキストで見つかったプレースホルダーのどちらが優先されますか？たとえば、ソーステキストに {name} があり、コメントに @placeholders: {username} とある場合です。",
    "a_faq_editor_1": "コメント内の @placeholders: ディレクティブが優先されます。これは、開発者からの明示的な指示であり、「真実のソース」と見なされます。この例では、エディタは翻訳に {username} を要求し、ソーステキストの {name} を無視します。",
    "q_faq_editor_2": "ディレクティブにタイプミスがあった場合（例: @placeholders: の代わりに @placeholder:）、無視されますか、それともツールは警告を発しますか？",
    "a_faq_editor_2": "単に無視されます。ツールは @placeholders: の完全一致を探します。ディレクティブのスペルが間違っている場合、通常のコメントの一部として扱われ、検証は古い方法、つまりソーステキストのプレースホルダーに基づいて機能します。",
    "q_faq_editor_3": "自動保存システムは Backups/AutoSaves フォルダにファイルを作成します。これらのファイルは、手動で正常に保存されたり、ウィンドウが閉じられたりした後に自動的に削除されますか？",
    "a_faq_editor_3": "はい。手動で正常に保存されたり、ウィンドウが正常に閉じられたりした場合（変更を保存した場合）、すべての自動保存ファイルは削除され、次回の起動時に回復を求められることがなくなります。エディタがクラッシュした場合にのみ残ります。",
    "q_faq_editor_4": "エディタで列の幅を変更した場合、これらの設定は Unity セッション間で保存されますか？",
    "a_faq_editor_4": "はい。列の幅は、翻訳エディタウィンドウを閉じるたびに EditorPrefs に保存され、次回開いたときに復元されます。",
    "q_faq_editor_5": "テキスト編集ポップアップウィンドウ（MultiLineEditWindow）は、その中で行われた変更に対して独自の元に戻す/やり直しスタック（Ctrl+Z 経由）をサポートしていますか？",
    "a_faq_editor_5": "はい。MultiLineEditWindow には、ウィンドウが開いている間機能する独自の一時的な元に戻す/やり直しスタックがあります。これにより、そのウィンドウ内でテキストの変更を元に戻したり、やり直したりできます。結果を保存すると（ウィンドウを閉じると）、この変更はメインエディタのグローバルな元に戻す/やり直しスタックに単一のアクションとして記録されます。",
    "q_faq_examples_1": "_() 関数に渡された匿名型のプロパティ名が文字列内のプレースホルダーと一致しない場合はどうなりますか？たとえば、_(\"こんにちは、{username} さん\", new { user_name = \"Bob\" }) です。エラーが発生しますか、それともプレースホルダーは単に置き換えられませんか？",
    "a_faq_examples_1": "エラーは発生しません。{username} プレースホルダーは単に置き換えられず、「こんにちは、{username} さん」という文字列が結果として得られます。置換は、名前が完全に一致した場合にのみ発生します。",
    "q_faq_examples_2": "[LocalizableField] 属性は private フィールドで機能します。static フィールドでも機能しますか？",
    "a_faq_examples_2": "はい、機能します。パーサーはリフレクションを使用して、BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static フラグを持つフィールドを見つけるため、静的フィールドを見つけて処理します。",
    "q_faq_examples_3": "[OnLanguageChange] 属性をパラメータを持つメソッド（例: void UpdateUI(string newLang)）に付けた場合はどうなりますか？コンパイルエラーまたはランタイム警告が発生しますか？",
    "a_faq_examples_3": "コンパイルエラーは発生しませんが、実行時に Unity コンソールに LocalizedBehaviour からの警告が表示されます。属性を持つメソッドが見つかったが、メソッドにパラメータがあるため無視されたことが報告されます。このようなメソッドは呼び出されません。",
    "q_faq_examples_4": "_(\"apple_count\", count) を使用しています。現在の言語で count = 1 の場合にキー apple_count_one がない場合、システムはどの形式を選択しますか？フォールバックとして apple_count_other を使用しますか？",
    "a_faq_examples_4": "はい。特定の形式（_one、_few など）が見つからない場合、システムはフォールバックとして _other サフィックスを持つキーを使用しようとします。それも見つからない場合は、基本キー apple_count の翻訳が使用されます。",
    "q_faq_examples_5": "関数 _(\"key\", new { username = \"Alex\" }) は匿名型を使用します。これにより、Update() メソッドで頻繁に呼び出すと、事前に作成された Dictionary<string, object> を渡す場合と比較して、ガベージコレクタ（GC）に過剰な「負荷」がかかりませんか？",
    "a_faq_examples_5": "はい、かかります。new { ... } を呼び出すたびにマネージдヒープにメモリが割り当てられ、ガベージコレクタの余分な作業が発生します。毎フレーム更新されるテキスト（Update または LateUpdate 内）の場合、Start() で一度 Dictionary<string, object> を作成し、Update() でその値のみを更新してから _() 関数に渡す方が、パフォーマンスが大幅に向上します。",
    "q_faq_notes_1": "ドキュメントでは、LanguageSelector を無視リストに追加することを推奨しています。これを忘れると具体的に何が壊れますか？「オプション A、オプション B」の余分なキーが作成されますか？",
    "a_faq_notes_1": "はい。LanguageSelector を無視リストに追加しないと、パーサーはその TMP_Dropdown を通常のドロップダウンとして扱います。Unity が作成するデフォルトの「オプション A、オプション B、オプション C」を見つけて、翻訳ファイルにキーを追加します。LanguageSelector は実行時にこれらのオプションを削除して独自のオプションを作成するため、これは不要なキーでファイルを乱雑にします。",
    "q_faq_notes_2": "LanguageSelector で使用される TMP_Dropdown 内の Label に isStyleOnly チェックボックスが有効になっている空の LocalizedText を追加し忘れた場合、フォントは変更されませんか？なぜこれが必要なのですか？",
    "a_faq_notes_2": "はい、フォントは変更されません。これは、LanguageSelector が label.text プロパティを直接変更するためです。このオブジェクトに LocalizedText がないと、ローカリゼーションシステムは、言語が変更されたときにこの要素にスタイル（フォント、RTL）を適用する必要があることを認識しません。isStyleOnly が有効になっている空の LocalizedText は、システムに対して「このオブジェクトを監視し、スタイルを適用しますが、テキストには触れないでください」という「マーカー」として機能します。",
    "q_faq_notes_3": "Update() メソッドで _() を呼び出すことは推奨されていません。しかし、タイマーのように毎フレームテキストを更新する必要がある場合はどうすればよいですか？書式文字列のみをキャッシュして、最もパフォーマンスの高い方法は何ですか？",
    "a_faq_notes_3": "最もパフォーマンスの高いアプローチは、Start() または [OnLanguageChange] メソッドで書式文字列をキャッシュし、Update() で通常の string.Format を使用することです。例: private string timerFormat; [OnLanguageChange] void UpdateTimerFormat() { timerFormat = _(\"timer_format\"); } void Update() { myTextComponent.text = string.Format(timerFormat, timeLeft); } これにより、毎フレーム辞書でキーを検索する必要がなくなり、大幅に高速になります。",
    "q_faq_extending_1": "カスタムパーサーは、キーを更新するたびに自動的に呼び出されますか？どこかに登録する必要がありますか、それともプロジェクトに ITextComponentParser を実装するクラスがあれば十分ですか？",
    "a_faq_extending_1": "クラスがあるだけで十分です。TextParser が実行されると、リフレクションを使用してプロジェクト内の ITextComponentParser インターフェイスを実装するすべてのクラスを見つけ、各 GameObject に対して自動的にそれらの Parse() メソッドを呼び出します。手動での登録は必要ありません。",
    "q_faq_extending_2": "カスタムパーサーで例外が発生した場合はどうなりますか？解析プロセス全体が中断されますか、それともツールは他のパーサーで安全に続行しますか？",
    "a_faq_extending_2": "カスタムパーサーの例外はプロセスを中断します。メインの解析ループは、カスタムパーサーの呼び出しをtry-catchブロックでラップしません。Parse()メソッドが未処理の例外をスローした場合、",
    "toggle_notes_title": "ノートの切り替え",
    "mindmap_toggle_title": "マインドマップの表示",
    "on_this_page_title": "このページの内容",
    "my_notes_title": "私のノート",
    "no_notes_message_new": "テキストにカーソルを合わせるとノートを追加できます。",
    "notes_add_title": "このブロックにノートを追加",
    "notes_placeholder": "あなたのノート...",
    "notes_close_title": "閉じる",
    "notes_goto_title": "テキストへ移動",
    "notes_edit_title": "ノートを編集",
    "notes_delete_title": "ノートを削除",
    "notes_edit_text": "編集",
    "copy_code_copy": "コピー",
    "copy_code_copied": "コピーしました！",
    "copy_code_error": "エラー",
    "error_loading_title": "読み込みエラー",
    "error_loading_message": "接続を確認して再読み込みしてください。",
    "lightbox_aria_close": "画像ビューアを閉じる",
    "lightbox_image_alt": "拡大表示",
    "mindmap_preset_full": "フルビュー",
    "mindmap_preset_quick_start": "クイックスタート",
    "mindmap_preset_dev": "開発者ワークフロー",
    "mindmap_preset_translator": "翻訳者ワークフロー",
    "mindmap_edge_configure": "1. 設定",
    "mindmap_edge_specify_content": "2. コンテンツの指定",
    "mindmap_edge_parse_project": "3. プロジェクトの解析",
    "mindmap_edge_creates_components": "コンポーネントを作成",
    "mindmap_edge_generates": "生成する",
    "mindmap_edge_opens": "開く",
    "mindmap_edge_manages_assets": "アセットを管理",
    "mindmap_edge_defines_rules": "ルールを定義",
    "mindmap_edge_reports_on": "レポート",
    "mindmap_edge_enables_reaction": "反応を有効にする",
    "mindmap_edge_processed_by": "処理者",
    "mindmap_edge_edited_in": "編集場所",
    "mindmap_edge_extends": "拡張",
    "mindmap_edge_warns_about": "警告",
    "mindmap_edge_relates_to": "関連",
    "mindmap_edge_recommends_for": "推奨",
    "mindmap_edge_see_faq": "FAQを参照"
}